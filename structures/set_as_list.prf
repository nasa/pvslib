(|set_as_list|
 (|empty_sl_is_empty| 0
  (|empty_sl_is_empty-1| |nil| 3591613697
   ("" (SKOSIMP*)
    (("" (SPLIT)
      (("1" (SKOSIMP*)
        (("1" (EXPAND "empty_sl?")
          (("1" (REWRITE -1)
            (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("2" (GENERALIZE "l!1" "l")
        (("2" (INDUCT "l")
          (("1" (EXPAND "empty_sl?") (("1" (PROPAX) NIL NIL)) NIL)
           ("2" (SKOSIMP*)
            (("2" (INST -2 "cons1_var!1")
              (("2" (EXPAND "member" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|empty_sl?| CONST-DECL "bool" |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL))
   SHOSTAK))
 (|subset_sl?_TCC1| 0
  (|subset_sl?_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -1) (("" (EXPAND "member") (("" (PROPAX) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)) NIL
   (|subset_sl?| SUBTYPE "booleans.TRUE"
    "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.=>(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}")))
 (|subset_sl?_TCC2| 0
  (|subset_sl?_TCC2-1| |nil| 3569678532 ("" (TERMINATION-TCC) NIL NIL)
   ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)) NIL
   (|subset_sl?| TERMINATION
    "set_as_list.subset_sl?(set_as_list.q, set_as_list.l2)" "NIL")))
 (|subset_sl?_TCC3| 0
  (|subset_sl?_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (TYPEPRED "v(q, l2)")
      (("1" (SPLIT 1)
        (("1" (SKOSIMP*)
          (("1" (ASSERT)
            (("1" (REWRITE -6)
              (("1" (EXPAND "member" -3)
                (("1" (INST -4 "x!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL)
         ("2" (SKOSIMP*)
          (("2" (ASSERT)
            (("2" (INST-CP -1 "a")
              (("2" (REWRITE -5)
                (("2" (EXPAND "member" -2 1)
                  (("2" (ASSERT)
                    (("2" (SKOSIMP*)
                      (("2" (EXPAND "member" -1 1)
                        (("2" (INST -1 "x!1") (("2" (ASSERT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (REWRITE -1) (("2" (EXPAND "<<") (("2" (PROPAX) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|subset_sl?| SUBTYPE
    "booleans.AND(list_props[set_as_list.T].member(set_as_list.a, set_as_list.l2), set_as_list.subset_sl?(set_as_list.q, set_as_list.l2))"
    "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.=>(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}")))
 (|add_sl_TCC1| 0
  (|add_sl_TCC1-1| |nil| 3569678532
   ("" (SKOSIMP*)
    (("" (EXPAND "nonempty_sl?")
      (("" (EXPAND "empty_sl?")
        (("" (REWRITE -1)
          (("" (EXPAND "member" 1 2)
            (("" (EXPAND "member" 1)
              (("" (EXPAND "member" 1)
                (("" (ASSERT)
                  (("" (SKOSIMP*)
                    (("" (SPLIT 1)
                      (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|nonempty_sl?| CONST-DECL "bool" |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|empty_sl?| CONST-DECL "bool" |set_as_list| NIL))
   NIL
   (|add_sl| SUBTYPE "(: set_as_list.x :)"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (|add_sl_TCC2| 0
  (|add_sl_TCC2-2| "" 3803615429
   ("" (SKEEP)
    (("" (REWRITE -1)
      (("" (SPLIT 1)
        (("1" (GRIND) NIL NIL)
         ("2" (SKOSIMP*)
          (("2" (EXPAND "member" 1) (("2" (GROUND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|add_sl| SUBTYPE "set_as_list.l"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))
  (|add_sl_TCC2-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -2)
      (("" (SPLIT 1)
        (("1" (GRIND) NIL NIL)
         ("2" (SKOSIMP*)
          (("2" (EXPAND "member" 1) (("2" (GROUND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)
    (|nonempty_sl?| CONST-DECL "bool" |set_as_list| NIL)
    (|empty_sl?| CONST-DECL "bool" |set_as_list| NIL))
   NIL
   (|add_sl| SUBTYPE "set_as_list.l"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (|add_sl_TCC3| 0
  (|add_sl_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -1) (("" (EXPAND "<<") (("" (PROPAX) NIL NIL)) NIL)) NIL))
    NIL)
   ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)) NIL
   (|add_sl| TERMINATION "set_as_list.add_sl(set_as_list.x, set_as_list.q)"
    "NIL")))
 (|add_sl_TCC4| 0
  (|add_sl_TCC4-1| |nil| 3569679497
   ("" (SKEEP)
    (("" (GROUND)
      (("1" (GRIND) NIL NIL)
       ("2" (TYPEPRED "v(x, q)")
        (("1" (SKEEP)
          (("1" (EXPAND "member" 1 1)
            (("1" (INST -2 "y")
              (("1" (REWRITE -2)
                (("1" (REWRITE -3)
                  (("1" (HIDE -2)
                    (("1" (EXPAND "member" 1 2) (("1" (GRIND) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (REWRITE -1) (("2" (EXPAND "<<") (("2" (PROPAX) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|empty_sl?| CONST-DECL "bool" |set_as_list| NIL)
    (|nonempty_sl?| CONST-DECL "bool" |set_as_list| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL))
   NIL
   (|add_sl| SUBTYPE
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.add_sl(set_as_list.x, set_as_list.q))"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (|remove_sl_TCC1| 0
  (|remove_sl_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -1) (("" (EXPAND "member") (("" (PROPAX) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)) NIL
   (|remove_sl| SUBTYPE "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (|remove_sl_TCC2| 0
  (|remove_sl_TCC2-1| |nil| 3569678532 ("" (TERMINATION-TCC) NIL NIL)
   ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)) NIL
   (|remove_sl| TERMINATION
    "set_as_list.remove_sl(set_as_list.x, set_as_list.q)" "NIL")))
 (|remove_sl_TCC3| 0
  (|remove_sl_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(x, q)")
        (("" (INST -1 "y")
          (("" (REWRITE -3)
            (("" (EXPAND "member" 1 2)
              (("" (REWRITE -1) (("" (HIDE -1) (("" (GRIND) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL))
   NIL
   (|remove_sl| SUBTYPE "set_as_list.remove_sl(set_as_list.x, set_as_list.q)"
    "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (|remove_sl_TCC4| 0
  (|remove_sl_TCC4-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(x, q)")
        (("" (INST -1 "y")
          (("" (REWRITE -2)
            (("" (EXPAND "member" 2)
              (("" (REWRITE -1) (("" (HIDE -1) (("" (GRIND) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL))
   NIL
   (|remove_sl| SUBTYPE
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.remove_sl(set_as_list.x, set_as_list.q))"
    "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (|equal_sl_TCC1| 0
  (|equal_sl_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (TYPEPRED "subset_sl?(l1, l2)")
      (("" (TYPEPRED "subset_sl?(l2, l1)") (("" (GRIND) NIL NIL)) NIL)) NIL))
    NIL)
   ((|subset_sl?| DEF-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" |set_as_list|
     NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|equal_sl| SUBTYPE
    "booleans.AND(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), set_as_list.subset_sl?(set_as_list.l2, set_as_list.l1))"
    "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}")))
 (|strict_subset_sl?_TCC1| 0
  (|strict_subset_sl?_TCC1-1| |nil| 3569678532
   ("" (SKEEP) (("" (EXPAND "equal_sl") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|equal_sl| CONST-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}"
     |set_as_list| NIL))
   NIL
   (|strict_subset_sl?| SUBTYPE
    "booleans.&(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), (booleans.NOT)(set_as_list.subset_sl?(set_as_list.l2, set_as_list.l1)))"
    "{b: booleans.bool | booleans.IFF(b, booleans.&(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), (booleans.NOT)(set_as_list.equal_sl(set_as_list.l2, set_as_list.l1))))}")))
 (|union_sl_TCC1| 0
  (|union_sl_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -1) (("" (EXPAND "member" 1 2) (("" (PROPAX) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)) NIL
   (|union_sl| SUBTYPE "set_as_list.l2"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.OR(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (|union_sl_TCC2| 0
  (|union_sl_TCC2-1| |nil| 3569678532 ("" (TERMINATION-TCC) NIL NIL)
   ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)) NIL
   (|union_sl| TERMINATION
    "set_as_list.union_sl(set_as_list.q, set_as_list.l2)" "NIL")))
 (|union_sl_TCC3| 0
  (|union_sl_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (TYPEPRED "add_sl(a, v(q, l2))")
          (("" (REWRITE -4)
            (("" (INST -2 "x")
              (("" (INST -3 "x")
                (("" (REWRITE -2)
                  (("" (REWRITE -3)
                    (("" (EXPAND "member" 1 3)
                      (("" (ASSERT)
                        (("" (HIDE -1 -2 -3) (("" (GROUND) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|add_sl| DEF-DECL
     "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
     |set_as_list| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|nonempty_sl?| CONST-DECL "bool" |set_as_list| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL))
   NIL
   (|union_sl| SUBTYPE
    "set_as_list.add_sl(set_as_list.a, set_as_list.union_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.OR(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (|intersection_sl_TCC1| 0
  (|intersection_sl_TCC1-1| |nil| 3569678532
   ("" (SKOSIMP*)
    (("" (REWRITE -1)
      (("" (EXPAND "member" 1 (1 2)) (("" (PROPAX) NIL NIL)) NIL)) NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)) NIL
   (|intersection_sl| SUBTYPE "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (|intersection_sl_TCC2| 0
  (|intersection_sl_TCC2-2| "" 3803615612
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (EXPAND "member" 1 1)
          (("" (INST -1 "x")
            (("" (REWRITE -1)
              (("" (HIDE -1)
                (("" (REWRITE -1)
                  (("" (EXPAND "member" 1 3) (("" (GROUND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|intersection_sl| SUBTYPE
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.intersection_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}"))
  (|intersection_sl_TCC2-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (EXPAND "member" 1 1)
          (("" (INST -1 "x")
            (("" (REWRITE -1)
              (("" (HIDE -1)
                (("" (REWRITE -2)
                  (("" (EXPAND "member" 1 3) (("" (GROUND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL))
   NIL
   (|intersection_sl| SUBTYPE
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.intersection_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (|intersection_sl_TCC3| 0
  (|intersection_sl_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (REWRITE -2)
          (("" (INST -1 "x")
            (("" (REWRITE -1)
              (("" (HIDE -1)
                (("" (EXPAND "member" 2 3) (("" (GROUND) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL))
   NIL
   (|intersection_sl| SUBTYPE
    "set_as_list.intersection_sl(set_as_list.q, set_as_list.l2)"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (|difference_sl_TCC1| 0
  (|difference_sl_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (REWRITE -1) (("" (EXPAND "member" 1) (("" (PROPAX) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|member| DEF-DECL "bool" |list_props| NIL)) NIL
   (|difference_sl| SUBTYPE "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")))
 (|difference_sl_TCC2| 0
  (|difference_sl_TCC2-2| "" 3803615743
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (REWRITE -2)
          (("" (INST -1 "x")
            (("" (REWRITE -1)
              (("" (HIDE -1)
                (("" (EXPAND "member" 1 3) (("" (GROUND) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|difference_sl| SUBTYPE
    "set_as_list.difference_sl(set_as_list.q, set_as_list.l2)"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}"))
  (|difference_sl_TCC2-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (REWRITE -3)
          (("" (INST -1 "x")
            (("" (REWRITE -1)
              (("" (HIDE -1)
                (("" (EXPAND "member" 1 3) (("" (GROUND) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL))
   NIL
   (|difference_sl| SUBTYPE
    "set_as_list.difference_sl(set_as_list.q, set_as_list.l2)"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")))
 (|difference_sl_TCC3| 0
  (|difference_sl_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "v(q, l2)")
        (("" (INST -1 "x")
          (("" (REWRITE -2)
            (("" (EXPAND "member" 2 (1 2))
              (("" (REWRITE -1) (("" (HIDE -1) (("" (GROUND) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL))
   NIL
   (|difference_sl| SUBTYPE
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.difference_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")))
 (|list2set_TCC1| 0
  (|list2set_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -1)
      (("" (EXPAND "member" 1)
        (("" (GROUND) (("" (EXPAND "emptyset") (("" (PROPAX) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL) NIL
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL))
   NIL
   (|list2set| SUBTYPE "sets[set_as_list.T].emptyset"
    "{s: finite_sets[set_as_list.T].finite_set | s = {x | list_props[set_as_list.T].member(set_as_list.x, set_as_list.l)}}")))
 (|list2set_TCC2| 0
  (|list2set_TCC2-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (EXPAND "add")
      (("" (TYPEPRED "v(q)")
        (("1" (REWRITE -3)
          (("1" (EXPAND "member" 1 2)
            (("1" (REWRITE -2)
              (("1" (EXPAND "member" 1 1)
                (("1" (ASSERT)
                  (("1" (LEMMA "extensionality[T]")
                    (("1" (INST? -1)
                      (("1" (SPLIT -1)
                        (("1" (PROPAX) NIL NIL)
                         ("2" (HIDE 2)
                          (("2" (SKEEP)
                            (("2" (EXPAND "member" 1 (1 3))
                              (("2" (GROUND) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (REWRITE -1) (("2" (EXPAND "<<") (("2" (PROPAX) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|extensionality| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL))
   NIL
   (|list2set| SUBTYPE
    "sets[set_as_list.T].add(set_as_list.a, set_as_list.list2set(set_as_list.q))"
    "{s: finite_sets[set_as_list.T].finite_set | s = {x | list_props[set_as_list.T].member(set_as_list.x, set_as_list.l)}}")))
 (|set2list_TCC1| 0
  (|set2list_TCC1-1| |nil| 3656356303
   ("" (SKEEP)
    (("" (USE "empty_card")
      (("" (ASSERT)
        (("" (REPLACE -1) (("" (EXPAND "length") (("" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|empty_card| FORMULA-DECL NIL |finite_sets| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   NIL
   (|set2list| SUBTYPE "list_adt[set_as_list.T].null"
    "{l: list_adt[set_as_list.T].list | booleans.AND(list_props[set_as_list.T].length(l) = finite_sets[set_as_list.T].card(set_as_list.s), FORALL (x: set_as_list.T): booleans.IFF(set_as_list.s(x), list_props[set_as_list.T].member(x, l)))}")))
 (|set2list_TCC2| 0
  (|set2list_TCC2-1| |nil| 3656356303 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL))
   NIL (|set2list| SUBTYPE "set_as_list.s" "(sets[set_as_list.T].nonempty?)")))
 (|set2list_TCC3| 0
  (|set2list_TCC3-1| |nil| 3656356303
   ("" (SKEEP) (("" (USE "card_rest") (("" (ASSERT) NIL NIL)) NIL)) NIL)
   ((|card_rest| FORMULA-DECL NIL |finite_sets| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) NIL
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL))
   NIL
   (|set2list| TERMINATION
    "set_as_list.set2list(sets[set_as_list.T].rest(set_as_list.s))" "NIL")))
 (|set2list_TCC4| 0
  (|set2list_TCC4-1| |nil| 3656356303
   ("" (SKEEP*)
    (("" (TYPEPRED "v(rest(s))")
      (("1" (SPLIT 2)
        (("1" (EXPAND "length" 1 1)
          (("1" (REPLACE -1 :HIDE? T)
            (("1" (USE "card_rest") (("1" (ASSERT) NIL NIL)) NIL)) NIL))
          NIL)
         ("2" (SKEEP)
          (("2" (EXPAND "member" 1 1)
            (("2" (GROUND)
              (("1" (USE "choose_rest_or[T]")
                (("1" (EXPAND "member" -1)
                  (("1" (INST -4 "x") (("1" (ASSERT) NIL NIL)) NIL)) NIL))
                NIL)
               ("2" (INST -3 "x")
                (("2" (ASSERT)
                  (("2" (USE "rest_member[T]")
                    (("2" (EXPAND "member" -1) (("2" (PROPAX) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (USE "card_rest") (("2" (ASSERT) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|rest| CONST-DECL "set" |sets| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|card| CONST-DECL "{n: nat | n = Card(S)}" |finite_sets| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) NIL
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|choose_rest_or| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|rest_member| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|card_rest| FORMULA-DECL NIL |finite_sets| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL))
   NIL
   (|set2list| SUBTYPE
    "list_adt[set_as_list.T].cons(sets[set_as_list.T].choose(set_as_list.s), set_as_list.set2list(sets[set_as_list.T].rest(set_as_list.s)))"
    "{l: list_adt[set_as_list.T].list | booleans.AND(list_props[set_as_list.T].length(l) = finite_sets[set_as_list.T].card(set_as_list.s), FORALL (x: set_as_list.T): booleans.IFF(set_as_list.s(x), list_props[set_as_list.T].member(x, l)))}")))
 (|card_sl_TCC1| 0
  (|card_sl_TCC1-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (REWRITE -1)
      (("" (EXPAND "list2set")
        (("" (LEMMA "card_emptyset") (("" (ASSERT) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|card_emptyset| FORMULA-DECL NIL |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL) NIL
    (|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL))
   NIL
   (|card_sl| SUBTYPE "0"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")))
 (|card_sl_TCC2| 0
  (|card_sl_TCC2-2| "" 3803616304
   ("" (SKEEP)
    (("" (TYPEPRED "v(q)")
      (("" (TYPEPRED "list2set(l)")
        (("" (TYPEPRED "list2set(q)")
          (("" (REWRITE -5)
            (("" (CASE "list2set(q) = list2set(l)")
              (("1" (ASSERT) NIL NIL)
               ("2" (HIDE 2)
                (("2" (REWRITE -2)
                  (("2" (REWRITE -4)
                    (("2" (APPLY-EXTENSIONALITY 1)
                      (("2" (HIDE 2)
                        (("2" (REWRITE -3)
                          (("2" (EXPAND "member" 1 2)
                            (("2" (CASE "x!1 = a")
                              (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|card_sl| SUBTYPE "set_as_list.card_sl(set_as_list.q)"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}"))
  (|card_sl_TCC2-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (TYPEPRED "v(q)")
      (("" (TYPEPRED "list2set(l)")
        (("" (TYPEPRED "list2set(q)")
          (("" (REWRITE -5)
            (("" (CASE "list2set(q) = list2set(l)")
              (("1" (ASSERT) NIL NIL)
               ("2" (HIDE 2)
                (("2" (REWRITE -2)
                  (("2" (REWRITE -3)
                    (("2" (APPLY-EXTENSIONALITY 1)
                      (("2" (HIDE 2)
                        (("2" (REWRITE -4)
                          (("2" (EXPAND "member" 1 2)
                            (("2" (CASE "x!1 = a")
                              (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL))
   NIL
   (|card_sl| SUBTYPE "set_as_list.card_sl(set_as_list.q)"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")))
 (|card_sl_TCC3| 0
  (|card_sl_TCC3-1| |nil| 3569678532
   ("" (SKEEP)
    (("" (TYPEPRED "list2set(q)")
      (("" (LEMMA "card_add")
        (("" (INST -1 "{x | member(x, q)}" "a")
          (("1" (TYPEPRED "list2set(l)")
            (("1" (REWRITE -2)
              (("1" (REWRITE -5)
                (("1" (EXPAND "member" 2)
                  (("1" (HIDE -1)
                    (("1" (EXPAND "add" -1)
                      (("1" (EXPAND "member" -1 1)
                        (("1"
                          (CASE
                              "{y: T | a = y OR member(y, q)} = {x | x = a OR member(x, q)}")
                          (("1" (REWRITE -1) (("1" (ASSERT) NIL NIL)) NIL)
                           ("2" (APPLY-EXTENSIONALITY 1)
                            (("2" (CASE "x!1 = a")
                              (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (ASSERT) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) NIL
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|card_add| FORMULA-DECL NIL |finite_sets| NIL))
   NIL
   (|card_sl| SUBTYPE
    "(number_fields.+)(1, set_as_list.card_sl(set_as_list.q))"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")))
 (|reduce_sl_TCC1| 0
  (|reduce_sl_TCC1-1| |nil| 3569739643
   ("" (EXPAND "equal_sl")
    (("" (SKOSIMP*)
      (("" (REWRITE -1) (("" (EXPAND "subset_sl?") (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|subset_sl?| DEF-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" |set_as_list|
     NIL)
    (|card_sl| DEF-DECL "{n: nat | n = Card(list2set(l))}" |set_as_list| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|equal_sl| CONST-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}"
     |set_as_list| NIL))
   NIL
   (|reduce_sl| SUBTYPE "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")))
 (|reduce_sl_TCC2| 0
  (|reduce_sl_TCC2-2| "" 3803616670
   ("" (SKOSIMP*)
    (("" (TYPEPRED "v!1(q!1)")
      (("1" (SPLIT)
        (("1" (EXPAND "equal_sl" 1)
          (("1" (EXPAND "equal_sl" -1)
            (("1" (FLATTEN)
              (("1" (SPLIT)
                (("1" (EXPAND "subset_sl?" 1)
                  (("1" (REWRITE -4)
                    (("1" (ASSERT)
                      (("1" (TYPEPRED "subset_sl?(q!1,v!1(q!1))")
                        (("1" (ASSERT)
                          (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (REWRITE -4)
                  (("2" (TYPEPRED "subset_sl?(v!1(q!1), cons(a!1, q!1))")
                    (("2" (SPLIT -2)
                      (("1" (PROPAX) NIL NIL)
                       ("2" (TYPEPRED "subset_sl?(v!1(q!1), q!1)")
                        (("2" (SKOSIMP*)
                          (("2" (EXPAND "member" 1)
                            (("2" (ASSERT)
                              (("2" (FLATTEN)
                                (("2" (INST? -1) (("2" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (PROPAX) NIL NIL))
        NIL)
       ("2" (REWRITE -1) (("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|reduce_sl| SUBTYPE "set_as_list.reduce_sl(set_as_list.q)"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}"))
  (|reduce_sl_TCC2-1| |nil| 3569739643
   ("" (SKOSIMP*)
    (("" (TYPEPRED "v!1(q!1)")
      (("1" (SPLIT)
        (("1" (EXPAND "equal_sl" 1)
          (("1" (EXPAND "equal_sl" -1)
            (("1" (FLATTEN)
              (("1" (SPLIT)
                (("1" (EXPAND "subset_sl?" 1)
                  (("1" (REWRITE -5)
                    (("1" (ASSERT)
                      (("1" (TYPEPRED "subset_sl?(q!1,v!1(q!1))")
                        (("1" (ASSERT)
                          (("1" (INST? -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (REWRITE -5)
                  (("2" (TYPEPRED "subset_sl?(v!1(q!1), cons(a!1, q!1))")
                    (("2" (SPLIT -2)
                      (("1" (PROPAX) NIL NIL)
                       ("2" (TYPEPRED "subset_sl?(v!1(q!1), q!1)")
                        (("2" (SKOSIMP*)
                          (("2" (EXPAND "member" 1)
                            (("2" (ASSERT)
                              (("2" (FLATTEN)
                                (("2" (INST? -1) (("2" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (PROPAX) NIL NIL))
        NIL)
       ("2" (REWRITE -2) (("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|length| DEF-DECL "nat" |list_props| NIL)
    (|card_sl| DEF-DECL "{n: nat | n = Card(list2set(l))}" |set_as_list| NIL)
    (|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|equal_sl| CONST-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}"
     |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|subset_sl?| DEF-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" |set_as_list|
     NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL))
   NIL
   (|reduce_sl| SUBTYPE "set_as_list.reduce_sl(set_as_list.q)"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")))
 (|reduce_sl_TCC3| 0
  (|reduce_sl_TCC3-1| |nil| 3569739643
   ("" (SKOSIMP*)
    (("" (TYPEPRED "v!1(q!1)")
      (("1" (REWRITE -3)
        (("1" (SPLIT)
          (("1" (TYPEPRED "equal_sl[T](q!1, v!1(q!1))")
            (("1"
              (TYPEPRED "equal_sl[T](cons(a!1, q!1), cons[T](a!1, v!1(q!1)))")
              (("1" (ASSERT)
                (("1" (SKOSIMP*)
                  (("1" (HIDE -1)
                    (("1" (HIDE -2)
                      (("1" (EXPAND "member" 1)
                        (("1" (INST? -1) (("1" (GRIND) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (EXPAND "card_sl" 1)
            (("2" (ASSERT)
              (("2" (TYPEPRED "equal_sl[T](q!1, v!1(q!1))")
                (("2" (ASSERT)
                  (("2" (HIDE -2)
                    (("2" (INST? -1)
                      (("2" (ASSERT)
                        (("2" (EXPAND "length" 2) (("2" (PROPAX) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (REWRITE -1) (("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|length| DEF-DECL "nat" |list_props| NIL)
    (|card_sl| DEF-DECL "{n: nat | n = Card(list2set(l))}" |set_as_list| NIL)
    (|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)
    (|strict_well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|equal_sl| CONST-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}"
     |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL
   (|reduce_sl| SUBTYPE
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.reduce_sl(set_as_list.q))"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")))
 (|equal_sl_card| 0
  (|equal_sl_card-1| |nil| 3569741498
   ("" (SKEEP)
    (("" (TYPEPRED "equal_sl(l1,l2)")
      (("" (ASSERT)
        (("" (HIDE -2 -3)
          (("" (TYPEPRED "card_sl(l1)")
            (("" (TYPEPRED "card_sl(l2)")
              (("" (TYPEPRED "list2set(l1)")
                (("" (TYPEPRED "list2set(l2)")
                  (("" (HIDE -1 -3)
                    (("" (REWRITE -1)
                      (("" (REWRITE -1)
                        (("" (REWRITE -1)
                          (("" (REWRITE -1)
                            ((""
                              (CASE
                                  "{x | member(x, l1)} = {x | member(x, l2)}")
                              (("1" (ASSERT) NIL NIL)
                               ("2" (HIDE 2)
                                (("2" (APPLY-EXTENSIONALITY 1)
                                  (("2" (INST? -1) (("2" (REWRITE -1) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|equal_sl| CONST-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}"
     |set_as_list| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL)
    (|card_sl| DEF-DECL "{n: nat | n = Card(list2set(l))}" |set_as_list| NIL))
   SHOSTAK))
 (|member_sl| 0
  (|member_sl-1| |nil| 3681834201
   ("" (EXPAND "member" 1 2)
    (("" (MEASURE-INDUCT+ "length(l)" "l")
      (("" (SKEEP)
        (("" (EXPAND "list2set" 1)
          (("" (LIFT-IF)
            (("" (PROP)
              (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL)
               ("2" (EXPAND "add")
                (("2" (EXPAND "reduce_sl" -2)
                  (("2" (ASSERT)
                    (("2" (LIFT-IF)
                      (("2" (PROP)
                        (("1" (INST -3 "cdr(x!1)")
                          (("1" (INST -3 "x")
                            (("1" (ASSERT)
                              (("1" (EXPAND "member" 3)
                                (("1" (ASSERT)
                                  (("1" (HIDE-ALL-BUT (4 1))
                                    (("1" (GRIND) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (EXPAND "member" -1)
                          (("2" (INST -2 "cdr(x!1)")
                            (("2" (INST -2 "x")
                              (("2" (EXPAND "member" 4)
                                (("2" (ASSERT)
                                  (("2" (HIDE-ALL-BUT (5 2))
                                    (("2" (GRIND) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (T FORMAL-TYPE-DECL NIL |set_as_list| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|member| DEF-DECL "bool" |list_props| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|equal_sl| CONST-DECL
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}"
     |set_as_list| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (|list2set| DEF-DECL "{s: finite_set[T] | s = {x | member(x, l)}}"
     |set_as_list| NIL)
    (|card_sl| DEF-DECL "{n: nat | n = Card(list2set(l))}" |set_as_list| NIL)
    (|reduce_sl| DEF-DECL
     "{ll: list[T] | equal_sl[T](l, ll) & card_sl(ll) = length(ll)}"
     |set_as_list| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) NIL
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL))
   SHOSTAK)))

