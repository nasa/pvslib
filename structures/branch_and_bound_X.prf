(branch_and_bound_X (emptyDirVars_TCC1 0 (emptyDirVars_TCC1-1 nil 3546959448 ("" (grind) nil nil) ((length def-decl "nat" list_props nil)) nil (emptyDirVars subtype "list_adt[DirVar].null" "{s: stack[DirVar].stack | list_props[DirVar].length(s) = 0}"))) (length_empty 0 (length_empty-1 nil 3546943024 ("" (grind) nil nil) ((emptyDirVars const-decl "DirVarStack" branch_and_bound_X nil)) shostak)) (topDirVar_TCC1 0 (topDirVar_TCC1-2 nil 3546959497 ("" (skeep :preds? t) (("" (typepred "stack(dirvars)") (("" (grind) nil nil)) nil)) nil) ((nonempty? const-decl "bool" branch_and_bound_X nil) (DirVarStack type-eq-decl nil branch_and_bound_X nil) (stack type-eq-decl nil stack nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (VarType formal-type-decl nil branch_and_bound_X nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (top const-decl "Maybe[T]" stack nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (topDirVar subtype "stack[DirVar].top(stack(branch_and_bound_X.dirvars))" "(Maybe[DirVar].some?)")) (topDirVar_TCC1-1 nil 3546959448 ("" (subtype-tcc) nil nil) nil nil (topDirVar subtype "stack[DirVar].top(stack(branch_and_bound_X.dirvars))" "(Maybe[DirVar].some?)"))) (pushDirVar_TCC1 0 (pushDirVar_TCC1-2 nil 3546959526 ("" (skeep) (("" (typepred "stack(dirvars)") (("" (grind) nil nil)) nil)) nil) ((DirVarStack type-eq-decl nil branch_and_bound_X nil) (stack type-eq-decl nil stack nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (VarType formal-type-decl nil branch_and_bound_X nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (push const-decl "stack" stack nil)) nil (pushDirVar subtype "stack[DirVar].push(branch_and_bound_X.dirvar, stack(branch_and_bound_X.dirvars))" "{s: stack[DirVar].stack | list_props[DirVar].length(s) = (number_fields.+)(1, branch_and_bound_X.dirvars`length)}")) (pushDirVar_TCC1-1 nil 3546959448 ("" (subtype-tcc) nil nil) nil nil (pushDirVar subtype "stack[DirVar].push(branch_and_bound_X.dirvar, stack(branch_and_bound_X.dirvars))" "{s: stack[DirVar].stack | list_props[DirVar].length(s) = (number_fields.+)(1, branch_and_bound_X.dirvars`length)}"))) (pushDirVar_TCC2 0 (pushDirVar_TCC2-1 nil 3546959448 ("" (grind) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (push const-decl "stack" stack nil) (nonempty? const-decl "bool" branch_and_bound_X nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pushDirVar subtype "(# length := (number_fields.+)(branch_and_bound_X.dirvars`length, 1), stack := stack[DirVar].push(branch_and_bound_X.dirvar, stack(branch_and_bound_X.dirvars)) #)" "(branch_and_bound_X.nonempty?)"))) (popDirVar_TCC1 0 (popDirVar_TCC1-1 nil 3546959448 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (popDirVar subtype "(number_fields.-)(branch_and_bound_X.dirvars`length, 1)" "nat"))) (popDirVar_TCC2 0 (popDirVar_TCC2-2 nil 3546959629 ("" (skeep) (("" (typepred "stack(dirvars)") (("" (expand "length" -1) (("" (grind) nil nil)) nil)) nil)) nil) ((DirVarStack type-eq-decl nil branch_and_bound_X nil) (stack type-eq-decl nil stack nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (VarType formal-type-decl nil branch_and_bound_X nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (pop const-decl "stack" stack nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (popDirVar subtype "stack[DirVar].pop(stack(branch_and_bound_X.dirvars))" "{s: stack[DirVar].stack | list_props[DirVar].length(s) = (number_fields.-)(branch_and_bound_X.dirvars`length, 1)}")) (popDirVar_TCC2-1 nil 3546959448 ("" (subtype-tcc) nil nil) nil nil (popDirVar subtype "stack[DirVar].pop(stack(branch_and_bound_X.dirvars))" "{s: stack[DirVar].stack | list_props[DirVar].length(s) = (number_fields.-)(branch_and_bound_X.dirvars`length, 1)}"))) (branch_and_bound_TCC1 0 (branch_and_bound_TCC1-1 nil 3521295757 ("" (subtype-tcc) nil nil) nil nil (branch_and_bound subtype "(number_fields.-)(branch_and_bound_X.maxdepth, length(branch_and_bound_X.dirvars))" "naturalnumber"))) (branch_and_bound_TCC2 0 (branch_and_bound_TCC2-1 nil 3521298539 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (VarType formal-type-decl nil branch_and_bound_X nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (list type-decl nil list_adt nil) (stack type-eq-decl nil stack nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound_X nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (branch_and_bound subtype "branch_and_bound_X.acc" "(Maybe[branch_and_bound_X.AnsType].some?)"))) (branch_and_bound_TCC3 0 (branch_and_bound_TCC3-1 nil 3521298539 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (VarType formal-type-decl nil branch_and_bound_X nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (list type-decl nil list_adt nil) (stack type-eq-decl nil stack nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound_X nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (push const-decl "stack" stack nil) (pushDirVar const-decl "(nonempty?)" branch_and_bound_X nil)) nil (branch_and_bound subtype "branch_and_bound_X.pushDirVar((branch_and_bound_X.dir, branch_and_bound_X.v), branch_and_bound_X.dirvars)" "{dirvars | reals.<=(length(branch_and_bound_X.dirvars), branch_and_bound_X.maxdepth)}"))) (branch_and_bound_TCC4 0 (branch_and_bound_TCC4-1 nil 3546942913 ("" (subtype-tcc) nil nil) ((push const-decl "stack" stack nil) (pushDirVar const-decl "(nonempty?)" branch_and_bound_X nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (branch_and_bound termination "branch_and_bound_X.branch_and_bound(branch_and_bound_X.evaluate, branch_and_bound_X.branch, branch_and_bound_X.subdivide, branch_and_bound_X.denorm, branch_and_bound_X.combine, branch_and_bound_X.prune, branch_and_bound_X.le, branch_and_bound_X.ge, branch_and_bound_X.select, branch_and_bound_X.accumulate, branch_and_bound_X.maxdepth)(branch_and_bound_X.sp1, branch_and_bound_X.dom1, Maybe[branch_and_bound_X.AnsType].Some(branch_and_bound_X.newacc1), branch_and_bound_X.pushDirVar((branch_and_bound_X.dir, branch_and_bound_X.v), branch_and_bound_X.dirvars))" "nil"))) (branch_and_bound_TCC5 0 (branch_and_bound_TCC5-1 nil 3546942913 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (VarType formal-type-decl nil branch_and_bound_X nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (list type-decl nil list_adt nil) (stack type-eq-decl nil stack nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound_X nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (push const-decl "stack" stack nil) (pushDirVar const-decl "(nonempty?)" branch_and_bound_X nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (branch_and_bound subtype "branch_and_bound_X.pushDirVar(((booleans.NOT)(branch_and_bound_X.dir), branch_and_bound_X.v), branch_and_bound_X.dirvars)" "{dirvars | reals.<=(length(branch_and_bound_X.dirvars), branch_and_bound_X.maxdepth)}"))) (branch_and_bound_TCC6 0 (branch_and_bound_TCC6-1 nil 3547374379 ("" (termination-tcc) nil nil) ((push const-decl "stack" stack nil) (pushDirVar const-decl "(nonempty?)" branch_and_bound_X nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (branch_and_bound termination "branch_and_bound_X.branch_and_bound(branch_and_bound_X.evaluate, branch_and_bound_X.branch, branch_and_bound_X.subdivide, branch_and_bound_X.denorm, branch_and_bound_X.combine, branch_and_bound_X.prune, branch_and_bound_X.le, branch_and_bound_X.ge, branch_and_bound_X.select, branch_and_bound_X.accumulate, branch_and_bound_X.maxdepth)(branch_and_bound_X.sp2, branch_and_bound_X.dom2, Maybe[branch_and_bound_X.AnsType].Some(branch_and_bound_X.newacc2), branch_and_bound_X.pushDirVar(((booleans.NOT)(branch_and_bound_X.dir), branch_and_bound_X.v), branch_and_bound_X.dirvars))" "nil"))) (branch_and_bound_sound 0 (branch_and_bound_sound-9 "" 3883188021 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                                          denorm, combine, prune, le, ge, select,accumulate,
                                                                          maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                                                                    depth = maxdepth-length(dirvars) IMPLIES
                                                                                                                                                     LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                                                                       IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "sound_evaluate?") (("2" (inst - "dom" "obj") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "sound_evaluate?") (("3" (inst - "dom" "obj") (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (hide -11) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "presound_combine?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (expand "sound_subdivide?") (("1" (expand "le_subdivide?") (("1" (inst - "dom1" "dom" "obj" "vp") (("1" (replace -7 :dir rl) (("1" (replace -12 :dir rl) (("1" (split -) (("1" (expand "sound_branch?") (("1" (inst - "dom1" "obj" "nobj" "vp") (("1" (assert) (("1" (flatten) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replaces (-8 -10) :hide? nil) (("1" (hide -19) (("1" (expand "presound_evaluate?") (("1" (inst -16 "dom1" "branch(vp,nobj)`1" "branch(vp,obj)`1" "firstout`ans") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -5 :dir rl) (("2" (replaces (-7 -9) :hide? nil) (("2" (hide -17) (("2" (expand "presound_evaluate?") (("2" (inst -15 "dom1" "branch(vp,nobj)`2" "branch(vp,obj)`2" "firstout`ans") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -4) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces 1) (("2" (skoletin* - :tcc-step (skip)) (("1" (replaces -1 :dir rl) (("1" (assert) (("1" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                                                                                                           denorm(left(vp),
                                                                                                                                                                                                                                                                                                                                                                                  branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                                                                  (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                                                                                                           denorm(right(vp),
                                                                                                                                                                                                                                                                                                                                                                                  branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                                                                  (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "sound_combine?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                                                                            (funsplit`1, domsplit`1, accl,
                                                                                                                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replace -12) (("1" (expand "sound_subdivide?") (("1" (inst - "domsplit`1" "dom" "obj" "vp") (("1" (replaces -16 :dir rl) (("1" (expand "le_subdivide?") (("1" (expand "sound_branch?") (("1" (inst -21 "domsplit`1" "obj" "nobj" "vp") (("1" (assert) (("1" (flatten) (("1" (hide -22) (("1" (expand "presound_evaluate?") (("1" (inst - "domsplit`1" "branch(vp,nobj)`1" "branch(vp,obj)`1" "BAB") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                                                                            (funsplit`2, domsplit`2, accr,
                                                                                                                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (replace -12) (("1" (expand "sound_subdivide?") (("1" (inst - "domsplit`2" "dom" "obj" "vp") (("1" (expand "le_subdivide?") (("1" (replaces -16 :dir rl) (("1" (expand "sound_branch?") (("1" (inst -21 "domsplit`2" "obj" "nobj" "vp") (("1" (assert) (("1" (flatten) (("1" (hide -21) (("1" (expand "presound_evaluate?") (("1" (inst - "domsplit`2" "branch(vp,nobj)`2" "branch(vp,obj)`2" "BAB") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "PP") (("4" (expand "pushDirVar" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil) ("3" (hide-all-but 1) (("3" (subtype-tcc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (branch_and_bound_sound-8 nil 3571414984 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                                          denorm, combine, prune, le, ge, select,accumulate,
                                                                          maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                                                                    depth = maxdepth-length(dirvars) IMPLIES
                                                                                                                                                     LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                                                                       IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "sound_evaluate?") (("2" (inst - "dom" "obj") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "sound_evaluate?") (("3" (inst - "dom" "obj") (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (hide -11) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "presound_combine?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (expand "sound_subdivide?") (("1" (expand "le_subdivide?") (("1" (inst - "dom1" "dom" "obj" "vp") (("1" (replace -7 :dir rl) (("1" (replace -12 :dir rl) (("1" (split -) (("1" (expand "sound_branch?") (("1" (inst - "dom1" "obj" "nobj" "vp") (("1" (assert) (("1" (flatten) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replaces (-8 -10) :hide? nil) (("1" (hide -19) (("1" (expand "presound_evaluate?") (("1" (inst -16 "dom1" "branch(vp,nobj)`1" "branch(vp,obj)`1" "firstout`ans") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -5 :dir rl) (("2" (replaces (-7 -9) :hide? nil) (("2" (hide -17) (("2" (expand "presound_evaluate?") (("2" (inst -15 "dom1" "branch(vp,nobj)`2" "branch(vp,obj)`2" "firstout`ans") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -4) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces 1) (("2" (skoletin* - :tcc-step (skip)) (("1" (replaces -1 :dir rl) (("1" (assert) (("1" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                                                                                                           denorm(left(vp),
                                                                                                                                                                                                                                                                                                                                                                                  branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                                                                  (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                                                                                                           denorm(right(vp),
                                                                                                                                                                                                                                                                                                                                                                                  branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                                                                  (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "sound_combine?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                                                                            (funsplit`1, domsplit`1, accl,
                                                                                                                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replace -12) (("1" (expand "sound_subdivide?") (("1" (inst - "domsplit`1" "dom" "obj" "vp") (("1" (replaces -16 :dir rl) (("1" (expand "le_subdivide?") (("1" (expand "sound_branch?") (("1" (inst -21 "domsplit`1" "obj" "nobj" "vp") (("1" (assert) (("1" (flatten) (("1" (hide -22) (("1" (expand "presound_evaluate?") (("1" (inst - "domsplit`1" "branch(vp,nobj)`1" "branch(vp,obj)`1" "BAB") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                                                                            (funsplit`2, domsplit`2, accr,
                                                                                                                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (replace -12) (("1" (expand "sound_subdivide?") (("1" (inst - "domsplit`2" "dom" "obj" "vp") (("1" (expand "le_subdivide?") (("1" (replaces -16 :dir rl) (("1" (expand "sound_branch?") (("1" (inst -21 "domsplit`2" "obj" "nobj" "vp") (("1" (assert) (("1" (flatten) (("1" (hide -21) (("1" (expand "presound_evaluate?") (("1" (inst - "domsplit`2" "branch(vp,nobj)`2" "branch(vp,obj)`2" "BAB") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "PP") (("4" (expand "pushDirVar" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DomainType formal-type-decl nil branch_and_bound_X nil) (ObjType formal-type-decl nil branch_and_bound_X nil) (AnsType formal-type-decl nil branch_and_bound_X nil) (Evaluator type-eq-decl nil branch_and_bound_X nil) (VarType formal-type-decl nil branch_and_bound_X nil) (Brancher type-eq-decl nil branch_and_bound_X nil) (SubdivDomain type-eq-decl nil branch_and_bound_X nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (DenormAns type-eq-decl nil branch_and_bound_X nil) (Combiner type-eq-decl nil branch_and_bound_X nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (stack type-eq-decl nil stack nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound_X nil) (ExitPred type-eq-decl nil branch_and_bound_X nil) (LocalExitPred type-eq-decl nil branch_and_bound_X nil) (DirVarSelector type-eq-decl nil branch_and_bound_X nil) (Accumulator type-eq-decl nil branch_and_bound_X nil) (branch_and_bound def-decl "Output" branch_and_bound_X nil) (<= const-decl "bool" reals nil) (SoundPred type-eq-decl nil branch_and_bound_X nil) (Output type-eq-decl nil branch_and_bound_X nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AccType type-eq-decl nil branch_and_bound_X nil) (Maybe type-decl nil Maybe nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (dirvars skolem-const-decl "DirVarStack" branch_and_bound_X nil) (maxdepth skolem-const-decl "nat" branch_and_bound_X nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (PP skolem-const-decl "[Evaluator, Brancher, SubdivDomain, DenormAns, Combiner, ExitPred,
 LocalExitPred, ExitPred, DirVarSelector, Accumulator, nat]" branch_and_bound_X nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sound_evaluate? const-decl "bool" branch_and_bound_X nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe nil) (pushDirVar const-decl "(nonempty?)" branch_and_bound_X nil) (nonempty? const-decl "bool" branch_and_bound_X nil) (val adt-accessor-decl "[(some?) -> T]" Maybe nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posint nonempty-type-eq-decl nil integers nil) (FALSE const-decl "bool" booleans nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (push const-decl "stack" stack nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sound_combine? const-decl "bool" branch_and_bound_X nil) (presound_combine? const-decl "bool" branch_and_bound_X nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (le_subdivide? const-decl "bool" branch_and_bound_X nil) (presound_evaluate? const-decl "bool" branch_and_bound_X nil) (sound_dir const-decl "bool" branch_and_bound_X nil) (sound_branch? const-decl "bool" branch_and_bound_X nil) (sound_subdivide? const-decl "bool" branch_and_bound_X nil) (int_plus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) nil) (branch_and_bound_sound-7 nil 3571414643 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                                      denorm, combine, prune, le, ge, select,accumulate,
                                                                      maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                                                      depth = maxdepth-length(dirvars) IMPLIES
                                                                                                                                       LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                                                         IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil))))))) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "sound_subdivide?") (("2" (inst - "dom" "obj") (("2" (flatten) (("2" (assert) nil))))))))))))))) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "sound_subdivide?") (("3" (inst - "dom" "obj") (("3" (flatten) (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (inst - "vp") (("2" (flatten) (("2" (replaces (-13 -14) :hide? nil :dir rl) (("2" (hide -11) (("2" (replaces (-7 -8) :dir rl :hide? nil) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "presound_combine?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (replace -7 :dir rl) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (replaces (-6 -8)) (("1" (hide-all-but (-2 -13 1)) (("1" (postpone) nil))))))))))) ("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (replaces (-5 -7)) (("2" (hide-all-but (-1 -13 2)) (("2" (postpone) nil))))))))))))))))))))) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar" 1) (("2" (assert) nil))))))))))) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil))))))))))))))))))) ("2" (replaces 1) (("2" (skoletin* -) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                                                                             denorm(left(vp),
                                                                                                                                                                                                                                                                                                                                                    branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                                    (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                                                                             denorm(right(vp),
                                                                                                                                                                                                                                                                                                                                                    branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                                    (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil))))) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil))))))))) ("2" (hide 2) (("2" (skeep) (("2" (expand "sound_combine?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                                            (funsplit`1, domsplit`1, accl,
                                                                                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -19 1)) (("1" (postpone) nil))))))) ("2" (expand "pushDirVar" 1) (("2" (assert) nil))))))) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                                            (funsplit`2, domsplit`2, accr,
                                                                                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -20 1)) (("1" (postpone) nil))))))) ("2" (expand "pushDirVar" 1) (("2" (assert) nil))))))))))))))))))))))))) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil))))) ("4" (expand "PP") (("4" (expand "pushDirVar" 1) (("4" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil))))))))) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil)))))))))))) nil) nil nil) (branch_and_bound_sound-6 nil 3571414554 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                                    denorm, combine, prune, le, ge, select,accumulate,
                                                                    maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                                               depth = maxdepth-length(dirvars) IMPLIES
                                                                                                                                LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                                                  IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "sound_subdivide?") (("2" (inst - "dom" "obj") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "sound_subdivide?") (("3" (inst - "dom" "obj") (("3" (flatten) (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (inst - "vp") (("2" (flatten) (("2" (replaces (-13 -14) :hide? nil :dir rl) (("2" (hide -11) (("2" (replaces (-7 -8) :dir rl :hide? nil) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "presound_combine?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (replace -7 :dir rl) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (replaces (-6 -8)) (("1" (hide-all-but (-2 -13 1)) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (replaces (-5 -7)) (("2" (hide-all-but (-1 -13 2)) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces 1) (("2" (skoletin* -) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                                                              denorm(left(vp),
                                                                                                                                                                                                                                                                                                                                     branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                     (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                                                              denorm(right(vp),
                                                                                                                                                                                                                                                                                                                                     branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                                     (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "subdiv_sound?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                            (funsplit`1, domsplit`1, accl,
                                                                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -19 1)) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                                            (funsplit`2, domsplit`2, accr,
                                                                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -20 1)) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "PP") (("4" (expand "pushDirVar" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (branch_and_bound_sound-5 nil 3571413876 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                                  denorm, combine, prune, le, ge, select,accumulate,
                                                                  maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                                        depth = maxdepth-length(dirvars) IMPLIES
                                                                                                                         LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                                           IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "sound_subdivide?") (("2" (inst - "dom" "obj") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "sound_subdivide?") (("3" (inst - "dom" "obj") (("3" (flatten) (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (inst - "vp") (("2" (flatten) (("2" (replaces (-13 -14) :hide? nil :dir rl) (("2" (hide -11) (("2" (replaces (-7 -8) :dir rl :hide? nil) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "subdiv_presound?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (replace -7 :dir rl) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (replaces (-6 -8)) (("1" (hide-all-but (-2 -13 1)) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (replaces (-5 -7)) (("2" (hide-all-but (-1 -13 2)) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces 1) (("2" (skoletin* -) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                                               denorm(left(vp),
                                                                                                                                                                                                                                                                                                                      branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                      (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                                               denorm(right(vp),
                                                                                                                                                                                                                                                                                                                      branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                                      (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "subdiv_sound?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                            (funsplit`1, domsplit`1, accl,
                                                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -19 1)) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                                            (funsplit`2, domsplit`2, accr,
                                                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -20 1)) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "PP") (("4" (expand "pushDirVar" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (branch_and_bound_sound-4 nil 3571412230 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                                denorm, combine, prune, le, ge, select,accumulate,
                                                                maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                                 depth = maxdepth-length(dirvars) IMPLIES
                                                                                                                  LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                                    IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "accomodates?") (("2" (inst - "dom" "obj") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "accomodates?") (("3" (inst - "dom" "obj") (("3" (flatten) (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (inst - "vp") (("2" (flatten) (("2" (replaces (-13 -14) :hide? nil :dir rl) (("2" (hide -11) (("2" (replaces (-7 -8) :dir rl :hide? nil) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "subdiv_presound?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (replace -7 :dir rl) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (replaces (-6 -8)) (("1" (hide-all-but (-2 -13 1)) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (replaces (-5 -7)) (("2" (hide-all-but (-1 -13 2)) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces 1) (("2" (skoletin* -) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                                denorm(left(vp),
                                                                                                                                                                                                                                                                                                       branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                       (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                                denorm(right(vp),
                                                                                                                                                                                                                                                                                                       branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                                       (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "subdiv_sound?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                            (funsplit`1, domsplit`1, accl,
                                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -19 1)) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                                            (funsplit`2, domsplit`2, accr,
                                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (hide-all-but (-1 -20 1)) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar" 1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "PP") (("4" (expand "pushDirVar" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (branch_and_bound_sound-2 nil 3546959685 ("" (skeep) (("" (name-replace "PP" "(evaluate, branch, subdivide,
                                                              denorm, combine, prune, le, ge, select,accumulate,
                                                              maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                                                          depth = maxdepth-length(dirvars) IMPLIES
                                                                                                           LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                                                             IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "accomodates?") (("2" (inst - "dom" "obj") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("3" (replaces "PP" :dir rl) (("3" (skoletin* -1) (("3" (label "HI" -6) (("3" (hide "HI") (("3" (expand "accomodates?") (("3" (inst - "dom" "obj") (("3" (flatten) (("3" (case-replace "length(dirvars) = maxdepth OR le(thisans) OR thisout`exit OR prune(dirvars, newacc1, thisans)") (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces :from 1 :to 4) (("2" (skoletin -1 :postfix "p") (("2" (skoletin* -1) (("2" (inst - "vp") (("2" (flatten) (("2" (replaces (-13 -14) :hide? nil :dir rl) (("2" (hide -11) (("2" (replaces (-7 -8) :dir rl :hide? nil) (("2" (case-replace "firstout`exit") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (expand "subdiv_presound?") (("1" (inst? -) (("1" (assert) (("1" (hide 1) (("1" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,pushDirVar((dirp, vp), dirvars))`ans)") (("1" (expand "PP") (("1" (replaces -3 :dir rl) (("1" (replace -7 :dir rl) (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (replaces (-6 -8)) (("1" (hide -14) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (replaces (-5 -7)) (("2" (hide -12) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "HI") (("2" (inst? -1) (("2" (assert) (("2" (expand "pushDirVar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces 1) (("2" (skoletin* -) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                                                                                                                 denorm(left(vp),
                                                                                                                                                                                                                                                                                        branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                        (funsplit`1,domsplit`1,accl,pushDirVar(left(vp),dirvars))`ans),
                                                                                                                                                                                                                                                                                 denorm(right(vp),
                                                                                                                                                                                                                                                                                        branch_and_bound(PP)
                                                                                                                                                                                                                                                                                                        (funsplit`2,domsplit`2,accr,pushDirVar(right(vp),dirvars))`ans)))") (("1" (expand "PP") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "subdiv_sound?") (("2" (inst? -) (("2" (assert) (("2" (hide 1) (("2" (replace -10 :dir rl) (("2" (reveal "HI") (("2" (split 1) (("1" (inst? -1) (("1" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                            (funsplit`1, domsplit`1, accl,
                             pushDirVar((TRUE, vp), dirvars))`ans") (("1" (replaces -12) (("1" (postpone) nil nil)) nil)) nil) ("2" (expand "pushDirVar") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst? -1) (("2" (split -1) (("1" (name-replace "BAB" "branch_and_bound(PP)
                            (funsplit`2, domsplit`2, accr,
                             pushDirVar((FALSE, vp), dirvars))`ans") (("1" (postpone) nil nil)) nil) ("2" (expand "pushDirVar" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PP") (("3" (expand "pushDirVar") (("3" (assert) nil nil)) nil)) nil) ("4" (expand "PP") (("4" (expand "pushDirVar") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((stack type-eq-decl nil stack nil) (Maybe type-decl nil Maybe nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe nil) (val adt-accessor-decl "[(some?) -> T]" Maybe nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe nil) (push const-decl "stack" stack nil)) nil) (branch_and_bound_sound-1 nil 3546361375 ("" (skeep) (("" (name-replace "PP" "(simplify, evaluate, branch, subdivide,
                                                  denorm, combine, prune, le, ge, select,accumulate,
                                                  maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, acc, dirvars,(depth:nat)):
                                                                depth = maxdepth-length(dirvars) IMPLIES
                                                                 LET bandb = branch_and_bound(PP)(obj, dom, acc, dirvars)
                                                                   IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-length(dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (skeep) (("2" (move-terms -1 r 2) (("2" (assert) (("2" (expand "branch_and_bound") (("2" (expand "accomodates?") (("2" (inst - "dom" "obj" "dirvars") (("2" (expand "evaluate_simplify?") (("2" (inst - "dom" "obj" "dirvars") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, acc,dirvars)" :hide? nil) (("3" (expand "branch_and_bound" -1 :assert? none) (("3" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15)) (("3" (replaces "PP" :hide? nil :dir rl) (("3" (skoletin* -1) (("3" (case-replace "length(dirvars) = maxdepth OR
                                                                                                                                                                                                                          le(thisans) OR
                                                                                                                                                                                                                           thisout`exit OR prune(dirvars, acc, thisans)") (("1" (hide (-1 -6)) (("1" (replaces (-2 -1)) (("1" (assert) (("1" (replaces (-1 -2)) (("1" (expand "accomodates?") (("1" (inst - "dom" "obj" "dirvars") (("1" (expand "evaluate_simplify?") (("1" (inst - "dom" "obj" "dirvars") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace 1) (("2" (replace 2) (("2" (replace 3) (("2" (replace 4) (("2" (skoletin -2 :postfix "p") (("2" (skoletin* -3) (("2" (case "firstout`exit") (("1" (assert) (("1" (replaces -3 :dir rl) (("1" (assert) (("1" (expand "subdiv_presound?") (("1" (inst? -32) (("1" (assert) (("1" (hide 5) (("1" (split 5) (("1" (expand "accomodates?") (("1" (inst -29 "dom" "obj" "dirvars") (("1" (expand "evaluate_simplify?") (("1" (inst -31 "dom" "obj" "dirvars") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,newacc1,push((dirp, vp), dirvars))`ans)") (("1" (expand "sound_dir") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand "branch_simplify?") (("1" (inst? -35) (("1" (expand "simplify_invariant?" -) (("1" (inst? -32) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "branch_simplify?") (("2" (inst? -34) (("2" (expand "simplify_invariant?" -) (("2" (inst? -31) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst? -) (("2" (assert) (("2" (expand "push" 6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "push" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (skoletin* -2) (("2" (replaces -3 :dir rl) (("2" (assert) (("2" (case "FORALL(accl,accr:AccType):sound(dom,obj,combine(vp,
                                                                                                                                                                                       denorm(left(vp),
                                                                                                                                                                                              branch_and_bound(PP)
                                                                                                                                                                                                              (funsplit`1,domsplit`1,accl,push(left(vp),dirvars))`ans),
                                                                                                                                                                                       denorm(right(vp),
                                                                                                                                                                                              branch_and_bound(PP)
                                                                                                                                                                                                              (funsplit`2,domsplit`2,accr,push(right(vp),dirvars))`ans)))") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newacc1" "newacc2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newacc2" "newacc1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 7) (("2" (skeep) (("2" (expand "subdiv_sound?") (("2" (inst? -36) (("2" (assert) (("2" (hide 1) (("2" (expand "branch_simplify?") (("2" (inst -36 "vp" "obj") (("2" (replaces (-11 -12 -17 -36)) (("2" (assert) (("2" (split 6) (("1" (expand "simplify_invariant?" -30) (("1" (inst? -30) (("1" (assert) (("1" (hide 1) (("1" (inst - "simplify(branch(vp, obj)`1)" "subdivide(vp, dom)`1" "accl" "push((TRUE, vp), dirvars)") (("1" (assert) (("1" (expand "push" 6) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "simplify_invariant?" -30) (("2" (inst? -30) (("2" (assert) (("2" (hide 1) (("2" (inst - "simplify(branch(vp, obj)`2)" "subdivide(vp, dom)`2" "accr" "push((FALSE, vp), dirvars)") (("2" (assert) (("2" (expand "push" 6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "push" 1) (("3" (assert) nil nil)) nil) ("4" (expand "push" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((stack type-eq-decl nil stack nil)) nil) (branch_and_bound_sound-3 nil 3546178611 ("" (skeep) (("" (name-replace "PP" "(simplify, evaluate, branch, subdivide,
                                  denorm, comb, prune, le, ge, select,
                                  maxdepth)" :hide? nil) (("" (decompose-equality -1) (("" (case " FORALL (obj, dom, depth, ans0, dirvars):
        depth <= maxdepth IMPLIES
         LET bandb = branch_and_bound(PP)(obj, dom, maxdepth-depth, ans0, dirvars)
           IN sound(dom, obj, bandb`ans)") (("1" (skeep) (("1" (inst? -) (("1" (inst - "maxdepth-depth" "ans0" "dirvars") (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "depth") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (expand "branch_and_bound") (("2" (expand "accomodates?") (("2" (inst - "dom" "obj" "dirvars") (("2" (expand "evaluate_simplify?") (("2" (inst - "dom" "obj" "dirvars") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 "depth") (("3" (flatten) (("3" (skeep) (("3" (name-replace "bandb" "branch_and_bound(PP)(obj, dom, maxdepth - (depth + 1), ans0,dirvars)" :hide? nil) (("1" (expand "branch_and_bound" -1 :assert? none) (("1" (label "PP" (-4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14)) (("1" (replaces "PP" :hide? nil :dir rl) (("1" (skoletin* -1) (("1" (case-replace "maxdepth - (depth + 1) = maxdepth OR
                                                                                                                                                            le(thisout) OR
                                                                                                                                                             ge(thisout) OR (some?(ans0) AND prune(some(ans0), thisout`ans))") (("1" (hide (-1 -6)) (("1" (replaces (-2 -1)) (("1" (assert) (("1" (replaces (-1 -2)) (("1" (expand "accomodates?") (("1" (inst - "dom" "obj" "dirvars") (("1" (expand "evaluate_simplify?") (("1" (inst - "dom" "obj" "dirvars") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace 1) (("2" (replace 2) (("2" (replace 3) (("2" (replace 4) (("2" (skoletin -2 :postfix "p") (("2" (skoletin* -3) (("2" (case "ge(firstout)") (("1" (assert) (("1" (replaces -3 :dir rl) (("1" (assert) (("1" (expand "comb_sound_presound?") (("1" (inst? -33) (("1" (assert) (("1" (hide 5) (("1" (split 5) (("1" (hide -16) (("1" (replace -14) (("1" (expand "accomodates?") (("1" (replaces -15) (("1" (inst - "dom" "obj" "dirvars") (("1" (expand "evaluate_simplify?") (("1" (inst - "dom" "obj" "dirvars") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subdiv_presound?" -) (("2" (inst? -33) (("2" (assert) (("2" (hide 1) (("2" (hide -1) (("2" (replaces -1) (("2" (case "sound(dom1,sp1,branch_and_bound(PP)(sp1,dom1,depth_1,Some(newans1),push((dirp, vp), dirvars))`ans)") (("1" (hide -15) (("1" (replaces -14) (("1" (expand "sound_dir") (("1" (split 5) (("1" (flatten) (("1" (assert) (("1" (replaces (-6 -9)) (("1" (replaces (-7 -8)) (("1" (expand "branch_simplify?") (("1" (inst? -) (("1" (expand "simplify_invariant?" -) (("1" (inst? -) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces (-5 -8)) (("2" (replaces (-6 -7)) (("2" (expand "branch_simplify?") (("2" (inst? -) (("2" (expand "simplify_invariant?" -) (("2" (inst? -) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 6) (("2" (inst? -) (("2" (inst? -) (("2" (inst? -) (("2" (inst - "push((dirp,vp),dirvars)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (skoletin* -2) (("2" (replaces -3 :dir rl) (("2" (assert) (("2" (case "FORALL(ansl,ansr:Maybe[AnsType]):sound(dom,obj,comb(vp,
                                                 denorm(left(vp),
                                                        branch_and_bound(PP)
                                                                        (funsplit`1,domsplit`1,depth_1,ansl,push(left(vp),dirvars))),
                                                 denorm(right(vp),
                                                        branch_and_bound(PP)
                                                                        (funsplit`2,domsplit`2,depth_1,ansr,push(right(vp),dirvars)))))") (("1" (case "dirp") (("1" (assert) (("1" (inst - "newans1" "newans2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "newans2" "newans1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 7) (("2" (skeep) (("2" (expand "subdiv_sound?") (("2" (inst? -38) (("2" (assert) (("2" (hide 1) (("2" (expand "branch_simplify?") (("2" (inst -38 "vp" "obj") (("2" (replaces (-12 -13 -18 -38)) (("2" (assert) (("2" (split 6) (("1" (expand "simplify_invariant?" -30) (("1" (inst? -30) (("1" (assert) (("1" (hide 1) (("1" (inst - "simplify(branch(vp, obj)`1)" "subdivide(vp, dom)`1" "ansl" "push((TRUE, vp), dirvars)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "simplify_invariant?" -30) (("2" (inst? -30) (("2" (assert) (("2" (hide 1) (("2" (inst - "simplify(branch(vp, obj)`2)" "subdivide(vp, dom)`2" "ansr" "push((FALSE, vp), dirvars)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((stack type-eq-decl nil stack nil) (push const-decl "stack" stack nil)) nil)) (b_and_b_TCC1 0 (b_and_b_TCC1-1 nil 3546341495 ("" (subtype-tcc) nil nil) ((emptyDirVars const-decl "DirVarStack" branch_and_bound_X nil)) nil (b_and_b subtype "branch_and_bound_X.emptyDirVars" "{dirvars | reals.<=(length(branch_and_bound_X.dirvars), branch_and_bound_X.maxdepth)}"))) (b_and_b_sound 0 (b_and_b_sound-1 nil 3546341520 ("" (skeep) (("" (expand "b_and_b") (("" (lemma "branch_and_bound_sound") (("" (inst? -) (("" (inst? -) (("" (assert) (("" (inst? -) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((b_and_b const-decl "Output" branch_and_bound_X nil) (DomainType formal-type-decl nil branch_and_bound_X nil) (ObjType formal-type-decl nil branch_and_bound_X nil) (AnsType formal-type-decl nil branch_and_bound_X nil) (Evaluator type-eq-decl nil branch_and_bound_X nil) (VarType formal-type-decl nil branch_and_bound_X nil) (Brancher type-eq-decl nil branch_and_bound_X nil) (SubdivDomain type-eq-decl nil branch_and_bound_X nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (DirVar type-eq-decl nil branch_and_bound_X nil) (DenormAns type-eq-decl nil branch_and_bound_X nil) (Combiner type-eq-decl nil branch_and_bound_X nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (stack type-eq-decl nil stack nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound_X nil) (ExitPred type-eq-decl nil branch_and_bound_X nil) (LocalExitPred type-eq-decl nil branch_and_bound_X nil) (DirVarSelector type-eq-decl nil branch_and_bound_X nil) (Accumulator type-eq-decl nil branch_and_bound_X nil) (length_empty formula-decl nil branch_and_bound_X nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Maybe type-decl nil Maybe nil) (AccType type-eq-decl nil branch_and_bound_X nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe nil) (None adt-constructor-decl "(none?)" Maybe nil) (emptyDirVars const-decl "DirVarStack" branch_and_bound_X nil) (SoundPred type-eq-decl nil branch_and_bound_X nil) (branch_and_bound_sound formula-decl nil branch_and_bound_X nil)) shostak)))
