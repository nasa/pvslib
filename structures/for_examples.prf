(|for_examples|
 (|expit_TCC1| 0
  (|expit_TCC1-1| |nil| 3759603117 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|expit| SUBTYPE
    "LAMBDA (i: naturalnumbers.below(for_examples.n), a: reals.real): number_fields.*(a, for_examples.x)"
    "ForBody[real](0, (number_fields.-)(for_examples.n, 1))")))
 (|expit_test| 0
  (|expit_test-1| |nil| 3505593379 ("" (GRIND) NIL NIL)
   ((|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|expit| CONST-DECL "real" |for_examples| NIL)
    (|for| CONST-DECL "T" |for_iterate| NIL)
    (|for_it| DEF-DECL
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}" |for_iterate|
     NIL))
   SHOSTAK))
 (|expit_inv_TCC1| 0
  (|expit_inv_TCC1-1| |nil| 3759583715 ("" (SUBTYPE-TCC) NIL NIL)
   ((/= CONST-DECL "boolean" |notequal| NIL)) NIL
   (|expit_inv| SUBTYPE "for_examples.i"
    "{i: integers.int | booleans.OR(for_examples.x /= 0, reals.>=(i, 0))}")))
 (|expit_sound_TCC1| 0
  (|expit_sound_TCC1-1| NIL 3931811310 ("" (SUBTYPE-TCC) NIL NIL)
   ((/= CONST-DECL "boolean" |notequal| NIL)) NIL
   (|expit_sound| SUBTYPE "for_examples.n"
    "{i: integers.int | booleans.OR(for_examples.x /= 0, reals.>=(i, 0))}")))
 (|expit_sound| 0
  (|expit_sound-1| |nil| 3508441066
   ("" (SKEEP)
    (("" (EXPAND "expit")
      (("" (LEMMA "for_invariant[real]")
        (("" (INST?)
          (("1" (INST -1 "expit_inv(x,n)")
            (("1" (REWRITE "expt_x0")
              (("1" (ASSERT) (("1" (HIDE 2) (("1" (GRIND) NIL NIL)) NIL)) NIL))
              NIL)
             ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|expit| CONST-DECL "real" |for_examples| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (|ForBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |for_examples| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|expt_x0| FORMULA-DECL NIL |exponentiation| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|expt| DEF-DECL "real" |exponentiation| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|for_invariant| FORMULA-DECL NIL |for_iterate| NIL))
   SHOSTAK))
 (|factit_test| 0
  (|factit_test-1| |nil| 3505593275 ("" (GRIND) NIL NIL)
   ((|for_it| DEF-DECL
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}" |for_iterate|
     NIL)
    (|for| CONST-DECL "T" |for_iterate| NIL)
    (|for_down| CONST-DECL "T" |for_iterate| NIL)
    (|factit| CONST-DECL "posnat" |for_examples| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   SHOSTAK))
 (|factit_sound| 0
  (|factit_sound-1| |nil| 3508421087
   ("" (SKEEP)
    (("" (CASE "n=0")
      (("1" (GRIND) NIL NIL)
       ("2" (EXPAND "factit")
        (("2" (LEMMA "for_down_invariant[posnat]")
          (("2" (INST? -1)
            (("1" (INST -1 "factit_inv(n)")
              (("1" (ASSERT)
                (("1" (HIDE 3)
                  (("1" (SKEEP)
                    (("1" (EXPAND "factorial" -1 2)
                      (("1" (GRIND-REALS) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|for_it| DEF-DECL
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}" |for_iterate|
     NIL)
    (|for| CONST-DECL "T" |for_iterate| NIL)
    (|for_down| CONST-DECL "T" |for_iterate| NIL)
    (|factit| CONST-DECL "posnat" |for_examples| NIL)
    (|factorial| DEF-DECL "posnat" |factorial| |ints|)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|for_down_invariant| FORMULA-DECL NIL |for_iterate| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL)
    (|factorial_1| FORMULA-DECL NIL |factorial| |ints|)
    (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals|
     NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|ForBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |for_examples| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|min_idx_TCC1| 0
  (|min_idx_TCC1-1| NIL 3931861260 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|min_idx| SUBTYPE "0" "below(for_examples.N)")))
 (|min_idx_TCC2| 0
  (|min_idx_TCC2-1| NIL 3931861260 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|min_idx| SUBTYPE "for_examples.i" "below(for_examples.N)")))
 (|min_idx_TCC3| 0
  (|min_idx_TCC3-1| NIL 3931861260 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|min_idx| SUBTYPE "for_examples.j" "below(for_examples.N)")))
 (|min_idx_TCC4| 0
  (|min_idx_TCC4-1| NIL 3931861260
   ("" (SKEEP*)
    (("" (INSTEEP -1) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)
   ((|j| SKOLEM-CONST-DECL "below(1 + k_1)" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|k_1| SKOLEM-CONST-DECL "subrange(1, N - 1)" |for_examples| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL))
   NIL
   (|min_idx| SUBTYPE
    "LAMBDA (i: integers.subrange(1, for_examples.N), k: naturalnumbers.below(for_examples.N)): FORALL (j: naturalnumbers.below(i)): reals.<=(for_examples.A(k), for_examples.A(j))"
    "{inv: defined_types[[subrange(1, for_examples.N), below(for_examples.N)]].PRED | FORALL (k_1: integers.subrange(1, (number_fields.-)(for_examples.N, 1)), ak: below(for_examples.N)): booleans.IMPLIES(booleans.AND(inv(k_1, ak), for_examples.A(ak) /= 0), inv((number_fields.+)(1, k_1), IF reals.<(for_examples.A(k_1), for_examples.A(ak)) THEN k_1 ELSE ak ENDIF))}")))
 (|min_idx_sound| 0
  (|min_idx_sound-1| NIL 3931939998
   ("" (SKEEP)
    (("" (SKOLETIN)
      (("" (EXPAND "min_idx")
        ((""
          (WITH-TCCS
           (TYPEPRED "for(1, N - 1, 0,
           LAMBDA (i: subrange(1, N - 1), k: below(N)): A(k) /= 0,
           LAMBDA (i: subrange(1, N - 1), k: below(N)):
             IF A(i) < A(k) THEN i ELSE k ENDIF,
           LAMBDA (i: subrange(1, N), k: below(N)):
             FORALL (j: below(i)): A(k) <= A(j))"))
          (("" (REPLACES -4 :DIR RL)
            (("" (CASE "N=1")
              (("1" (ASSERT) NIL NIL)
               ("2" (ASSERT)
                (("2" (SKOLEM -2 "i" :SKOLEM-TYPEPREDS? T)
                  (("2" (HIDE -5)
                    (("2" (FLATTEN)
                      (("2" (CASE-REPLACE "i <= N-1")
                        (("1" (FLATTEN)
                          (("1" (SKEEP 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)
                         ("2" (ASSERT)
                          (("2" (CASE "i=N")
                            (("1" (SKEEP) (("1" (INST -8 "j") NIL NIL)) NIL)
                             ("2" (ASSERT) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((TRUE CONST-DECL "bool" |booleans| NIL)
    (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|min_idx| CONST-DECL "below(N)" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|ForBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|iter| DEF-DECL "T" |for_while| NIL)
    (|for| CONST-DECL "{t: T |
   IF m <= n
     THEN EXISTS (i: subrange(m, n + 1)):
            (t = iter(m, n)(i - m)(init, f)) AND
             (FORALL (k: subrange(m, i - 1)):
                while(k, iter(m, n)(k - m)(init, f)))
              AND
              (i <= n IMPLIES NOT while(i, t)) AND
               (inv(m, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|max_idx_TCC1| 0
  (|max_idx_TCC2-1| NIL 3931939802
   ("" (SKEEP*)
    (("" (INSTEEP -1) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)
   ((|j| SKOLEM-CONST-DECL "below(1 + k_1)" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|k_1| SKOLEM-CONST-DECL "subrange(1, N - 1)" |for_examples| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL))
   NIL
   (|max_idx| SUBTYPE
    "LAMBDA (i: integers.subrange(1, for_examples.N), k: naturalnumbers.below(for_examples.N)): FORALL (j: naturalnumbers.below(i)): reals.>=(for_examples.A(k), for_examples.A(j))"
    "{inv: defined_types[[subrange(1, for_examples.N), below(for_examples.N)]].PRED | FORALL (k_1: integers.subrange(1, (number_fields.-)(for_examples.N, 1)), ak: below(for_examples.N)): booleans.IMPLIES(inv(k_1, ak), inv((number_fields.+)(1, k_1), IF reals.>(for_examples.A(k_1), for_examples.A(ak)) THEN k_1 ELSE ak ENDIF))}")))
 (|max_idx_sound| 0
  (|max_idx_sound-1| NIL 3931941352
   ("" (SKEEP)
    (("" (SKOLETIN 1)
      (("" (EXPAND "max_idx")
        ((""
          (WITH-TCCS
           (TYPEPRED "for(1, N - 1, 0,
           LAMBDA (i: subrange(1, N - 1), k: below(N)):
             IF A(i) > A(k) THEN i ELSE k ENDIF,
           LAMBDA (i: subrange(1, N), k: below(N)):
             FORALL (j: below(i)): A(k) >= A(j))"))
          (("" (REPLACES -4 :DIR RL)
            (("" (CASE "N=1")
              (("1" (ASSERT) NIL NIL)
               ("2" (ASSERT)
                (("2" (HIDE -3)
                  (("2" (SKOLEM -2 "i" :SKOLEM-TYPEPREDS? T)
                    (("2" (FLATTEN)
                      (("2" (SKEEP)
                        (("2" (INST -6 "j") (("2" (ASSERT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((TRUE CONST-DECL "bool" |booleans| NIL)
    (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|max_idx| CONST-DECL "below(N)" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|ForBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|iter| DEF-DECL "T" |for_while| NIL)
    (|for| CONST-DECL "{t: T |
   IF m <= n
     THEN EXISTS (i: subrange(m, n + 1)):
            (t = iter(m, n)(i - m)(init, f)) AND
             (i = n + 1) AND (inv(m, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|i| SKOLEM-CONST-DECL "subrange(1, N)" |for_examples| NIL)
    (|j| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|find_first_TCC1| 0
  (|find_first_TCC1-1| NIL 3931878674 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|find_first| SUBTYPE
    "LAMBDA (i: naturalnumbers.below(for_examples.N), k: naturalnumbers.nat): for_examples.A(i) /= for_examples.x"
    "PRED[[subrange(0, N - 1), nat]]")))
 (|find_first_TCC2| 0
  (|find_first_TCC2-1| NIL 3931878674 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|find_first| SUBTYPE
    "LAMBDA (i: naturalnumbers.below(for_examples.N), k: naturalnumbers.nat): (number_fields.+)(i, 1)"
    "ForBody[nat](0, (number_fields.-)(for_examples.N, 1))")))
 (|find_first_sound_TCC1| 0
  (|find_first_sound_TCC1-1| NIL 3931812147 ("" (SUBTYPE-TCC) NIL NIL)
   ((|find_first| CONST-DECL "nat" |for_examples| NIL)
    (|for| CONST-DECL "{t: T |
   IF m <= n
     THEN EXISTS (i: subrange(m, n + 1)):
            (t = iter(m, n)(i - m)(init, f)) AND
             (FORALL (k: subrange(m, i - 1)):
                while(k, iter(m, n)(k - m)(init, f)))
              AND (i <= n IMPLIES NOT while(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|for| CONST-DECL "{t: T |
   IF m <= n
     THEN EXISTS (i: subrange(m, n + 1)):
            (t = iter(m, n)(i - m)(init, f)) AND
             (FORALL (k: subrange(m, i - 1)):
                while(k, iter(m, n)(k - m)(init, f)))
              AND
              (i <= n IMPLIES NOT while(i, t)) AND
               (inv(m, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL) (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|find_first_sound| SUBTYPE "for_examples.i" "below(for_examples.N)")))
 (|find_first_sound| 0
  (|find_first_sound-1| NIL 3931811339
   ("" (SKEEP)
    (("" (SKOLETIN 1)
      (("" (EXPAND "find_first")
        ((""
          (WITH-TCCS
           (TYPEPRED "for(0, N - 1, 0, LAMBDA (i: below(N), a: nat): A(i) /= x,
           LAMBDA (i: below(N), a: nat): 1 + i)"))
          (("" (ASSERT)
            (("" (HIDE -2)
              (("" (SKOLEM -1 "j")
                (("" (FLATTEN)
                  (("" (EXPAND "iter")
                    (("" (REPLACES -1)
                      (("" (CASE-REPLACE "IF j = 0 THEN 0 ELSE j ENDIF = j")
                        (("1" (ASSERT)
                          (("1" (HIDE -1)
                            (("1" (SPLIT 1)
                              (("1" (SKEEP :PREDS? T)
                                (("1" (INST -3 "i") (("1" (ASSERT) NIL NIL))
                                  NIL))
                                NIL)
                               ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (T DECL-FORMAL-TYPE NIL |for_examples| NIL)
    (|find_first| CONST-DECL "nat" |for_examples| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)
    (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|ForBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|iter| DEF-DECL "T" |for_while| NIL)
    (|for| CONST-DECL "{t: T |
   IF m <= n
     THEN EXISTS (i: subrange(m, n + 1)):
            (t = iter(m, n)(i - m)(init, f)) AND
             (FORALL (k: subrange(m, i - 1)):
                while(k, iter(m, n)(k - m)(init, f)))
              AND (i <= n IMPLIES NOT while(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|for| CONST-DECL "{t: T |
   IF m <= n
     THEN EXISTS (i: subrange(m, n + 1)):
            (t = iter(m, n)(i - m)(init, f)) AND
             (FORALL (k: subrange(m, i - 1)):
                while(k, iter(m, n)(k - m)(init, f)))
              AND
              (i <= n IMPLIES NOT while(i, t)) AND
               (inv(m, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|k| SKOLEM-CONST-DECL "nat" |for_examples| NIL)
    (|x!1| SKOLEM-CONST-DECL "int" |for_examples| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|M_x_N_eq_1| 0
  (|M_x_N_eq_1-1| NIL 3932054418 ("" (GRIND-REALS) NIL NIL)
   ((|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|product_1| FORMULA-DECL NIL |real_props| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   SHOSTAK))
 (|M_x_N_eq_i_j| 0
  (|M_x_N_eq_i_j-1| NIL 3932055089
   ("" (SKEEP)
    (("" (MOVE-TERMS -1 R 1)
      (("" (FACTOR -1)
        (("" (TYPEPRED "j")
          (("" (CASE-REPLACE "i=M")
            (("1" (ASSERT) NIL NIL)
             ("2" (HIDE 2)
              (("2" (CASE "N*(M-i) < N")
                (("1" (HIDE -3) (("1" (CANCEL-BY -1 "N") NIL NIL)) NIL)
                 ("2" (ASSERT) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|rat_times_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL)
    (|posrat_times_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals|
     NIL)
    (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL)
    (|both_sides_times_pos_lt1| FORMULA-DECL NIL |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   SHOSTAK))
 (|min_mat_idx_TCC1| 0
  (|min_mat_idx_TCC9-1| NIL 3932028563 ("" (GRIND) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL
   (|min_mat_idx| SUBTYPE
    "(number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)"
    "nat")))
 (|min_mat_idx_TCC2| 0
  (|min_mat_idx_TCC1-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|min_mat_idx| SUBTYPE "1" "upto(for_examples.M)")))
 (|min_mat_idx_TCC3| 0
  (|min_mat_idx_TCC2-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|min_mat_idx| SUBTYPE "0" "upto(for_examples.M)")))
 (|min_mat_idx_TCC4| 0
  (|min_mat_idx_TCC3-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|min_mat_idx| SUBTYPE "1" "below(for_examples.N)")))
 (|min_mat_idx_TCC5| 0
  (|min_mat_idx_TCC4-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|min_mat_idx| SUBTYPE "0" "below(for_examples.M)")))
 (|min_mat_idx_TCC6| 0
  (|min_mat_idx_TCC5-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL)
   ((<= CONST-DECL "bool" |reals| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|min_mat_idx| SUBTYPE "(number_fields.+)(for_examples.i, 1)"
    "upto(for_examples.M)")))
 (|min_mat_idx_TCC7| 0
  (|min_mat_idx_TCC6-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL)
   ((<= CONST-DECL "bool" |reals| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|min_mat_idx| SUBTYPE "for_examples.i" "below(for_examples.M)")))
 (|min_mat_idx_TCC8| 0
  (|min_mat_idx_TCC7-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL (|min_mat_idx| SUBTYPE "for_examples.ki" "below(for_examples.M)")))
 (|min_mat_idx_TCC9| 0
  (|min_mat_idx_TCC8-1| NIL 3932028563 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL (|min_mat_idx| SUBTYPE "for_examples.kj" "below(for_examples.N)")))
 (|min_mat_idx_TCC10| 0
  (|min_mat_idx_TCC10-1| NIL 3932030566
   ("" (SKEEP)
    (("" (SKEEP :PREDS? T)
      (("" (BETA -2)
        (("" (FLATTEN)
          (("" (CASE-REPLACE "ak`ixj`1 = M")
            (("1" (BETA) (("1" (ASSERT) NIL NIL)) NIL)
             ("2" (ASSERT)
              (("2" (NAME-REPLACE "i" "ak`ixj`1")
                (("2" (NAME-REPLACE "j" "ak`ixj`2")
                  (("2" (NAME-REPLACE "m" "ak`mxn`1")
                    (("2" (NAME-REPLACE "n" "ak`mxn`2")
                      (("2" (ASSERT)
                        (("2" (CASE-REPLACE "1 + j < N")
                          (("1" (ASSERT)
                            (("1" (HIDE -3)
                              (("1" (SPLIT)
                                (("1" (SKEEP :PREDS? T)
                                  (("1" (REWRITE "i" :DIR RL)
                                    (("1" (REWRITE "j" :DIR RL)
                                      (("1" (ASSERT)
                                        (("1" (LIFT-IF)
                                          (("1" (SPLIT 1)
                                            (("1" (FLATTEN)
                                              (("1" (INSTEEP -6)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (REWRITE "i" :DIR RL) NIL
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2" (FLATTEN)
                                              (("2" (INSTEEP -5)
                                                (("2" (REWRITE "i" :DIR RL) NIL
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (SKEEP :PREDS? T)
                                  (("2" (REWRITE "j" :DIR RL)
                                    (("2" (ASSERT)
                                      (("2"
                                        (CASE-REPLACE "mat(i)(j) < mat(m)(n)")
                                        (("1" (CASE-REPLACE "kj=j")
                                          (("1" (ASSERT) NIL NIL)
                                           ("2" (INSTEEP -6)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (REWRITE "j" :DIR RL)
                                              (("2" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL)
                                         ("2" (ASSERT)
                                          (("2" (INST -5 "kj")
                                            (("2" (REWRITE "j" :DIR RL)
                                              (("2" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT)
                            (("2" (HIDE -2)
                              (("2" (CASE-REPLACE "mat(i)(j) < mat(m)(n)")
                                (("1" (SPLIT)
                                  (("1" (SKEEP :PREDS? T)
                                    (("1" (REWRITE "i" :DIR RL)
                                      (("1" (REWRITE "j" :DIR RL)
                                        (("1" (ASSERT)
                                          (("1" (INSTEEP -5)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (REWRITE "i" :DIR RL)
                                              (("2" (INSTEEP -5)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (REWRITE "j" :DIR RL)
                                                  (("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SKEEP :PREDS? T)
                                      (("2" (REWRITE "j" :DIR RL)
                                        (("2" (ASSERT) NIL NIL)) NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (SPLIT)
                                  (("1" (SKEEP :PREDS? T)
                                    (("1" (REWRITE "i" :DIR RL)
                                      (("1" (REWRITE "j" :DIR RL)
                                        (("1" (ASSERT)
                                          (("1" (INSTEEP -4)
                                            (("1" (REWRITE "i" :DIR RL)
                                              (("1" (INSTEEP -4)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (REWRITE "j" :DIR RL)
                                                  (("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SKEEP :PREDS? T)
                                      (("2" (REWRITE "j" :DIR RL)
                                        (("2" (ASSERT) NIL NIL)) NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|State| TYPE-EQ-DECL NIL |for_examples| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|ki| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN ak`ixj`1 ELSE 1 + ak`ixj`1 ENDIF)"
     |for_examples| NIL)
    (|kj| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (|ki| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN ak`ixj`1 ELSE 1 + ak`ixj`1 ENDIF)"
     |for_examples| NIL)
    (|kj| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (|i| SKOLEM-CONST-DECL "upto(M)" |for_examples| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (M SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|ak| SKOLEM-CONST-DECL "State(M, N)" |for_examples| NIL)
    (|ki| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN ak`ixj`1 ELSE 1 + ak`ixj`1 ENDIF)"
     |for_examples| NIL)
    (|j| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (|kj| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN 1 + ak`ixj`2 ELSE 0 ENDIF)" |for_examples|
     NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|min_mat_idx| SUBTYPE
    "LAMBDA (ij: naturalnumbers.upto((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), s: for_examples.State(for_examples.M, for_examples.N)): LET (m, n) = s`mxn, (i, j) = s`ixj IN booleans.AND((number_fields.+)(ij, 1) = (number_fields.+)(number_fields.*(for_examples.i, for_examples.N), for_examples.j), booleans.AND((FORALL (ki: naturalnumbers.below(for_examples.i), kj: naturalnumbers.below(for_examples.N)): reals.<=(for_examples.mat(for_examples.m)(for_examples.n), for_examples.mat(ki)(kj))), (booleans.IMPLIES(reals.<(for_examples.i, for_examples.M), FORALL (kj: naturalnumbers.below(for_examples.j)): reals.<=(for_examples.mat(for_examples.m)(for_examples.n), for_examples.mat(for_examples.i)(kj))))))"
    "{inv: defined_types[[upto((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), State(for_examples.M, for_examples.N)]].PRED | FORALL (k: naturalnumbers.below((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), ak: State(for_examples.M, for_examples.N)): booleans.IMPLIES(inv(k, ak), inv((number_fields.+)(1, k), IF ak`ixj`1 = for_examples.M THEN ak ELSE ak WITH [mxn := IF reals.<(for_examples.mat(ak`ixj`1)(ak`ixj`2), for_examples.mat(ak`mxn`1)(ak`mxn`2)) THEN (ak`ixj`1, ak`ixj`2) ELSE ak`mxn ENDIF, ixj := IF reals.<((number_fields.+)(1, ak`ixj`2), for_examples.N) THEN (ak`ixj`1, (number_fields.+)(1, ak`ixj`2)) ELSE ((number_fields.+)(1, ak`ixj`1), 0) ENDIF] ENDIF))}")))
 (|min_mat_idx_sound| 0
  (|min_mat_idx_sound-1| NIL 3932040233
   ("" (SKEEP)
    (("" (SKOLETIN)
      (("" (NAME-REPLACE "mm" "min_mat_idx(M,N,mat)" :HIDE? NIL)
        (("" (EXPAND "min_mat_idx")
          ((""
            (NAME-REPLACE "init" "(# mxn := (0, 0),
               ixj := IF N = 1 THEN (1, 0) ELSE (0, 1) ENDIF #)"
             :HIDE? NIL)
            ((""
              (NAME-REPLACE "guard"
               "LAMBDA (s: State(M, N)): mat(s`mxn`1)(s`mxn`2) /= 0" :HIDE?
               NIL)
              ((""
                (WITH-TCCS
                 (NAME-REPLACE "body" "LAMBDA (s: State(M, N)):
              IF s`ixj`1 = M THEN s
              ELSE s
                     WITH [mxn
                             := IF mat(s`ixj`1)(s`ixj`2) <
                                    mat(s`mxn`1)(s`mxn`2)
                                  THEN (s`ixj`1, s`ixj`2)
                                ELSE s`mxn
                                ENDIF,
                           ixj
                             := IF 1 + s`ixj`2 < N
                                  THEN (s`ixj`1, 1 + s`ixj`2)
                                ELSE (1 + s`ixj`1, 0)
                                ENDIF]
              ENDIF"))
                ((""
                  (WITH-TCCS
                   (NAME-REPLACE "inv"
                    "LAMBDA (ij: upto(M * N - 1), s: State(M, N)): 1 + ij = s`ixj`1 * N + s`ixj`2 AND
              (FORALL (ki: below(s`ixj`1), kj: below(N)):
                 mat(s`mxn`1)(s`mxn`2) <= mat(ki)(kj))
               AND
               (s`ixj`1 < M IMPLIES
                 FORALL (kj: below(s`ixj`2)):
                   mat(s`mxn`1)(s`mxn`2) <= mat(s`ixj`1)(kj))"
                    :HIDE? NIL))
                  ((""
                    (WITH-TCCS
                     (TYPEPRED "while(M * N - 1, init, guard, body, inv)"))
                    (("" (CASE-REPLACE "M*N-1 > 0")
                      (("1" (SKEEP -2 :PREDS? T)
                        (("1" (ASSERT)
                          (("1"
                            (NAME-REPLACE "W"
                             "while(M * N - 1, init, guard, body, inv)")
                            (("1" (REPLACE -7 -6 :DIR RL)
                              (("1" (BETA)
                                (("1" (SPLIT -6)
                                  (("1" (FLATTEN)
                                    (("1" (SKEEP :PREDS? T)
                                      (("1" (SPLIT -10)
                                        (("1" (EXPAND "guard" 1)
                                          (("1" (FLATTEN)
                                            (("1" (ASSERT) NIL NIL)) NIL))
                                          NIL)
                                         ("2" (LEMMA "M_x_N_eq_i_j")
                                          (("2" (INST? -1)
                                            (("2" (ASSERT)
                                              (("2" (FLATTEN)
                                                (("2" (INST -6 "i!1" "j")
                                                  (("1" (ASSERT) NIL NIL)
                                                   ("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (HIDE-ALL-BUT (-8 1))
                                    (("2" (GRIND) NIL NIL)) NIL)
                                   ("3" (HIDE 2)
                                    (("3" (SKEEP :PREDS? T)
                                      (("3" (REPLACE -10 :DIR RL)
                                        (("3" (BETA)
                                          (("3" (CASE-REPLACE "N=1")
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("4" (FLATTEN)
                                    (("4" (HIDE 2)
                                      (("4" (REPLACE -9 :DIR RL)
                                        (("4" (ASSERT)
                                          (("4" (CASE-REPLACE "N=1")
                                            (("1" (SKEEP :PREDS? T)
                                              (("1" (ASSERT) NIL NIL)) NIL)
                                             ("2" (ASSERT)
                                              (("2" (SKEEP :PREDS? T)
                                                (("2" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (LEMMA "M_x_N_eq_1")
                        (("2" (INSTEEP)
                          (("2" (ASSERT)
                            (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|exp2| DEF-DECL "posnat" |exp2| NIL)
    (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL)
    (|even?| CONST-DECL "bool" |integers| NIL)
    (|even_uint8| TYPE-EQ-DECL NIL |integertypes| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|iterate| DEF-DECL "T" |function_iterate| NIL)
    (|while| CONST-DECL "{t: T |
   IF N > 0
     THEN EXISTS (i: upto(N)):
            (t = iterate(f, i)(init)) AND
             (FORALL (k: below(i)): while(iterate(f, k)(init))) AND
              (i < N IMPLIES NOT while(t)) AND
               (inv(0, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|M_x_N_eq_1| FORMULA-DECL NIL |for_examples| NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|plus_u8_u8| APPLICATION-JUDGEMENT "uint16" |integertypes| NIL)
    (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL)
    (|guard| SKOLEM-CONST-DECL "[State(M, N) -> boolean]" |for_examples| NIL)
    (M SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|i!1| SKOLEM-CONST-DECL "below(M)" |for_examples| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|body| SKOLEM-CONST-DECL "[State(M, N) -> State(M, N)]" |for_examples|
     NIL)
    (|init| SKOLEM-CONST-DECL
     "[# ixj: [uint8, uint8], mxn: [even_uint8, even_uint8] #]" |for_examples|
     NIL)
    (|inv| SKOLEM-CONST-DECL "[[upto(M * N - 1), State(M, N)] -> boolean]"
     |for_examples| NIL)
    (W SKOLEM-CONST-DECL "{t: State(M, N) |
   IF M * N - 1 > 0
     THEN EXISTS (i: upto(M * N - 1)):
            t = iterate[State(M, N)](body, i)(init) AND
             (FORALL (k: below(i)):
                guard(iterate[State(M, N)](body, k)(init)))
              AND
              (i < M * N - 1 IMPLIES NOT guard(t)) AND
               (inv(0, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_examples| NIL)
    (|M_x_N_eq_i_j| FORMULA-DECL NIL |for_examples| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|State| TYPE-EQ-DECL NIL |for_examples| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|min_mat_idx| CONST-DECL "[below(M), below(N)]" |for_examples| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL))
   SHOSTAK))
 (|max_mat_idx_TCC1| 0
  (|max_mat_idx_TCC1-1| NIL 3932049279 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL (|max_mat_idx| SUBTYPE "for_examples.kj" "below(for_examples.N)")))
 (|max_mat_idx_TCC2| 0
  (|max_mat_idx_TCC2-2| NIL 3932049325
   ("" (SKEEP)
    (("" (SKEEP :PREDS? T)
      (("" (BETA -2)
        (("" (FLATTEN)
          (("" (CASE-REPLACE "ak`ixj`1 = M")
            (("1" (BETA) (("1" (ASSERT) NIL NIL)) NIL)
             ("2" (ASSERT)
              (("2" (NAME-REPLACE "i" "ak`ixj`1")
                (("2" (NAME-REPLACE "j" "ak`ixj`2")
                  (("2" (NAME-REPLACE "m" "ak`mxn`1")
                    (("2" (NAME-REPLACE "n" "ak`mxn`2")
                      (("2" (ASSERT)
                        (("2" (CASE-REPLACE "1 + j < N")
                          (("1" (ASSERT)
                            (("1" (HIDE -3)
                              (("1" (SPLIT)
                                (("1" (SKEEP :PREDS? T)
                                  (("1" (REWRITE "i" :DIR RL)
                                    (("1" (REWRITE "j" :DIR RL)
                                      (("1" (ASSERT)
                                        (("1" (LIFT-IF)
                                          (("1" (SPLIT 1)
                                            (("1" (FLATTEN)
                                              (("1" (INSTEEP -6)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (REWRITE "i" :DIR RL) NIL
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2" (FLATTEN)
                                              (("2" (INSTEEP -5)
                                                (("2" (REWRITE "i" :DIR RL) NIL
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (SKEEP :PREDS? T)
                                  (("2" (REWRITE "j" :DIR RL)
                                    (("2" (ASSERT)
                                      (("2"
                                        (CASE-REPLACE "mat(i)(j) > mat(m)(n)")
                                        (("1" (CASE-REPLACE "kj=j")
                                          (("1" (ASSERT) NIL NIL)
                                           ("2" (INSTEEP -6)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (REWRITE "j" :DIR RL)
                                              (("2" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL)
                                         ("2" (ASSERT)
                                          (("2" (INST -5 "kj")
                                            (("2" (REWRITE "j" :DIR RL)
                                              (("2" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT)
                            (("2" (HIDE -2)
                              (("2" (CASE-REPLACE "mat(i)(j) > mat(m)(n)")
                                (("1" (SPLIT)
                                  (("1" (SKEEP :PREDS? T)
                                    (("1" (REWRITE "i" :DIR RL)
                                      (("1" (REWRITE "j" :DIR RL)
                                        (("1" (ASSERT)
                                          (("1" (INSTEEP -5)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (REWRITE "i" :DIR RL)
                                              (("2" (INSTEEP -5)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (REWRITE "j" :DIR RL)
                                                  (("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SKEEP :PREDS? T)
                                      (("2" (REWRITE "j" :DIR RL)
                                        (("2" (ASSERT) NIL NIL)) NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (SPLIT)
                                  (("1" (SKEEP :PREDS? T)
                                    (("1" (REWRITE "i" :DIR RL)
                                      (("1" (REWRITE "j" :DIR RL)
                                        (("1" (ASSERT)
                                          (("1" (INSTEEP -4)
                                            (("1" (REWRITE "i" :DIR RL)
                                              (("1" (INSTEEP -4)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (REWRITE "j" :DIR RL)
                                                  (("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SKEEP :PREDS? T)
                                      (("2" (REWRITE "j" :DIR RL)
                                        (("2" (ASSERT) NIL NIL)) NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|kj| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN 1 + ak`ixj`2 ELSE 0 ENDIF)" |for_examples|
     NIL)
    (|j| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (|ki| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN ak`ixj`1 ELSE 1 + ak`ixj`1 ENDIF)"
     |for_examples| NIL)
    (|ak| SKOLEM-CONST-DECL "State(M, N)" |for_examples| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (M SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|i| SKOLEM-CONST-DECL "upto(M)" |for_examples| NIL)
    (|kj| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (|ki| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN ak`ixj`1 ELSE 1 + ak`ixj`1 ENDIF)"
     |for_examples| NIL)
    (|kj| SKOLEM-CONST-DECL "below(N)" |for_examples| NIL)
    (|ki| SKOLEM-CONST-DECL
     "below(IF 1 + ak`ixj`2 < N THEN ak`ixj`1 ELSE 1 + ak`ixj`1 ENDIF)"
     |for_examples| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|State| TYPE-EQ-DECL NIL |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL
   (|max_mat_idx| SUBTYPE
    "LAMBDA (ij: naturalnumbers.upto((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), s: for_examples.State(for_examples.M, for_examples.N)): LET (m, n) = s`mxn, (i, j) = s`ixj IN booleans.AND((number_fields.+)(ij, 1) = (number_fields.+)(number_fields.*(for_examples.i, for_examples.N), for_examples.j), booleans.AND((FORALL (ki: naturalnumbers.below(for_examples.i), kj: naturalnumbers.below(for_examples.N)): reals.>=(for_examples.mat(for_examples.m)(for_examples.n), for_examples.mat(ki)(kj))), (booleans.IMPLIES(reals.<(for_examples.i, for_examples.M), FORALL (kj: naturalnumbers.below(for_examples.j)): reals.>=(for_examples.mat(for_examples.m)(for_examples.n), for_examples.mat(for_examples.i)(kj))))))"
    "{inv: defined_types[[upto((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), State(for_examples.M, for_examples.N)]].PRED | FORALL (k: naturalnumbers.below((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), ak: State(for_examples.M, for_examples.N)): booleans.IMPLIES(inv(k, ak), inv((number_fields.+)(1, k), IF ak`ixj`1 = for_examples.M THEN ak ELSE ak WITH [mxn := IF reals.>(for_examples.mat(ak`ixj`1)(ak`ixj`2), for_examples.mat(ak`mxn`1)(ak`mxn`2)) THEN (ak`ixj`1, ak`ixj`2) ELSE ak`mxn ENDIF, ixj := IF reals.<((number_fields.+)(1, ak`ixj`2), for_examples.N) THEN (ak`ixj`1, (number_fields.+)(1, ak`ixj`2)) ELSE ((number_fields.+)(1, ak`ixj`1), 0) ENDIF] ENDIF))}"))
  (|max_mat_idx_TCC2-1| NIL 3932049279 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|max_mat_idx| SUBTYPE
    "LAMBDA (ij: naturalnumbers.upto((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), s: for_examples.State(for_examples.M, for_examples.N)): LET (m, n) = s`mxn, (i, j) = s`ixj IN booleans.AND((number_fields.+)(ij, 1) = (number_fields.+)(number_fields.*(for_examples.i, for_examples.N), for_examples.j), booleans.AND((FORALL (ki: naturalnumbers.below(for_examples.i), kj: naturalnumbers.below(for_examples.N)): reals.>=(for_examples.mat(for_examples.m)(for_examples.n), for_examples.mat(ki)(kj))), (booleans.IMPLIES(reals.<(for_examples.i, for_examples.M), FORALL (kj: naturalnumbers.below(for_examples.j)): reals.>=(for_examples.mat(for_examples.m)(for_examples.n), for_examples.mat(for_examples.i)(kj))))))"
    "{inv: defined_types[[upto((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), State(for_examples.M, for_examples.N)]].PRED | FORALL (k: naturalnumbers.below((number_fields.-)(number_fields.*(for_examples.M, for_examples.N), 1)), ak: State(for_examples.M, for_examples.N)): booleans.IMPLIES(inv(k, ak), inv((number_fields.+)(1, k), IF ak`ixj`1 = for_examples.M THEN ak ELSE ak WITH [mxn := IF reals.>(for_examples.mat(ak`ixj`1)(ak`ixj`2), for_examples.mat(ak`mxn`1)(ak`mxn`2)) THEN (ak`ixj`1, ak`ixj`2) ELSE ak`mxn ENDIF, ixj := IF reals.<((number_fields.+)(1, ak`ixj`2), for_examples.N) THEN (ak`ixj`1, (number_fields.+)(1, ak`ixj`2)) ELSE ((number_fields.+)(1, ak`ixj`1), 0) ENDIF] ENDIF))}")))
 (|max_mat_idx_sound| 0
  (|max_mat_idx_sound-1| NIL 3932049506
   ("" (SKEEP)
    (("" (SKOLETIN)
      (("" (NAME-REPLACE "mm" "max_mat_idx(M,N,mat)" :HIDE? NIL)
        (("" (EXPAND "max_mat_idx")
          ((""
            (NAME-REPLACE "init" "(# mxn := (0, 0),
               ixj := IF N = 1 THEN (1, 0) ELSE (0, 1) ENDIF #)"
             :HIDE? NIL)
            ((""
              (WITH-TCCS
               (NAME-REPLACE "body" "LAMBDA (s: State(M, N)):
              IF s`ixj`1 = M THEN s
              ELSE s
                     WITH [mxn
                             := IF mat(s`ixj`1)(s`ixj`2) >
                                    mat(s`mxn`1)(s`mxn`2)
                                  THEN (s`ixj`1, s`ixj`2)
                                ELSE s`mxn
                                ENDIF,
                           ixj
                             := IF 1 + s`ixj`2 < N
                                  THEN (s`ixj`1, 1 + s`ixj`2)
                                ELSE (1 + s`ixj`1, 0)
                                ENDIF]
              ENDIF"))
              ((""
                (WITH-TCCS
                 (NAME-REPLACE "inv"
                  "LAMBDA (ij: upto(M * N - 1), s: State(M, N)):
              1 + ij = s`ixj`1 * N + s`ixj`2 AND
              (FORALL (ki: below(s`ixj`1), kj: below(N)):
                 mat(s`mxn`1)(s`mxn`2) >= mat(ki)(kj))
               AND
               (s`ixj`1 < M IMPLIES
                 FORALL (kj: below(s`ixj`2)):
                   mat(s`mxn`1)(s`mxn`2) >= mat(s`ixj`1)(kj))"
                  :HIDE? NIL))
                (("" (WITH-TCCS (TYPEPRED "while(M * N - 1, init, body, inv)"))
                  (("" (CASE-REPLACE "M*N-1 > 0")
                    (("1" (SKEEP -2 :PREDS? T)
                      (("1"
                        (NAME-REPLACE "W" "while(M * N - 1, init, body, inv)")
                        (("1" (REPLACE -6 -5 :DIR RL)
                          (("1" (BETA)
                            (("1" (SPLIT -5)
                              (("1" (FLATTEN)
                                (("1" (SKEEP :PREDS? T)
                                  (("1" (LEMMA "M_x_N_eq_i_j")
                                    (("1" (INST? -1)
                                      (("1" (ASSERT)
                                        (("1" (FLATTEN)
                                          (("1" (INST -6 "i!1" "j")
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (HIDE-ALL-BUT (-6 1))
                                (("2" (GRIND) NIL NIL)) NIL)
                               ("3" (HIDE 2)
                                (("3" (SKEEP :PREDS? T)
                                  (("3" (REPLACE -8 :DIR RL)
                                    (("3" (BETA)
                                      (("3" (CASE-REPLACE "N=1")
                                        (("1" (ASSERT) NIL NIL)
                                         ("2" (ASSERT) NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("4" (FLATTEN)
                                (("4" (HIDE 2)
                                  (("4" (REPLACE -7 :DIR RL)
                                    (("4" (ASSERT)
                                      (("4" (CASE-REPLACE "N=1")
                                        (("1" (SKEEP :PREDS? T)
                                          (("1" (ASSERT) NIL NIL)) NIL)
                                         ("2" (ASSERT)
                                          (("2" (SKEEP :PREDS? T)
                                            (("2" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (LEMMA "M_x_N_eq_1")
                      (("2" (INSTEEP)
                        (("2" (ASSERT)
                          (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((TRUE CONST-DECL "bool" |booleans| NIL)
    (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|max_mat_idx| CONST-DECL "[below(M), below(N)]" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|State| TYPE-EQ-DECL NIL |for_examples| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|iterate| DEF-DECL "T" |function_iterate| NIL)
    (|while| CONST-DECL "{t: T |
   IF N > 0
     THEN EXISTS (i: upto(N)):
            (t = iterate(f, i)(init)) AND
             (i = N) AND (inv(0, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_while| NIL)
    (|M_x_N_eq_1| FORMULA-DECL NIL |for_examples| NIL)
    (M SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|i!1| SKOLEM-CONST-DECL "below(M)" |for_examples| NIL)
    (N SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|body| SKOLEM-CONST-DECL "[State(M, N) -> State(M, N)]" |for_examples|
     NIL)
    (|init| SKOLEM-CONST-DECL
     "[# ixj: [uint8, uint8], mxn: [even_uint8, even_uint8] #]" |for_examples|
     NIL)
    (|inv| SKOLEM-CONST-DECL "[[upto(M * N - 1), State(M, N)] -> boolean]"
     |for_examples| NIL)
    (W SKOLEM-CONST-DECL "{t: State(M, N) |
   IF M * N - 1 > 0
     THEN EXISTS (i: upto(M * N - 1)):
            t = iterate[State(M, N)](body, i)(init) AND
             (i = M * N - 1) AND (inv(0, init) IMPLIES inv(i, t))
   ELSE t = init
   ENDIF}"
     |for_examples| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|M_x_N_eq_i_j| FORMULA-DECL NIL |for_examples| NIL)
    (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL)
    (|plus_u8_u8| APPLICATION-JUDGEMENT "uint16" |integertypes| NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|even_uint8| TYPE-EQ-DECL NIL |integertypes| NIL)
    (|even?| CONST-DECL "bool" |integers| NIL)
    (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL)
    (|exp2| DEF-DECL "posnat" |exp2| NIL))
   NIL))
 (|sum_array_logic_TCC1| 0
  (|sum_array_logic_TCC1-1| |nil| 3759586521 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|sum_array_logic| SUBTYPE "(number_fields.-)(for_examples.i, 1)"
    "below(for_examples.n)")))
 (|sum_array_logic_TCC2| 0
  (|sum_array_logic_TCC2-1| |nil| 3759586521 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|sum_array_logic| SUBTYPE "(number_fields.-)(for_examples.i, 1)"
    "upto(for_examples.n)")))
 (|sum_array_logic_TCC3| 0
  (|sum_array_logic_TCC3-1| |nil| 3759586521 ("" (TERMINATION-TCC) NIL NIL) NIL
   NIL
   (|sum_array_logic| TERMINATION
    "for_examples.sum_array_logic(for_examples.n, for_examples.A)((number_fields.-)(for_examples.i, 1))"
    "NIL")))
 (|sum_array_sound_TCC1| 0
  (|sum_array_sound_TCC1-1| NIL 3931811310 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|sum_array_sound| SUBTYPE "for_examples.n" "upto(for_examples.n)")))
 (|sum_array_sound| 0
  (|sum_array_sound-3| |nil| 3759589303
   ("" (SKEEP)
    (("" (EXPAND "sum_array")
      (("" (LEMMA "for_invariant[real]")
        (("" (INST?)
          (("1" (INST -1 "sum_array_inv(n,A)")
            (("1" (ASSERT)
              (("1" (HIDE 2)
                (("1" (SPLIT)
                  (("1" (GRIND) NIL NIL)
                   ("2" (SKEEP)
                    (("2" (LIFT-IF)
                      (("2" (SPLIT)
                        (("1" (FLATTEN)
                          (("1" (EXPAND "sum_array_logic" +)
                            (("1" (ASSERT) NIL NIL)) NIL))
                          NIL)
                         ("2" (FLATTEN)
                          (("2" (EXPAND "sum_array_logic" +)
                            (("2" (ASSERT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|sum_array| CONST-DECL "real" |for_examples| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (|ForBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|Maybe| TYPE-DECL NIL |Maybe| NIL)
    (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |for_examples| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|sum_array_logic| DEF-DECL "real" |for_examples| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|for_invariant| FORMULA-DECL NIL |for_iterate| NIL))
   NIL)
  (|sum_array_sound-2| |nil| 3759586570
   ("" (SKEEP)
    (("" (EXPAND "expit")
      (("" (LEMMA "for_induction[real]")
        (("" (INST?)
          (("" (INST -1 "expit_inv(x,n)")
            (("" (REWRITE "expt_x0")
              (("" (ASSERT)
                (("" (HIDE 2)
                  (("" (SKEEP)
                    (("" (CASE-REPLACE "x=0")
                      (("1" (GRIND) NIL)
                       ("2" (REWRITE "expt_plus")
                        (("2" (REWRITE "expt_x1")
                          (("2" (ASSERT) NIL))))))))))))))))))))))))
    NIL)
   NIL NIL)
  (|sum_array_sound-1| |nil| 3759586538
   ("" (SKEEP)
    (("" (LEMMA "for_induction[real]")
      (("" (INST?) (("" (ASSERT) (("" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL))
    NIL)
   NIL SHOSTAK))
 (|maxit_TCC1| 0
  (|maxit_TCC1-1| |nil| 3505593581 ("" (GRIND) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   NIL
   (|maxit| SUBTYPE
    "(number_fields.-)(list_props[real].length(for_examples.l), 1)"
    "upfrom(0)")))
 (|maxit_TCC2| 0
  (|maxit_TCC2-1| |nil| 3508362429 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|maxit| SUBTYPE
    "LAMBDA (i: naturalnumbers.below(list_props[real].length(for_examples.l))): list_props[real].nth(for_examples.l, i)"
    "IterateBody[real](0, (number_fields.-)(list_props[real].length(for_examples.l), 1))")))
 (|maxit_test| 0
  (|maxit_test-1| |nil| 3505593776 ("" (GRIND) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|maxit| CONST-DECL "real" |for_examples| NIL)
    (|iterate_left| CONST-DECL "T" |for_iterate| NIL)
    (|for| CONST-DECL "T" |for_iterate| NIL)
    (|for_it| DEF-DECL
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}" |for_iterate|
     NIL)
    (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL)
    (|nth| DEF-DECL "T" |list_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   SHOSTAK))
 (|maxit_inv_TCC1| 0
  (|maxit_inv_TCC1-1| |nil| 3759694339 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|maxit_inv| SUBTYPE "for_examples.k" "below[length[real](l)]")))
 (|maxit_sound| 0
  (|maxit_sound-1| |nil| 3508424536
   ("" (SKEEP)
    (("" (EXPAND "maxit")
      (("" (LEMMA "iterate_left_invariant[real]")
        (("" (INST? -1)
          (("1" (INST -1 "maxit_inv(l)")
            (("1" (SPLIT -1)
              (("1" (SKEEP) (("1" (INSTEEP) NIL NIL)) NIL)
               ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
               ("3" (HIDE 2)
                (("3" (SKOSIMP*)
                  (("3" (REWRITE "max_ge")
                    (("3" (FLATTEN)
                      (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
           ("3" (HIDE 2) (("3" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|maxit| CONST-DECL "real" |for_examples| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (|IterateBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nth| DEF-DECL "T" |list_props| NIL)
    (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|l| SKOLEM-CONST-DECL "(cons?[real])" |for_examples| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|k!1| SKOLEM-CONST-DECL "subrange(0, length(l) - 2)" |for_examples| NIL)
    (|k!2| SKOLEM-CONST-DECL "upto(1 + k!1)" |for_examples| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|max_ge| FORMULA-DECL NIL |real_defs| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|iterate_left_invariant| FORMULA-DECL NIL |for_iterate| NIL))
   SHOSTAK))
 (|minit_test| 0
  (|minit_test-1| |nil| 3508284859 ("" (GRIND) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minit| CONST-DECL "real" |for_examples| NIL)
    (|iterate_right| CONST-DECL "T" |for_iterate| NIL)
    (|for_down| CONST-DECL "T" |for_iterate| NIL)
    (|for| CONST-DECL "T" |for_iterate| NIL)
    (|for_it| DEF-DECL
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}" |for_iterate|
     NIL)
    (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL)
    (|nth| DEF-DECL "T" |list_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   SHOSTAK))
 (|minit_inv_TCC1| 0
  (|minit_inv_TCC1-1| |nil| 3759745861 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|minit_inv| SUBTYPE "for_examples.k" "below[length[real](l)]")))
 (|minit_sound| 0
  (|minit_sound-1| |nil| 3508461473
   ("" (SKEEP)
    (("" (EXPAND "minit")
      (("" (LEMMA "iterate_right_invariant[real]")
        (("" (INST?)
          (("1" (INST -1 "minit_inv(l)")
            (("1" (SPLIT -1)
              (("1" (SKEEP) (("1" (INSTEEP) NIL NIL)) NIL)
               ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
               ("3" (HIDE 2)
                (("3" (SKOSIMP*)
                  (("3" (REWRITE "min_le")
                    (("3" (FLATTEN)
                      (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
           ("3" (HIDE 2) (("3" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|minit| CONST-DECL "real" |for_examples| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (|IterateBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nth| DEF-DECL "T" |list_props| NIL)
    (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|l| SKOLEM-CONST-DECL "(cons?[real])" |for_examples| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|k!1| SKOLEM-CONST-DECL "subrange(1, length(l) - 1)" |for_examples| NIL)
    (|k!2| SKOLEM-CONST-DECL "subrange(k!1 - 1, length(l) - 1)" |for_examples|
     NIL)
    (|min_le| FORMULA-DECL NIL |real_defs| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|iterate_right_invariant| FORMULA-DECL NIL |for_iterate| NIL))
   SHOSTAK))
 (|forall_and_upto_TCC1| 0
  (|forall_and_upto_TCC1-1| |nil| 3720484860 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|forall_and_upto| SUBTYPE "for_examples.P"
    "IterateBody[bool](0, for_examples.n)")))
 (|forall_and_upto| 0
  (|forall_and_upto-1| |nil| 3720484878
   ("" (SKEEP)
    (("" (LEMMA "iterate_left_induction[bool]")
      (("" (INST?)
        (("" (INST -1 "LAMBDA(j:upto(n),a:bool):(FORALL(k:upto(j)):P(k)) = a")
          (("" (SPLIT -1)
            (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
             ("3" (HIDE 2)
              (("3" (SKOLEM 1 ("kk" "ak"))
                (("3" (FLATTEN)
                  (("3" (REPLACES -1 :DIR RL)
                    (("3" (IFF)
                      (("3" (SPLIT)
                        (("1" (FLATTEN)
                          (("1" (SPLIT)
                            (("1" (SKEEP) (("1" (INST -1 "k") NIL NIL)) NIL)
                             ("2" (INST -1 "kk+1") (("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (FLATTEN)
                          (("2" (SKEEP)
                            (("2" (INST -1 "k") (("2" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|iterate_left_induction| FORMULA-DECL NIL |for_iterate| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|k| SKOLEM-CONST-DECL "upto(1 + kk)" |for_examples| NIL)
    (|kk| SKOLEM-CONST-DECL "below(n)" |for_examples| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |for_examples| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IterateBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL))
   SHOSTAK))
 (|forall_and_below_TCC1| 0
  (|forall_and_below_TCC1-1| |nil| 3720484986 ("" (SUBTYPE-TCC) NIL NIL) NIL
   NIL
   (|forall_and_below| SUBTYPE "(number_fields.-)(for_examples.n, 1)"
    "upfrom(0)")))
 (|forall_and_below| 0
  (|forall_and_below-1| |nil| 3720485076
   ("" (SKEEP)
    (("" (LEMMA "forall_and_upto")
      (("" (IFF)
        (("" (INST -1 "n-1" "P")
          (("1" (SPLIT)
            (("1" (FLATTEN)
              (("1" (ASSERT) (("1" (SKEEP) (("1" (INSTEEP) NIL NIL)) NIL))
                NIL))
              NIL)
             ("2" (FLATTEN)
              (("2" (REPLACES -2 :DIR RL)
                (("2" (SKEEP) (("2" (INSTEEP) NIL NIL)) NIL)) NIL))
              NIL))
            NIL)
           ("2" (SKEEP) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|forall_and_upto| FORMULA-DECL NIL |for_examples| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (P SKOLEM-CONST-DECL "[below(n) -> bool]" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|n| SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL))
 (|forall_and_subrange| 0
  (|forall_and_subrange-2| |nil| 3720486550
   ("" (SKEEP)
    (("" (LEMMA "iterate_left_induction[bool]")
      (("" (INST?)
        ((""
          (INST -1
           "LAMBDA(j:upto(n-m),a:bool):(FORALL(k:subrange(m,m+j)):P(k)) = a")
          (("" (SPLIT -1)
            (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
             ("3" (HIDE 2)
              (("3" (SKOLEM 1 ("kk" "ak"))
                (("3" (FLATTEN)
                  (("3" (REPLACES -1 :DIR RL)
                    (("3" (IFF)
                      (("3" (SPLIT)
                        (("1" (FLATTEN)
                          (("1" (SPLIT)
                            (("1" (SKEEP) (("1" (INST -1 "k") NIL NIL)) NIL)
                             ("2" (INST -1 "kk+m+1") (("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (FLATTEN)
                          (("2" (SKEEP)
                            (("2" (INST -1 "k") (("2" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|iterate_left_induction| FORMULA-DECL NIL |for_iterate| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|k| SKOLEM-CONST-DECL "subrange(m, 1 + kk + m)" |for_examples| NIL)
    (|kk| SKOLEM-CONST-DECL "below(n - m)" |for_examples| NIL)
    (|n| SKOLEM-CONST-DECL "upfrom(m)" |for_examples| NIL)
    (|m| SKOLEM-CONST-DECL "int" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|IterateBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   NIL)
  (|forall_and_subrange-1| |nil| 3720486166
   ("" (SKEEP)
    (("" (LEMMA "forall_and_upto")
      (("" (IFF)
        (("" (INST -1 "n-1" "P")
          (("1" (SPLIT)
            (("1" (FLATTEN)
              (("1" (ASSERT) (("1" (SKEEP) (("1" (INSTEEP) NIL)))))))
             ("2" (FLATTEN)
              (("2" (REPLACES -2 :DIR RL)
                (("2" (SKEEP) (("2" (INSTEEP) NIL)))))))))
           ("2" (SKEEP) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))))))
    NIL)
   NIL NIL))
 (|exists_or_upto| 0
  (|exists_or_upto-1| |nil| 3782424154
   ("" (SKEEP)
    (("" (LEMMA "iterate_left_induction[bool]")
      (("" (INST?)
        (("" (INST -1 "LAMBDA(j:upto(n),a:bool):(EXISTS(k:upto(j)):P(k)) = a")
          (("" (SPLIT -1)
            (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
             ("3" (HIDE 2)
              (("3" (SKOLEM 1 ("kk" "ak"))
                (("3" (FLATTEN)
                  (("3" (REPLACES -1 :DIR RL)
                    (("3" (IFF)
                      (("3" (SPLIT)
                        (("1" (FLATTEN)
                          (("1" (SKEEP)
                            (("1" (INSTEEP) (("1" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL)
                         ("2" (FLATTEN)
                          (("2" (SPLIT)
                            (("1" (SKEEP) (("1" (INSTEEP) NIL NIL)) NIL)
                             ("2" (INST 1 "kk+1") (("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|iterate_left_induction| FORMULA-DECL NIL |for_iterate| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |for_examples| NIL)
    (|kk| SKOLEM-CONST-DECL "below(n)" |for_examples| NIL)
    (|k| SKOLEM-CONST-DECL "upto(1 + kk)" |for_examples| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IterateBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL))
   NIL))
 (|exists_or_below| 0
  (|exists_or_below-1| |nil| 3782424249
   ("" (SKEEP)
    (("" (LEMMA "exists_or_upto")
      (("" (IFF)
        (("" (INST -1 "n-1" "P")
          (("1" (SPLIT)
            (("1" (FLATTEN)
              (("1" (ASSERT) (("1" (SKEEP) (("1" (INSTEEP) NIL NIL)) NIL))
                NIL))
              NIL)
             ("2" (FLATTEN)
              (("2" (REPLACES -2 :DIR RL)
                (("2" (SKEEP) (("2" (INSTEEP) NIL NIL)) NIL)) NIL))
              NIL))
            NIL)
           ("2" (SKEEP)
            (("2" (HIDE-ALL-BUT 1)
              (("2" (SPLIT)
                (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)
                 ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|exists_or_upto| FORMULA-DECL NIL |for_examples| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (P SKOLEM-CONST-DECL "[below(n) -> bool]" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|n| SKOLEM-CONST-DECL "posnat" |for_examples| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL))
 (|exists_or_subrange| 0
  (|exists_or_subrange-1| |nil| 3782424343
   ("" (SKEEP)
    (("" (LEMMA "iterate_left_induction[bool]")
      (("" (INST?)
        ((""
          (INST -1
           "LAMBDA(j:upto(n-m),a:bool):(EXISTS(k:subrange(m,m+j)):P(k)) = a")
          (("" (SPLIT -1)
            (("1" (PROPAX) NIL NIL)
             ("2" (HIDE 2)
              (("2" (IFF)
                (("2" (SPLIT)
                  (("1" (FLATTEN) (("1" (SKEEP) (("1" (ASSERT) NIL NIL)) NIL))
                    NIL)
                   ("2" (FLATTEN) (("2" (INST 1 "m") NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("3" (HIDE 2)
              (("3" (SKOLEM 1 ("kk" "ak"))
                (("3" (FLATTEN)
                  (("3" (REPLACES -1 :DIR RL)
                    (("3" (IFF)
                      (("3" (SPLIT)
                        (("1" (FLATTEN)
                          (("1" (SKEEP)
                            (("1" (INSTEEP) (("1" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL)
                         ("2" (FLATTEN)
                          (("2" (SPLIT)
                            (("1" (SKEEP) (("1" (INSTEEP) NIL NIL)) NIL)
                             ("2" (INST 1 "kk+m+1") (("2" (ASSERT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|iterate_left_induction| FORMULA-DECL NIL |for_iterate| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|m| SKOLEM-CONST-DECL "int" |for_examples| NIL)
    (|n| SKOLEM-CONST-DECL "upfrom(m)" |for_examples| NIL)
    (|kk| SKOLEM-CONST-DECL "below(n - m)" |for_examples| NIL)
    (|k| SKOLEM-CONST-DECL "subrange(m, 1 + kk + m)" |for_examples| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IterateBody| TYPE-EQ-DECL NIL |for_iterate| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   NIL)))

