(|seq2set| (|seq2set_TCC1| 0 (|seq2set_TCC1-1| |nil| 3282912778 ("" (SKOSIMP*) (("" (ASSERT) (("" (LEMMA "is_finite_surj[T]") (("" (INST?) (("" (ASSERT) (("" (HIDE 2) (("" (INST + "length(fs!1)" "(LAMBDA (ii: below(length(fs!1))):
                                          seq(fs!1)(ii))") (("1" (EXPAND "surjective?") (("1" (SKOSIMP*) (("1" (TYPEPRED "y!1") (("1" (SKOSIMP*) (("1" (ASSERT) (("1" (INST?) (("1" (ASSERT) (("1" (EXPAND "finseq_appl") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (ASSERT) (("2" (EXPAND "finseq_appl") (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|surjective?| CONST-DECL "bool" |functions| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|fs!1| SKOLEM-CONST-DECL "finite_sequence[T]" |seq2set| NIL) (|is_finite_surj| FORMULA-DECL NIL |finite_sets| NIL) (T FORMAL-TYPE-DECL NIL |seq2set| NIL)) SHOSTAK (|seq2set| SUBTYPE "{s: seq2set.T | EXISTS (kk: naturalnumbers.below(length(seq2set.fs))): finite_sequences[seq2set.T].finseq_appl(seq2set.fs)(kk) = s}" "finite_set[T]"))) (|seq2set_lem| 0 (|seq2set_lem-1| |nil| 3282915134 ("" (SKOSIMP*) (("" (EXPAND "finseq_appl") (("" (ASSERT) (("" (EXPAND "seq2set") (("" (EXPAND "finseq_appl") (("" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|seq2set| CONST-DECL "finite_set[T]" |seq2set| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |seq2set| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (|card_seq2set| 0 (|card_seq2set-2| "" 3283086594 ("" (SKOSIMP*) (("" (TYPEPRED "seq2set(fs!1)") (("" (TYPEPRED "length(fs!1)") (("" (EXPAND "seq2set") (("" (EXPAND "finseq_appl") (("" (LEMMA "seq2set_lem") (("" (INST?) (("" (ASSERT) (("" (EXPAND "seq2set") (("" (EXPAND "finseq_appl") (("" (LEMMA "Card_injection[T]") (("" (EXPAND "injective?") (("" (INST -1 "{s: T | EXISTS (kk: below(length(fs!1))): fs!1`seq(kk) = s}" "length(fs!1)") (("" (ASSERT) (("" (INST + "LAMBDA (f: {s: T | EXISTS (kk: below(length(fs!1))): fs!1`seq(kk) = s}): min( {kk: below(length(fs!1)) |  fs!1`seq(kk) = f})") (("1" (SKOSIMP*) (("1" (ASSERT) NIL NIL)) NIL) ("2" (SKOSIMP*) (("2" (EXPAND "nonempty?") (("2" (TYPEPRED "f!1") (("2" (SKOSIMP*) (("2" (EXPAND "empty?") (("2" (EXPAND "member") (("2" (INST -2 "kk!1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|seq2set| CONST-DECL "finite_set[T]" |seq2set| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (T FORMAL-TYPE-DECL NIL |seq2set| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|seq2set_lem| FORMULA-DECL NIL |seq2set| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|empty?| CONST-DECL "bool" |sets| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" |min_nat| NIL) (<= CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|fs!1| SKOLEM-CONST-DECL "finite_sequence[T]" |seq2set| NIL) (|nonempty?| CONST-DECL "bool" |sets| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|Card_injection| FORMULA-DECL NIL |finite_sets| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (>= CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK) (|card_seq2set-1| |nil| 3282918983 ("" (SKOSIMP*) (("" (EXPAND "seq2set") (("" (EXPAND "finseq_appl") (("" (LEMMA "seq2set_lem") (("" (INST?) (("" (ASSERT) (("" (EXPAND "seq2set") (("" (EXPAND "finseq_appl") (("" (LEMMA "Card_injection") (("" (EXPAND "injective?") (("" (INST -1 "{s: T | EXISTS (kk: below(length(fs!1))): fs!1`seq(kk) = s}" "length(fs!1)") (("1" (ASSERT) (("1" (HIDE 2) (("1" (INST + "LAMBDA (s: {s: T | EXISTS (kk: below(length(fs!1))): fs!1`seq(kk) = s}): min( {kk: below(length(fs!1)) |  fs!1`seq(kk) = s})") (("1" (SKOSIMP*) (("1" (INST-CP -2 "min({kk: below(length(fs!1)) | fs!1`seq(kk) = x1!1})") (("1" (INST -2 "min({kk: below(length(fs!1)) | fs!1`seq(kk) = x2!1})") (("1" (SKOSIMP*) (("1" (ASSERT) NIL NIL)) NIL) ("2" (SKOSIMP*) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (REDUCE) (("2" (GRIND) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|seq2set_TCC2| 0 (|seq2set_TCC2-2| |nil| 3559517457 ("" (SKOSIMP*) (("" (EXPAND "nonempty?") (("" (EXPAND "empty?") (("" (EXPAND "member") (("" (EXPAND "seq2set") (("" (INST - "ss!1(0)") (("" (INST + "0") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nonempty?| CONST-DECL "bool" |sets| NIL) (|member| CONST-DECL "bool" |sets| NIL) (T FORMAL-TYPE-DECL NIL |seq2set| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (> CONST-DECL "bool" |reals| NIL) (|ne_seqs| TYPE-EQ-DECL NIL |seqs| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|seq2set| CONST-DECL "finite_set[T]" |seq2set| NIL) (|empty?| CONST-DECL "bool" |sets| NIL)) NIL (|seq2set_| SUBTYPE "seq2set.seq2set(seq2set.ss)" "(sets[seq2set.T].nonempty?)")) (|seq2set_TCC2-1| |nil| 3282912778 ("" (SKOSIMP*) (("" (EXPAND "nonempty?") (("" (LEMMA "minmax_seq2set_TCC1") (("" (INST?) (("" (ASSERT) (("" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) (NIL) SHOSTAK (|seq2set_| SUBTYPE "seq2set.seq2set(seq2set.ss)" "(sets[seq2set.T].nonempty?)"))))(|minmax_seq2set| (|minmax_seq2set_TCC1| 0 (|minmax_seq2set_TCC1-2| |nil| 3559516730 ("" (SKOSIMP*) (("" (EXPAND "empty?") (("" (EXPAND "member") (("" (EXPAND "seq2set") (("" (INST - "ne_fs!1(0)") (("" (INST + "0") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NIL APPLICATION-JUDGEMENT "(nonempty?[T])" |minmax_seq2set| NIL) (|empty?| CONST-DECL "bool" |sets| NIL) (|seq2set| CONST-DECL "finite_set[T]" |seq2set| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|ne_seqs| TYPE-EQ-DECL NIL |seqs| NIL) (> CONST-DECL "bool" |reals| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |minmax_seq2set| NIL) (|member| CONST-DECL "bool" |sets| NIL)) NIL (|minmax_seq2set| SUBTYPE "seq2set[minmax_seq2set.T].seq2set(minmax_seq2set.ne_fs)" "non_empty_finite_set[T]")) (|minmax_seq2set_TCC1-1| |nil| 3559516643 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|minmax_seq2set| SUBTYPE "seq2set[minmax_seq2set.T].seq2set(minmax_seq2set.ne_fs)" "non_empty_finite_set[T]"))) (|minmax_seq2set| 0 (|minmax_seq2set-2| "" 3882149610 ("" (SKOSIMP*) (("" (TYPEPRED "seq2set(ne_fs!1)") (("" (TYPEPRED "ne_fs!1") (("" (SPLIT) (("1" (TYPEPRED "min(ne_fs!1)") (("1" (EXPAND "seq2set") (("1" (ASSERT) (("1" (SKOSIMP*) (("1" (EXPAND "finseq_appl") (("1" (INST?) (("1" (LEMMA "seq2set_lem") (("1" (INST?) (("1" (EXPAND "seq2set") (("1" (EXPAND "finseq_appl") (("1" (INST?) (("1" (LEMMA "min_seq_lem") (("1" (NAME "mm" "min[T, <=]({s: T | EXISTS (kk: below(length(ne_fs!1))): ne_fs!1`seq(kk) = s})") (("1" (REPLACE -1) (("1" (TYPEPRED "mm") (("1" (SKOSIMP*) (("1" (CASE "mm <= min(ne_fs!1)") (("1" (ASSERT) (("1" (CASE "min(ne_fs!1) <= mm") (("1" (ASSERT) (("1" (TYPEPRED "<=") (("1" (EXPAND "total_order?") (("1" (FLATTEN) (("1" (EXPAND "dichotomous?") (("1" (EXPAND "partial_order?") (("1" (EXPAND "antisymmetric?") (("1" (FLATTEN) (("1" (INST -2 "mm" "min(ne_fs!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (TYPEPRED "<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "dichotomous?") (("2" (EXPAND "partial_order?") (("2" (FLATTEN) (("2" (EXPAND "antisymmetric?") (("2" (INST -8 "ne_fs!1" "kk!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST? -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (SKOSIMP*) (("2" (EXPAND "empty?") (("2" (EXPAND "member") (("2" (INST?) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "max(ne_fs!1)") (("2" (EXPAND "seq2set") (("2" (ASSERT) (("2" (SKOSIMP*) (("2" (EXPAND "finseq_appl") (("2" (INST?) (("2" (LEMMA "seq2set_lem") (("2" (INST?) (("2" (EXPAND "seq2set") (("2" (EXPAND "finseq_appl") (("2" (INST?) (("2" (LEMMA "max_seq_lem") (("2" (NAME "mm" " max[T, <=]
                   ({s: T |
                       EXISTS (kk: below(length(ne_fs!1))): ne_fs!1`seq(kk) = s})") (("1" (REPLACE -1) (("1" (TYPEPRED "mm") (("1" (SKOSIMP*) (("1" (CASE "mm <= max(ne_fs!1)") (("1" (ASSERT) (("1" (CASE "max(ne_fs!1) <= mm") (("1" (ASSERT) (("1" (TYPEPRED "<=") (("1" (EXPAND "total_order?") (("1" (FLATTEN) (("1" (EXPAND "dichotomous?") (("1" (EXPAND "partial_order?") (("1" (EXPAND "antisymmetric?") (("1" (FLATTEN) (("1" (INST -2 "mm" "max(ne_fs!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (TYPEPRED "<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "dichotomous?") (("2" (EXPAND "partial_order?") (("2" (FLATTEN) (("2" (EXPAND "antisymmetric?") (("2" (EXPAND "preorder?") (("2" (EXPAND "reflexive?") (("2" (EXPAND "transitive?") (("2" (FLATTEN) (("2" (LEMMA "max_lem") (("2" (INST? -1) (("1" (REPLACE -9) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOSIMP*) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "empty?") (("2" (INST?) (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST?) (("2" (INST -4 "ne_fs!1" "kk!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (ASSERT) (("2" (EXPAND "empty?") (("2" (INST?) (("2" (EXPAND "member") (("2" (INST 1 "jj!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|minmax_seq2set-1| |nil| 3559516692 ("" (SKOSIMP*) (("" (TYPEPRED "seq2set(ne_fs!1)") (("" (TYPEPRED "ne_fs!1") (("" (SPLIT) (("1" (TYPEPRED "min(ne_fs!1)") (("1" (EXPAND "seq2set") (("1" (ASSERT) (("1" (SKOSIMP*) (("1" (EXPAND "finseq_appl") (("1" (INST?) (("1" (LEMMA "seq2set_lem") (("1" (INST?) (("1" (EXPAND "seq2set") (("1" (EXPAND "finseq_appl") (("1" (INST?) (("1" (LEMMA "min_seq_lem") (("1" (NAME MM "min[T, <=]({s: T | EXISTS (kk: below(length(ne_fs!1))): ne_fs!1`seq(kk) = s})") (("1" (REPLACE -1) (("1" (TYPEPRED "mm") (("1" (SKOSIMP*) (("1" (CASE "mm <= min(ne_fs!1)") (("1" (ASSERT) (("1" (CASE "min(ne_fs!1) <= mm") (("1" (ASSERT) (("1" (TYPEPRED "<=") (("1" (EXPAND "total_order?") (("1" (FLATTEN) (("1" (EXPAND "dichotomous?") (("1" (EXPAND "partial_order?") (("1" (EXPAND "antisymmetric?") (("1" (FLATTEN) (("1" (INST -2 "mm" "min(ne_fs!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (TYPEPRED "<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "dichotomous?") (("2" (EXPAND "partial_order?") (("2" (FLATTEN) (("2" (EXPAND "antisymmetric?") (("2" (INST -8 "ne_fs!1" "kk!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST? -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (SKOSIMP*) (("2" (EXPAND "empty?") (("2" (EXPAND "member") (("2" (INST?) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "max(ne_fs!1)") (("2" (EXPAND "seq2set") (("2" (ASSERT) (("2" (SKOSIMP*) (("2" (EXPAND "finseq_appl") (("2" (INST?) (("2" (LEMMA "seq2set_lem") (("2" (INST?) (("2" (EXPAND "seq2set") (("2" (EXPAND "finseq_appl") (("2" (INST?) (("2" (LEMMA "max_seq_lem") (("2" (NAME MM " max[T, <=]
                   ({s: T |
                       EXISTS (kk: below(length(ne_fs!1))): ne_fs!1`seq(kk) = s})") (("1" (REPLACE -1) (("1" (TYPEPRED "mm") (("1" (SKOSIMP*) (("1" (CASE "mm <= max(ne_fs!1)") (("1" (ASSERT) (("1" (CASE "max(ne_fs!1) <= mm") (("1" (ASSERT) (("1" (TYPEPRED "<=") (("1" (EXPAND "total_order?") (("1" (FLATTEN) (("1" (EXPAND "dichotomous?") (("1" (EXPAND "partial_order?") (("1" (EXPAND "antisymmetric?") (("1" (FLATTEN) (("1" (INST -2 "mm" "max(ne_fs!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (TYPEPRED "<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "dichotomous?") (("2" (EXPAND "partial_order?") (("2" (FLATTEN) (("2" (EXPAND "antisymmetric?") (("2" (EXPAND "preorder?") (("2" (EXPAND "reflexive?") (("2" (EXPAND "transitive?") (("2" (FLATTEN) (("2" (LEMMA "max_lem") (("2" (INST? -1) (("1" (REPLACE -9) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOSIMP*) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "empty?") (("2" (INST?) (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST?) (("2" (INST -4 "ne_fs!1" "kk!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (ASSERT) (("2" (EXPAND "empty?") (("2" (INST?) (("2" (EXPAND "member") (("2" (INST 1 "jj!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NIL APPLICATION-JUDGEMENT "(nonempty?[T])" |minmax_seq2set| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |minmax_seq2set| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|seq2set| CONST-DECL "finite_set[T]" |seq2set| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|ne_seqs| TYPE-EQ-DECL NIL |seqs| NIL) (|nonempty?| CONST-DECL "bool" |sets| NIL) (|min_seq_lem| FORMULA-DECL NIL |min_seq| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|dichotomous?| CONST-DECL "bool" |orders| NIL) (|antisymmetric?| CONST-DECL "bool" |relations| NIL) (|partial_order?| CONST-DECL "bool" |orders| NIL) (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|min| CONST-DECL "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}" |finite_sets_minmax| |finite_sets|) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|seq2set_lem| FORMULA-DECL NIL |seq2set| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|min| CONST-DECL "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" |min_seq| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|dom| TYPE-EQ-DECL NIL |min_seq| NIL) (<= FORMAL-CONST-DECL "(total_order?[T])" |minmax_seq2set| NIL) (|total_order?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|max_seq_lem| FORMULA-DECL NIL |max_seq| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (|ne_fs!1| SKOLEM-CONST-DECL "ne_seqs[T]" |minmax_seq2set| NIL) (|max_lem| FORMULA-DECL NIL |finite_sets_minmax| |finite_sets|) (|transitive?| CONST-DECL "bool" |relations| NIL) (|preorder?| CONST-DECL "bool" |orders| NIL) (|max| CONST-DECL "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}" |finite_sets_minmax| |finite_sets|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|max| CONST-DECL "{t: T |
   (FORALL (ii: dom(s)): seq(s)(ii) <= t) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" |max_seq| NIL) (|dom| TYPE-EQ-DECL NIL |max_seq| NIL)) NIL)))
