(more_list_props
 (prefix?_TCC1 0
  (prefix?_TCC1-1 nil 3286895430 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   shostak
   (prefix? termination
            "more_list_props.prefix?(more_list_props.x1, more_list_props.y1)"
            "nil")))
 (suffix?_TCC1 0
  (suffix?_TCC1-1 nil 3286897128
   ("" (skeep*)
    (("" (use "length_reverse[T]")
      (("" (replaces -1)
        (("" (use "length_reverse[T]")
          (("" (replaces -2)
            (("" (replaces -1 :dir rl)
              (("" (expand "length" 2)
                (("" (assert) (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil more_list_props nil)
    (length_reverse formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (suffix? termination
            "more_list_props.suffix?(list_props[more_list_props.T].reverse(more_list_props.x1), list_props[more_list_props.T].reverse(more_list_props.y1))"
            "nil")))
 (caret_TCC1 0
  (caret_TCC1-1 nil 3287764724 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (caret subtype "(number_fields.-)(more_list_props.n, 1)" "nat")))
 (caret_TCC2 0
  (caret_TCC2-1 nil 3287764724 ("" (termination-tcc) nil nil) nil
   shostak
   (caret termination
    "(more_list_props.^(more_list_props.l1, (number_fields.-)(more_list_props.n, 1)))"
    "nil")))
 (caret_TCC3 0
  (caret_TCC3-1 nil 3287771390 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (caret subtype
    "(number_fields.-)(more_list_props.pair`2, more_list_props.pair`1)"
    "naturalnumber")))
 (caret_TCC4 0
  (caret_TCC4-1 nil 3287771390 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak (caret subtype "more_list_props.m" "below[length[T](l1)]")))
 (caret_TCC5 0
  (caret_TCC5-2 "" 3790088127 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak (caret subtype "more_list_props.m" "below[length[T](l1)]"))
  (caret_TCC5-1 nil 3287771390
   ("" (termination-tcc) (("" (postpone) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak (caret subtype "more_list_props.m" "below[length[T](l1)]")))
 (caret_TCC6 0
  (caret_TCC6-1 nil 3287774349 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (caret termination
    "(more_list_props.^(more_list_props.l1, ((number_fields.+)(more_list_props.m, 1), more_list_props.n)))"
    "nil")))
 (caret_length 0
  (caret_length-3 nil 3792848292
   (""
    (case "FORALL ( l1: list[T], pair: [nat, nat], N:nat ):
                             N=pair`2-pair`1 AND pair`2 >= pair`1 AND pair`2 < length(l1) IMPLIES length((l1 ^ pair)) = pair`2 - pair`1 + 1")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "pair`2 - pair`1")
          (("1" (ground) nil) ("2" (ground) nil)))))))
     ("2" (hide 2)
      (("2" (induct "N")
        (("1" (skeep)
          (("1" (expand "^")
            (("1" (lift-if 1)
              (("1" (split)
                (("1" (ground) nil)
                 ("2" (flatten)
                  (("2" (split 4)
                    (("1" (ground)
                      (("1" (expand "length")
                        (("1" (expand "length")
                          (("1" (propax) nil)))))))
                     ("2" (flatten) (("2" (ground) nil)))))))))))))))
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand "^" 1)
              (("2" (lift-if 1)
                (("2" (split 1)
                  (("1" (flatten) (("1" (ground) nil)))
                   ("2" (flatten)
                    (("2" (split 4)
                      (("1" (flatten) (("1" (ground) nil)))
                       ("2" (flatten)
                        (("2" (inst -1 "l1" "(1+pair`1, pair`2)")
                          (("2" (assert)
                            (("2" (expand "length" 2)
                              (("2"
                                (propax)
                                nil))))))))))))))))))))))))))))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pair skolem-const-decl "[nat, nat]" more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil)
  (caret_length-2 nil 3792848259
   (""
    (case "FORALL ( l1: list[T], pair: [nat, nat], N:nat ):
                             N=pair`2-pair`1 AND pair`2 >= pair`1 AND pair`2 < length(l1) IMPLIES length((l1 ^ pair)) = pair`2 - pair`1 + 1")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "pair`2 - pair`1")
          (("1" (ground) nil) ("2" (ground) nil)))))))
     ("2" (hide 2)
      (("2" (induct "N")
        (("1" (skeep)
          (("1" (expand "^")
            (("1" (lift-if 1)
              (("1" (split)
                (("1" (ground) nil)
                 ("2" (flatten)
                  (("2" (split 4)
                    (("1" (ground)
                      (("1" (expand "length")
                        (("1" (expand "length")
                          (("1" (propax) nil)))))))
                     ("2" (flatten) (("2" (ground) nil)))))))))))))))
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand "^" 1)
              (("2" (lift-if 1)
                (("2" (split 1)
                  (("1" (flatten) (("1" (ground) nil)))
                   ("2" (flatten)
                    (("2" (split 4)
                      (("1" (flatten) (("1" (ground) nil)))
                       ("2" (flatten)
                        (("2" (inst -1 "l1" "(1+pair`1, pair`2)")
                          (("2" (assert)
                            (("2" (expand "length" 2)
                              (("2"
                                (propax)
                                nil))))))))))))))))))))))))))))
    nil)
   nil nil)
  (caret_length-1 nil 3655812777
   (""
    (case "FORALL (l1: list[T], pair: [nat, nat], N:nat ):
                      N=pair`2-pair`1 AND pair`2 >= pair`1 AND pair`2 < length(l1) IMPLIES length((l1 ^ pair)) = pair`2 - pair`1 + 1")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "pair`2 - pair`1")
          (("1" (ground) nil nil) ("2" (ground) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "N")
        (("1" (skeep)
          (("1" (expand "^")
            (("1" (lift-if 1)
              (("1" (split)
                (("1" (ground) nil nil)
                 ("2" (flatten)
                  (("2" (split 4)
                    (("1" (ground)
                      (("1" (expand "length")
                        (("1" (expand "length")
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (flatten) (("2" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand "^" 1)
              (("2" (lift-if 1)
                (("2" (split 1)
                  (("1" (flatten) (("1" (ground) nil nil)) nil)
                   ("2" (flatten)
                    (("2" (split 4)
                      (("1" (flatten) (("1" (ground) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (inst -1 "l1" "(1+pair`1, pair`2)")
                          (("2" (assert)
                            (("2" (expand "length" 2)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (caret_cdr_TCC1 0
  (caret_cdr_TCC1-1 nil 3656150636
   ("" (skeep)
    (("" (lemma "caret_length")
      (("" (inst?)
        (("" (ground)
          (("" (expand "length" -1) (("" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((caret_length formula-decl nil more_list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (caret_cdr subtype
    "(more_list_props.^(more_list_props.l1, more_list_props.pair))"
    "(list_adt[more_list_props.T].cons?)")))
 (caret_cdr_TCC2 0
  (caret_cdr_TCC2-1 nil 3656150636
   ("" (skeep)
    (("" (expand "length")
      (("" (lift-if -2) (("" (ground) nil nil)) nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (caret_cdr subtype "more_list_props.l1"
    "(list_adt[more_list_props.T].cons?)")))
 (caret_cdr_TCC3 0
  (caret_cdr_TCC3-1 nil 3656150636 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (caret_cdr subtype "(number_fields.-)(more_list_props.pair`2, 1)"
    "nat")))
 (caret_cdr 0
  (caret_cdr-1 nil 3656150786
   (""
    (case " FORALL (l1: list[T], N:nat, pair: [nat, nat]):
                      N = pair`2-pair`1 AND pair`2 >= pair`1 AND pair`2 < length(l1) AND pair`1 > 0 IMPLIES
                       cdr((l1 ^ pair)) = (cdr(l1) ^ (pair`1, pair`2 - 1))")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "pair`2 - pair `1")
          (("1" (ground) nil nil) ("2" (ground) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "N")
        (("1" (skeep) (("1" (expand "^") (("1" (ground) nil nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand "^" 1 2)
              (("2" (lift-if 1)
                (("2" (ground)
                  (("1" (expand " length" -5)
                    (("1" (lift-if -5) (("1" (ground) nil nil)) nil))
                    nil)
                   ("2" (replace -1 -3)
                    (("2" (simplify -3)
                      (("2" (replace -3)
                        (("2" (expand "length" -5)
                          (("2" (ground)
                            (("2" (lift-if -5)
                              (("2"
                                (ground)
                                (("2"
                                  (replace -2)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst -1 "l1" "(pair`1+1, pair`2)")
                    (("3" (ground)
                      (("3" (replace -1 :dir rl)
                        (("3" (expand "^" 2 1)
                          (("3"
                            (case " FORALL (L: list[T], nn:nat, Pair: [nat, nat]):
                      nn = Pair`2-Pair`1 AND Pair`2 >= Pair`1 AND Pair`2 < length(L) IMPLIES nth(L, Pair`1) = car(L^(Pair))")
                            (("1"
                              (inst -1 "l1" "pair`2-pair`1-1 "
                               "(pair`1+1, pair`2)")
                              (("1"
                                (ground)
                                (("1"
                                  (expand "nth" -1)
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (ground)
                                      (("1"
                                        (case
                                         "FORALL (LL: list[T]): null?(LL) OR LL = cons(car(LL), cdr(LL))")
                                        (("1"
                                          (inst
                                           -1
                                           "l1 ^ (1 + pair`1, pair`2)")
                                          (("1"
                                            (ground)
                                            (("1"
                                              (lemma "caret_length")
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (ground)
                                                  (("1"
                                                    (expand "length")
                                                    (("1"
                                                      (ground)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide-all-but 1)
                                          (("2"
                                            (skeep)
                                            (("2"
                                              (decompose-equality 2)
                                              nil
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (decompose-equality 3)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (expand "^")
                                  (("2"
                                    (lift-if 1)
                                    (("2" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (skeep)
                              (("3"
                                (lemma "caret_length")
                                (("3"
                                  (inst?)
                                  (("3"
                                    (ground)
                                    (("3"
                                      (expand "length" -1)
                                      (("3" (ground) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("4" (skeep) (("4" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep) (("3" (ground) nil nil)) nil)
         ("4" (skeep)
          (("4" (ground)
            (("4" (skeep)
              (("4" (expand "length") (("4" (ground) nil nil)) nil))
              nil))
            nil))
          nil)
         ("5" (hide 2)
          (("5" (skeep)
            (("5" (lemma "caret_length")
              (("5" (inst?)
                (("5" (ground)
                  (("5" (expand "length" -1) (("5" (ground) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep) (("3" (ground) nil nil)) nil)
     ("4" (skeep)
      (("4" (ground)
        (("4" (skeep)
          (("4" (expand "length") (("4" (ground) nil nil)) nil)) nil))
        nil))
      nil)
     ("5" (hide 2)
      (("5" (skeep)
        (("5" (lemma "caret_length")
          (("5" (inst?)
            (("5" (ground)
              (("5" (expand "length" -1) (("5" (ground) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (caret_length formula-decl nil more_list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pair skolem-const-decl "[nat, nat]" more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (> const-decl "bool" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (^ def-decl "list[T]" more_list_props nil))
   shostak))
 (caret_nth_TCC1 0
  (caret_nth_TCC1-1 nil 3656945177 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (caret_nth subtype "more_list_props.n" "below[length[T](l1)]")))
 (caret_nth_TCC2 0
  (caret_nth_TCC2-1 nil 3656945700
   ("" (skeep)
    (("" (assert)
      (("" (lemma "caret_length")
        (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (caret_length formula-decl nil more_list_props nil))
   nil
   (caret_nth subtype
    "(number_fields.-)(more_list_props.n, more_list_props.pair`1)"
    "below[length[T](l1 ^ pair)]")))
 (caret_nth 0
  (caret_nth-1 nil 3656945701
   (""
    (case "FORALL (l1: list[T], m,n: nat, pair: [nat, nat]):
        m = n-pair`1 AND pair`2 >= pair`1 AND
         pair`2 < length(l1) AND n >= pair`1 AND n <= pair`2
         IMPLIES nth(l1, n) = nth(l1 ^ pair, n - pair`1)")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst - "n - pair`1")
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct " m")
        (("1" (skeep)
          (("1" (replace -1 :dir rl)
            (("1" (expand "^")
              (("1" (assert)
                (("1" (expand "nth" 1 2) (("1" (ground) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (replace -2 :dir rl)
              (("2" (expand "^" 1)
                (("2" (assert)
                  (("2" (expand "nth" 1 2)
                    (("2" (inst -1 "l1" "n" "(1+pair`1, pair`2)")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (lemma "caret_length")
            (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
          nil)
         ("4" (skeep) (("4" (assert) nil nil)) nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (lemma "caret_length")
        (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
      nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil))
    nil)
   ((caret_length formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n skolem-const-decl "nat" more_list_props nil)
    (pair skolem-const-decl "[nat, nat]" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (^ def-decl "list[T]" more_list_props nil))
   shostak))
 (prefix_length 0
  (prefix_length-1 nil 3287327236
   ("" (skosimp*) (("" (expand "prefix?") (("" (assert) nil nil)) nil))
    nil)
   ((prefix? def-decl "bool" more_list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (suffix_length 0
  (suffix_length-1 nil 3287327263
   ("" (skosimp*) (("" (expand "suffix?") (("" (assert) nil nil)) nil))
    nil)
   ((suffix? def-decl "bool" more_list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (every_forall 0
  (every_forall-1 nil 3286897625
   ("" (skeep) (("" (rewrite "every_nth") nil nil)) nil)
   ((every_nth formula-decl nil list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (every_as_member 0
  (every_as_member-1 nil 3791362884
   ("" (skeep 1 :but "l")
    (("" (induct "l")
      (("1" (grind) nil nil)
       ("2" (skolem 1 ("x" "xs"))
        (("2" (flatten)
          (("2" (expand "every" -2)
            (("2" (flatten)
              (("2" (assert)
                (("2" (skeep)
                  (("2" (expand "member" -4)
                    (("2" (split -4)
                      (("1" (grind) nil nil)
                       ("2" (inst -2 "x_1") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (some_exists 0
  (some_exists-1 nil 3287148696
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (inst?)
        (("2" (rewrite "some" +)
          (("2" (replace -1)
            (("2" (hide -1)
              (("2" (prop)
                (("1" (rewrite "nth")
                  (("1" (inst?)
                    (("1" (assert) nil nil)
                     ("2" (assert)
                      (("2" (rewrite "length") (("2" (ground) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (inst 1 "n!1+1")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil)
                 ("3" (skosimp*)
                  (("3" (inst + "n!1-1")
                    (("1" (grind)
                      (("1" (expand "nth")
                        (("1" (prop)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "n!1")
                      (("2" (rewrite "length" -)
                        (("2" (assert)
                          (("2" (hide -1)
                            (("2" (rewrite "nth" -) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (n!1 skolem-const-decl
     "below(length(cons(cons1_var!1, cons2_var!1)))" more_list_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (n!1 skolem-const-decl "below(length(cons2_var!1))" more_list_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons2_var!1 skolem-const-decl "list[T]" more_list_props nil)
    (cons1_var!1 skolem-const-decl "T" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some adt-def-decl "boolean" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (list_extensionality_TCC1 0
  (list_extensionality_TCC1-1 nil 3546992291 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (list_extensionality subtype "more_list_props.n"
    "below[length[T](l2)]")))
 (list_extensionality 0
  (list_extensionality-1 nil 3546992303
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "null?(l2)")
          (("1" (grind) nil nil)
           ("2" (lemma "list_cons_eta[T]")
            (("2" (inst -1 "l2")
              (("1" (replaces -1 :dir rl)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (replaces -1) (("1" (skeep) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (rewrite "list_cons_extensionality[T]")
                      (("1" (inst -2 "0")
                        (("1" (expand "nth") (("1" (propax) nil nil))
                          nil)
                         ("2" (expand "length" 1)
                          (("2" (assert) nil nil)) nil))
                        nil)
                       ("2" (expand "length" -1)
                        (("2" (inst -3 "cdr(l2)")
                          (("2" (assert)
                            (("2" (skeep 4)
                              (("2"
                                (inst -2 "n+1")
                                (("1"
                                  (expand "nth" -2)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (expand "length" 1)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cons2_var skolem-const-decl "list[T]" more_list_props nil)
    (cons1_var skolem-const-decl "T" more_list_props nil)
    (n skolem-const-decl "below(length(cons2_var))" more_list_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (TRUE const-decl "bool" booleans nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (list_pigeonhole 0
  (list_pigeonhole-2 "" 3790088131
   ("" (measure-induct "card(A)" "A" 1)
    (("" (skosimp*)
      (("" (rewrite "length" -)
        (("" (lift-if)
          (("" (ground)
            (("" (inst - "remove(car(B!1), x!1)")
              (("" (rewrite "card_remove")
                (("" (rewrite "every")
                  (("" (flatten)
                    (("" (assert)
                      (("" (inst - "cdr(B!1)")
                        (("" (prop)
                          (("1" (skosimp*)
                            (("1" (inst + "n!1+1" "m!1+1")
                              (("1"
                                (expand "nth" +)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (typepred "m!1")
                                (("2"
                                  (assert)
                                  (("2"
                                    (rewrite "length" +)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (typepred "n!1")
                                (("3"
                                  (rewrite "length" +)
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst + 0 _)
                            (("1" (rewrite "nth" +)
                              (("1"
                                (expand "remove")
                                (("1"
                                  (expand "member")
                                  (("1"
                                    (rewrite "every_forall")
                                    (("1"
                                      (rewrite "every_forall")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst 3 "n!1+1")
                                          (("1"
                                            (inst -3 "n!1")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (rewrite "nth" 3)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred "n!1")
                                            (("2"
                                              (rewrite "length" 1)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite "length" 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (rewrite "length" 1)
                              (("2" (assert) nil nil)) nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_remove application-judgement "finite_set" finite_sets nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (remove const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (B!1 skolem-const-decl "list[T]" more_list_props nil)
    (n!1 skolem-const-decl "below[length(cdr(B!1))]" more_list_props
     nil)
    (m!1 skolem-const-decl "below[length(cdr(B!1))]" more_list_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (n!1 skolem-const-decl "below(length(cdr(B!1)))" more_list_props
     nil)
    (every_forall formula-decl nil more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (> const-decl "bool" reals nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak)
  (list_pigeonhole-1 nil 3287156645
   ("" (measure-induct "card(A)" "A" 1)
    (("" (skosimp*)
      (("" (rewrite "length" -)
        (("" (lift-if)
          (("" (ground)
            (("" (inst - "remove(car(B!1), x!1)")
              (("" (rewrite "card_remove")
                (("" (rewrite "every")
                  (("" (flatten)
                    (("" (assert)
                      (("" (inst - "cdr(B!1)")
                        (("" (prop)
                          (("1" (skosimp*)
                            (("1" (inst + "n!1+1" "m!1+1")
                              (("1"
                                (expand "nth" +)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (typepred "m!1")
                                (("2"
                                  (assert)
                                  (("2"
                                    (rewrite "length" +)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (typepred "n!1")
                                (("3"
                                  (rewrite "length" +)
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst + 0 _)
                            (("1" (rewrite "nth" +)
                              (("1"
                                (expand "remove")
                                (("1"
                                  (expand "member")
                                  (("1"
                                    (rewrite "every_forall")
                                    (("1"
                                      (rewrite "every_forall")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst 3 "n!1+1")
                                          (("1"
                                            (inst -3 "n!1")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (rewrite "nth" 3)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (typepred "n!1")
                                                  (("2"
                                                    (rewrite
                                                     "length"
                                                     1)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred "n!1")
                                            (("2"
                                              (rewrite "length" 1)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite "length" 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (rewrite "length" 1)
                              (("2" (assert) nil nil)) nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_remove application-judgement "finite_set" finite_sets nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (remove const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (every_forall formula-decl nil more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (> const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (nth_append_TCC1 0
  (nth_append_TCC1-1 nil 3577469759
   ("" (skeep) (("" (rewrite "length_append") nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (nth_append subtype "more_list_props.i"
    "below[length[T](append[T](l1, l2))]")))
 (nth_append_TCC2 0
  (nth_append_TCC2-1 nil 3577469759 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (nth_append subtype
    "(number_fields.-)(more_list_props.i, list_props[more_list_props.T].length(more_list_props.l1))"
    "below[length[T](l2)]")))
 (nth_append 0
  (nth_append-1 nil 3577469817
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (case-replace "length(cons(a,l))=length(l)+1")
            (("1" (hide -1)
              (("1" (expand "append" 1)
                (("1" (lift-if)
                  (("1" (case-replace "i < 1 + length(l)")
                    (("1" (expand "nth" 1)
                      (("1" (case-replace "i=0")
                        (("1" (assert)
                          (("1" (inst? -2) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (expand "nth" 2 1)
                        (("2" (inst? -) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "length" 1 1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)
     ("4" (hide 2)
      (("4" (skeep) (("4" (rewrite "length_append") nil nil)) nil))
      nil))
    nil)
   ((length_append formula-decl nil list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (append_eq_length_left 0
  (append_eq_length_left-1 nil 3797002527
   ("" (skeep)
    (("" (rewrite "list_extensionality")
      (("" (flatten)
        (("" (rewrite "length_append")
          (("" (rewrite "length_append")
            (("" (case "l1=l3")
              (("1" (assert)
                (("1" (replace -1 :hide? t :dir rl)
                  (("1" (rewrite "list_extensionality")
                    (("1" (skeep :preds? t)
                      (("1" (inst - "length(l1)+n")
                        (("1" (rewrite "nth_append")
                          (("1" (rewrite "nth_append") nil nil)) nil)
                         ("2" (rewrite "length_append")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (rewrite "list_extensionality")
                  (("2" (assert)
                    (("2" (skeep :preds? t)
                      (("2" (inst -3 "n")
                        (("1" (rewrite "nth_append")
                          (("1" (rewrite "nth_append") nil nil)) nil)
                         ("2" (rewrite "length_append")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_extensionality formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth_append formula-decl nil more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (l1 skolem-const-decl "list[T]" more_list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (n skolem-const-decl "below(length(l2))" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (n skolem-const-decl "below(length(l1))" more_list_props nil))
   shostak))
 (length_null 0
  (length_null-1 nil 3580049561 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) shostak))
 (length_singleton 0
  (length_singleton-1 nil 3580049452 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) shostak))
 (length_null_list 0
  (length_null_list-1 nil 3601030512
   ("" (skeep)
    (("" (ground)
      (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)
       ("2" (expand "length") (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (reverse_def_TCC1 0
  (reverse_def_TCC1-1 nil 3601030498
   ("" (skeep) (("" (rewrite "length_reverse") nil nil)) nil)
   ((length_reverse formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (reverse_def subtype "more_list_props.j"
    "below[length[T](reverse[T](L))]")))
 (reverse_def_TCC2 0
  (reverse_def_TCC2-1 nil 3601030498 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reverse_def subtype
    "(number_fields.-)((number_fields.-)(list_props[more_list_props.T].length(more_list_props.L), 1), more_list_props.j)"
    "below[length[T](L)]")))
 (reverse_def 0
  (reverse_def-1 nil 3601030538
   (""
    (case "NOT forall (lpr:list[T],j:nat,k:nat): k+1=length(lpr) AND j<length(lpr) IMPLIES nth(lpr,j) = nth(reverse(lpr),length(lpr)-1-j)")
    (("1" (hide 2)
      (("1" (induct "k")
        (("1" (skeep)
          (("1" (assert)
            (("1" (case "NOT j = 0")
              (("1" (assert) nil nil)
               ("2" (replaces -1)
                (("2" (assert)
                  (("2" (copy -1)
                    (("2" (hide -3)
                      (("2" (replace -1 :dir rl)
                        (("2" (assert)
                          (("2" (expand "nth" +)
                            (("2" (copy -1)
                              (("2"
                                (expand "length" -1)
                                (("2"
                                  (expand "length" -1)
                                  (("2"
                                    (lift-if)
                                    (("2"
                                      (ground)
                                      (("2"
                                        (expand "reverse" +)
                                        (("2"
                                          (expand "reverse" +)
                                          (("2"
                                            (expand "append")
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (assert)
            (("2" (expand "reverse" +)
              (("2" (lemma "length_null_list")
                (("2" (inst - "lpr!1")
                  (("2" (assert)
                    (("2" (rewrite "nth_append")
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (name "kk" "j!1")
                            (("1" (replaces -1)
                              (("1"
                                (assert)
                                (("1"
                                  (inst - "cdr(lpr!1)" "j!2-1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (split -)
                                      (("1"
                                        (case
                                         "length(cdr(lpr!1)) = length(lpr!1)-1")
                                        (("1"
                                          (replaces -1)
                                          (("1"
                                            (replaces -1 :dir rl)
                                            (("1"
                                              (expand "nth" + 1)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (ground)
                                                  (("1"
                                                    (replaces -1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (rewrite
                                                         "length_reverse")
                                                        (("1"
                                                          (expand
                                                           "length"
                                                           -
                                                           1)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand "length" 1 2)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "length" -2)
                                        (("2" (assert) nil nil))
                                        nil)
                                       ("3"
                                        (expand "length" -3)
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (case "NOT j!2 = 0")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (replaces -1)
                                        (("2"
                                          (rewrite "length_reverse")
                                          (("2"
                                            (expand "length" -1 1)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite "length_reverse")
                            (("2" (expand "length" 1 1)
                              (("2"
                                (assert)
                                (("2"
                                  (case "NOT j!2 = 0")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (replaces -1)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "length" 2 1)
                                        (("2"
                                          (hide -)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "length_reverse")
                        (("2" (expand "length" 1 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skosimp*)
            (("3" (assert)
              (("3" (rewrite "length_reverse") (("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (inst - "L" "length(L)-1-j" "length(L)-1")
        (("1" (assert) nil nil) ("2" (assert) nil nil)
         ("3" (assert) nil nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp*)
        (("3" (assert)
          (("3" (rewrite "length_reverse") (("3" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (L skolem-const-decl "list[T]" more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth_append formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_singleton formula-decl nil more_list_props nil)
    (j!2 skolem-const-decl "nat" more_list_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (length_reverse formula-decl nil list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_null_list formula-decl nil more_list_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (append def-decl "list[T]" list_props nil)
    (TRUE const-decl "bool" booleans nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (cons_append 0
  (cons_append-1 nil 3613292587
   ("" (skeep)
    (("" (rewrite "list_extensionality")
      (("" (split)
        (("1" (expand "length" 1 1)
          (("1" (rewrite "length_append") nil nil)) nil)
         ("2" (skeep)
          (("2" (rewrite "nth_append")
            (("1" (expand "nth" 1)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (lift-if)
                    (("1" (assert)
                      (("1" (ground)
                        (("1" (expand "nth") (("1" (propax) nil nil))
                          nil)
                         ("2" (expand "nth" + 1)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "n")
              (("2" (expand "length" -1) (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_extensionality formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nth_append formula-decl nil more_list_props nil)
    (length def-decl "nat" list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_singleton formula-decl nil more_list_props nil))
   shostak))
 (expand_list_TCC1 0
  (expand_list_TCC1-1 nil 3613298395 ("" (subtype-tcc) nil nil) nil nil
   (expand_list subtype "more_list_props.L"
    "(list_adt[more_list_props.T].cons?)")))
 (expand_list 0
  (expand_list-1 nil 3613298397
   ("" (skeep)
    (("" (lemma "list_extensionality")
      (("" (inst?)
        (("" (assert)
          (("" (hide 3)
            (("" (split)
              (("1" (expand "length") (("1" (propax) nil nil)) nil)
               ("2" (skeep)
                (("2" (expand "nth") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_extensionality formula-decl nil more_list_props nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (expand_list_app 0
  (expand_list_app-1 nil 3656151908
   ("" (skeep 1 :but ("l"))
    (("" (induct "l")
      (("1" (grind) nil nil)
       ("2" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
        (("2" (expand "member" -2)
          (("2" (split -2)
            (("1" (hide -2)
              (("1" (replace -1 :hide? t)
                (("1" (inst 1 "null" "xs") (("1" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (skeep -2)
                (("2" (inst 1 "cons(x,l1)" "l2")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (append_null_left 0
  (append_null_left-1 nil 3613298991 ("" (grind) nil nil)
   ((append def-decl "list[T]" list_props nil)) shostak))
 (append_null_right 0
  (append_null_right-1 nil 3656951505
   ("" (measure-induct+ "length(L)" "L")
    (("" (case "null?(x!1)")
      (("1" (expand "append")
        (("1" (lift-if 1) (("1" (ground) nil nil)) nil)) nil)
       ("2" (expand "append" 2)
        (("2" (lift-if 2)
          (("2" (ground)
            (("2" (inst - "cdr(x!1)")
              (("2" (assert)
                (("2" (ground)
                  (("1" (replace -1)
                    (("1" (decompose-equality 2) nil nil)) nil)
                   ("2" (expand "length" 1 2) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (member_append_fi 0
  (member_append_fi-1 nil 3645178866
   ("" (skosimp*)
    (("" (name "L_" "length(l1!1)+length(l2!1)")
      (("" (generalize-skolem-constants)
        (("" (induct "L_1")
          (("1" (skolem 1 ("i" "l1" "l2"))
            (("1" (flatten)
              (("1" (case "l1 = null AND l2 = null")
                (("1" (flatten)
                  (("1" (replaces -1)
                    (("1" (replaces -1) (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (skolem 1 ("i" "l1" "l2"))
              (("2" (flatten)
                (("2" (expand "append" -3)
                  (("2" (lift-if -3)
                    (("2" (split -3)
                      (("1" (flatten) nil nil)
                       ("2" (flatten)
                        (("2" (expand "member" -1)
                          (("2" (split -1)
                            (("1" (replaces -1) (("1" (grind) nil nil))
                              nil)
                             ("2" (inst -2 "i" "cdr(l1)" "l2")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (null_append 0
  (null_append-1 nil 3645179039
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("h1" "t1"))
      (("2" (flatten) (("2" (grind) nil nil)) nil)) nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (cdr_append_TCC1 0
  (cdr_append_TCC1-1 nil 3655660650
   ("" (skeep)
    (("" (use "null_append")
      (("" (typepred "l1") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((null_append formula-decl nil more_list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (cdr_append subtype
    "list_props[more_list_props.T].append(more_list_props.l1, more_list_props.l2)"
    "(list_adt[more_list_props.T].cons?)")))
 (cdr_append_TCC2 0
  (cdr_append_TCC2-1 nil 3660317172 ("" (subtype-tcc) nil nil) nil nil
   (cdr_append subtype "more_list_props.l1"
    "(list_adt[more_list_props.T].cons?)")))
 (cdr_append 0
  (cdr_append-1 nil 3656098980
   ("" (skeep) (("" (expand "append" 1 1) (("" (propax) nil nil)) nil))
    nil)
   ((append def-decl "list[T]" list_props nil)) shostak))
 (car_append 0
  (car_append-1 nil 3791205264 ("" (grind) nil nil)
   ((append def-decl "list[T]" list_props nil)) shostak))
 (car_append_2_TCC1 0
  (car_append_2_TCC1-1 nil 3791205264 ("" (subtype-tcc) nil nil) nil
   nil
   (car_append_2 subtype
    "list_props[more_list_props.T].append(more_list_props.l1, more_list_props.l2)"
    "(list_adt[more_list_props.T].cons?)")))
 (car_append_2_TCC2 0
  (car_append_2_TCC2-1 nil 3791205264
   ("" (skeep :preds? t)
    (("" (use "null_append") (("" (assert) nil nil)) nil)) nil)
   ((null_append formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (car_append_2 subtype "more_list_props.l2"
    "(list_adt[more_list_props.T].cons?)")))
 (car_append_2 0
  (car_append_2-1 nil 3791205269 ("" (grind) nil nil)
   ((append def-decl "list[T]" list_props nil)) shostak))
 (member_nth 0
  (member_nth-1 nil 3644930816
   ("" (induct "l")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skolem 1 ("x" "xs"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (inst -1 "t")
            (("2" (expand "member" -2)
              (("2" (split -2)
                (("1" (inst 1 "0")
                  (("1" (grind) nil nil)
                   ("2" (expand "length") (("2" (assert) nil nil))
                    nil))
                  nil)
                 ("2" (expand "nth" 1)
                  (("2" (assert)
                    (("2" (skeep)
                      (("2" (inst 1 "i+1")
                        (("1" (assert) nil nil)
                         ("2" (typepred "i") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (i skolem-const-decl "below(length(xs))" more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (x skolem-const-decl "T" more_list_props nil)
    (xs skolem-const-decl "list[T]" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (nth_member 0
  (nth_member-1 nil 3653992860
   (""
    (case "FORALL (n:nat, (l: list[T] | length(l) = n), t: T, i: below(length(l))):
        nth(l, i) = t IMPLIES member(t, l)")
    (("1" (skeep)
      (("1" (inst - "length(l)" "l" "t" "i") (("1" (ground) nil nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep) nil nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (typepred (l))
              (("2" (case " i=0")
                (("1" (replace -1)
                  (("1" (expand "nth")
                    (("1" (expand "member")
                      (("1" (expand "length")
                        (("1" (ground) (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "nth" -3)
                  (("2" (ground)
                    (("2" (expand "member" 2)
                      (("2" (inst -2 "cdr(l)" "t" "i-1")
                        (("1" (ground) (("1" (grind) nil nil)) nil)
                         ("2" (expand "length" -1)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (l skolem-const-decl "{l: list[T] | length(l) = 1 + j}"
     more_list_props nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (member def-decl "bool" list_props nil))
   shostak))
 (member_iff_nth 0
  (member_iff_nth-1 nil 3721404684
   ("" (skeep)
    (("" (split)
      (("1" (flatten) (("1" (rewrite "member_nth") nil nil)) nil)
       ("2" (flatten)
        (("2" (skeep)
          (("2" (lemma "nth_member")
            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((member_nth formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_member formula-decl nil more_list_props nil))
   shostak))
 (member_append_r 0
  (member_append_r-1 nil 3645179340
   ("" (skeep)
    (("" (name "L_" "length(l1) + length(l2)")
      (("" (generalize-skolem-constants)
        (("" (induct "L_1")
          (("1" (skeep)
            (("1" (case "l1_1 = null AND l2_1 = null")
              (("1" (flatten)
                (("1" (replaces -1)
                  (("1" (replaces -1) (("1" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (skeep)
              (("2" (expand "append" 1)
                (("2" (lift-if 1)
                  (("2" (split 1)
                    (("1" (flatten) nil nil)
                     ("2" (flatten)
                      (("2" (expand "member" 2)
                        (("2" (flatten)
                          (("2" (inst -1 "i_1" "cdr(l1_1)" "l2_1")
                            (("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (append def-decl "list[T]" list_props nil))
   nil))
 (member_append_l 0
  (member_append_l-1 nil 3645179454
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("hl" "tl"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "member" -2)
            (("2" (split -2)
              (("1" (replaces -1) (("1" (grind) nil nil)) nil)
               ("2" (expand "append" 1) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (every_implies 0
  (every_implies-1 nil 3645179531
   ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (append_right_inj 0
  (append_right_inj-1 nil 3645265347
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "append" -2)
            (("2" (inst -1 "l1" "l2")
              (("2" (decompose-equality -2) (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (subl_over_len_TCC1 0
  (subl_over_len_TCC1-1 nil 3644927435 ("" (subtype-tcc) nil nil) nil
   nil
   (subl_over_len subtype
    "(number_fields.-)(list_props[more_list_props.T].length(more_list_props.l), 1)"
    "nat")))
 (subl_over_len 0
  (subl_over_len-1 nil 3644927452
   ("" (skolem 1 ("m_" "l_" "i_") :skolem-typepreds? t)
    (("" (name "k_" "i_ - m_")
      (("" (generalize "k_" "k" "nat")
        (("1" (grind) nil nil)
         ("2" (generalize-skolem-constants)
          (("2" (induct "k")
            (("1" (skolem 1 ("m" "l" "i") :skolem-typepreds? t)
              (("1" (assert) nil nil)) nil)
             ("2" (skeep)
              (("2" (skolem 1 ("m" "l" "i") :skolem-typepreds? t)
                (("2" (assert)
                  (("2" (flatten)
                    (("2" (expand "^" 1)
                      (("2" (case "m=length(l)-1")
                        (("1" (replaces -1)
                          (("1" (assert) (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (inst -4 "1+m" "l" "i")
                          (("1" (assert) nil nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((upfrom nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (l skolem-const-decl "{l: list[T] | m < length(l)}" more_list_props
     nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (k_ skolem-const-decl "int" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (^ def-decl "list[T]" more_list_props nil))
   nil))
 (subl_shr_TCC1 0
  (subl_shr_TCC1-1 nil 3644927489 ("" (subtype-tcc) nil nil) nil nil
   (subl_shr subtype "(number_fields.-)(more_list_props.m, 1)" "nat")))
 (subl_shr 0
  (subl_shr-2 nil 3644927609
   ("" (skolem 1 ("a_" "l_" "m_" "n_") :skolem-typepreds? t)
    (("" (case "m_ > n_")
      (("1" (grind) nil nil)
       ("2" (case "m_ = n_")
        (("1" (replaces -1)
          (("1" (hide -1 1)
            (("1" (expand "^" 1)
              (("1" (expand "length" 1 1)
                (("1" (lift-if 1)
                  (("1" (lift-if 1)
                    (("1" (assert)
                      (("1" (split 1)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (expand "nth" 2 1)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "m_ < n_")
          (("1" (hide (1 2))
            (("1" (name "k_" "n_ - m_")
              (("1" (generalize "k_" "k_" "nat")
                (("1" (assert) nil nil)
                 ("2" (generalize-skolem-constants)
                  (("2" (induct "k_")
                    (("1" (grind) nil nil)
                     ("2" (skeep)
                      (("2"
                        (skolem 1 ("a" "l" "m" "n") :skolem-typepreds?
                         t)
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (expand "^" 1 1)
                              (("2"
                                (assert)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (case "m+1 = n")
                                        (("1"
                                          (replaces -1 :dir rl)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "^" 2 1)
                                              (("1"
                                                (lift-if 2)
                                                (("1"
                                                  (split 2)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (inst -3 "a" "l" "1+m" "n")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (replaces -3)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((above nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (k_ skolem-const-decl "int" more_list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil)
  (subl_shr-1 nil 3644927506
   ("" (skeep)
    (("" (case "l=null")
      (("1" (replaces -1) (("1" (grind) nil)))
       ("2" (generalize-skolem-constants)
        (("1" (induct "l_1")
          (("1" (skolem 1 ("a_" "l_"))
            (("1" (flatten)
              (("1" (split -1)
                (("1" (replaces -1)
                  (("1" (hide 1) (("1" (grind) nil)))))
                 ("2" (hide 1)
                  (("2" (expand "^" 1)
                    (("2" (lift-if 1)
                      (("2" (split 1)
                        (("1" (grind) nil)
                         ("2" (flatten)
                          (("2" (split 3)
                            (("1" (grind) nil)
                             ("2" (flatten)
                              (("2"
                                (use "subl_shr")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (expand "length" 2)
                                    (("1" (grind) nil)))))
                                 ("2"
                                  (grind)
                                  nil)))))))))))))))))))))))
           ("2" (grind) nil)))
         ("2" (grind) nil) ("3" (grind) nil))))))
    nil)
   nil nil))
 (subl_idemp_TCC1 0
  (subl_idemp_TCC1-1 nil 3644927635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (subl_idemp subtype
    "(number_fields.-)(list_props[more_list_props.T].length(more_list_props.l), 1)"
    "nat")))
 (subl_idemp 0
  (subl_idemp-1 nil 3644927656
   ("" (skeep)
    (("" (case "l=null")
      (("1" (replaces -1) (("1" (grind) nil nil)) nil)
       ("2" (generalize-skolem-constants)
        (("1" (induct "l_1")
          (("1" (assert) nil nil)
           ("2" (skolem 1 ("a_" "l_"))
            (("2" (flatten)
              (("2" (split -1)
                (("1" (replaces -1)
                  (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (hide 1)
                  (("2" (expand "^" 1)
                    (("2" (lift-if 1)
                      (("2" (split 1)
                        (("1" (grind) nil nil)
                         ("2" (flatten)
                          (("2" (split 3)
                            (("1" (grind) nil nil)
                             ("2" (flatten)
                              (("2"
                                (use "subl_shr")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (expand "length" 2)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil)
         ("2" (grind) nil nil) ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (> const-decl "bool" reals nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (a_ skolem-const-decl "T" more_list_props nil)
    (l_ skolem-const-decl "list[T]" more_list_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (subl_shr formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil))
 (length_subl 0
  (length_subl-1 nil 3644927692
   ("" (skeep :preds? t)
    (("" (case "n>=length(l)")
      (("1" (use "subl_over_len")
        (("1" (replace -1 1 :hide? t)
          (("1" (case "min(length(l), n + 1) = length(l)")
            (("1" (replace -1 1 :hide? t)
              (("1" (hide -1 -2 -3)
                (("1" (generalize "l" "l_" "(cons?[T])")
                  (("1" (grind) nil nil)
                   ("2" (generalize "m" "m_")
                    (("1" (induct "l_")
                      (("1" (grind) nil nil) ("2" (assert) nil nil)
                       ("3" (skolem 1 ("a_" "l_"))
                        (("3" (flatten)
                          (("3" (skeep)
                            (("3" (case "l_=null")
                              (("1"
                                (hide -2)
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (expand "length" -1)
                                    (("1"
                                      (expand "length" -1)
                                      (("1"
                                        (expand "length" 1 2)
                                        (("1"
                                          (expand "length" 1 2)
                                          (("1"
                                            (expand "length" 1 2)
                                            (("1"
                                              (expand "length" 1 2)
                                              (("1"
                                                (case "m_=0")
                                                (("1"
                                                  (replaces -1)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (assert)
                                (("2"
                                  (expand "length" -2)
                                  (("2"
                                    (case "m_ =0 ")
                                    (("1"
                                      (replaces -1)
                                      (("1"
                                        (hide -1)
                                        (("1"
                                          (use "subl_idemp")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (use "subl_shr")
                                      (("1"
                                        (replace -1 3 :hide? t)
                                        (("1"
                                          (inst -1 "m_ - 1")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "length" 3 2)
                                              (("1"
                                                (replace -1 3 :hide? t)
                                                (("1" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil)
                                       ("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (assert) (("4" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil)
       ("2" (name "k" "n-m")
        (("2" (generalize "k" "k" "nat")
          (("1" (assert) nil nil)
           ("2" (generalize-skolem-constants)
            (("2" (induct "k")
              (("1" (grind) nil nil)
               ("2" (skeep)
                (("2" (skolem 1 ("m_" "l_" "n_") :skolem-typepreds? t)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (case "m_ = length(l_)")
                        (("1" (replaces -1) nil nil)
                         ("2" (inst -4 "1+m_" "l_" "n_")
                          (("1" (assert)
                            (("1" (expand "^" 3)
                              (("1"
                                (expand "length" 3 1)
                                (("1"
                                  (replace -4 3 :hide? t)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (^ def-decl "list[T]" more_list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (length_null formula-decl nil more_list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (nth def-decl "T" list_props nil)
    (subl_shr formula-decl nil more_list_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (l_ skolem-const-decl "list[T]" more_list_props nil)
    (a_ skolem-const-decl "T" more_list_props nil)
    (m_ skolem-const-decl "nat" more_list_props nil)
    (> const-decl "bool" reals nil)
    (subl_idemp formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (l skolem-const-decl "{l: list[T] | length(l) >= m}"
     more_list_props nil)
    (n skolem-const-decl "upfrom(m)" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (< const-decl "bool" reals nil)
    (subl_over_len formula-decl nil more_list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (k skolem-const-decl "int" more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (m_ skolem-const-decl "nat" more_list_props nil)
    (l_ skolem-const-decl "{l: list[T] | length(l) >= m_}"
     more_list_props nil)
    (n_ skolem-const-decl "upfrom(m_)" more_list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (cdr_subl_TCC1 0
  (cdr_subl_TCC1-1 nil 3644927727 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (cdr_subl subtype
    "more_list_props.^(more_list_props.l, (more_list_props.m, more_list_props.n))"
    "(list_adt[more_list_props.T].cons?)")))
 (cdr_subl_TCC2 0
  (cdr_subl_TCC2-1 nil 3644927727 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (cdr_subl subtype "more_list_props.l"
    "(list_adt[more_list_props.T].cons?)")))
 (cdr_subl_TCC3 0
  (cdr_subl_TCC3-1 nil 3644927727 ("" (subtype-tcc) nil nil) nil nil
   (cdr_subl subtype "(number_fields.-)(more_list_props.n, 1)" "nat")))
 (cdr_subl 0
  (cdr_subl-1 nil 3644927744
   ("" (skeep)
    (("" (expand "^" 2 1)
      (("" (lift-if 2)
        (("" (split 2)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2" (lemma "subl_shr")
              (("2" (inst -1 "car(l)" "cdr(l)" "1+m" "n")
                (("2" (assert)
                  (("2" (replaces -1 :dir rl)
                    (("2" (case "l = cons(car(l),cdr(l))")
                      (("1" (assert) nil nil)
                       ("2" (apply-extensionality) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((^ def-decl "list[T]" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subl_shr formula-decl nil more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (member_nth_subl_TCC1 0
  (member_nth_subl_TCC1-1 nil 3644930796 ("" (subtype-tcc) nil nil) nil
   nil
   (member_nth_subl subtype "more_list_props.j"
    "below[length[T](l)]")))
 (member_nth_subl 0
  (member_nth_subl-1 nil 3644927781
   ("" (induct "j")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "k")
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (expand "member" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (grind) nil nil)
                 ("2" (flatten)
                  (("2" (expand "nth" 3)
                    (("2" (inst -4 "cdr(l)" "m" "n-1")
                      (("1" (use "cdr_subl")
                        (("1" (assert) nil nil)
                         ("2" (case "n=m")
                          (("1" (replaces -1)
                            (("1" (case "m=k+1")
                              (("1"
                                (replaces -1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (case "m=k+1")
                        (("1" (replaces -1)
                          (("1" (expand "^" 3) (("1" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("3" (expand "length" -1)
                        (("3" (lift-if -1)
                          (("3" (split -1)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (l skolem-const-decl "{l: list[T] | 1 + k < length(l)}"
     more_list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (> const-decl "bool" reals nil)
    (n skolem-const-decl "upfrom(1 + k)" more_list_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (cdr_subl formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (k skolem-const-decl "nat" more_list_props nil)
    (m skolem-const-decl "upto(1 + k)" more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ def-decl "list[T]" more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (member def-decl "bool" list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (nth_subl_prefix_TCC1 0
  (nth_subl_prefix_TCC1-1 nil 3644927801 ("" (subtype-tcc) nil nil) nil
   nil
   (nth_subl_prefix subtype "more_list_props.j"
    "below[length[T](l ^ (m, n))]")))
 (nth_subl_prefix_TCC2 0
  (nth_subl_prefix_TCC2-1 nil 3644927801
   ("" (skeep :preds? t)
    (("" (use "length_subl")
      (("1" (assert) nil nil)
       ("2" (assert) (("2" (grind) nil nil)) nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((length_subl formula-decl nil more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (n skolem-const-decl "{n: nat | j < length(l ^ (m, n))}"
     more_list_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (nth_subl_prefix subtype
    "(number_fields.+)(more_list_props.m, more_list_props.j)"
    "below[length[T](l)]")))
 (nth_subl_prefix 0
  (nth_subl_prefix-1 nil 3644927815
   ("" (induct "j")
    (("1" (skeep :preds? t)
      (("1" (expand "nth" 1 1)
        (("1" (expand "^" 1)
          (("1" (lift-if 1)
            (("1" (split 1)
              (("1" (grind) nil nil) ("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 "k")
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (expand "nth" 1)
            (("2" (inst -3 "cdr(l)" "m" "n-1")
              (("1" (use "cdr_subl")
                (("1" (assert) (("1" (grind) nil nil)) nil)
                 ("2" (hide-all-but (-2 1))
                  (("2" (expand "^" -1)
                    (("2" (lift-if -1)
                      (("2" (split -1)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (split 1)
                (("1" (case "n=1")
                  (("1" (replaces -1) (("1" (grind) nil nil)) nil)
                   ("2" (case "n=0")
                    (("1" (replaces -1)
                      (("1" (case "m=0")
                        (("1" (replaces -1)
                          (("1" (expand "^" -2)
                            (("1" (lift-if -2)
                              (("1"
                                (split -2)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (case "NOT null?(l ^ (m, n))")
                  (("1" (use "cdr_subl")
                    (("1" (assert)
                      (("1" (replaces -1 :dir rl)
                        (("1" (expand "length" -2)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-2 1))
                      (("2" (expand "^" -1)
                        (("2" (lift-if -1) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep :preds? t)
        (("3" (use "length_subl")
          (("1" (assert) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((length_subl formula-decl nil more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (n skolem-const-decl "{n: nat | j < length(l ^ (m, n))}"
     more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (k skolem-const-decl "nat" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (n skolem-const-decl "{n: nat | 1 + k < length(l ^ (m, n))}"
     more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (cdr_subl formula-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (TRUE const-decl "bool" booleans nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (subl_incl 0
  (subl_incl-1 nil 3644930849
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (use "member_nth")
        (("" (assert)
          (("" (skeep)
            (("" (use "nth_subl_prefix")
              (("" (lemma "member_nth_subl")
                (("" (inst -1 "m+i" "l" "m_" "n_")
                  (("1" (assert) nil nil)
                   ("2" (typepred "i")
                    (("2" (use "length_subl")
                      (("1" (assert) nil nil)
                       ("2" (assert) (("2" (grind) nil nil)) nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil)
                   ("3" (typepred "i")
                    (("3" (use "length_subl")
                      (("1" (assert) nil nil) ("2" (grind) nil nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nth_subl_prefix formula-decl nil more_list_props nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (n skolem-const-decl "nat" more_list_props nil)
    (i skolem-const-decl "below(length(l ^ (m, n)))" more_list_props
       nil)
    (n_ skolem-const-decl "upfrom(n)" more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (length_subl formula-decl nil more_list_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member_nth_subl formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (^ def-decl "list[T]" more_list_props nil)
    (member_nth formula-decl nil more_list_props nil))
   shostak))
 (take_TCC1 0
  (take_TCC1-1 nil 3647949757 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (take subtype "(number_fields.-)(more_list_props.n, 1)" "nat")))
 (take_TCC2 0
  (take_TCC2-1 nil 3647949757 ("" (termination-tcc) nil nil) nil nil
   (take termination
    "more_list_props.take(more_list_props.l, (number_fields.-)(more_list_props.n, 1))"
    "nil")))
 (take_TCC3 0
  (take_TCC3-1 nil 3647949757 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (take subtype "more_list_props.l"
    "(list_adt[more_list_props.T].cons?)")))
 (length_take 0
  (length_take-1 nil 3647949758
   ("" (induct "n")
    (("1" (expand "take" 1)
      (("1" (skolem 1 ("l_"))
        (("1" (lift-if)
          (("1" (split)
            (("1" (flatten) (("1" (grind) nil nil)) nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("n_"))
      (("2" (flatten)
        (("2" (skolem 1 ("l_"))
          (("2" (expand "take" 1)
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (inst -1 "cdr(l_)")
                    (("2" (expand "length" 2 1)
                      (("2" (replace -1 2)
                        (("2" (expand "length" 2 2)
                          (("2" (lift-if)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (take def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (nth_take_TCC1 0
  (nth_take_TCC1-1 nil 3647949757 ("" (subtype-tcc) nil nil) nil nil
   (nth_take subtype "more_list_props.j" "below[length[T](l)]")))
 (nth_take 0
  (nth_take-1 nil 3647949867
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("h" "t"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "nth" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand "take" 1)
                    (("1" (expand "member" 1) (("1" (propax) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "take" 2)
                    (("2" (expand "member" 2)
                      (("2" (flatten)
                        (("2" (inst -1 "i-1" "j-1")
                          (("1" (assert) nil nil)
                           ("2" (typepred "i")
                            (("2" (expand "length" -1)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (h skolem-const-decl "T" more_list_props nil)
    (t skolem-const-decl "list[T]" more_list_props nil)
    (i skolem-const-decl "below(1 + length(cons(h, t)))"
       more_list_props nil)
    (j skolem-const-decl "{j: nat | j < i}" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (take def-decl "list[T]" more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (member def-decl "bool" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_take2_TCC1 0
  (nth_take2_TCC1-1 nil 3647949757
   ("" (skeep)
    (("" (typepred "j")
      (("" (use "length_take") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (take def-decl "list[T]" more_list_props nil)
    (length_take formula-decl nil more_list_props nil))
   nil
   (nth_take2 subtype "more_list_props.j"
    "below[length[T](take(l, i))]")))
 (nth_take2 0
  (nth_take2-1 nil 3647949887
   ("" (induct "i")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "i")
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "take" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (inst -2 "l" "j")
                    (("1" (typepred "j") (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "nth" 2 1)
                    (("2" (lift-if 2)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (expand "nth" 2 2)
                            (("2" (assert)
                              (("2"
                                (inst -1 "cdr(l)" "j-1")
                                (("2"
                                  (typepred "j")
                                  (("2"
                                    (expand "length" -2 1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (use "length_take")
          (("3" (typepred "j") (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((length_take formula-decl nil more_list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (j skolem-const-decl "{j: nat | j < 1 + i AND j < length(l)}"
     more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (i skolem-const-decl "nat" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (take def-decl "list[T]" more_list_props nil))
   shostak))
 (take_null 0
  (take_null-1 nil 3647949914
   ("" (induct "i")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (expand "take" 1)
        (("2" (lift-if 1)
          (("2" (split 1)
            (("1" (flatten) nil nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (take def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (take_prop_1 0
  (take_prop_1-1 nil 3647949930
   ("" (skeep)
    (("" (typepred "i")
      (("" (merge-fnums *)
        ((""
          (case "FORALL(i: nat): i > length(l) IMPLIES take(l, i) = take(l, length(l))")
          (("1" (inst?) nil nil)
           ("2" (hide 2)
            (("2" (induct "i")
              (("1" (typepred "length(l)") (("1" (assert) nil nil))
                nil)
               ("2" (skeep)
                (("2" (case "j=length(l)")
                  (("1" (replace -1 1) (("1" (grind) nil nil)) nil)
                   ("2" (split -1)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((above nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (take def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (take_prop_2 0
  (take_prop_2-1 nil 3647949952
   ("" (induct " l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (length def-decl "nat" list_props nil)
    (take def-decl "list[T]" more_list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (member_take_1 0
  (member_take_1-1 nil 3647949973
   ("" (induct "i")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "i_")
      (("2" (flatten)
        (("2" (skeep*)
          (("2" (expand "take" -2)
            (("2" (lift-if -2)
              (("2" (split -2)
                (("1" (flatten)
                  (("1" (inst?)
                    (("1" (inst -3 "j" "x") (("1" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "member" -1)
                    (("2" (case "j>length(l)")
                      (("1" (use "take_prop_1")
                        (("1" (replace -1 2 :hide? t)
                          (("1" (expand "take" 2)
                            (("1" (lift-if 2)
                              (("1"
                                (split 2)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "take" 3)
                        (("2" (assert)
                          (("2" (case "j-1 = i_")
                            (("1" (assert) nil nil)
                             ("2" (inst -2 "cdr(l)" "j-1" "x")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i_ skolem-const-decl "nat" more_list_props nil)
    (j skolem-const-decl "above(1 + i_)" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (take_prop_1 formula-decl nil more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (take def-decl "list[T]" more_list_props nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (suffix_rev_prefix 0
  (suffix_rev_prefix-1 nil 3648839549
   ("" (measure-induct+ "length(l1)+length(l2)" ("l1" "l2"))
    (("" (expand "suffix?" 1)
      (("" (expand "prefix?" 1)
        (("" (rewrite "length_reverse")
          (("" (rewrite "length_reverse")
            (("" (lift-if)
              (("" (prop)
                (("1"
                  (inst -3 "reverse(cdr(reverse(x!1)))"
                   "reverse(cdr(reverse(x!2)))")
                  (("1" (rewrite "reverse_reverse")
                    (("1" (rewrite "reverse_reverse")
                      (("1" (assert)
                        (("1" (hide-all-but (2 3 5))
                          (("1" (rewrite "length_reverse")
                            (("1" (rewrite "length_reverse")
                              (("1"
                                (use "length_reverse[T]")
                                (("1"
                                  (lemma "length_reverse[T]")
                                  (("1"
                                    (inst -1 "x!1")
                                    (("1"
                                      (replaces -1 :dir rl)
                                      (("1"
                                        (replaces -1 :dir rl)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2"
                  (inst -3 "reverse(cdr(reverse(x!1)))"
                   "reverse(cdr(reverse(x!2)))")
                  (("2" (rewrite "reverse_reverse")
                    (("2" (rewrite "reverse_reverse")
                      (("2" (assert)
                        (("2" (hide-all-but (2 3 5))
                          (("2" (rewrite "length_reverse")
                            (("2" (rewrite "length_reverse")
                              (("2"
                                (use "length_reverse[T]")
                                (("2"
                                  (lemma "length_reverse[T]")
                                  (("2"
                                    (inst -1 "x!1")
                                    (("2"
                                      (replaces -1 :dir rl)
                                      (("2"
                                        (replaces -1 :dir rl)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length_reverse formula-decl nil list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reverse_reverse formula-decl nil list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (suffix? def-decl "bool" more_list_props nil)
    (prefix? def-decl "bool" more_list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (prefix_rev_suffix 0
  (prefix_rev_suffix-1 nil 3648839572
   ("" (skeep)
    (("" (lemma "suffix_rev_prefix")
      (("" (inst -1 "reverse(l1)" "reverse(l2)")
        (("" (rewrite "reverse_reverse")
          (("" (rewrite "reverse_reverse") (("" (prop) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_rev_prefix formula-decl nil more_list_props nil)
    (reverse_reverse formula-decl nil list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil))
 (prefix_first 0
  (prefix_first-1 nil 3648839592
   ("" (measure-induct+ "length(l1)" "l1")
    (("" (skeep)
      (("" (expand "prefix?" 1)
        (("" (lift-if)
          (("" (prop)
            (("1" (expand "prefix?" -3)
              (("1" (rewrite "length_append") (("1" (assert) nil nil))
                nil))
              nil)
             ("2" (lift-if)
              (("2" (prop)
                (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil))
              nil)
             ("3" (lift-if)
              (("3" (prop)
                (("1" (expand "append" -2)
                  (("1" (assert)
                    (("1" (expand "prefix?" -2)
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (expand "append" -2)
                  (("2" (assert)
                    (("2" (expand "prefix?" -2)
                      (("2" (prop)
                        (("2" (inst -3 "cdr(x!1)")
                          (("2" (inst?)
                            (("2" (assert)
                              (("2"
                                (hide-all-but (3 6))
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prefix? def-decl "bool" more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (suffix_last 0
  (suffix_last-1 nil 3648839614
   ("" (skeep)
    (("" (rewrite "suffix_rev_prefix")
      (("" (rewrite "reverse_append")
        (("" (rewrite "suffix_rev_prefix")
          (("" (use "prefix_first") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((suffix_rev_prefix formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (prefix_first formula-decl nil more_list_props nil)
    (reverse_append formula-decl nil list_props nil))
   nil))
 (suffix_end 0
  (suffix_end-1 nil 3655569010
   ("" (skeep)
    (("" (lemma "suffix_last")
      (("" (inst -1 "L" "(:a:)" "l")
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((suffix_last formula-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (prefix_app 0
  (prefix_app-1 nil 3648839639
   ("" (measure-induct+ "length(l1)" "l1")
    (("" (skeep)
      (("" (expand "append" 1)
        (("" (lift-if)
          (("" (prop)
            (("1" (expand "prefix?" -1)
              (("1" (prop)
                (("1" (inst -2 "cdr(x!1)")
                  (("1" (inst?)
                    (("1" (assert)
                      (("1" (hide-all-but (3 4))
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "prefix?" 1)
              (("2" (prop)
                (("1" (expand "length" -1)
                  (("1" (rewrite "length_append")
                    (("1" (rewrite "length_append")
                      (("1" (use "prefix_length")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (inst -2 "cdr(x!1)")
                  (("2" (inst?)
                    (("2" (assert)
                      (("2" (hide-all-but (3 4))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (prefix_length formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (prefix? def-decl "bool" more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (suffix_app 0
  (suffix_app-1 nil 3648839660
   ("" (skeep)
    (("" (rewrite "suffix_rev_prefix")
      (("" (rewrite "reverse_append")
        (("" (rewrite "reverse_append")
          (("" (rewrite "suffix_rev_prefix")
            (("" (rewrite "prefix_app") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_rev_prefix formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (prefix_app formula-decl nil more_list_props nil)
    (reverse_append formula-decl nil list_props nil))
   nil))
 (prefix_supl 0
  (prefix_supl-1 nil 3648839682
   ("" (measure-induct+ "length(l1)+length(l2)" ("l1" "l2"))
    (("" (expand "prefix?" 1)
      (("" (expand "append" 1)
        (("" (lift-if)
          (("" (prop)
            (("1" (skeep)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (hide -4) (("1" (grind) nil nil)) nil)
                   ("2" (replace -1 :dir rl)
                    (("2" (expand "length" -2 1)
                      (("2" (rewrite "length_append")
                        (("2" (hide -3) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst 1 "x!2") nil nil)
             ("3" (skeep)
              (("3" (replace -1 :dir rl)
                (("3" (hide-all-but (-2 1)) (("3" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("4" (inst -3 "cdr(x!1)" "cdr(x!2)")
              (("4" (assert)
                (("4" (prop)
                  (("1" (skeep)
                    (("1" (replace -2)
                      (("1" (inst 1 "L")
                        (("1" (replace -1)
                          (("1" (hide-all-but (1 2))
                            (("1" (decompose-equality) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but (1 3 4)) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("5" (skeep) (("5" (decompose-equality) nil nil)) nil)
             ("6" (skeep)
              (("6" (inst -2 "cdr(x!1)" "cdr(x!2)")
                (("6" (assert)
                  (("6" (prop)
                    (("1" (inst?)
                      (("1" (decompose-equality -1) nil nil)) nil)
                     ("2" (hide-all-but (1 3 4))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (prefix? def-decl "bool" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (suffix_supl 0
  (suffix_supl-1 nil 3648839703
   ("" (skeep)
    (("" (rewrite "suffix_rev_prefix")
      (("" (rewrite "prefix_supl")
        (("" (prop)
          (("1" (skeep)
            (("1" (inst 1 "reverse(L)")
              (("1" (lemma "reverse_append[T]")
                (("1" (inst -1 "reverse(l1)" "L")
                  (("1" (rewrite "reverse_reverse")
                    (("1" (replace -2)
                      (("1" (rewrite "reverse_reverse")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (inst 1 "reverse(L)")
              (("2" (lemma "reverse_append[T]")
                (("2" (inst -1 "L" "l1")
                  (("2" (replace -2) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_rev_prefix formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (reverse_reverse formula-decl nil list_props nil)
    (reverse_append formula-decl nil list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (prefix_supl formula-decl nil more_list_props nil))
   nil))
 (suffix_same_length 0
  (suffix_same_length-1 nil 3658655439
   ("" (skeep)
    (("" (use "suffix_supl")
      (("" (assert)
        (("" (skolem -1 "l3")
          (("" (replace -1 :hide? t :dir rl)
            (("" (use "length_append[T]")
              (("" (replace -1 :hide? t)
                (("" (grind)
                  (("" (case "l3 =null")
                    (("1" (replace -1 :hide? t) (("1" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_supl formula-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (length_append formula-decl nil list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (suffix? def-decl "bool" more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (suffix_of_null 0
  (suffix_of_null-1 nil 3658654467 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (suffix? def-decl "bool" more_list_props nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (prefix_of_null 0
  (prefix_of_null-1 nil 3797007309 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (prefix? def-decl "bool" more_list_props nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (suffix_of_cons 0
  (suffix_of_cons-1 nil 3658607393
   ("" (skeep)
    (("" (use "suffix_supl")
      (("" (assert)
        (("" (skolem -1 "l3")
          (("" (case "l3 /= null")
            (("1" (case "l1 = cdr(append(l3,l2))")
              (("1" (use "cdr_append")
                (("1" (replace -1 :hide? t)
                  (("1" (lemma "suffix_supl")
                    (("1" (inst -1 "l2" "l1")
                      (("1" (assert)
                        (("1" (hide 2)
                          (("1" (inst?) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil)
               ("2" (replace -2 :hide? t) (("2" (assert) nil nil)) nil)
               ("3" (grind) nil nil))
              nil)
             ("2" (replace -1 :hide? t :dir rl)
              (("2" (use "length_append[T]")
                (("2" (replace -1 :hide? t) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_supl formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (l3 skolem-const-decl "list[T]" more_list_props nil)
    (cdr_append formula-decl nil more_list_props nil)
    (suffix? def-decl "bool" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (/= const-decl "boolean" notequal nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (suffix_nth_TCC1 0
  (suffix_nth_TCC1-1 nil 3658606359
   ("" (skeep*)
    (("" (assert)
      (("" (use "suffix_length") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (suffix_length formula-decl nil more_list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (suffix_nth subtype
    "(number_fields.+)((number_fields.-)(list_props[more_list_props.T].length(more_list_props.l1), list_props[more_list_props.T].length(more_list_props.l2)), more_list_props.i)"
    "below[length[T](l1)]")))
 (suffix_nth 0
  (suffix_nth-1 nil 3658606633
   ("" (induct "l1")
    (("1" (skeep)
      (("1" (skeep)
        (("1" (case "l2=null")
          (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)
           ("2" (hide 2)
            (("2" (use "suffix_of_null") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep 1 :but (("cons1_var" "x" "cons2_var" "xs")))
      (("2" (skeep)
        (("2" (skeep)
          (("2" (expand "nth" 1 2)
            (("2" (lift-if 1)
              (("2" (case "length(cons(x,cons2_var)) = length(l2)")
                (("1" (use "suffix_same_length")
                  (("1" (assert)
                    (("1" (replace -2)
                      (("1" (assert)
                        (("1" (split 1)
                          (("1" (flatten)
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (replace -1 :dir rl)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (replace -1 :dir rl)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split 2)
                  (("1" (flatten) (("1" (grind) nil nil)) nil)
                   ("2" (flatten)
                    (("2" (inst -1 "l2")
                      (("2" (split -1)
                        (("1" (inst -1 "i")
                          (("1" (expand "length" 2 1)
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (use "suffix_of_cons")
                          (("2" (assert) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (suffix_of_cons formula-decl nil more_list_props nil)
    (suffix_same_length formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (suffix_of_null formula-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (suffix? def-decl "bool" more_list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (prefix_reflexive 0
  (prefix_reflexive-1 nil 3655569568
   ("" (skeep)
    (("" (use "prefix_supl")
      (("" (assert)
        (("" (hide 2)
          (("" (inst 1 "null") (("" (use "append_null[T]") nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefix_supl formula-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append_null formula-decl nil list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (suffix_reflexive 0
  (suffix_reflexive-1 nil 3655574124
   ("" (skeep)
    (("" (use "suffix_supl")
      (("" (assert)
        (("" (hide 2)
          (("" (inst 1 "null") (("" (use "append_null_left") nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_supl formula-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append_null_left formula-decl nil more_list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (suffix_member 0
  (suffix_member-1 nil 3656147458
   ("" (skeep)
    (("" (use "suffix_supl")
      (("" (assert)
        (("" (skeep -1)
          (("" (skeep)
            (("" (replace -1 :hide? t :dir rl)
              (("" (use "member_append_r") (("" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_supl formula-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (member_append_r formula-decl nil more_list_props nil))
   shostak))
 (prefix_cdr_TCC1 0
  (prefix_cdr_TCC1-1 nil 3655661298 ("" (subtype-tcc) nil nil) nil nil
   (prefix_cdr subtype "more_list_props.l2"
    "(list_adt[more_list_props.T].cons?)")))
 (prefix_cdr 0
  (prefix_cdr-1 nil 3655661305
   ("" (skeep*)
    (("" (lemma "prefix_app")
      (("" (inst -1 "cdr(l2)" "(:car(l1):)" "cdr(l1)")
        (("" (assert)
          (("" (hide 2)
            (("" (expand "append" 1 1)
              (("" (expand "append" 1 1)
                (("" (case "l1 = cons(car(l1), cdr(l1))")
                  (("1" (replace -1 :hide? t :dir rl)
                    (("1" (case "car(l1)=car(l2)")
                      (("1" (replace -1 :hide? t)
                        (("1" (case "l2 = cons(car(l2), cdr(l2))")
                          (("1" (expand "append")
                            (("1" (expand "append")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (apply-extensionality) nil nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (use "prefix_supl")
                          (("2" (assert)
                            (("2" (skeep)
                              (("2"
                                (expand "append")
                                (("2" (decompose-equality -1) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (apply-extensionality) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefix_app formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (prefix_supl formula-decl nil more_list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (prefix_eq 0
  (prefix_eq-1 nil 3656147641
   ("" (skeep)
    (("" (use "prefix_supl")
      (("" (assert)
        (("" (skeep -1)
          (("" (replace -1 :hide? t :dir rl)
            (("" (use "length_append[T]")
              (("" (replace -1 :hide? t)
                (("" (assert)
                  (("" (case "L=null")
                    (("1" (replace -1 :hide? t)
                      (("1" (use "append_null[T]")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefix_supl formula-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (length_null formula-decl nil more_list_props nil)
    (append_null formula-decl nil list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (suffix_first_elem_TCC1 0
  (suffix_first_elem_TCC1-1 nil 3656332930 ("" (grind) nil nil)
   ((T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (suffix? def-decl "bool" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (suffix_first_elem subtype
    "(number_fields.-)(list_props[more_list_props.T].length(more_list_props.l1), list_props[more_list_props.T].length(more_list_props.l2))"
    "below[length[T](l1)]")))
 (suffix_first_elem 0
  (suffix_first_elem-1 nil 3656666898
   ("" (skeep)
    (("" (use "suffix_supl")
      (("" (assert)
        (("" (skeep)
          (("" (replace -1 1 :dir rl)
            (("" (lemma "nth_append")
              ((""
                (inst -1 "L" "l2" "length(append(L, l2)) - length(l2)")
                (("1" (split -1)
                  (("1" (replace -1 :hide? t)
                    (("1" (use "length_append[T]")
                      (("1" (replace -1 :hide? t)
                        (("1" (assert) (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (use "length_append[T]")
                    (("2" (replace -1 :hide? t)
                      (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (use "length_append[T]")
                  (("2" (replace -1 :hide? t) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_supl formula-decl nil more_list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth_append formula-decl nil more_list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (L skolem-const-decl "list[T]" more_list_props nil)
    (l2 skolem-const-decl "{l2 | NOT null?(l2)}" more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (rdc_TCC1 0
  (rdc_TCC1-2 nil 3651336467
   ("" (skeep)
    (("" (lemma "length_reverse[T]")
      (("" (inst?) (("" (typepred "l") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil more_list_props nil)
    (length_reverse formula-decl nil list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil
   (rdc subtype
    "list_props[more_list_props.T].reverse(more_list_props.l)"
    "(list_adt[more_list_props.T].cons?)"))
  (rdc_TCC1-1 nil 3651335593 ("" (subtype-tcc) nil nil) nil nil
   (rdc subtype
    "list_props[more_list_props.T].reverse(more_list_props.l)"
    "(list_adt[more_list_props.T].cons?)")))
 (rac_TCC1 0
  (rac_TCC1-2 nil 3651336488
   ("" (skeep) (("" (typepred "l") (("" (grind) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (rac subtype
    "(number_fields.-)(list_props[more_list_props.T].length(more_list_props.l), 1)"
    "below[length[T](l)]"))
  (rac_TCC1-1 nil 3651335593 ("" (subtype-tcc) nil nil) nil nil
   (rac subtype
    "(number_fields.-)(list_props[more_list_props.T].length(more_list_props.l), 1)"
    "below[length[T](l)]")))
 (rac_append_TCC1 0
  (rac_append_TCC1-2 nil 3651336514
   ("" (skeep)
    (("" (typepred "l2")
      (("" (expand append) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil))
   nil
   (rac_append subtype
    "list_props[more_list_props.T].append(more_list_props.l1, more_list_props.l2)"
    "{l: list_adt[more_list_props.T].list | (booleans.NOT)(list_adt[more_list_props.T].null?(l))}"))
  (rac_append_TCC1-1 nil 3651335593 ("" (subtype-tcc) nil nil) nil nil
   (rac_append subtype
    "list_props[more_list_props.T].append(more_list_props.l1, more_list_props.l2)"
    "{l: list_adt[more_list_props.T].list | (booleans.NOT)(list_adt[more_list_props.T].null?(l))}")))
 (rac_append 0
  (rac_append-1 nil 3651335632
   ("" (measure-induct+ "length(l1)" ("l1"))
    (("1" (expand "rac")
      (("1" (skeep)
        (("1" (expand "append" 1)
          (("1" (lift-if)
            (("1" (prop)
              (("1" (expand "length" 2 1)
                (("1" (inst? -1)
                  (("1" (expand "nth" 2 1)
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (hide-all-but (-2))
                          (("1" (typepred "l2")
                            (("1" (lemma "length_append[T]")
                              (("1"
                                (inst? -1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but (1 3))
                          (("2" (grind) nil nil)) nil)
                         ("3" (hide-all-but (1 4))
                          (("3" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "rac")
      (("2" (typepred "l2!1")
        (("2" (lemma "length_append[T]")
          (("2" (inst?)
            (("2" (hide-all-but (-1 -3 1)) (("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (typepred "l2!1")
      (("3" (use "length_append[T]")
        (("3" (hide-all-but (-1 -2 1)) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length_append formula-decl nil list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nth def-decl "T" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rac const-decl "T" more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (rdc_append 0
  (rdc_append-1 nil 3651336263
   ("" (expand "rdc")
    (("" (measure-induct+ "length(l1)" l1)
      (("1" (skeep)
        (("1" (expand "append" 1)
          (("1" (lift-if)
            (("1" (prop)
              (("1" (expand "reverse" 2 2)
                (("1"
                  (case "cons(car(x!1), null) = reverse(cons(car(x!1), null))")
                  (("1" (replaces -1)
                    (("1" (rewrite "reverse_append" :dir rl)
                      (("1" (case "null?(cdr(x!1))")
                        (("1" (expand "append" 2 (2 3))
                          (("1" (assert)
                            (("1" (expand "append" 2)
                              (("1"
                                (expand "append" 2)
                                (("1"
                                  (expand "reverse" 2 2)
                                  (("1"
                                    (expand "append" 2)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (typepred "l2")
                                          (("1"
                                            (hide-all-but (-1 1))
                                            (("1"
                                              (use "length_reverse[T]")
                                              (("1"
                                                (expand "length" -1 1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (hide -2)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (case
                                           "cdr(cons(car(reverse(l2)),
                                                                                   append(cdr(reverse(l2)), cons(car(x!1), null)))) = append(cdr(reverse(l2)), cons(car(x!1), null))")
                                          (("1"
                                            (replaces -1)
                                            (("1"
                                              (rewrite
                                               "reverse_append")
                                              (("1"
                                                (expand "reverse" 2 1)
                                                (("1"
                                                  (expand
                                                   "reverse"
                                                   2
                                                   1)
                                                  (("1"
                                                    (expand
                                                     "append"
                                                     2
                                                     2)
                                                    (("1"
                                                      (expand
                                                       "append"
                                                       2)
                                                      (("1"
                                                        (expand
                                                         "append")
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst-cp -1 "cons(car(x!1), null)")
                          (("2" (inst -2 "append(cdr(x!1), l2)")
                            (("1" (expand "length" -2)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "length" -2)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (prop)
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (expand "append" 3 1)
                                          (("1"
                                            (expand "append" 3 1)
                                            (("1"
                                              (inst -1 "cdr(x!1)")
                                              (("1"
                                                (inst -1 l2)
                                                (("1"
                                                  (expand
                                                   "length"
                                                   -1
                                                   2)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but 1)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "l2")
                              (("2"
                                (hide-all-but (-1 1))
                                (("2"
                                  (use "length_append[T]")
                                  (("2"
                                    (use "length_null[T]")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "l2!1")
        (("2" (hide-all-but (1 2))
          (("2" (grind)
            (("2" (expand "append")
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (typepred "l2!1")
        (("3" (hide-all-but (1 2))
          (("3" (expand "append")
            (("3" (lift-if)
              (("3" (prop)
                (("1" (expand "reverse")
                  (("1" (expand "append")
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "reverse")
                  (("2" (expand "append" 2 1)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (typepred "l2!1")
        (("4" (hide-all-but (1 2))
          (("4" (expand "reverse")
            (("4" (expand "append")
              (("4" (lift-if)
                (("4" (prop)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (typepred "l2!1")
        (("5" (hide-all-but (1 2))
          (("5" (expand "append")
            (("5" (lift-if)
              (("5" (prop)
                (("1" (expand "reverse")
                  (("1" (expand "append")
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "reverse")
                  (("2" (expand "append" 2 1)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (reverse_append formula-decl nil list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_null formula-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (l2 skolem-const-decl "{l2: list[T] | NOT null?(l2)}"
     more_list_props nil)
    (x!1 skolem-const-decl "list[T]" more_list_props nil)
    (length_reverse formula-decl nil list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (rdc const-decl "list[T]" more_list_props nil))
   nil))
 (rdc_rac 0
  (rdc_rac-1 nil 3651336361
   ("" (skeep)
    (("" (expand* "rdc" "rac")
      (("" (lemma "reverse_def[T]")
        (("" (inst -1 "l1" 0)
          (("" (assert)
            (("" (prop)
              (("1" (replaces -1 :dir rl)
                (("1" (expand "nth" 1)
                  (("1"
                    (case "(: car(reverse(l1)) :) = reverse((: car(reverse(l1)) :))")
                    (("1" (replaces -1)
                      (("1" (rewrite "reverse_append" :dir rl)
                        (("1" (expand "append")
                          (("1" (expand "append")
                            (("1" (use "expand_list[T]")
                              (("1"
                                (prop)
                                (("1"
                                  (typepred "l1")
                                  (("1"
                                    (hide 2)
                                    (("1"
                                      (use "length_reverse[T]")
                                      (("1"
                                        (expand "length" -1)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (replaces -1 :dir rl)
                                  (("2"
                                    (rewrite "reverse_reverse")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "l1")
                (("2" (hide -1 3) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rac const-decl "T" more_list_props nil)
    (rdc const-decl "list[T]" more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (expand_list formula-decl nil more_list_props nil)
    (reverse_reverse formula-decl nil list_props nil)
    (length_reverse formula-decl nil list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (reverse_append formula-decl nil list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reverse_def formula-decl nil more_list_props nil))
   nil))
 (length_appendn 0
  (length_appendn-2 nil 3652036152
   ("" (skeep 1 :but ("n"))
    (("" (induct "n")
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (expand "^" 1)
          (("2" (use "length_append[T]") (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil))
   nil)
  (length_appendn-1 nil 3652036141 ("" (postpone) nil nil) nil
   shostak))
 (nth_appendn_TCC1 0
  (nth_appendn_TCC1-1 nil 3652037189 ("" (grind) nil nil)
   ((T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (^ def-decl "list[T]" more_list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (nth_appendn subtype
    "list_props[more_list_props.T].length(more_list_props.l)"
    "posnat")))
 (nth_appendn 0
  (nth_appendn-1 nil 3652037195
   ("" (skeep)
    (("" (induct "n")
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (skeep)
          (("2" (expand "^" 1)
            (("2" (use "nth_append")
              (("2" (split -1)
                (("1" (replaces -1)
                  (("1" (lift-if 1)
                    (("1" (split 1)
                      (("1" (flatten)
                        (("1" (use "rem_mod2") (("1" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (typepred "i")
                          (("2" (inst -2 "i - length(l)")
                            (("1" (replaces -2)
                              (("1"
                                (case
                                 "rem(length(l)) (i - length(l)) = rem (length(l)) (i)")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (hide-all-but (1 2))
                                  (("2"
                                    (lemma "rem_diff")
                                    (("2"
                                      (inst
                                       -1
                                       "length(l)"
                                       "0"
                                       "i"
                                       "i"
                                       "length(l)")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (use "rem_zero")
                                          (("2"
                                            (use "rem_self")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "i")
                  (("2" (expand "^" -1)
                    (("2" (use "length_append[T]")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (l skolem-const-decl "{l: list[T] | NOT null?(l)}" more_list_props
     nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_append formula-decl nil more_list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (rem_mod2 formula-decl nil modulo_arithmetic nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (append def-decl "list[T]" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (rem_zero formula-decl nil modulo_arithmetic nil)
    (rem_self formula-decl nil modulo_arithmetic nil)
    (rem_diff formula-decl nil modulo_arithmetic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(length(l ^ (1 + j)))" more_list_props
       nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   shostak))
 (nth_extensionality 0
  (nth_extensionality-1 nil 3653730677
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (apply-extensionality)
            (("1" (inst -3 "0")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (inst?)
              (("2" (assert)
                (("2" (split 2)
                  (("1" (expand "length" -1)
                    (("1" (lift-if -1)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep 1)
                    (("2" (case "n=0")
                      (("1" (replaces -1 :hide? t)
                        (("1" (grind) nil nil)) nil)
                       ("2" (inst -2 "n+1")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (n skolem-const-decl "below(length(l))" more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (x skolem-const-decl "T" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (last_cons_TCC1 0
  (last_cons_TCC1-1 nil 3660317172 ("" (subtype-tcc) nil nil) nil nil
   (last_cons subtype
    "list_adt[more_list_props.T].cons(more_list_props.a, more_list_props.l)"
    "{l: list_adt[more_list_props.T].list | (booleans.NOT)(list_adt[more_list_props.T].null?(l))}")))
 (last_cons 0
  (last_cons-1 nil 3656152258 ("" (grind) nil nil)
   ((T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (last const-decl "T" more_list_props nil))
   shostak))
 (last_append 0
  (last_append-1 nil 3656153040
   ("" (skeep 1 :but ("l1"))
    (("" (induct "l1")
      (("1" (grind) nil nil)
       ("2" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
        (("2" (expand "append" 1)
          (("2" (use "last_cons") (("2" (assert) nil nil)) nil)) nil))
        nil)
       ("3" (hide 2)
        (("3" (skeep)
          (("3" (typepred "l2")
            (("3" (use "null_append") (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((l2 skolem-const-decl "{l2 | NOT null?(l2)}" more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (last const-decl "T" more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (last_cons formula-decl nil more_list_props nil)
    (null_append formula-decl nil more_list_props nil))
   shostak))
 (last_cdr_TCC1 0
  (last_cdr_TCC1-1 nil 3791215457 ("" (subtype-tcc) nil nil) nil nil
   (last_cdr subtype
    "list_adt[more_list_props.T].cdr(more_list_props.l1)"
    "{l: list_adt[more_list_props.T].list | (booleans.NOT)(list_adt[more_list_props.T].null?(l))}")))
 (last_cdr_TCC2 0
  (last_cdr_TCC2-1 nil 3791215457 ("" (subtype-tcc) nil nil) nil nil
   (last_cdr subtype "more_list_props.l1"
    "{l: list_adt[more_list_props.T].list | (booleans.NOT)(list_adt[more_list_props.T].null?(l))}")))
 (last_cdr 0
  (last_cdr-1 nil 3791215461 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (last const-decl "T" more_list_props nil))
   shostak))
 (null_reverse 0
  (null_reverse-1 nil 3656152416
   ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (last_reverse_TCC1 0
  (last_reverse_TCC1-1 nil 3655660650
   ("" (skeep :preds? t)
    (("" (use "null_reverse") (("" (assert) nil nil)) nil)) nil)
   ((null_reverse formula-decl nil more_list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (last_reverse subtype
    "list_props[more_list_props.T].reverse(more_list_props.l)"
    "{l: list_adt[more_list_props.T].list | (booleans.NOT)(list_adt[more_list_props.T].null?(l))}")))
 (last_reverse 0
  (last_reverse-1 nil 3656152467
   ("" (skeep :preds? t)
    (("" (use "expand_list")
      (("" (assert)
        (("" (replace -1 :hide? t)
          (("" (expand "reverse" 2)
            ((""
              (case "last(append(reverse(cdr(l)), cons(car(l), null))) = last(cons(car(l),null))")
              (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)
               ("2" (use "last_append") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expand_list formula-decl nil more_list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (last const-decl "T" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (last_append formula-decl nil more_list_props nil)
    (reverse def-decl "list[T]" list_props nil))
   shostak))
 (car_reverse 0
  (car_reverse-1 nil 3656153196
   ("" (induct "l")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
      (("3" (case "null?(xs)")
        (("1" (grind) nil nil)
         ("2" (assert)
          (("2" (expand "reverse" 2)
            (("2" (expand "append" 2)
              (("2" (lift-if 2)
                (("2" (split 2)
                  (("1" (flatten)
                    (("1" (use "null_reverse") (("1" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (use "last_cons") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (use "null_reverse") (("4" (assert) nil nil)) nil)) nil))
    nil)
   ((null_reverse formula-decl nil more_list_props nil)
    (last_cons formula-decl nil more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (last const-decl "T" more_list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil))
   shostak))
 (member_reverse 0
  (member_reverse-1 nil 3656153365
   ("" (skeep 1 :but ("l"))
    (("" (induct "l")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
        (("3" (split 1)
          (("1" (flatten)
            (("1" (hide -3)
              (("1" (expand "member" -1)
                (("1" (split -1)
                  (("1" (replace -1 :hide? t)
                    (("1" (hide -1)
                      (("1" (expand "reverse")
                        (("1" (use "member_append_r")
                          (("1" (assert) (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (expand "reverse" 1)
                      (("2" (use "member_append_l")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (hide -2)
              (("2" (expand "reverse" -1)
                (("2" (use "member_append_fi") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (member_append_r formula-decl nil more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (member_append_l formula-decl nil more_list_props nil)
    (member_append_fi formula-decl nil more_list_props nil))
   shostak))
 (nnprefixes_same_head_TCC1 0
  (nnprefixes_same_head_TCC1-1 nil 3645179212
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (prefixes const-decl "bool" more_list_props nil))
   nil
   (nnprefixes_same_head subtype "more_list_props.l2"
    "(list_adt[more_list_props.T].cons?)")))
 (nnprefixes_same_head 0
  (nnprefixes_same_head-1 nil 3645179230
   ("" (skeep)
    (("" (typepred "l2")
      (("" (grind)
        (("" (case "l1 = cons(car(l1), cdr(l1))")
          (("1" (replaces -1)
            (("1" (grind) (("1" (decompose-equality) nil nil)) nil))
            nil)
           ("2" (grind)
            (("2" (use "list_cons_eta[T]") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefixes const-decl "bool" more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil))
   nil))
 (no_repetitions_append 0
  (no_repetitions_append-2 nil 3656333872
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("v" "vs"))
      (("2" (flatten)
        (("2" (skeep 1)
          (("2" (inst -1 "l2")
            (("2" (split 1)
              (("1" (flatten)
                (("1" (hide -5)
                  (("1" (assert)
                    (("1" (expand "append" 1)
                      (("1" (expand "no_repetitions?" 1)
                        (("1" (skeep :preds? t)
                          (("1" (split -7)
                            (("1" (case "i=0")
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (expand "nth" -7 1)
                                  (("1"
                                    (expand "nth" -7 1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (use "nth_append[T]")
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (lift-if -7)
                                              (("1"
                                                (split -7)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     "no_repetitions?"
                                                     -6)
                                                    (("1"
                                                      (inst -6 "0" "j")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("3"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (lemma
                                                     "nth_member[T]")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "l2"
                                                       "v"
                                                       "j-1-length(vs)")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst -8 "v")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide-all-but (-3 1))
                                            (("2"
                                              (expand "length" -1)
                                              (("2"
                                                (use
                                                 "length_append[T]")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (case "j=0")
                                (("1"
                                  (replace -1 :hide? t)
                                  (("1"
                                    (hide 2)
                                    (("1"
                                      (expand "nth" -7)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (use "nth_append[T]")
                                          (("1"
                                            (split -1)
                                            (("1"
                                              (replace -1 :hide? t)
                                              (("1"
                                                (lift-if -7)
                                                (("1"
                                                  (split -7)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       "no_repetitions?"
                                                       -6)
                                                      (("1"
                                                        (inst
                                                         -6
                                                         "0"
                                                         "i")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "nth"
                                                             -6)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (lemma
                                                       "nth_member[T]")
                                                      (("2"
                                                        (inst
                                                         -1
                                                         "l2"
                                                         "v"
                                                         "i-1-length(vs)")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -8
                                                             "v")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide-all-but (1 -2))
                                              (("2"
                                                (expand "length" -1)
                                                (("2"
                                                  (use
                                                   "length_append[T]")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "no_repetitions?" -1)
                                  (("2"
                                    (inst -1 "i-1" "j-1")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (1 -3))
                              (("2"
                                (expand "no_repetitions?")
                                (("2"
                                  (skeep)
                                  (("2"
                                    (inst -2 "i!1+1" "j!1+1")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (hide-all-but (-5 1))
                              (("3"
                                (skeep)
                                (("3"
                                  (inst -3 "n")
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (hide -2)
                  (("2" (split -2)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split 1)
                          (("1" (hide-all-but (-4 1))
                            (("1" (expand "no_repetitions?")
                              (("1"
                                (skeep 1 :preds? t)
                                (("1"
                                  (inst -4 "i" "j")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (use "nth_append[T]")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (use "nth_append[T]")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use "length_append[T]")
                                    (("2" (assert) nil nil))
                                    nil)
                                   ("3"
                                    (use "length_append[T]")
                                    (("3" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep 1)
                            (("2" (inst -5 "n")
                              (("2"
                                (expand "member" -1)
                                (("2"
                                  (split -1)
                                  (("1"
                                    (replace -1 :hide? t)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "no_repetitions?" -4)
                                        (("1"
                                          (use "member_nth[T]")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (skeep -1)
                                              (("1"
                                                (inst
                                                 -5
                                                 "0"
                                                 "i+length(cons(v,vs)) ")
                                                (("1"
                                                  (split -5)
                                                  (("1"
                                                    (expand "nth" -1 1)
                                                    (("1"
                                                      (expand
                                                       "append"
                                                       1
                                                       1)
                                                      (("1"
                                                        (use
                                                         "nth_append[T]")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand "length" 1)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "length_append[T]")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (use
                                                   "length_append[T]")
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (expand "no_repetitions?")
                        (("2" (skeep)
                          (("2" (inst -2 "i+1" "j+1")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((j!1 skolem-const-decl "below(length(vs))" more_list_props nil)
    (i!1 skolem-const-decl "below(length(vs))" more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nth_member formula-decl nil more_list_props nil)
    (v skolem-const-decl "T" more_list_props nil)
    (vs skolem-const-decl "list[T]" more_list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (j skolem-const-decl "below(length(cons(v, append(vs, l2))))"
     more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth_append formula-decl nil more_list_props nil)
    (i skolem-const-decl "below(length(cons(v, append(vs, l2))))"
       more_list_props nil)
    (j skolem-const-decl "below(length(append(vs, l2)))"
     more_list_props nil)
    (i skolem-const-decl "below(length(append(vs, l2)))"
       more_list_props nil)
    (i skolem-const-decl "below(length(cons(v, vs)))" more_list_props
       nil)
    (j skolem-const-decl "below(length(cons(v, vs)))" more_list_props
     nil)
    (member_nth formula-decl nil more_list_props nil)
    (i skolem-const-decl "below(length(l2))" more_list_props nil)
    (/= const-decl "boolean" notequal nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil)
  (no_repetitions_append-1 nil 3656333838
   ("" (induct "l1")
    (("1" (grind) nil)
     ("2" (skolem 1 ("v" "vs"))
      (("2" (flatten)
        (("2" (skeep 1)
          (("2" (inst -1 "l2")
            (("2" (split 1)
              (("1" (flatten)
                (("1" (hide -5)
                  (("1" (assert)
                    (("1" (expand "append" 1)
                      (("1" (expand "no_repetitions?" 1)
                        (("1" (skeep :preds? t)
                          (("1" (split -7)
                            (("1" (case "i=0")
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (expand "nth" -7 1)
                                  (("1"
                                    (expand "nth" -7 1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (use "nth_append[nat]")
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (lift-if -7)
                                              (("1"
                                                (split -7)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     "no_repetitions?"
                                                     -6)
                                                    (("1"
                                                      (inst -6 "0" "j")
                                                      (("1"
                                                        (grind)
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil)
                                                       ("3"
                                                        (grind)
                                                        nil)))))))
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (lemma
                                                     "nth_member[nat]")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "l2"
                                                       "v"
                                                       "j-1-length(vs)")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst -8 "v")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (grind)
                                                              nil)))))))
                                                       ("2"
                                                        (grind)
                                                        nil)))))))))))))
                                           ("2"
                                            (hide-all-but (-3 1))
                                            (("2"
                                              (expand "length" -1)
                                              (("2"
                                                (use
                                                 "length_append[nat]")
                                                (("2"
                                                  (assert)
                                                  nil)))))))))))))))))))
                               ("2"
                                (case "j=0")
                                (("1"
                                  (replace -1 :hide? t)
                                  (("1"
                                    (hide 2)
                                    (("1"
                                      (expand "nth" -7)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (use "nth_append[nat]")
                                          (("1"
                                            (split -1)
                                            (("1"
                                              (replace -1 :hide? t)
                                              (("1"
                                                (lift-if -7)
                                                (("1"
                                                  (split -7)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       "no_repetitions?"
                                                       -6)
                                                      (("1"
                                                        (inst
                                                         -6
                                                         "0"
                                                         "i")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               "nth"
                                                               -6)
                                                              (("1"
                                                                (assert)
                                                                nil)))))))
                                                         ("2"
                                                          (grind)
                                                          nil)
                                                         ("3"
                                                          (grind)
                                                          nil)))))))
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (lemma
                                                       "nth_member[nat]")
                                                      (("2"
                                                        (inst
                                                         -1
                                                         "l2"
                                                         "v"
                                                         "i-1-length(vs)")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -8
                                                             "v")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (grind)
                                                                nil)))))))
                                                         ("2"
                                                          (grind)
                                                          nil)))))))))))))
                                             ("2"
                                              (hide-all-but (1 -2))
                                              (("2"
                                                (expand "length" -1)
                                                (("2"
                                                  (use
                                                   "length_append[nat]")
                                                  (("2"
                                                    (assert)
                                                    nil)))))))))))))))))))
                                 ("2"
                                  (expand "no_repetitions?" -1)
                                  (("2"
                                    (inst -1 "i-1" "j-1")
                                    (("1" (grind) nil)
                                     ("2" (grind) nil)
                                     ("3" (grind) nil)))))))))
                             ("2" (hide-all-but (1 -3))
                              (("2"
                                (expand "no_repetitions?")
                                (("2"
                                  (skeep)
                                  (("2"
                                    (inst -2 "i!1+1" "j!1+1")
                                    (("1" (grind) nil)
                                     ("2" (grind) nil)
                                     ("3" (grind) nil)))))))))
                             ("3" (hide-all-but (-5 1))
                              (("3"
                                (skeep)
                                (("3"
                                  (inst -3 "n")
                                  (("3"
                                    (grind)
                                    nil)))))))))))))))))))))
               ("2" (flatten)
                (("2" (hide -2)
                  (("2" (split -2)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split 1)
                          (("1" (hide-all-but (-4 1))
                            (("1" (expand "no_repetitions?")
                              (("1"
                                (skeep 1 :preds? t)
                                (("1"
                                  (inst -4 "i" "j")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (use "nth_append[nat]")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (use "nth_append[nat]")
                                              (("1"
                                                (assert)
                                                nil)))))))))))))
                                   ("2"
                                    (use "length_append[nat]")
                                    (("2" (assert) nil)))
                                   ("3"
                                    (use "length_append[nat]")
                                    (("3" (assert) nil)))))))))))
                           ("2" (skeep 1)
                            (("2" (inst -5 "n")
                              (("2"
                                (expand "member" -1)
                                (("2"
                                  (split -1)
                                  (("1"
                                    (replace -1 :hide? t)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "no_repetitions?" -4)
                                        (("1"
                                          (use "member_nth[nat]")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (skeep -1)
                                              (("1"
                                                (inst
                                                 -5
                                                 "0"
                                                 "i+length(cons(v,vs)) ")
                                                (("1"
                                                  (split -5)
                                                  (("1"
                                                    (expand "nth" -1 1)
                                                    (("1"
                                                      (expand
                                                       "append"
                                                       1
                                                       1)
                                                      (("1"
                                                        (use
                                                         "nth_append[nat]")
                                                        (("1"
                                                          (assert)
                                                          nil)))))))
                                                   ("2"
                                                    (expand "length" 1)
                                                    (("2"
                                                      (assert)
                                                      nil)))))
                                                 ("2"
                                                  (use
                                                   "length_append[nat]")
                                                  (("2" (assert) nil)))
                                                 ("3"
                                                  (use
                                                   "length_append[nat]")
                                                  (("3"
                                                    (assert)
                                                    nil)))))))))))))))))
                                   ("2" (assert) nil)))))))))))))))
                     ("2" (hide 2)
                      (("2" (expand "no_repetitions?")
                        (("2" (skeep)
                          (("2" (inst -2 "i+1" "j+1")
                            (("1" (assert) (("1" (grind) nil)))
                             ("2" (grind) nil)
                             ("3" (grind) nil))))))))))))))))))))))))))
    nil)
   nil nil))
 (idx_TCC1 0
  (idx_TCC1-1 nil 3656332930 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil))
   nil
   (idx subtype "more_list_props.l"
    "(list_adt[more_list_props.T].cons?)")))
 (idx_TCC2 0
  (idx_TCC2-1 nil 3656332930
   ("" (skeep)
    (("" (expand "nth" 1)
      (("" (assert)
        (("" (typepred "a")
          (("" (expand "length" 1) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nth def-decl "T" list_props nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (idx subtype "0"
    "{i: naturalnumbers.below(list_props[more_list_props.T].length(more_list_props.l)) | list_props[more_list_props.T].nth(more_list_props.l, i) = more_list_props.a}")))
 (idx_TCC3 0
  (idx_TCC3-1 nil 3656332930
   ("" (skeep)
    (("" (typepred "a")
      (("" (expand "member" -1)
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (idx subtype "more_list_props.a"
    "{a: more_list_props.T | list_props[more_list_props.T].member(a, list_adt[more_list_props.T].cdr(more_list_props.l))}")))
 (idx_TCC4 0
  (idx_TCC4-1 nil 3656332930
   ("" (grind) (("" (expand "length") (("" (grind) nil nil)) nil)) nil)
   ((length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil))
   nil
   (idx termination
    "more_list_props.idx(list_adt[more_list_props.T].cdr(more_list_props.l), more_list_props.a)"
    "nil")))
 (idx_TCC5 0
  (idx_TCC5-1 nil 3656332930
   ("" (skeep)
    (("" (typepred "v(cdr[T](l), a)")
      (("1" (split 2)
        (("1" (typepred "a")
          (("1" (expand "member" -1) (("1" (grind) nil nil)) nil)) nil)
         ("2" (grind) nil nil))
        nil)
       ("2" (typepred "a")
        (("2" (expand "member" -1) (("2" (grind) nil nil)) nil)) nil)
       ("3" (typepred "a")
        (("3" (expand "member" -1) (("3" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (idx subtype
    "(number_fields.+)(1, more_list_props.idx(list_adt[more_list_props.T].cdr(more_list_props.l), more_list_props.a))"
    "{i: naturalnumbers.below(list_props[more_list_props.T].length(more_list_props.l)) | list_props[more_list_props.T].nth(more_list_props.l, i) = more_list_props.a}")))
 (idx_nth_no_rep_TCC1 0
  (idx_nth_no_rep_TCC1-2 nil 3656667178
   ("" (skeep) (("" (use "nth_member") nil nil)) nil)
   ((T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (no_repetitions? const-decl "bool" more_list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_member formula-decl nil more_list_props nil))
   nil
   (idx_nth_no_rep subtype
    "list_props[more_list_props.T].nth(more_list_props.l, more_list_props.i)"
    "{a: more_list_props.T | list_props[more_list_props.T].member(a, more_list_props.l)}"))
  (idx_nth_no_rep_TCC1-1 nil 3656665787 ("" (subtype-tcc) nil nil) nil
   nil
   (idx_nth_no_rep subtype
    "list_props[more_list_props.T].nth(more_list_props.l, more_list_props.i)"
    "{a: more_list_props.T | list_props[more_list_props.T].member(a, more_list_props.l)}")))
 (idx_nth_no_rep 0
  (idx_nth_no_rep-1 nil 3656665791
   ("" (skeep)
    (("" (typepred "idx(l, nth(l, i))")
      (("" (typepred "l")
        (("" (expand "no_repetitions?")
          (("" (inst?)
            (("" (inst -1 "idx(l,nth(l,i))") (("" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_repetitions? const-decl "bool" more_list_props nil)
    (idx def-decl "{i: below(length(l)) | nth(l, i) = a}"
     more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (idx_inj 0
  (idx_inj-1 nil 3656665980
   ("" (skeep :preds? t)
    (("" (expand "no_repetitions?")
      (("" (inst -1 "idx(l,a)" "idx(l,b)") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((no_repetitions? const-decl "bool" more_list_props nil)
    (idx def-decl "{i: below(length(l)) | nth(l, i) = a}"
     more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member def-decl "bool" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (filtered_from_TCC1 0
  (filtered_from_TCC1-1 nil 3660317172 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (filtered_from subtype "more_list_props.i" "below[length[T](l2)]")))
 (filtered_from_TCC2 0
  (filtered_from_TCC2-1 nil 3660317172 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (T formal-type-decl nil more_list_props nil))
   nil
   (filtered_from subtype
    "list_props[nat].nth(more_list_props.idxs, more_list_props.i)"
    "below[length[T](l1)]")))
 (filter_idxs_TCC1 0
  (filter_idxs_TCC1-1 nil 3656701697 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (filtered_from const-decl "bool" more_list_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (filter_idxs subtype "list_adt[more_list_props.T].null"
    "(more_list_props.filtered_from(more_list_props.l, more_list_props.idxs))")))
 (filter_idxs_TCC2 0
  (filter_idxs_TCC2-2 nil 3656701757
   ("" (skeep*)
    (("" (typepred "idxs")
      (("" (inst -2 "0") (("1" (grind) nil nil) ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (idxs skolem-const-decl "{idxs: list[nat] |
   FORALL (i: below(length(idxs))): nth(idxs, i) < length(l)}"
     more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil (filter_idxs subtype "more_list_props.i" "below[length[T](l)]"))
  (filter_idxs_TCC2-1 nil 3656701697 ("" (subtype-tcc) nil nil) nil nil
   (filter_idxs subtype "more_list_props.i" "below[length[T](l)]")))
 (filter_idxs_TCC3 0
  (filter_idxs_TCC3-1 nil 3656701697 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (filter_idxs subtype "more_list_props.idxs"
    "(list_adt[nat].cons?)")))
 (filter_idxs_TCC4 0
  (filter_idxs_TCC4-2 "" 3744486179
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "idxs")
        (("" (inst -2 "i!1+1")
          (("1" (grind) nil nil)
           ("2" (typepred "i!1") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (i!1 skolem-const-decl "below(length(cdr(idxs)))" more_list_props
     nil)
    (idxs skolem-const-decl "{idxs: list[nat] |
   FORALL (i: below(length(idxs))): nth(idxs, i) < length(l)}"
     more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (T formal-type-decl nil more_list_props nil))
   shostak
   (filter_idxs subtype "list_adt[nat].cdr(more_list_props.idxs)"
    "{idxs: list_adt[nat].list | FORALL (i: naturalnumbers.below(list_props[nat].length(idxs))): reals.<(list_props[nat].nth(idxs, i), list_props[more_list_props.T].length(more_list_props.l))}"))
  (filter_idxs_TCC4-1 nil 3656701697
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "idxs")
        (("" (inst -2 "i_1+1")
          (("1" (grind) nil nil)
           ("2" (typepred "i_1") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil nil
   (filter_idxs subtype "list_adt[nat].cdr(more_list_props.idxs)"
    "{idxs: list_adt[nat].list | FORALL (i: naturalnumbers.below(list_props[nat].length(idxs))): reals.<(list_props[nat].nth(idxs, i), list_props[more_list_props.T].length(more_list_props.l))}")))
 (filter_idxs_TCC5 0
  (filter_idxs_TCC5-1 nil 3656701697 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (filter_idxs termination
    "more_list_props.filter_idxs(more_list_props.l, list_adt[nat].cdr(more_list_props.idxs))"
    "nil")))
 (filter_idxs_TCC6 0
  (filter_idxs_TCC6-2 nil 3656701874
   ("" (skeep*)
    (("" (expand "filtered_from")
      (("" (typepred "v(l, cdr[nat](idxs))")
        (("1" (expand "filtered_from")
          (("1" (flatten)
            (("1" (expand "length" 1 1)
              (("1" (replace -1 1)
                (("1" (expand "length" 1 2)
                  (("1" (assert)
                    (("1" (skeep)
                      (("1" (case "i_1 =0")
                        (("1" (replace -1 :hide? t)
                          (("1" (grind) nil nil)) nil)
                         ("2" (inst -2 "i_1-1")
                          (("1" (grind) nil nil)
                           ("2" (assert)
                            (("2" (typepred "i_1")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil)
         ("3" (hide 2)
          (("3" (skeep)
            (("3" (typepred "idxs")
              (("3" (inst -2 "i!1+1")
                (("1" (grind) nil nil)
                 ("2" (typepred "i!1") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (grind) nil nil))
        nil))
      nil))
    nil)
   ((filtered_from const-decl "bool" more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i!1 skolem-const-decl "below(length(cdr[nat](idxs)))"
     more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (idxs skolem-const-decl "{idxs: list[nat] |
   FORALL (i: below(length(idxs))): nth(idxs, i) < length(l)}"
     more_list_props nil)
    (i_1 skolem-const-decl "below(length(idxs))" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (filter_idxs subtype
    "list_adt[more_list_props.T].cons(list_props[more_list_props.T].nth(more_list_props.l, more_list_props.i), more_list_props.filter_idxs(more_list_props.l, list_adt[nat].cdr(more_list_props.idxs)))"
    "(more_list_props.filtered_from(more_list_props.l, more_list_props.idxs))"))
  (filter_idxs_TCC6-1 nil 3656701697 ("" (subtype-tcc) nil nil) nil nil
   (filter_idxs subtype
    "list_adt[more_list_props.T].cons(list_props[more_list_props.T].nth(more_list_props.l, more_list_props.i), more_list_props.filter_idxs(more_list_props.l, list_adt[nat].cdr(more_list_props.idxs)))"
    "(more_list_props.filtered_from(more_list_props.l, more_list_props.idxs))")))
 (no_rep_filter 0
  (no_rep_filter-1 nil 3656667775
   ("" (skeep*)
    (("" (expand "no_repetitions?")
      (("" (skeep 1)
        (("" (typepred "l2")
          (("" (expand "filtered_from")
            (("" (flatten)
              (("" (inst-cp -2 "i")
                (("1" (inst -2 "j")
                  (("1" (replace -2 -5 :hide? t)
                    (("1" (replace -2 -4 :hide? t)
                      (("1" (typepred "l1")
                        (("1" (expand "no_repetitions?" -1)
                          (("1" (inst -1 "nth(idxs,i)" "nth(idxs,j)")
                            (("1" (assert)
                              (("1"
                                (expand "/=")
                                (("1"
                                  (inst -3 "i" "j")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_repetitions? const-decl "bool" more_list_props nil)
    (filtered_from const-decl "bool" more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (j skolem-const-decl "below(length(l2))" more_list_props nil)
    (/= const-decl "boolean" notequal nil)
    (l1 skolem-const-decl "(no_repetitions?)" more_list_props nil)
    (idxs skolem-const-decl "{idxs: list[nat] |
   FORALL (i: below(length(idxs))): nth(idxs, i) < length(l1)}"
     more_list_props nil)
    (l2 skolem-const-decl "(filtered_from(l1, idxs))" more_list_props
     nil)
    (i skolem-const-decl "below(length(l2))" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (update_list_TCC1 0
  (update_list_TCC1-1 nil 3657975670 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (update_list subtype "more_list_props.l"
    "(list_adt[more_list_props.T].cons?)")))
 (update_list_TCC2 0
  (update_list_TCC2-1 nil 3657975670
   ("" (skeep)
    (("" (split 1)
      (("1" (expand "length" 1 2)
        (("1" (expand "length" 1 1)
          (("1" (grind)
            (("1" (typepred "i") (("1" (grind) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil))
   nil
   (update_list subtype
    "list_adt[more_list_props.T].cons(more_list_props.x, list_adt[more_list_props.T].cdr(more_list_props.l))"
    "{r: list_adt[more_list_props.T].list | booleans.AND(list_props[more_list_props.T].length(more_list_props.l) = list_props[more_list_props.T].length(r), FORALL (j: naturalnumbers.below(list_props[more_list_props.T].length(more_list_props.l))): list_props[more_list_props.T].nth(r, j) = IF more_list_props.i = j THEN more_list_props.x ELSE list_props[more_list_props.T].nth(more_list_props.l, j) ENDIF)}")))
 (update_list_TCC3 0
  (update_list_TCC3-1 nil 3657975670 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (update_list subtype "more_list_props.l"
    "(list_adt[more_list_props.T].cons?)")))
 (update_list_TCC4 0
  (update_list_TCC4-1 nil 3657975670
   ("" (skeep :preds? t)
    (("" (assert)
      (("" (expand "length" -1) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (update_list subtype "(number_fields.-)(more_list_props.i, 1)"
    "naturalnumbers.below(list_props[more_list_props.T].length(list_adt[more_list_props.T].cdr(more_list_props.l)))")))
 (update_list_TCC5 0
  (update_list_TCC5-1 nil 3657975670
   ("" (skeep :preds? t)
    (("" (expand "length" 2 2) (("" (grind) nil nil)) nil)) nil)
   ((length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (update_list termination
    "more_list_props.update_list(list_adt[more_list_props.T].cdr(more_list_props.l), (number_fields.-)(more_list_props.i, 1), more_list_props.x)"
    "nil")))
 (update_list_TCC6 0
  (update_list_TCC6-1 nil 3657975670
   ("" (skeep)
    (("" (split 2)
      (("1" (typepred "v(cdr(l),i-1,x)")
        (("1" (expand "length" 1 2)
          (("1" (replace -1 :dir rl :hide? t)
            (("1" (expand "length" 1 1)
              (("1" (typepred "i") (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (typepred "i")
            (("2" (expand "length" -1) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (typepred "v(cdr(l),i-1,x)")
          (("1" (expand "nth" 1 1)
            (("1" (lift-if 1)
              (("1" (split 1)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (inst -2 "j-1")
                    (("1" (assert)
                      (("1" (replace -2 :hide? t)
                        (("1" (lift-if 2)
                          (("1" (split 2)
                            (("1" (propax) nil nil)
                             ("2" (flatten) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (typepred "j")
                        (("2" (expand "length" -1)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (typepred "i")
              (("2" (expand "length" -1) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(length[T](l))" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (j skolem-const-decl "below(length(l))" more_list_props nil))
   nil
   (update_list subtype
    "list_adt[more_list_props.T].cons(list_adt[more_list_props.T].car(more_list_props.l), more_list_props.update_list(list_adt[more_list_props.T].cdr(more_list_props.l), (number_fields.-)(more_list_props.i, 1), more_list_props.x))"
    "{r: list_adt[more_list_props.T].list | booleans.AND(list_props[more_list_props.T].length(more_list_props.l) = list_props[more_list_props.T].length(r), FORALL (j: naturalnumbers.below(list_props[more_list_props.T].length(more_list_props.l))): list_props[more_list_props.T].nth(r, j) = IF more_list_props.i = j THEN more_list_props.x ELSE list_props[more_list_props.T].nth(more_list_props.l, j) ENDIF)}")))
 (no_rep_cdr 0
  (no_rep_cdr-1 nil 3658602625
   ("" (skeep)
    (("" (expand "no_repetitions?" -1)
      (("" (split 1)
        (("1" (expand "no_repetitions?")
          (("1" (skeep)
            (("1" (inst -2 "i+1" "j+1")
              (("1" (assert) (("1" (grind) nil nil)) nil)
               ("2" (typepred "j") (("2" (grind) nil nil)) nil)
               ("3" (typepred "i") (("3" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (use "member_nth")
          (("2" (assert)
            (("2" (skeep)
              (("2" (inst -3 "i+1" "0")
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_repetitions? const-decl "bool" more_list_props nil)
    (member_nth formula-decl nil more_list_props nil)
    (i skolem-const-decl "below(length(l))" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (a skolem-const-decl "T" more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (i skolem-const-decl "below(length(l))" more_list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (j skolem-const-decl "below(length(l))" more_list_props nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (no_rep_suffix 0
  (no_rep_suffix-1 nil 3658602820
   ("" (skeep)
    (("" (expand "no_repetitions?")
      (("" (skeep)
        (("" (lemma "suffix_nth")
          (("" (inst -1 "l1" "l2")
            (("" (assert)
              (("" (inst-cp -1 "i")
                (("" (replace -2 :hide? t)
                  (("" (inst -1 "j")
                    (("" (replace -1 :hide? t)
                      ((""
                        (inst -1 "i + length(l1) - length(l2)"
                         "j + length(l1) - length(l2)")
                        (("1" (assert) nil nil)
                         ("2" (use "suffix_length")
                          (("2" (assert) nil nil)) nil)
                         ("3" (use "suffix_length")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_repetitions? const-decl "bool" more_list_props nil)
    (suffix_nth formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (suffix_length formula-decl nil more_list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (j skolem-const-decl "below(length(l2))" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (l1 skolem-const-decl "list[T]" more_list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (i skolem-const-decl "below(length(l2))" more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (clone_times_TCC1 0
  (clone_times_TCC1-1 nil 3662144655 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (clone_times subtype "more_list_props.i"
    "below[length[list[nat]](r)]")))
 (clone_times_TCC2 0
  (clone_times_TCC2-1 nil 3662144655 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (clone_times subtype "list_adt[list[nat]].null"
    "{r: list_adt[list[nat]].list | booleans.AND(list_props[list[nat]].length(r) = more_list_props.n, FORALL (i: naturalnumbers.below(more_list_props.n)): list_props[list[nat]].nth(r, i) = more_list_props.l)}")))
 (clone_times_TCC3 0
  (clone_times_TCC3-1 nil 3662144655
   ("" (skeep)
    (("" (typepred "v(n - 1)(l)")
      (("1" (hide -1)
        (("1" (split 2)
          (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)
           ("2" (skeep)
            (("2" (case "i=0")
              (("1" (expand "nth" 1) (("1" (assert) nil nil)) nil)
               ("2" (expand "nth" 2)
                (("2" (assert) (("2" (inst? -2) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (clone_times subtype
    "list_adt[list[nat]].cons(more_list_props.l, more_list_props.clone_times((number_fields.-)(more_list_props.n, 1))(more_list_props.l))"
    "{r: list_adt[list[nat]].list | booleans.AND(list_props[list[nat]].length(r) = more_list_props.n, FORALL (i: naturalnumbers.below(more_list_props.n)): list_props[list[nat]].nth(r, i) = more_list_props.l)}")))
 (length_snoc 0
  (length_snoc-1 nil 3793386649
   ("" (skeep)
    (("" (expand "snoc") (("" (rewrite "length_append") nil nil)) nil))
    nil)
   ((snoc const-decl "list[T]" more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (length_append formula-decl nil list_props nil)
    (length_singleton formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (length_parm 0
  (length_parm-2 "" 3790088164
   ("" (skolem 1 ("PP" _))
    (("" (induct "pl") (("" (grind) nil nil)) nil)) nil)
   ((list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak)
  (length_parm-1 nil 3664739412
   ("" (skolem 1 ("PP" _))
    (("" (induct "pl")
      (("1" (grind) nil nil)
       ("2" (skosimp* :preds? t)
        (("2" (expand "length" +) (("2" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (nth_parm 0
  (nth_parm-2 "" 3790088164
   ("" (skolem 1 ("PP" _ _))
    (("" (induct "pl")
      (("1" (grind) nil nil) ("2" (skosimp* :preds? t) nil nil)) nil))
    nil)
   ((list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak)
  (nth_parm-1 nil 3664739421
   ("" (skolem 1 ("PP" _ _))
    (("" (induct "pl")
      (("1" (grind) nil nil)
       ("2" (skosimp* :preds? t)
        (("2" (expand "nth" +)
          (("2" (lift-if)
            (("2" (prop) (("2" (inst?) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind)
        (("3" (hide-all-but (-3 1))
          (("3" (use "length_parm") (("3" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (every_parm 0
  (every_parm-2 "" 3790088165
   ("" (skosimp* :preds? t)
    (("" (iff)
      (("" (prop)
        (("1" (rewrite "every_nth")
          (("1" (rewrite "every_nth")
            (("1" (rewrite "every_nth")
              (("1" (skosimp* :preds? t)
                (("1" (expand "restrict") (("1" (inst?) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite "every_nth")
          (("2" (rewrite "every_nth")
            (("2" (rewrite "every_nth")
              (("2" (skosimp* :preds? t)
                (("2" (expand "restrict") (("2" (inst?) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (restrict const-decl "R" restrict nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil))
   shostak)
  (every_parm-1 nil 3664739446
   ("" (skosimp* :preds? t)
    (("" (iff)
      (("" (prop)
        (("1" (rewrite "every_nth")
          (("1" (rewrite "every_nth")
            (("1" (rewrite "every_nth")
              (("1" (skosimp* :preds? t)
                (("1" (expand "restrict")
                  (("1" (inst?)
                    (("1" (inst?)
                      (("1" (assert)
                        (("1" (hide -1 -3)
                          (("1" (lemma "nth_parm")
                            (("1" (inst -1 "P!1" "pl!1" "i!1")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use "length_parm") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite "every_nth")
          (("2" (rewrite "every_nth")
            (("2" (rewrite "every_nth")
              (("2" (skosimp* :preds? t)
                (("2" (expand "restrict")
                  (("2" (inst?)
                    (("1" (inst?)
                      (("1" (assert)
                        (("1" (hide -1 -3)
                          (("1" (lemma "nth_parm")
                            (("1" (inst -1 "P!1" "pl!1" "i!1")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use "length_parm") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (restrict const-decl "R" restrict nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (append_parm 0
  (append_parm-2 "" 3790088165
   ("" (skolem 1 ("P" "_" "_"))
    (("" (induct "l1") (("1" (grind) nil nil) ("2" (skosimp) nil nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak)
  (append_parm-1 nil 3664739476
   ("" (skolem 1 ("P" "_" "_"))
    (("" (induct "l1")
      (("1" (grind) nil nil)
       ("2" (skosimp)
        (("2" (skosimp)
          (("2" (expand "append" +)
            (("2" (inst -1 "l2!1") (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (member_parm 0
  (member_parm-2 "" 3790088165
   ("" (skolem 1 ("P" _ "x"))
    (("" (induct "pl") (("" (grind) nil nil)) nil)) nil)
   ((list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak)
  (member_parm-1 nil 3665227555
   ("" (skolem 1 ("P" _ "x"))
    (("" (induct "pl") (("1" (grind) nil nil) ("2" (grind) nil nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (append_append_cons 0
  (append_append_cons-1 nil 3664739535
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skeep :preds? t)
      (("2" (skeep :preds? t)
        (("2" (expand "append" 1 1)
          (("2" (expand "append" 1 3)
            (("2" (expand "append" 1 2)
              (("2" (decompose-equality 1) (("2" (inst?) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_cons_extensionality formula-decl nil list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (append_equal_null 0
  (append_equal_null-1 nil 3664739560
   ("" (induct "l2")
    (("1" (induct "l1")
      (("1" (skeep :preds? t)
        (("1" (expand "append" -2) (("1" (propax) nil nil)) nil)) nil))
      nil)
     ("2" (skeep :preds? t)
      (("2" (induct "l1")
        (("2" (skeep :preds? t)
          (("2" (expand "append" -2)
            (("2" (decompose-equality -2)
              (("2"
                (case-replace
                 "append(cons2_var_1, cons(cons1_var, cons2_var)) =
     append(append(cons2_var_1, cons(cons1_var, null)), cons2_var)"
                 :hide? t)
                (("1" (hide -3)
                  (("1"
                    (inst -3
                     "append(cons2_var_1, cons(cons1_var, null))")
                    (("1" (assert)
                      (("1" (expand "append" -3)
                        (("1" (lift-if) (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (use "append_append_cons") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append_append_cons formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_append_below_TCC1 0
  (nth_append_below_TCC1-1 nil 3664739389
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skosimp)
      (("2" (skosimp)
        (("2" (expand "append" +)
          (("2" (expand "length" +)
            (("2" (expand "length" -2)
              (("2" (inst?)
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (rewrite "length_append")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil
   (nth_append_below subtype "more_list_props.i"
    "below[length[T](append[T](l1, l2))]")))
 (nth_append_below 0
  (nth_append_below-1 nil 3664739595
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skosimp :preds? t)
      (("2" (skosimp :preds? t)
        (("2" (expand "append" 1 1)
          (("2" (expand "nth" +)
            (("2" (lift-if)
              (("2" (prop)
                (("2" (inst?)
                  (("1" (assert)
                    (("1" (expand "length" -2) (("1" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp :preds? t)
        (("3" (rewrite "length_append") (("3" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i!1 skolem-const-decl "nat" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil))
   shostak))
 (nth_append_above_TCC1 0
  (nth_append_above_TCC1-1 nil 3664739389
   ("" (skosimp)
    (("" (rewrite "length_append") (("" (assert) nil nil)) nil)) nil)
   ((length_append formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (nth_append_above subtype
    "(number_fields.-)(more_list_props.i, list_props[more_list_props.T].length(more_list_props.l1))"
    "below[length[T](l2)]")))
 (nth_append_above 0
  (nth_append_above-1 nil 3664739616
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skosimp :preds? t)
      (("2" (skosimp :preds? t)
        (("2" (expand "append" +)
          (("2" (expand "length" +)
            (("2" (expand "nth" 1 1)
              (("2" (lift-if)
                (("2" (expand "length" -3)
                  (("2" (assert)
                    (("2" (inst -2 "i!1 - 1" "l2!1")
                      (("2" (assert)
                        (("2" (expand "append" -3)
                          (("2" (expand "length" -3)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp :preds? t)
      (("3" (assert)
        (("3" (assert)
          (("3" (rewrite "length_append") (("3" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (append def-decl "list[T]" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (tail?_TCC1 0
  (tail?_TCC1-1 nil 3664739389 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (tail? termination
    "more_list_props.tail?(list_adt[more_list_props.T].cdr(more_list_props.l1), more_list_props.l2)"
    "nil")))
 (tail_append 0
  (tail_append-1 nil 3664739643
   ("" (induct "l1")
    (("1" (grind) (("1" (expand "tail?") (("1" (propax) nil nil)) nil))
      nil)
     ("2" (skeep :preds? t)
      (("2" (expand "append" +)
        (("2" (expand "tail?" +)
          (("2" (skeep :preds? t) (("2" (inst?) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (tail? def-decl "bool" more_list_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (ldiff_TCC1 0
  (ldiff_TCC1-1 nil 3664739389
   ("" (skeep :preds? t)
    (("" (expand "tail?") (("" (assert) nil nil)) nil)) nil)
   ((tail? def-decl "bool" more_list_props nil)) nil
   (ldiff subtype "more_list_props.l1"
          "(list_adt[more_list_props.T].cons?)")))
 (ldiff_TCC2 0
  (ldiff_TCC2-1 nil 3664739389
   ("" (skeep :preds? t)
    (("" (expand "tail?" -) (("" (assert) nil nil)) nil)) nil)
   ((tail? def-decl "bool" more_list_props nil)) nil
   (ldiff subtype "more_list_props.l2"
          "{l2 | more_list_props.tail?(list_adt[more_list_props.T].cdr(more_list_props.l1), more_list_props.l2)}")))
 (ldiff_TCC3 0
  (ldiff_TCC3-1 nil 3664739389
   ("" (skeep :preds? t)
    (("" (assert)
      (("" (expand "<<")
        (("" (lift-if)
          (("" (expand "tail?") (("" (prop) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((tail? def-decl "bool" more_list_props nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil
   (ldiff termination
          "more_list_props.ldiff(list_adt[more_list_props.T].cdr(more_list_props.l1), more_list_props.l2)"
          "nil")))
 (ldiff_append_TCC1 0
  (ldiff_append_TCC1-1 nil 3664739389
   ("" (induct "l1")
    (("1" (grind) (("1" (expand "tail?") (("1" (propax) nil nil)) nil))
      nil)
     ("2" (skeep :preds? t)
      (("2" (expand "append" +)
        (("2" (expand "tail?" +)
          (("2" (skeep :preds? t)
            (("2" (hide 1) (("2" (inst?) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (tail? def-decl "bool" more_list_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil
   (ldiff_append subtype "more_list_props.l2"
    "{l2_1 | more_list_props.tail?(list_props[more_list_props.T].append(more_list_props.l1, more_list_props.l2), l2_1)}")))
 (ldiff_append 0
  (ldiff_append-1 nil 3664739659
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skeep :preds? t)
      (("2" (skeep :preds? t)
        (("2" (expand "append" +)
          (("2" (expand "ldiff" +)
            (("2" (lift-if)
              (("2" (prop)
                (("1" (lemma "append_equal_null")
                  (("1" (inst -1 "cons(cons1_var, cons2_var)" "l2")
                    (("1" (expand "append" -1 1)
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (hide 1)
                  (("2" (apply-extensionality :hide? t)
                    (("2" (inst?) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep :preds? t) (("3" (use "tail_append") nil nil)) nil))
    nil)
   ((tail_append formula-decl nil more_list_props nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (append_equal_null formula-decl nil more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (ldiff def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (tail? def-decl "bool" more_list_props nil)
    (append def-decl "list[T]" list_props nil))
   shostak))
 (filter_nth 0
  (filter_nth-1 nil 3774946724
   (""
    (case "FORALL (n: nat, L: list[T], P: [T -> bool]):
               LET FL = filter(L, P) IN
                n=length(L) AND cons?(FL) IMPLIES
                  (FORALL (i: below(length(FL))):
                     EXISTS (j: below(length(L))): nth(FL, i) = nth(L, j))")
    (("1" (skeep)
      (("1" (ground) (("1" (inst -1 "length(L)" "L" "P") nil nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep)
          (("1" (assert)
            (("1" (flatten)
              (("1" (skeep :preds? T)
                (("1" (inst -2 "L" "P")
                  (("1" (assert) (("1" (inst -2 "i") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (assert)
            (("2" (skeep :preds? T)
              (("2" (expand "length" -2)
                (("2" (lift-if -2)
                  (("2" (split -2)
                    (("1" (expand "filter" -2) (("1" (assert) nil nil))
                      nil)
                     ("2" (flatten) (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (skeep)
            (("3" (case "j_1=0")
              (("1" (replace -1)
                (("1" (skeep :preds? T)
                  (("1" (expand "length" -4)
                    (("1" (lift-if -4)
                      (("1" (split -4)
                        (("1" (assert) nil nil)
                         ("2" (flatten)
                          (("2" (expand "filter" -2)
                            (("2" (lift-if -2)
                              (("2"
                                (split -2)
                                (("1" (flatten) nil nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (expand "length" -2)
                                    (("2"
                                      (lift-if -2)
                                      (("2"
                                        (split -2)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand "filter" -2)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (split -2)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (case "NOT i=0")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (replace -1 3)
                                                      (("2"
                                                        (inst 3 "0")
                                                        (("1"
                                                          (expand
                                                           "nth")
                                                          (("1"
                                                            (expand
                                                             "filter"
                                                             3)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             "length")
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep :preds? T)
                (("2" (case "P(car(L))")
                  (("1" (case "i=0")
                    (("1" (inst 2 "0")
                      (("1" (replace -1 2)
                        (("1" (expand "filter" 2)
                          (("1" (lift-if 2)
                            (("1" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand "length" -6)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "nth" 2)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (inst -3 "cdr(L)" "P")
                      (("2" (expand "length" -4)
                        (("2" (assert)
                          (("2" (lift-if -4)
                            (("2" (split -4)
                              (("1" (assert) nil nil)
                               ("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "length" -3)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "filter" -5)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (case
                                               "NOT 0 < length[T](cdr(filter(L, P)))")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (split -5)
                                                (("1"
                                                  (expand "filter " 4)
                                                  (("1"
                                                    (expand "nth" 4 1)
                                                    (("1"
                                                      (inst -1 "i-1")
                                                      (("1"
                                                        (skeep)
                                                        (("1"
                                                          (inst
                                                           4
                                                           "j+1")
                                                          (("1"
                                                            (expand
                                                             "nth"
                                                             4
                                                             2)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (typepred
                                                             "j")
                                                            (("2"
                                                              (expand
                                                               "length"
                                                               1)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (expand
                                                           "filter"
                                                           -4)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "filter" -1)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand
                                                       "length"
                                                       -1)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -2 "cdr(L)" "P")
                    (("2" (assert)
                      (("2" (expand "length" -3)
                        (("2" (lift-if -3)
                          (("2" (split -3)
                            (("1" (assert) nil nil)
                             ("2" (assert)
                              (("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (split -3)
                                    (("1"
                                      (expand "filter" 4)
                                      (("1"
                                        (inst -1 "i")
                                        (("1"
                                          (skeep)
                                          (("1"
                                            (inst 4 "j+1")
                                            (("1"
                                              (expand "nth" 4 2)
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand "filter" -2)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "filter" -3)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (assert)
                    (("3" (expand "length") (("3" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length_singleton formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (L skolem-const-decl "list[T]" more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (P skolem-const-decl "[T -> bool]" more_list_props nil)
    (i skolem-const-decl "below(length(filter(L, P)))" more_list_props
       nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (j skolem-const-decl "below(length(cdr(L)))" more_list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length_null formula-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (filter def-decl "list[T]" filters nil))
   nil))
 (takeFromRight_TCC1 0
  (takeFromRight_TCC1-1 nil 3763820594 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (takeFromRight termination
    "more_list_props.takeFromRight(list_adt[more_list_props.T].cdr(more_list_props.l), more_list_props.n)"
    "nil")))
 (takeFromRight_decreasing 0
  (takeFromRight_decreasing-1 nil 3759150867 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (takeFromRight def-decl "list[T]" more_list_props nil))
   shostak))
 (takeFromRight_length 0
  (takeFromRight_length-1 nil 3759150925
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (expand "takeFromRight" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (inst -2 "n") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((a skolem-const-decl "T" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (n skolem-const-decl "upto(length(cons(a, l)))" more_list_props
     nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (takeFromRight def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (takeFromRight_member 0
  (takeFromRight_member-1 nil 3759150955
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "takeFromRight" -2)
            (("2" (lift-if -2)
              (("2" (split -2)
                (("1" (grind) nil nil)
                 ("2" (ground)
                  (("2" (inst -2 "a_1" "n")
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (takeFromRight def-decl "list[T]" more_list_props nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (takeFromRight_takeFromRight 0
  (takeFromRight_takeFromRight-1 nil 3759150975
   ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var!1 skolem-const-decl "T" more_list_props nil)
    (cons2_var!1 skolem-const-decl "list[T]" more_list_props nil)
    (n!1 skolem-const-decl
     "below(length(cons(cons1_var!1, cons2_var!1)))" more_list_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (takeFromRight def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_takeFromRight_TCC1 0
  (nth_takeFromRight_TCC1-1 nil 3763820594
   ("" (skeep :preds? t)
    (("" (rewrite "takeFromRight_length") (("" (assert) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (takeFromRight_length formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil
   (nth_takeFromRight subtype
    "(number_fields.+)((number_fields.-)(list_props[more_list_props.T].length(more_list_props.l), more_list_props.n), more_list_props.m)"
    "below[length[T](l)]")))
 (nth_takeFromRight 0
  (nth_takeFromRight-1 nil 3759151025
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (rewrite "takeFromRight_length")
            (("2" (expand "takeFromRight" 1)
              (("2" (expand "nth" 1 2)
                (("2" (expand "length" 1)
                  (("2" (expand "length" -1)
                    (("2" (case "n = 1 + length(l)")
                      (("1" (replace -1 :hide? t)
                        (("1" (assert) nil nil)) nil)
                       ("2" (inst -3 "n" "m") (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep :preds? t)
        (("3" (rewrite "takeFromRight_length") (("3" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (n skolem-const-decl "below(length(cons(a, l)))" more_list_props
     nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (a skolem-const-decl "T" more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (takeFromRight_length formula-decl nil more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (takeFromRight def-decl "list[T]" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (merge_TCC1 0
  (merge_TCC1-1 nil 3791452996 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (merge termination "more_list_props.merge(more_list_props.xs)"
          "nil")))
 (LIST_induction 0
  (LIST_induction-1 nil 3791453026
   ("" (skeep)
    (("" (lemma "NAT_induction")
      ((""
        (inst -1
         "LAMBDA(n:nat)->bool: FORALL (l: list[T] | n=length(l)): p(l)")
        (("" (split -1)
          (("1" (skeep)
            (("1" (inst -1 "length(l)") (("1" (inst -1 "l") nil nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skeep)
              (("2" (skeep 1)
                (("2" (inst -2 "l")
                  (("2" (split -2)
                    (("1" (propax) nil nil)
                     ("2" (hide 2)
                      (("2" (skeep :preds? t)
                        (("2" (inst -2 "length(l2)")
                          (("2" (assert) (("2" (inst -2 "l2") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NAT_induction formula-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (sublist?_TCC1 0
  (sublist?_TCC1-1 nil 3796804190 ("" (subtype-tcc) nil nil) nil nil
   (sublist? subtype "more_list_props.l2"
    "(list_adt[more_list_props.T].cons?)")))
 (sublist?_TCC2 0
  (sublist?_TCC2-1 nil 3796804190 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil
   (sublist? termination
    "more_list_props.sublist?(more_list_props.l1, list_adt[more_list_props.T].cdr(more_list_props.l2))"
    "nil")))
 (sublist_alt_def_TCC1 0
  (sublist_alt_def_TCC1-1 nil 3797002971
   ("" (skeep* :preds? t)
    (("" (iff)
      (("" (split 1)
        (("1" (flatten)
          (("1" (case "null?[T](l1)")
            (("1" (assert)
              (("1" (hide -2)
                (("1" (inst 1 "l2")
                  (("1" (expand "prefix?") (("1" (grind) nil nil)) nil)
                   ("2" (use "suffix_reflexive") nil nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (flatten)
                (("2" (split -1)
                  (("1" (inst 3 "l2")
                    (("1" (rewrite "suffix_reflexive") nil nil)) nil)
                   ("2" (typepred "v(l1, cdr[T](l2))")
                    (("2" (replace -1 :hide? t)
                      (("2" (skeep - :preds? t)
                        (("2" (inst 3 "l_")
                          (("2" (rewrite "suffix_supl")
                            (("2" (rewrite "suffix_supl")
                              (("2"
                                (skeep)
                                (("2"
                                  (inst 1 "cons(car(l2),L)")
                                  (("2"
                                    (expand "append" 1)
                                    (("2"
                                      (replace -1 :hide? t)
                                      (("2"
                                        (lemma "expand_list")
                                        (("2"
                                          (inst -1 "l2")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (skeep - :preds? t)
            (("2" (split +)
              (("1" (lemma "suffix_of_null")
                (("1" (inst -1 "l_")
                  (("1" (assert)
                    (("1" (replace -1 :hide? t)
                      (("1" (use "prefix_of_null")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (case "l_=l2")
                  (("1" (replace -1 :hide? t) (("1" (propax) nil nil))
                    nil)
                   ("2" (typepred "v(l1, cdr[T](l2))")
                    (("2" (replace -1 :hide? t)
                      (("2" (case "l_=l1")
                        (("1" (replace -1 :hide? t :dir rl)
                          (("1" (inst 3 "l_")
                            (("1" (lemma "suffix_of_cons")
                              (("1"
                                (inst -1 "car(l2)" "cdr(l2)" "l_")
                                (("1"
                                  (lemma "expand_list")
                                  (("1"
                                    (inst -1 "l2")
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (hide -2)
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (replace -1 :hide? t :dir rl)
                                        (("2"
                                          (split -1)
                                          (("1" (propax) nil nil)
                                           ("2" (propax) nil nil)
                                           ("3"
                                            (lemma
                                             "suffix_same_length")
                                            (("3"
                                              (inst? -1 :where -2)
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (lemma
                                                   "suffix_length")
                                                  (("3"
                                                    (inst?
                                                     -1
                                                     :where
                                                     -2)
                                                    (("3"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst 4 "l_")
                          (("2" (lemma "expand_list")
                            (("2" (inst -1 "l2")
                              (("2"
                                (split -1)
                                (("1"
                                  (lemma "suffix_of_null")
                                  (("1"
                                    (inst -1 "l_")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma "suffix_of_cons")
                                  (("2"
                                    (inst -1 "car(l2)" "cdr(l2)" "l_")
                                    (("2"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2" (assert) nil nil)
                                       ("3"
                                        (replace -1 :hide? t :dir rl)
                                        (("3"
                                          (lemma "suffix_same_length")
                                          (("3"
                                            (inst? -1 :where -2)
                                            (("3"
                                              (assert)
                                              (("3"
                                                (lemma "suffix_length")
                                                (("3"
                                                  (inst? -1 :where -2)
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefix_of_null formula-decl nil more_list_props nil)
    (suffix_of_null formula-decl nil more_list_props nil)
    (suffix_of_cons formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (suffix_length formula-decl nil more_list_props nil)
    (suffix_same_length formula-decl nil more_list_props nil)
    (l_ skolem-const-decl "{l_: list[T] | suffix?(l_, l2)}"
     more_list_props nil)
    (l_ skolem-const-decl "{l_: list[T] | suffix?(l_, cdr[T](l2))}"
     more_list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (expand_list formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (suffix_supl formula-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (suffix? def-decl "bool" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (prefix? def-decl "bool" more_list_props nil)
    (suffix_reflexive formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sublist_alt_def_ subtype
    "booleans.OR(list_adt[more_list_props.T].null?(more_list_props.l1), (booleans.AND((booleans.NOT)(list_adt[more_list_props.T].null?(more_list_props.l2)), (booleans.OR(more_list_props.prefix?(more_list_props.l1, more_list_props.l2), more_list_props.v(more_list_props.l1, list_adt[more_list_props.T].cdr(more_list_props.l2)))))))"
    "{b: booleans.bool | b = EXISTS (l_: list_adt[more_list_props.T].list | more_list_props.suffix?(l_, more_list_props.l2)): more_list_props.prefix?(more_list_props.l1, l_)}")))
 (prefix_is_sublist 0
  (prefix_is_sublist-1 nil 3796808144
   ("" (skeep)
    (("" (expand "sublist?")
      (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((sublist? def-decl "bool" more_list_props nil)
    (prefix? def-decl "bool" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (respects_order?_TCC1 0
  (respects_order?_TCC1-1 nil 3796808686 ("" (subtype-tcc) nil nil) nil
   nil
   (respects_order? subtype "more_list_props.j1"
    "below[length[T](l1)]")))
 (respects_order?_TCC2 0
  (respects_order?_TCC2-1 nil 3796808686 ("" (subtype-tcc) nil nil) nil
   nil
   (respects_order? subtype "more_list_props.j2"
    "below[length[T](l2)]")))
 (prefix_respects_order 0
  (prefix_respects_order-2 nil 3797007215
   ("" (skeep :preds? t)
    (("" (rewrite "prefix_supl")
      (("" (skeep -)
        (("" (skeep :preds? t)
          (("" (inst 1 "i1" "j1")
            (("1" (replace -4 :hide? t :dir rl)
              (("1" (rewrite "nth_append")
                (("1" (rewrite "nth_append") nil nil)) nil))
              nil)
             ("2" (replace -4 :hide? t :dir rl)
              (("2" (rewrite "length_append") (("2" (assert) nil nil))
                nil))
              nil)
             ("3" (replace -4 :hide? t :dir rl)
              (("3" (rewrite "length_append") (("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefix_supl formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (prefix? def-decl "bool" more_list_props nil)
    (length_append formula-decl nil list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nth_append formula-decl nil more_list_props nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (j1 skolem-const-decl "subrange(1 + i1, length(l1) - 1)"
     more_list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (l1 skolem-const-decl "{l1: list[T] | prefix?(l1, l2)}"
     more_list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i1 skolem-const-decl "below(length(l1))" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil)
  (prefix_respects_order-1 nil 3796992895
   ("" (skeep :preds? t)
    (("" (rewrite "prefix?_alt_def")
      (("" (skeep -)
        (("" (skeep :preds? t)
          (("" (inst 1 "i1" "j1")
            (("1" (replace -4 :hide? t :dir rl)
              (("1" (rewrite "nth_append")
                (("1" (rewrite "nth_append") nil nil)) nil))
              nil)
             ("2" (replace -4 :hide? t :dir rl)
              (("2" (rewrite "length_append") (("2" (assert) nil nil))
                nil))
              nil)
             ("3" (replace -4 :hide? t :dir rl)
              (("3" (rewrite "length_append") (("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (prefix? def-decl "bool" more_list_props nil)
    (length_append formula-decl nil list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nth_append formula-decl nil more_list_props nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (suffix_respects_order 0
  (suffix_respects_order-1 nil 3797002333
   ("" (skeep* :preds? t)
    (("" (rewrite "suffix_supl")
      (("" (skeep)
        (("" (inst 1 "length(L)+i1" "length(L)+j1")
          (("1" (replace -4 :hide? t :dir rl)
            (("1" (rewrite "nth_append")
              (("1" (rewrite "nth_append") nil nil)) nil))
            nil)
           ("2" (replace -4 :hide? t :dir rl)
            (("2" (rewrite "length_append") (("2" (assert) nil nil))
              nil))
            nil)
           ("3" (replace -4 :hide? t :dir rl)
            (("3" (rewrite "length_append") (("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((suffix_supl formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (suffix? def-decl "bool" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (i1 skolem-const-decl "below(length(l1))" more_list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (l1 skolem-const-decl "{l1: list[T] | suffix?(l1, l2)}"
     more_list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (L skolem-const-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (j1 skolem-const-decl "subrange(1 + i1, length(l1) - 1)"
     more_list_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nth_append formula-decl nil more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length_append formula-decl nil list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (sublist_respects_order 0
  (sublist_respects_order-1 nil 3796990909
   ("" (skeep :preds? t)
    (("" (rewrite "sublist_alt_def")
      (("" (skeep -1 :preds? t)
        (("" (lemma "suffix_respects_order")
          (("" (insteep -1 :but (("l1" "l_") "i1" "j1"))
            (("" (lemma "prefix_respects_order")
              (("" (insteep -1 :but (("l2" "l_") "i1" "j1"))
                (("" (skeep :preds? t)
                  (("" (insteep -4)
                    (("" (skeep :preds? t)
                      (("" (inst -9 "i2" "j2")
                        (("" (skeep :preds? t)
                          (("" (inst 1 "i2_1" "j2_1")
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sublist_alt_def recursive-judgement-axiom nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (sublist? def-decl "bool" more_list_props nil)
    (suffix_respects_order formula-decl nil more_list_props nil)
    (prefix_respects_order formula-decl nil more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (l_ skolem-const-decl "{l_: list[T] | suffix?(l_, l2)}"
     more_list_props nil)
    (l1 skolem-const-decl "{l1: list[T] | sublist?(l1, l2)}"
     more_list_props nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (prefix? def-decl "bool" more_list_props nil)
    (suffix? def-decl "bool" more_list_props nil))
   shostak))
 (sublist_nth_ordered 0
  (sublist_nth_ordered-1 nil 3796807142
   ("" (induct "l2")
    (("1" (skeep :preds? t)
      (("1" (expand "sublist?")
        (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skolem 1 ("a2" "l2"))
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (expand "sublist?" -1)
            (("2" (case "null?(l1)")
              (("1" (expand "length") (("1" (assert) nil nil)) nil)
               ("2" (split -1)
                (("1" (propax) nil nil)
                 ("2" (use "prefix_cdr")
                  (("2" (assert)
                    (("2" (use "prefix_is_sublist")
                      (("2" (assert)
                        (("2" (case "i1=length(l1)-1")
                          (("1" (assert) nil nil)
                           ("2" (postpone) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (snoc_car_sublist_append 0
  (snoc_car_sublist_append-1 nil 3796808084
   ("" (skeep)
    (("" (rewrite "prefix_is_sublist")
      (("" (hide 2)
        (("" (expand "snoc")
          (("" (rewrite "prefix_app") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((prefix_is_sublist formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (snoc const-decl "list[T]" more_list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (prefix? def-decl "bool" more_list_props nil)
    (prefix_app formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   shostak))
 (append_consume_one 0
  (append_consume_one-1 nil 3796807732
   ("" (skeep)
    (("" (expand "snoc")
      (("" (rewrite "append_assoc")
        (("" (use "expand_list")
          (("" (assert)
            (("" (expand "append" 1 2)
              (("" (expand "append" 1 2) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((snoc const-decl "list[T]" more_list_props nil)
    (expand_list formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (append_assoc formula-decl nil list_props nil))
   shostak)))

