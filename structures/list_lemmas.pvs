list_lemmas [T: TYPE]: THEORY % Welcome
% Written By:           AD, LW, JTS

%-----     %
  BEGIN
%     -----%

%-------------------------------------------
%% Define global list variables,
%  varialbe of type T,
%  and predicates on the type T
%-------------------------------------------

  l, l1, l2, l3: VAR list[T]
  x: VAR T
  P, Q: VAR PRED[T]

%-------------------------------------------
%% Importing more_list_props to have
%  many of the already established properties
%  of lists
%-------------------------------------------

  IMPORTING more_list_props
%            more_list_props[list[T]],
%            more_list_props[nat]

%-------------------------------------------
%% If a predicate is true for every entry of
%  a list, then it is true for every entry
%  of the reverse of that list
%-------------------------------------------

every_reverse: LEMMA 
    FORALL(P: PRED[T], l: list[T]):
    every(P)(l) IMPLIES every(P)(reverse(l))

%–-  Relations between length, cons, and cdr

lenght_cons : LEMMA
  cons?(l) IFF length(l) > 0

length_cdr: LEMMA 
  FORALL ( l : (cons?[T])):
    length(cdr(l)) = length(l)-1

%–- A generic find. Returns a suffix of l where the first element
%–- satisfies test or the empty list if none of the elements satisfies t
 find(test:PRED[T],l) : RECURSIVE {ll:list[T] |
 			  EXISTS (i:upto(length(l))) :
			    length(ll) = length(l)-i AND
			    (FORALL(k:below(i)): NOT test(nth(l,k))) AND
			    (cons?(ll) IMPLIES test(car(ll))) AND
			    (FORALL(k:subrange(i,length(l)-1)):
			     nth(l,k) = nth(ll,k-i))} =
  IF null?(l) THEN l
  ELSIF test(car(l)) THEN l
  ElSE find(test,cdr(l))
  ENDIF
  MEASURE l BY <<

%–- A generic position. Returns position of first element that satisfies
%—– test (returns length of list if none) 
 position(test:PRED[T],l) : RECURSIVE {n : upto(length(l)) |
			    (FORALL(k:below(n)): NOT test(nth(l,k))) AND
			    (n < length(l) IMPLIES test(nth(l,n)))} =
  IF null?(l) OR test(car(l)) THEN 0
  ElSE position(test,cdr(l))+1
  ENDIF
  MEASURE l BY <<

%-------------------------------------------
%% Define max length, measuring length of
%  largest list in list of lists
%-------------------------------------------

max_length(L: list[list[T]]): RECURSIVE
  nat =
  IF L=null 
     THEN 0
  ELSE
     max(length(car(L)), max_length(cdr(L)))
  ENDIF
  MEASURE length(L)

%--------------------------------------
%% All pairwise combining list terms
%--------------------------------------

zip(l1:list[T],l2:{ ll:list[T] | length(ll) = length(l1)}): RECURSIVE list[list[T]] =
  IF l1 = null
    THEN null 
  ELSE  
    cons((:car(l1),car(l2):), zip(cdr(l1),cdr(l2)))
  ENDIF
  MEASURE length(l1)


combo_list(l1,l2:list[T]): list[list[T]] =
  IF l1 = null
    THEN (: l2 :)
  ELSIF l2 = null
    THEN (: l1 :)
  ELSE 
    zip(l1^length(l2),l2^length(l1))
  ENDIF

%------------------------------------------
%% Helpful append lemma
%------------------------------------------

append_left_inj: LEMMA
  FORALL(l,l1,l2:list[T]): append(l1,l) = append(l2,l) IMPLIES l1 = l2

caret_swap: LEMMA
  FORALL (l:list[T], n:nat):
  l^(n+1) = append(l^n, l)
  
caret_to_append: LEMMA
  FORALL (l: list[T], m, n:nat):
  m>n IMPLIES
  l^m = append(l^n, l^(m-n))

append_carat: LEMMA
  FORALL(l1,l2:list[T], w:T, n,m:nat):
  m > n AND append(l1,(: w :)^n) = append(l2,(: w :)^m)
  IMPLIES l1 = append(l2, (: w :)^(m-n))

 append_list: LEMMA
  FORALL(l1,l2,l3,l4:list[T]):
  length(l1)=length(l3)
  AND
  append(l1,l2) = append(l3,l4)
  IMPLIES
  l1=l3

%------------------------------------------
%% Add two lists of natural numbers
%------------------------------------------

add_lists(l1,l2:list[nat]): RECURSIVE list[nat] = 
  IF l1 = null 
    THEN l2
  ELSIF l2 = null
    THEN l1
  ELSE 
    cons(car(l1) + car(l2), add_lists(cdr(l1),cdr(l2))) 
  ENDIF
  MEASURE length(l1) + length(l2)

add_lists_length: LEMMA
  FORALL(l1,l2:list[nat]):
  length(add_lists(l1,l2)) = max(length(l1),length(l2))

% @QED add_list_nth proved by lmwhite3 on Mon, 18 Apr 2022 14:35:42 GMT
add_list_nth: LEMMA
  FORALL(l1,l2:list[nat], n:nat | n < min(length(l1),length(l2))):
  nth(l1,n) + nth(l2,n) = nth(add_lists(l1,l2),n)


%------------------------------------------
%% Making a list of nats 0 to n-1
%------------------------------------------

list_length_n(n:nat): RECURSIVE list[nat] = 
  IF n=0
    THEN null
  ELSE 
    cons( 0, add_lists((: 1 :)^(n-1),
      list_length_n(n-1)))
  ENDIF
  MEASURE n

%------------------------------------------
%% Example of list_length_n
%------------------------------------------

ex_list_n: LEMMA
  list_length_n(3) = (: 0,1,2 :)

%------------------------------------------
%% Properties of list_length_n
%------------------------------------------

% @QED add_list_length proved by lmwhite3 on Mon, 18 Apr 2022 17:57:47 GMT
add_list_length: LEMMA
  FORALL(l1,l2:list[nat]):
  length(add_lists(l1,l2)) = max(length(l1),length(l2))

% @QED list_length_n proved by lmwhite3 on Mon, 18 Apr 2022 17:57:00 GMT
list_length_n: LEMMA
  FORALL(n:nat): n = length(list_length_n(n))

% @QED list_n_nth proved by lmwhite3 on Mon, 18 Apr 2022 18:20:40 GMT
list_n_nth: LEMMA   
FORALL(n:nat, i:below(n)): nth(list_length_n(n),i)=i

%---------------------------------------------
% Properties of filtering
%---------------------------------------------

every_filter: LEMMA
 FORALL(l: list[T], P:[T->bool]):
 every(P)(filter(P)(l))

every_of_filter: LEMMA
 FORALL(l: list[T], P, Q:[T->bool] ):
 every(Q)(l) IMPLIES
 every(Q)(filter(Q)(l))

filter_exists_cons: LEMMA
  FORALL (l:list[T], P:[T->bool]):
  (EXISTS (i:below(length(l))):
  P(nth(l,i))) IMPLIES
  cons?(filter(P)(l))

cons_filter_exists: LEMMA
  FORALL (l:list[T], P:[T->bool]):
  cons?(filter(P)(l)) IMPLIES
  (EXISTS (i:below(length(l))):
  P(nth(l,i)))

min_list(l:list[real] | cons?[real](l)): RECURSIVE {t:real |
  FORALL(i:below(length(l))): t <= nth(l,i) AND EXISTS(i:below(length(l))): t = nth(l,i)} =
  IF length[real](l)=1 THEN car(l)
  ELSIF car(l) <= min_list(cdr(l)) THEN car(l)
  ELSE min_list(cdr(l)) 
  ENDIF
 MEASURE length(l)

min_lemma: LEMMA
  FORALL(l1:list[real],l2:list[real] | cons?(l1) AND cons?(l2)):
    min_list(append[real](l1,l2)) = min(min_list(l1),min_list(l2))

%~ The End  ~~%
end list_lemmas
