(affine_bandb_numerical (evaluate_TCC1 0 (evaluate_TCC1-2 "" 3883623575 ("" (skeep*) (("" (lemma "length_Lbbox") (("" (inst?) nil nil)) nil)) nil) nil shostak (evaluate subtype "box.Lbbox(affine_bandb_numerical.box):: box.ProperBox" "{x: ProperBox | list_props[Interval].length(x) = list_props[Interval].length(affine_bandb_numerical.box)}")) (evaluate_TCC1-1 nil 3883590421 ("" (subtype-tcc) nil nil) ((length_Lbbox formula-decl nil box interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (evaluate subtype "box.Lbbox(affine_bandb_numerical.box):: box.ProperBox" "{x: ProperBox | list_props[Interval].length(x) = list_props[Interval].length(affine_bandb_numerical.box)}"))) (evaluate_TCC2 0 (evaluate_TCC2-2 "" 3883623605 ("" (skeep*) (("" (lemma "length_Ubbox") (("" (inst?) nil nil)) nil)) nil) nil shostak (evaluate subtype "box.Ubbox(affine_bandb_numerical.box):: box.ProperBox" "{x: ProperBox | list_props[Interval].length(x) = list_props[Interval].length(affine_bandb_numerical.box)}")) (evaluate_TCC2-1 nil 3883590421 ("" (subtype-tcc) nil nil) ((length_Ubbox formula-decl nil box interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (evaluate subtype "box.Ubbox(affine_bandb_numerical.box):: box.ProperBox" "{x: ProperBox | list_props[Interval].length(x) = list_props[Interval].length(affine_bandb_numerical.box)}"))) (evaluate_TCC3 0 (evaluate_TCC1-1 nil 3633434349 ("" (skeep*) (("" (assert) nil nil)) nil) ((Ubbox_Proper application-judgement "ProperBox" box interval_arith) (Lbbox_Proper application-judgement "ProperBox" box interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (evaluate subtype "affine_bandb_numerical.P1" "(Maybe[AffineCombination].some?)"))) (evaluate_TCC4 0 (evaluate_TCC2-1 nil 3633434349 ("" (skeep*) (("" (assert) nil nil)) nil) ((Ubbox_Proper application-judgement "ProperBox" box interval_arith) (Lbbox_Proper application-judgement "ProperBox" box interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (evaluate subtype "affine_bandb_numerical.P2" "(Maybe[AffineCombination].some?)"))) (evaluate_TCC5 0 (evaluate_TCC3-1 nil 3633434349 ("" (skeep*) (("" (assert) nil nil)) nil) ((Ubbox_Proper application-judgement "ProperBox" box interval_arith) (Lbbox_Proper application-judgement "ProperBox" box interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (evaluate subtype "affine_bandb_numerical.X" "(Maybe[AffineCombination].some?)"))) (combine_TCC1 0 (combine_TCC1-2 "" 3789918466 ("" (grind) nil nil) nil shostak (combine subtype "affine_bandb_numerical.M1" "(Maybe[[# lb_box: box.ProperBox, lb_max: reals.real, mm: interval.ProperInterval, ub_box: box.ProperBox, ub_min: reals.real #]].some?)")) (combine_TCC1-1 nil 3633434349 ("" (grind)) nil nil (combine subtype "affine_bandb_numerical.M1" "(Maybe[[# lb_box: box.ProperBox, lb_max: reals.real, mm: interval.ProperInterval, ub_box: box.ProperBox, ub_min: reals.real #]].some?)"))) (combine_TCC2 0 (combine_TCC2-2 "" 3789918467 ("" (grind) nil nil) nil shostak (combine subtype "affine_bandb_numerical.M2" "(Maybe[[# lb_box: box.ProperBox, lb_max: reals.real, mm: interval.ProperInterval, ub_box: box.ProperBox, ub_min: reals.real #]].some?)")) (combine_TCC2-1 nil 3633434349 ("" (grind)) nil nil (combine subtype "affine_bandb_numerical.M2" "(Maybe[[# lb_box: box.ProperBox, lb_max: reals.real, mm: interval.ProperInterval, ub_box: box.ProperBox, ub_min: reals.real #]].some?)"))) (combine_TCC3 0 (combine_TCC3-1 nil 3635261517 ("" (skeep*) (("" (typepred "mm
                      (val
                           [[# lb_box: ProperBox,
                               lb_max: real,
                               mm: ProperInterval,
                               ub_box: ProperBox,
                               ub_min: real #]]
                           (M1))") (("" (typepred "mm
                      (val
                           [[# lb_box: ProperBox,
                               lb_max: real,
                               mm: ProperInterval,
                               ub_box: ProperBox,
                               ub_min: real #]]
                           (M2))") (("" (grind) nil nil)) nil)) nil)) nil) ((IntervalMinMax type-eq-decl nil affine_bandb_numerical nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (ProperInterval type-eq-decl nil interval interval_arith) (ProperBox type-eq-decl nil box interval_arith) (Proper? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) ([\|\|] const-decl "Interval" interval interval_arith) (Union const-decl "Interval" interval interval_arith) (Safe2 const-decl "Interval" safe_arith interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (combine subtype "safe_arith.Safe2(interval.Union)(mm(Maybe[[# lb_box: box.ProperBox, lb_max: reals.real, mm: interval.ProperInterval, ub_box: box.ProperBox, ub_min: reals.real #]].val(affine_bandb_numerical.M1)), mm(Maybe[[# lb_box: box.ProperBox, lb_max: reals.real, mm: interval.ProperInterval, ub_box: box.ProperBox, ub_min: reals.real #]].val(affine_bandb_numerical.M2)))" "ProperInterval"))) (var_varsel_TCC1 0 (var_varsel_TCC1-2 "" 3789918470 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil) ([\|\|] const-decl "Interval" interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (var_varsel subtype "affine_bandb_numerical.lbub" "(Maybe[AffineCombination].some?)")) (var_varsel_TCC1-1 nil 3633434349 ("" (grind)) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (listn type-eq-decl nil listn structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil)) nil (var_varsel subtype "affine_bandb_numerical.lbub" "(Maybe[AffineCombination].some?)"))) (var_varsel_TCC2 0 (var_varsel_TCC2-1 nil 3883590421 ("" (subtype-tcc) nil nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (var_varsel subtype "0" "{x: uint8 | integers.even?(x)}"))) (var_varsel_TCC3 0 (var_varsel_TCC2-2 "" 3789918472 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (even? const-decl "bool" integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (var_varsel subtype "affine_bandb_numerical.lbub" "(Maybe[AffineCombination].some?)")) (var_varsel_TCC2-1 nil 3633434349 ("" (grind)) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (listn type-eq-decl nil listn structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil)) nil (var_varsel subtype "affine_bandb_numerical.lbub" "(Maybe[AffineCombination].some?)"))) (mindir_maxvar_aux_TCC1 0 (mindir_maxvar_aux_TCC1-2 "" 3883625581 ("" (skeep) (("" (lemma "length_Midbox") (("" (inst?) (("" (typepred "Midbox(box)") (("" (propax) nil nil)) nil)) nil)) nil)) nil) nil shostak (mindir_maxvar_aux subtype "box.Midbox(affine_bandb_numerical.box)" "{x: listn[Interval](list_props[Interval].length(affine_bandb_numerical.box)) | box.ProperBox?(x)}")) (mindir_maxvar_aux_TCC1-1 nil 3883590421 ("" (subtype-tcc) nil nil) ((length_Midbox formula-decl nil box interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (Midbox_Proper application-judgement "ProperBox" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil)) nil (mindir_maxvar_aux subtype "box.Midbox(affine_bandb_numerical.box)" "{x: listn[Interval](list_props[Interval].length(affine_bandb_numerical.box)) | box.ProperBox?(x)}"))) (mindir_maxvar_aux_TCC2 0 (mindir_maxvar_aux_TCC1-2 "" 3789918473 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (slice const-decl "real" interval interval_arith) (midpoint const-decl "real" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith) (real_plus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (mindir_maxvar_aux subtype "(number_fields.-)(list_props[Interval].length(affine_bandb_numerical.box), 1)" "upfrom(0)")) (mindir_maxvar_aux_TCC1-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (listn type-eq-decl nil listn structures) (slice const-decl "real" interval interval_arith) (midpoint const-decl "real" interval interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith)) nil (mindir_maxvar_aux subtype "(number_fields.-)(list_props[Interval].length(affine_bandb_numerical.box), 1)" "upfrom(0)"))) (mindir_maxvar_aux_TCC3 0 (mindir_maxvar_aux_TCC2-2 "" 3789918475 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (slice const-decl "real" interval interval_arith) (midpoint const-decl "real" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith) (real_plus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (mindir_maxvar_aux subtype "affine_bandb_numerical.var_varsel(affine_bandb_numerical.expr, affine_bandb_numerical.box, affine_bandb_numerical.both, affine_bandb_numerical.Mb)" "IterateBody[VarSel](0, (number_fields.-)(list_props[Interval].length(affine_bandb_numerical.box), 1))")) (mindir_maxvar_aux_TCC2-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (listn type-eq-decl nil listn structures) (slice const-decl "real" interval interval_arith) (midpoint const-decl "real" interval interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith)) nil (mindir_maxvar_aux subtype "affine_bandb_numerical.var_varsel(affine_bandb_numerical.expr, affine_bandb_numerical.box, affine_bandb_numerical.both, affine_bandb_numerical.Mb)" "IterateBody[VarSel](0, (number_fields.-)(list_props[Interval].length(affine_bandb_numerical.box), 1))"))) (max_rec_TCC1 0 (max_rec_TCC1-2 "" 3789918476 ("" (grind) nil nil) nil shostak (max_rec subtype "affine_bandb_numerical.b" "{b_1: box.Box | affine_bandb_numerical.n = (number_fields.+)(affine_bandb_numerical.i, list_props[Interval].length(b_1))}")) (max_rec_TCC1-1 nil 3633434349 ("" (grind)) nil nil (max_rec subtype "affine_bandb_numerical.b" "{b_1: box.Box | affine_bandb_numerical.n = (number_fields.+)(affine_bandb_numerical.i, list_props[Interval].length(b_1))}"))) (max_rec_TCC2 0 (max_rec_TCC2-1 nil 3633434349 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "affine_bandb_numerical.i" "below(affine_bandb_numerical.n)"))) (max_rec_TCC3 0 (max_rec_TCC3-2 "" 3789918477 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (size const-decl "real" interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (max_rec subtype "(number_fields.+)(affine_bandb_numerical.i, 1)" "subrange(1, affine_bandb_numerical.n)")) (max_rec_TCC3-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "(number_fields.+)(affine_bandb_numerical.i, 1)" "subrange(1, affine_bandb_numerical.n)"))) (max_rec_TCC4 0 (max_rec_TCC4-2 "" 3789918478 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith)) shostak (max_rec subtype "affine_bandb_numerical.b" "(list_adt[Interval].cons?)")) (max_rec_TCC4-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "affine_bandb_numerical.b" "(list_adt[Interval].cons?)"))) (max_rec_TCC5 0 (max_rec_TCC5-2 "" 3789918478 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (max_rec subtype "list_adt[Interval].cdr(affine_bandb_numerical.b)" "{b: box.Box | affine_bandb_numerical.n = (number_fields.+)((number_fields.+)(1, affine_bandb_numerical.i), list_props[Interval].length(b))}")) (max_rec_TCC5-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "list_adt[Interval].cdr(affine_bandb_numerical.b)" "{b: box.Box | affine_bandb_numerical.n = (number_fields.+)((number_fields.+)(1, affine_bandb_numerical.i), list_props[Interval].length(b))}"))) (max_rec_TCC6 0 (max_rec_TCC6-2 "" 3789918479 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith)) shostak (max_rec termination "affine_bandb_numerical.max_rec(affine_bandb_numerical.n, affine_bandb_numerical.mm, affine_bandb_numerical.i, (number_fields.+)(affine_bandb_numerical.i, 1), list_adt[Interval].cdr(affine_bandb_numerical.b))" "nil")) (max_rec_TCC6-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec termination "affine_bandb_numerical.max_rec(affine_bandb_numerical.n, affine_bandb_numerical.mm, affine_bandb_numerical.i, (number_fields.+)(affine_bandb_numerical.i, 1), list_adt[Interval].cdr(affine_bandb_numerical.b))" "nil"))) (max_rec_TCC7 0 (max_rec_TCC7-2 "" 3789918480 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (size const-decl "real" interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (max_rec subtype "(number_fields.+)(affine_bandb_numerical.i, 1)" "subrange(1, affine_bandb_numerical.n)")) (max_rec_TCC7-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "(number_fields.+)(affine_bandb_numerical.i, 1)" "subrange(1, affine_bandb_numerical.n)"))) (max_rec_TCC8 0 (max_rec_TCC8-2 "" 3789918480 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith)) shostak (max_rec subtype "affine_bandb_numerical.b" "(list_adt[Interval].cons?)")) (max_rec_TCC8-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "affine_bandb_numerical.b" "(list_adt[Interval].cons?)"))) (max_rec_TCC9 0 (max_rec_TCC9-2 "" 3789918481 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (max_rec subtype "list_adt[Interval].cdr(affine_bandb_numerical.b)" "{b: box.Box | affine_bandb_numerical.n = (number_fields.+)((number_fields.+)(1, affine_bandb_numerical.i), list_props[Interval].length(b))}")) (max_rec_TCC9-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec subtype "list_adt[Interval].cdr(affine_bandb_numerical.b)" "{b: box.Box | affine_bandb_numerical.n = (number_fields.+)((number_fields.+)(1, affine_bandb_numerical.i), list_props[Interval].length(b))}"))) (max_rec_TCC10 0 (max_rec_TCC10-2 "" 3789918482 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (size const-decl "real" interval interval_arith)) shostak (max_rec termination "affine_bandb_numerical.max_rec(affine_bandb_numerical.n, affine_bandb_numerical.m, affine_bandb_numerical.v, (number_fields.+)(affine_bandb_numerical.i, 1), list_adt[Interval].cdr(affine_bandb_numerical.b))" "nil")) (max_rec_TCC10-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (size const-decl "real" interval interval_arith)) nil (max_rec termination "affine_bandb_numerical.max_rec(affine_bandb_numerical.n, affine_bandb_numerical.m, affine_bandb_numerical.v, (number_fields.+)(affine_bandb_numerical.i, 1), list_adt[Interval].cdr(affine_bandb_numerical.b))" "nil"))) (max_rec_TCC11 0 (max_rec_TCC11-2 "" 3789918482 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (max_rec subtype "affine_bandb_numerical.b" "(list_adt[Interval].cons?)")) (max_rec_TCC11-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (max_rec subtype "affine_bandb_numerical.b" "(list_adt[Interval].cons?)"))) (max_aux_TCC1 0 (max_aux_TCC1-2 "" 3789918483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals)) shostak (max_aux subtype "list_props[Interval].length(affine_bandb_numerical.box)" "posnat")) (max_aux_TCC1-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (max_aux subtype "list_props[Interval].length(affine_bandb_numerical.box)" "posnat"))) (max_aux_TCC2 0 (max_aux_TCC2-2 "" 3789918484 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil)) shostak (max_aux subtype "affine_bandb_numerical.box" "(list_adt[Interval].cons?)")) (max_aux_TCC2-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (max_aux subtype "affine_bandb_numerical.box" "(list_adt[Interval].cons?)"))) (max_aux_TCC3 0 (max_aux_TCC3-2 "" 3789918484 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals)) shostak (max_aux subtype "0" "below(list_props[Interval].length(affine_bandb_numerical.box))")) (max_aux_TCC3-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (max_aux subtype "0" "below(list_props[Interval].length(affine_bandb_numerical.box))"))) (max_aux_TCC4 0 (max_aux_TCC4-2 "" 3789918485 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals)) shostak (max_aux subtype "1" "subrange(1, list_props[Interval].length(affine_bandb_numerical.box))")) (max_aux_TCC4-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (max_aux subtype "1" "subrange(1, list_props[Interval].length(affine_bandb_numerical.box))"))) (max_aux_TCC5 0 (max_aux_TCC5-2 nil 3633437273 ("" (skeep) (("" (case-replace "box=null") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (length def-decl "nat" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (max_aux subtype "list_adt[Interval].cdr(affine_bandb_numerical.box)" "{b: box.Box | list_props[Interval].length(affine_bandb_numerical.box) = (number_fields.+)(1, list_props[Interval].length(b))}")) (max_aux_TCC5-1 nil 3633434349 ("" (subtype-tcc) nil nil) nil shostak (max_aux subtype "list_adt[Interval].cdr(affine_bandb_numerical.box)" "{b: box.Box | list_props[Interval].length(affine_bandb_numerical.box) = (number_fields.+)(1, list_props[Interval].length(b))}"))) (altvar_TCC1 0 (altvar_TCC1-2 "" 3789918486 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) shostak (altvar subtype "list_props[Interval].length(affine_bandb_numerical.box)" "nonzero_real")) (altvar_TCC1-1 nil 3633434349 ("" (grind)) ((Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (altvar subtype "list_props[Interval].length(affine_bandb_numerical.box)" "nonzero_real"))) (altvar_TCC2 0 (altvar_TCC2-2 nil 3633437321 ("" (skeep :preds? t) (("" (lemma "mod_pos") (("" (inst?) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((mod_pos formula-decl nil reals_mod reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mod const-decl "{k | abs(k) < abs(j)}" reals_mod reals) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (DirVarStack type-eq-decl nil branch_and_bound structures) (= const-decl "[T, T -> boolean]" equalities nil) (stack type-eq-decl nil stack structures) (DirVar type-eq-decl nil branch_and_bound structures) (IntervalMinMax type-eq-decl nil affine_bandb_numerical nil) (Maybe type-decl nil Maybe structures) (ProperInterval type-eq-decl nil interval interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (box skolem-const-decl "ProperBox" affine_bandb_numerical nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (altvar subtype "reals_mod.mod(length(affine_bandb_numerical.dirvars), list_props[Interval].length(affine_bandb_numerical.box))" "nat")) (altvar_TCC2-1 nil 3633434349 ("" (subtype-tcc) nil nil) nil shostak (altvar subtype "reals_mod.mod(length(affine_bandb_numerical.dirvars), list_props[Interval].length(affine_bandb_numerical.box))" "nat"))) (interval_minmax_soundness 0 (interval_minmax_soundness-4 "" 3789918545 ("" (skeep) (("" (lemma "b_and_b_id_sound") (("" (expand "interval_minmax") (("" (inst?) (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "accomodates?") (("1" (skeep) (("1" (expand "sound?") (("1" (flatten) (("1" (name-replace "ev" "evaluate(dom, obj)" :hide? nil) (("1" (copy -1) (("1" (expand "evaluate" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (assert) nil nil) ("2" (flatten) (("2" (skoletin* -1 :old? t) (("2" (case "Inclusion?(val(ev)`lb_box, dom) AND Inclusion?(val(ev)`ub_box, dom)") (("1" (flatten) (("1" (assert) (("1" (split 4) (("1" (skeep) (("1" (case "val(ev)`mm = eval_by_intervals(val(X_1))") (("1" (replaces -1) (("1" (use "containment_interval") (("1" (assert) (("1" (hide 2) (("1" (expand "containment" 1) (("1" (expand "Eval" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (expand "Eval" -13) (("1" (assert) (("1" (replace -13 1 :hide? t) (("1" (use "EvalwCache_inclusion") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -5 -14)) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (hide (-3 -4 -5)) (("2" (case-replace "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "ub_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs,length(Lb))") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-9 -10) :dir RL) (("1" (expand "Eval" 4) (("1" (lift-if 4) (("1" (assert) (("1" (split 4) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Lb") (("1" (assert) nil nil) ("2" (replace -11 1 :hide? t) (("2" (replaces -6) (("2" (replaces -5 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 -8 -6)) (("2" (replaces -3) (("2" (replaces -2) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "ub_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs, length(Ub))") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-8 -9) :dir RL) (("1" (expand "Eval" 6) (("1" (lift-if 6) (("1" (assert) (("1" (split 6) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Ub") (("1" (assert) nil nil) ("2" (replace -10 1 :hide? t) (("2" (replace -5 -4 :hide? t) (("2" (replace -4 1 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -3 :hide? t) (("2" (replace -3 1 :dir RL :hide? t) (("2" (replace -4 1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (replaces -14) (("3" (hide (-2 -7 -8)) (("3" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "lb_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs, length(Lb))") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -10 :dir RL :hide? t) (("1" (expand "Eval" 3) (("1" (lift-if 3) (("1" (assert) (("1" (split 3) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil nil) ("2" (replace -5 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -8 1 :dir RL :hide? t) (("2" (replace -5 -6 :hide? t) (("2" (hide-all-but (1 -10 -5)) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "lb_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs,length(Ub))") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -8 :dir RL :hide? t) (("1" (expand "Eval" 5) (("1" (lift-if 5) (("1" (assert) (("1" (split 5) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 1 :hide? t :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (split 1) (("1" (case "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (assert) (("1" (lemma "Lbbox_Inclusion") (("1" (replace -5 1 :hide? t :dir RL) (("1" (replace -5 1 :hide? t) (("1" (replace -9 1 :hide? t) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "Ubbox_Inclusion") (("2" (replace -4 2 :hide? t :dir RL) (("2" (replace -4 2 :hide? t) (("2" (replace -7 2 :hide? t) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil) ("2" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (replace -4 1 :dir RL :hide? t) (("1" (replace -2 1 :hide? t) (("1" (replace -8 1) (("1" (use "Lbbox_Inclusion") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -3 2 :dir RL :hide? t) (("2" (replace -1 2 :hide? t) (("2" (replace -6 2 :hide? t) (("2" (use "Ubbox_Inclusion") (("2" (hide-all-but (-1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subdiv_presound?") (("2" (skeep) (("2" (expand "denorm") (("2" (expand "branch") (("2" (expand "subdivide") (("2" (expand "sound?") (("2" (flatten) (("2" (expand "combine" -3) (("2" (lift-if -3) (("2" (assert) (("2" (split -3) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
                                        Proper?(mm(val(ans))) AND
                                         Safe2(Union)(mm(val(ans1)), mm(val(ans))) = Union(mm(val(ans1)), mm(val(ans)))") (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (assert) (("1" (replace -3 3 :hide? t) (("1" (flatten) (("1" (expand "combine") (("1" (expand "sound_dir") (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (split 3) (("1" (skeep :preds? t) (("1" (inst - "vs") (("1" (rewrite "Union_inclusion") nil nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans1)`lb_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (assert) (("3" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (box1, box2, box: Box):
                                                                       Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
                                                                        Inclusion?(box1, box)") (("1" (case "FORALL (box1, box2, box: Box):
                                                                             Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
                                                                              Inclusion?(box1, box)") (("1" (inst -1 "val(ans1)`ub_box" "br" "dom") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (lemma "Inclusion_trans") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans)`lb_max") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -5 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -4 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -15) (("2" (inst -13 "vs") nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans)`ub_min") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -6 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -5 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -15) (("2" (inst -14 "vs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "split_Inclusion") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (split 1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "Proper_Safe2") (("1" (assert) (("1" (assert) (("1" (typepred "mm(val(ans1))") (("1" (typepred "mm(val(ans))") (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subdiv_sound?") (("3" (skeep) (("3" (expand "denorm") (("3" (expand "branch") (("3" (expand "subdivide") (("3" (expand "sound?") (("3" (flatten) (("3" (expand "combine" -3) (("3" (lift-if -3) (("3" (assert) (("3" (split -3) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
                                        Proper?(mm(val(ans2))) AND
                                         Safe2(Union)(mm(val(ans1)), mm(val(ans2))) = Union(mm(val(ans1)), mm(val(ans2)))") (("1" (assert) (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (expand "combine") (("1" (split 3) (("1" (skeep :preds? t) (("1" (lemma "split_vars_in_box") (("1" (inst? -1) (("1" (inst?) (("1" (beta) (("1" (split -1) (("1" (inst? -10) (("1" (replace -9 1 :hide? t) (("1" (rewrite "Union_inclusion") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst? -15) (("1" (replace -9 1 :hide? t) (("1" (rewrite "Union_inclusion") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`lb_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`ub_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans2)`lb_max") (("1" (assert) (("1" (inst -13 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -17 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans2)`ub_min") (("1" (assert) (("1" (inst -14 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -18 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "split_Inclusion") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (use "Proper_Safe2") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (expand "Safe2") (("1" (expand "Union") (("1" (expand "Proper?") (("1" (assert) (("1" (typepred "mm(val(ans1))") (("1" (typepred "mm(val(ans2))") (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (ProperBox? const-decl "bool" box interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (IntervalMinMax type-eq-decl nil affine_bandb_numerical nil) (Maybe type-decl nil Maybe structures) (ProperInterval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (ProperBox type-eq-decl nil box interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (b_and_b_id_sound formula-decl nil branch_and_bound structures) (Accumulator type-eq-decl nil branch_and_bound structures) (accumulate const-decl "IntervalMinMax" affine_bandb_numerical nil) (Brancher type-eq-decl nil branch_and_bound structures) (branch const-decl "[RealExpr, RealExpr]" affine_bandb_numerical nil) (Combiner type-eq-decl nil branch_and_bound structures) (combine const-decl "IntervalMinMax" affine_bandb_numerical nil) (DirVar type-eq-decl nil branch_and_bound structures) (DenormAns type-eq-decl nil branch_and_bound structures) (denorm const-decl "IntervalMinMax" affine_bandb_numerical nil) (Evaluator type-eq-decl nil branch_and_bound structures) (evaluate const-decl "IntervalMinMax" affine_bandb_numerical nil) (stack type-eq-decl nil stack structures) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound structures) (ExitPred type-eq-decl nil branch_and_bound structures) (LocalExitPred type-eq-decl nil branch_and_bound structures) (DirVarSelector type-eq-decl nil branch_and_bound structures) (SoundPred type-eq-decl nil branch_and_bound structures) (sound? const-decl "bool" affine_bandb_numerical nil) (SubdivDomain type-eq-decl nil branch_and_bound structures) (subdivide const-decl "[ProperBox, ProperBox]" affine_bandb_numerical nil) (subdiv_sound? const-decl "bool" branch_and_bound structures) (v skolem-const-decl "nat" affine_bandb_numerical nil) (dom skolem-const-decl "ProperBox" affine_bandb_numerical nil) (vs skolem-const-decl "(vars_in_box?(dom))" affine_bandb_numerical nil) (split_vars_in_box formula-decl nil interval_expr interval_arith) (ans2 skolem-const-decl "IntervalMinMax" affine_bandb_numerical nil) (ans1 skolem-const-decl "IntervalMinMax" affine_bandb_numerical nil) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (subdiv_presound? const-decl "bool" branch_and_bound structures) (Safe2 const-decl "Interval" safe_arith interval_arith) (Union const-decl "Interval" interval interval_arith) (split_Inclusion formula-decl nil interval_expr interval_arith) (split def-decl "{lrb: [Box, Box] |
   LET (lb, rb) = lrb IN
     length(lb) = length(box) AND
      length(rb) = length(box) AND
       FORALL (i: below(length(box))):
         IF i = v
           THEN nth(lb, i) = HalfLeft(nth(box, i)) AND
                 nth(rb, i) = HalfRight(nth(box, i))
         ELSE nth(lb, i) = nth(box, i) AND nth(rb, i) = nth(box, i)
         ENDIF}" interval_expr interval_arith) (HalfRight const-decl "Interval" interval interval_arith) (HalfLeft const-decl "Interval" interval interval_arith) (below type-eq-decl nil nat_types nil) (Union_inclusion formula-decl nil interval interval_arith) (Inclusion_trans formula-decl nil affine_box nil) (split_Proper judgement-tcc nil interval_expr interval_arith) (Inclusion? const-decl "bool" box interval_arith) (sound_dir const-decl "bool" branch_and_bound structures) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (ans1 skolem-const-decl "IntervalMinMax" affine_bandb_numerical nil) (ans skolem-const-decl "IntervalMinMax" affine_bandb_numerical nil) (Proper_Safe2 formula-decl nil safe_arith interval_arith) (split_Proper application-judgement "[ProperBox, ProperBox]" interval_expr interval_arith) (accomodates? const-decl "bool" branch_and_bound structures) (Lbbox_Proper application-judgement "ProperBox" box interval_arith) (Ubbox_Proper application-judgement "ProperBox" box interval_arith) (lb_aff const-decl "real" affine nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ub_aff const-decl "real" affine nil) (< const-decl "bool" reals nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Ubbox const-decl "listn[Interval](length(box))" box interval_arith) (Lbbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) (Proper? const-decl "bool" interval interval_arith) (eval_by_intervals const-decl "ProperInterval" affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (Lbbox_Inclusion formula-decl nil affine_box nil) (Ubbox_Inclusion formula-decl nil affine_box nil) (containment_interval formula-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (Env type-eq-decl nil box interval_arith) (vars_in_box? const-decl "bool" box interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (EvalwCache_inclusion formula-decl nil affine_expr_Eval nil) (containment const-decl "bool" affine nil) (Ub skolem-const-decl "{x: listn[Interval](length(dom)) | ProperBox?(x)}" affine_bandb_numerical nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (dom skolem-const-decl "ProperBox" affine_bandb_numerical nil) (Lb skolem-const-decl "{x: listn[Interval](length(dom)) | ProperBox?(x)}" affine_bandb_numerical nil) (obj skolem-const-decl "RealExpr" affine_bandb_numerical nil) (vs skolem-const-decl "(vars_in_box?(val(evaluate(dom, obj))`lb_box))" affine_bandb_numerical nil) (Proper_Add application-judgement "ProperInterval" interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (Add const-decl "Interval" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (null_ol? const-decl "bool" ordered_list structures) ([\|\|] const-decl "Interval" interval interval_arith) (|##| const-decl "bool" interval interval_arith) (int_minus_int_is_int application-judgement "int" integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (below type-eq-decl nil naturalnumbers nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (nzBaseType type-eq-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (Eval_wCache def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)}" affine_expr_Eval nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (upfrom nonempty-type-eq-decl nil integers nil) (ub_box skolem-const-decl "{x: listn[Interval](length(dom)) | ProperBox?(x)}" affine_bandb_numerical nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (restrict const-decl "R" restrict nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (eval_ac_noise const-decl "real" affine nil) (<< const-decl "bool" interval interval_arith) (/= const-decl "boolean" notequal nil) (vs skolem-const-decl "(vars_in_box?(val(evaluate(dom, obj))`ub_box))" affine_bandb_numerical nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (ev skolem-const-decl "IntervalMinMax" affine_bandb_numerical nil) (map adt-def-decl "list[T1]" list_adt_map nil) (Inclusion? const-decl "bool" affine_box nil) (interval_minmax const-decl "Output" affine_bandb_numerical nil)) shostak) (interval_minmax_soundness-3 nil 3635260654 ("" (skeep) (("" (lemma "b_and_b_id_sound") (("" (expand "interval_minmax") (("" (inst?) (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "accomodates?") (("1" (skeep) (("1" (expand "sound?") (("1" (flatten) (("1" (name-replace "ev" "evaluate(dom, obj)" :hide? nil) (("1" (copy -1) (("1" (expand "evaluate" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (assert) nil nil) ("2" (flatten) (("2" (skoletin* -1 :old? t) (("1" (case "Inclusion?(val(ev)`lb_box, dom) AND Inclusion?(val(ev)`ub_box, dom)") (("1" (flatten) (("1" (assert) (("1" (split 4) (("1" (skeep) (("1" (case "val(ev)`mm = eval_by_intervals(val(X_1))") (("1" (replaces -1) (("1" (use "containment_interval") (("1" (assert) (("1" (hide 2) (("1" (expand "containment" 1) (("1" (expand "Eval" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (expand "Eval" -13) (("1" (assert) (("1" (replace -13 1 :hide? t) (("1" (use "EvalwCache_inclusion") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -5 -14)) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (hide (-3 -4 -5)) (("2" (case-replace "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "ub_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs,length(Lb))") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-9 -10) :dir RL) (("1" (expand "Eval" 4) (("1" (lift-if 4) (("1" (assert) (("1" (split 4) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Lb") (("1" (assert) nil nil) ("2" (replace -11 1 :hide? t) (("2" (replaces -6) (("2" (replaces -5 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 -8 -6)) (("2" (replaces -3) (("2" (replaces -2) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "ub_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs, length(Ub))") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-8 -9) :dir RL) (("1" (expand "Eval" 6) (("1" (lift-if 6) (("1" (assert) (("1" (split 6) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Ub") (("1" (assert) nil nil) ("2" (replace -10 1 :hide? t) (("2" (replace -5 -4 :hide? t) (("2" (replace -4 1 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -3 :hide? t) (("2" (replace -3 1 :dir RL :hide? t) (("2" (replace -4 1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (replaces -14) (("3" (hide (-2 -7 -8)) (("3" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "lb_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs, length(Lb))") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -10 :dir RL :hide? t) (("1" (expand "Eval" 3) (("1" (lift-if 3) (("1" (assert) (("1" (split 3) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil nil) ("2" (replace -5 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -8 1 :dir RL :hide? t) (("2" (replace -5 -6 :hide? t) (("2" (hide-all-but (1 -10 -5)) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "lb_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs,length(Ub))") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -8 :dir RL :hide? t) (("1" (expand "Eval" 5) (("1" (lift-if 5) (("1" (assert) (("1" (split 5) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 1 :hide? t :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (split 1) (("1" (case "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (assert) (("1" (lemma "Lbbox_Inclusion") (("1" (replace -5 1 :hide? t :dir RL) (("1" (replace -5 1 :hide? t) (("1" (replace -9 1 :hide? t) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "Ubbox_Inclusion") (("2" (replace -4 2 :hide? t :dir RL) (("2" (replace -4 2 :hide? t) (("2" (replace -7 2 :hide? t) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil) ("2" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (replace -4 1 :dir RL :hide? t) (("1" (replace -2 1 :hide? t) (("1" (replace -8 1) (("1" (use "Lbbox_Inclusion") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -3 2 :dir RL :hide? t) (("2" (replace -1 2 :hide? t) (("2" (replace -6 2 :hide? t) (("2" (use "Ubbox_Inclusion") (("2" (hide-all-but (-1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (propax) nil nil)) nil) ("2" (hide 5) (("2" (replaces -2 :dir RL) (("2" (expand "evaluate" 1) (("2" (assert) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subdiv_presound?") (("2" (skeep) (("2" (expand "denorm") (("2" (expand "branch") (("2" (expand "subdivide") (("2" (expand "sound?") (("2" (flatten) (("2" (expand "combine" -3) (("2" (lift-if -3) (("2" (assert) (("2" (split -3) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
                                        Proper?(mm(val(ans))) AND
                                         Safe2(Union)(mm(val(ans1)), mm(val(ans))) = Union(mm(val(ans1)), mm(val(ans)))") (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (assert) (("1" (replace -3 3 :hide? t) (("1" (flatten) (("1" (expand "combine") (("1" (expand "sound_dir") (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (split 3) (("1" (skeep :preds? t) (("1" (inst - "vs") (("1" (rewrite "Union_inclusion") nil nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans1)`lb_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (assert) (("3" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (box1, box2, box: Box):
                                                                       Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
                                                                        Inclusion?(box1, box)") (("1" (case "FORALL (box1, box2, box: Box):
                                                                             Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
                                                                              Inclusion?(box1, box)") (("1" (inst -1 "val(ans1)`ub_box" "br" "dom") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (lemma "Inclusion_trans") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans)`lb_max") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -5 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -4 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -15) (("2" (inst -13 "vs") nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans)`ub_min") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -6 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -5 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -15) (("2" (inst -14 "vs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "split_Inclusion") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "dom") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "dom") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "Proper_Safe2") (("1" (assert) (("1" (assert) (("1" (typepred "mm(val(ans1))") (("1" (typepred "mm(val(ans))") (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subdiv_sound?") (("3" (skeep) (("3" (expand "denorm") (("3" (expand "branch") (("3" (expand "subdivide") (("3" (expand "sound?") (("3" (flatten) (("3" (expand "combine" -3) (("3" (lift-if -3) (("3" (assert) (("3" (split -3) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
                                        Proper?(mm(val(ans2))) AND
                                         Safe2(Union)(mm(val(ans1)), mm(val(ans2))) = Union(mm(val(ans1)), mm(val(ans2)))") (("1" (assert) (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (expand "combine") (("1" (split 3) (("1" (skeep :preds? t) (("1" (lemma "split_vars_in_box") (("1" (inst? -1) (("1" (inst?) (("1" (beta) (("1" (split -1) (("1" (inst? -10) (("1" (replace -9 1 :hide? t) (("1" (rewrite "Union_inclusion") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst? -15) (("1" (replace -9 1 :hide? t) (("1" (rewrite "Union_inclusion") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`lb_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`ub_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans2)`lb_max") (("1" (assert) (("1" (inst -13 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -17 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans2)`ub_min") (("1" (assert) (("1" (inst -14 "vs") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -18 "vs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "split_Inclusion") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (typepred "dom") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "dom") (("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (use "Proper_Safe2") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (expand "Safe2") (("1" (expand "Union") (("1" (expand "Proper?") (("1" (assert) (("1" (typepred "mm(val(ans1))") (("1" (typepred "mm(val(ans2))") (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ProperBox? const-decl "bool" box interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (Maybe type-decl nil Maybe structures) (ProperInterval type-eq-decl nil interval interval_arith) (ProperBox type-eq-decl nil box interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (b_and_b_id_sound formula-decl nil branch_and_bound structures) (Accumulator type-eq-decl nil branch_and_bound structures) (Brancher type-eq-decl nil branch_and_bound structures) (Combiner type-eq-decl nil branch_and_bound structures) (DirVar type-eq-decl nil branch_and_bound structures) (DenormAns type-eq-decl nil branch_and_bound structures) (Evaluator type-eq-decl nil branch_and_bound structures) (DirVarStack type-eq-decl nil branch_and_bound structures) (ExitPred type-eq-decl nil branch_and_bound structures) (LocalExitPred type-eq-decl nil branch_and_bound structures) (DirVarSelector type-eq-decl nil branch_and_bound structures) (SoundPred type-eq-decl nil branch_and_bound structures) (SubdivDomain type-eq-decl nil branch_and_bound structures) (subdiv_sound? const-decl "bool" branch_and_bound structures) (split_vars_in_box formula-decl nil interval_expr interval_arith) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (subdiv_presound? const-decl "bool" branch_and_bound structures) (Safe2 const-decl "Interval" safe_arith interval_arith) (Union const-decl "Interval" interval interval_arith) (split_Inclusion formula-decl nil interval_expr interval_arith) (split def-decl "{lrb: [Box, Box] |
   LET (lb, rb) = lrb IN
     length(lb) = length(box) AND
      length(rb) = length(box) AND
       FORALL (i: below(length(box))):
         IF i = v
           THEN nth(lb, i) = HalfLeft(nth(box, i)) AND
                 nth(rb, i) = HalfRight(nth(box, i))
         ELSE nth(lb, i) = nth(box, i) AND nth(rb, i) = nth(box, i)
         ENDIF}" interval_expr interval_arith) (HalfRight const-decl "Interval" interval interval_arith) (HalfLeft const-decl "Interval" interval interval_arith) (Union_inclusion formula-decl nil interval interval_arith) (Inclusion_trans formula-decl nil affine_box nil) (split_Proper judgement-tcc nil interval_expr interval_arith) (Inclusion? const-decl "bool" box interval_arith) (sound_dir const-decl "bool" branch_and_bound structures) (Proper_Safe2 formula-decl nil safe_arith interval_arith) (split_Proper application-judgement "[ProperBox, ProperBox]" interval_expr interval_arith) (accomodates? const-decl "bool" branch_and_bound structures) (Lbbox_Proper application-judgement "ProperBox" box interval_arith) (Ubbox_Proper application-judgement "ProperBox" box interval_arith) (lb_aff const-decl "real" affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ub_aff const-decl "real" affine nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Ubbox const-decl "listn[Interval](length(box))" box interval_arith) (Lbbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Proper? const-decl "bool" interval interval_arith) (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) (eval_by_intervals const-decl "ProperInterval" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (Lbbox_Inclusion formula-decl nil affine_box nil) (Ubbox_Inclusion formula-decl nil affine_box nil) (containment_interval formula-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (Env type-eq-decl nil box interval_arith) (vars_in_box? const-decl "bool" box interval_arith) (EvalwCache_inclusion formula-decl nil affine_expr_Eval nil) (containment const-decl "bool" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (Proper_Add application-judgement "ProperInterval" interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (Add const-decl "Interval" interval interval_arith) (null_ol? const-decl "bool" ordered_list structures) (|##| const-decl "bool" interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (Eval_wCache def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)}" affine_expr_Eval nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (<< const-decl "bool" interval interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (Inclusion? const-decl "bool" affine_box nil)) nil) (interval_minmax_soundness-2 nil 3635260527 ("" (skeep) (("" (lemma "b_and_b_id_sound") (("" (expand "interval_minmax") (("" (inst?) (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "accomodates?") (("1" (skeep) (("1" (expand "sound?") (("1" (flatten) (("1" (name-replace "ev" "evaluate(dom, obj)" :hide? nil) (("1" (copy -1) (("1" (expand "evaluate" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (assert) nil) ("2" (flatten) (("2" (skoletin* -1 :old? t) (("1" (case "Inclusion?(val(ev)`lb_box, dom) AND Inclusion?(val(ev)`ub_box, dom)") (("1" (flatten) (("1" (assert) (("1" (split 4) (("1" (skeep) (("1" (case "val(ev)`mm = eval_by_intervals(val(X_1))") (("1" (replaces -1) (("1" (use "containment_interval") (("1" (assert) (("1" (hide 2) (("1" (expand "containment" 1) (("1" (expand "Eval" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (expand "Eval" -13) (("1" (assert) (("1" (replace -13 1 :hide? t) (("1" (use "EvalwCache_inclusion") (("1" (assert) nil))))))))) ("2" (propax) nil))))))))))))))))))) ("2" (hide-all-but (1 -5 -14)) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality) nil))))))))) ("2" (skeep :preds? t) (("2" (hide (-3 -4 -5)) (("2" (case-replace "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "ub_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-9 -10) :dir RL) (("1" (expand "Eval" 4) (("1" (lift-if 4) (("1" (assert) (("1" (split 4) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Lb") (("1" (assert) nil) ("2" (replace -11 1 :hide? t) (("2" (replaces -6) (("2" (replaces -5 :dir RL) (("2" (grind) nil))))))))))))))))) ("2" (propax) nil))))))))))))))))))))))))) ("2" (hide-all-but (-4 1 -8 -6)) (("2" (replaces -3) (("2" (replaces -2) (("2" (replaces -1 :dir RL) (("2" (grind) nil))))))))))) ("2" (assert) (("2" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "ub_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-8 -9) :dir RL) (("1" (expand "Eval" 6) (("1" (lift-if 6) (("1" (assert) (("1" (split 6) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Ub") (("1" (assert) nil) ("2" (replace -10 1 :hide? t) (("2" (replace -5 -4 :hide? t) (("2" (replace -4 1 :dir RL :hide? t) (("2" (grind) nil))))))))))))))))) ("2" (propax) nil))))))))))))))))))))))))) ("2" (replace -5 -3 :hide? t) (("2" (replace -3 1 :dir RL :hide? t) (("2" (replace -4 1 :hide? t) (("2" (assert) nil))))))))))))))))) ("3" (skeep :preds? t) (("3" (replaces -14) (("3" (hide (-2 -7 -8)) (("3" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "lb_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -10 :dir RL :hide? t) (("1" (expand "Eval" 3) (("1" (lift-if 3) (("1" (assert) (("1" (split 3) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil) ("2" (replace -5 :dir RL :hide? t) (("2" (grind) nil))))))))))) ("2" (propax) nil))))))))))))))))))))))))))) ("2" (replace -8 1 :dir RL :hide? t) (("2" (replace -5 -6 :hide? t) (("2" (hide-all-but (1 -10 -5)) (("2" (replaces -1 :dir RL) (("2" (grind) nil))))))))))))) ("2" (assert) (("2" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "lb_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -8 :dir RL :hide? t) (("1" (expand "Eval" 5) (("1" (lift-if 5) (("1" (assert) (("1" (split 5) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil) ("2" (hide 2) (("2" (grind) nil))))))))))) ("2" (propax) nil))))))))))))))))))))))))))) ("2" (replace -5 1 :hide? t :dir RL) (("2" (grind) nil))))))))))))))))))))) ("2" (hide 5) (("2" (split 1) (("1" (case "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (assert) (("1" (lemma "Lbbox_Inclusion") (("1" (replace -5 1 :hide? t :dir RL) (("1" (replace -5 1 :hide? t) (("1" (replace -9 1 :hide? t) (("1" (inst?) (("1" (grind) nil))))))))))))) ("2" (assert) (("2" (lemma "Ubbox_Inclusion") (("2" (replace -4 2 :hide? t :dir RL) (("2" (replace -4 2 :hide? t) (("2" (replace -7 2 :hide? t) (("2" (inst?) (("2" (grind) nil))))))))))))) ("3" (assert) nil) ("4" (assert) nil))) ("2" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (replace -4 1 :dir RL :hide? t) (("1" (replace -2 1 :hide? t) (("1" (replace -8 1) (("1" (use "Lbbox_Inclusion") (("1" (grind) nil))))))))))) ("2" (assert) (("2" (replace -3 2 :dir RL :hide? t) (("2" (replace -1 2 :hide? t) (("2" (replace -6 2 :hide? t) (("2" (use "Ubbox_Inclusion") (("2" (hide-all-but (-1 2)) (("2" (grind) nil))))))))))))) ("3" (assert) nil) ("4" (assert) nil))))))) ("3" (grind) nil) ("4" (propax) nil))) ("2" (hide 5) (("2" (replaces -2 :dir RL) (("2" (expand "evaluate" 1) (("2" (assert) (("2" (apply-extensionality) nil))))))))))))))))))))))))))))))) ("2" (expand "subdiv_presound?") (("2" (skeep) (("2" (expand "denorm") (("2" (expand "branch") (("2" (expand "subdivide") (("2" (expand "sound?") (("2" (flatten) (("2" (expand "combine" -3) (("2" (lift-if -3) (("2" (assert) (("2" (split -3) (("1" (propax) nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
                  Proper?(mm(val(ans))) AND
                   Safe2(Union)(mm(val(ans1)), mm(val(ans))) = Union(mm(val(ans1)), mm(val(ans)))") (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (assert) (("1" (replace -3 3 :hide? t) (("1" (flatten) (("1" (expand "combine") (("1" (expand "sound_dir") (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (split 3) (("1" (skeep :preds? t) (("1" (inst - "vs") (("1" (rewrite "Union_inclusion") nil))))) ("2" (lift-if) (("2" (assert) (("2" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil))))))) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans1)`lb_box" "br" "dom") (("2" (assert) nil))))))))))) ("2" (propax) nil))))))) ("3" (lift-if) (("3" (assert) (("3" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil))))))) ("2" (flatten) (("2" (case "FORALL (box1, box2, box: Box):
                             Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
                              Inclusion?(box1, box)") (("1" (case "FORALL (box1, box2, box: Box):
                               Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
                                Inclusion?(box1, box)") (("1" (inst -1 "val(ans1)`ub_box" "br" "dom") (("1" (assert) nil))) ("2" (propax) nil))) ("2" (lemma "Inclusion_trans") (("2" (propax) nil))))))))))) ("2" (propax) nil))))))) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans)`lb_max") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -5 "vs") nil))) ("2" (flatten) (("2" (inst -4 "vs") nil))))))) ("2" (assert) (("2" (hide -15) (("2" (inst -13 "vs") nil))))))))))) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans)`ub_min") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -6 "vs") nil))) ("2" (flatten) (("2" (inst -5 "vs") nil))))))) ("2" (assert) (("2" (hide -15) (("2" (inst -14 "vs") nil))))))))))))))))))))))))))) ("2" (comment "box.split_Inclusion") (("2" (";; box.split_Inclusion" postpone) nil))))))))))))))))))) ("2" (comment "use interval.Proper_Safe2") (("2" (";; use interval.Proper_Safe2" postpone) nil))) ("3" (grind) nil) ("4" (grind) nil) ("5" (grind) nil) ("6" (grind) nil))))))))))))))))))))))))))) ("3" (expand "subdiv_sound?") (("3" (skeep) (("3" (expand "denorm") (("3" (expand "branch") (("3" (expand "subdivide") (("3" (expand "sound?") (("3" (flatten) (("3" (expand "combine" -3) (("3" (lift-if -3) (("3" (assert) (("3" (split -3) (("1" (propax) nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
                  Proper?(mm(val(ans2))) AND
                   Safe2(Union)(mm(val(ans1)), mm(val(ans2))) = Union(mm(val(ans1)), mm(val(ans2)))") (("1" (assert) (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (replace -3 3 :hide? t) (("1" (case "FORALL (pox : ProperBox,v: nat):
                   LET (bl,br) = split(v,pox) IN
                   Inclusion?(bl,pox) AND Inclusion?(br,pox)") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (expand "combine") (("1" (split 3) (("1" (skeep :preds? t) (("1" (lemma "split_vars_in_box") (("1" (inst? -1) (("1" (inst?) (("1" (beta) (("1" (split -1) (("1" (inst? -11) (("1" (rewrite "Union_inclusion") nil) ("2" (assert) nil))) ("2" (inst? -16) (("1" (rewrite "Union_inclusion") nil) ("2" (assert) nil))))))))))))))) ("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil))))))) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`lb_box" "br" "dom") (("2" (assert) nil))))))))))) ("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil))))))) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`ub_box" "br" "dom") (("2" (assert) nil))))))))))) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans2)`lb_max") (("1" (assert) (("1" (inst -14 "vs") nil))) ("2" (assert) (("2" (inst -18 "vs") nil))))))))) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans2)`ub_min") (("1" (assert) (("1" (inst -15 "vs") nil))) ("2" (assert) (("2" (inst -19 "vs") nil))))))))))))))))))))))))))) ("2" (comment "box.split_Inclusion") (("2" (";; box.split_Inclusion" postpone) nil))))))))))))) ("2" (comment "use interval.Proper_Safe2") (("2" (";; use interval.Proper_Safe2" postpone) nil))) ("3" (grind) nil) ("4" (grind) nil) ("5" (grind) nil) ("6" (grind) nil)))))))))))))))))))))))))))))))))))))))) nil) nil nil) (interval_minmax_soundness-1 nil 3635179980 ("" (skeep) (("" (lemma "b_and_b_id_sound") (("" (expand "interval_minmax") (("" (inst?) (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "accomodates?") (("1" (skeep) (("1" (expand "sound?") (("1" (flatten) (("1" (name-replace "ev" "evaluate(dom, obj)" :hide? nil) (("1" (copy -1) (("1" (expand "evaluate" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (assert) nil nil) ("2" (flatten) (("2" (skoletin* -1 :old? t) (("1" (case "Inclusion?(val(ev)`lb_box, dom) AND Inclusion?(val(ev)`ub_box, dom)") (("1" (flatten) (("1" (assert) (("1" (split 4) (("1" (skeep) (("1" (case "val(ev)`mm = eval_by_intervals(val(X_1))") (("1" (replaces -1) (("1" (use "containment_interval") (("1" (assert) (("1" (hide 2) (("1" (expand "containment" 1) (("1" (expand "Eval" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (expand "Eval" -13) (("1" (assert) (("1" (replace -13 1 :hide? t) (("1" (use "EvalwCache_inclusion") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -5 -14)) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (hide (-3 -4 -5)) (("2" (case-replace "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "ub_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-9 -10) :dir RL) (("1" (expand "Eval" 4) (("1" (lift-if 4) (("1" (assert) (("1" (split 4) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Lb") (("1" (assert) nil nil) ("2" (replace -11 1 :hide? t) (("2" (replaces -6) (("2" (replaces -5 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 -8 -6)) (("2" (replaces -3) (("2" (replaces -2) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "val(ev)`lb_max = ub_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "ub_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (expand "containment" 1) (("1" (replaces (-8 -9) :dir RL) (("1" (expand "Eval" 6) (("1" (lift-if 6) (("1" (assert) (("1" (split 6) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil nil) ("2" (case "val(evaluate(dom, obj))`lb_box = Ub") (("1" (assert) nil nil) ("2" (replace -10 1 :hide? t) (("2" (replace -5 -4 :hide? t) (("2" (replace -4 1 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -3 :hide? t) (("2" (replace -3 1 :dir RL :hide? t) (("2" (replace -4 1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (replaces -14) (("3" (hide (-2 -7 -8)) (("3" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Lb)))") (("1" (replace -1 1 :hide? t) (("1" (expand "lb_aff" 1) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Lb))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -10 :dir RL :hide? t) (("1" (expand "Eval" 3) (("1" (lift-if 3) (("1" (assert) (("1" (split 3) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Lb" "vs" "obj") (("1" (assert) nil nil) ("2" (replace -5 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -8 1 :dir RL :hide? t) (("2" (replace -5 -6 :hide? t) (("2" (hide-all-but (1 -10 -5)) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "val(ev)`ub_min = lb_aff(val(Eval(obj, Ub)))") (("1" (replace -1 2 :hide? t) (("1" (expand "lb_aff" 2) (("1" (lemma "containment_interval") (("1" (inst -1 "val(Eval(obj, Ub))" "eval_ACExpr_Env(obj, vs)") (("1" (expand "##") (("1" (assert) (("1" (hide 2) (("1" (expand "containment") (("1" (replace -8 :dir RL :hide? t) (("1" (expand "Eval" 5) (("1" (lift-if 5) (("1" (assert) (("1" (split 5) (("1" (expand "Eval" 1) (("1" (assert) (("1" (lemma "EvalwCache_inclusion") (("1" (inst -1 "Ub" "vs" "obj") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 1 :hide? t :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (split 1) (("1" (case "ub_aff(val(P1)) < ub_aff(val(P2))") (("1" (assert) (("1" (lemma "Lbbox_Inclusion") (("1" (replace -5 1 :hide? t :dir RL) (("1" (replace -5 1 :hide? t) (("1" (replace -9 1 :hide? t) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "Ubbox_Inclusion") (("2" (replace -4 2 :hide? t :dir RL) (("2" (replace -4 2 :hide? t) (("2" (replace -7 2 :hide? t) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil) ("2" (case "lb_aff(val(P1)) > lb_aff(val(P2))") (("1" (assert) (("1" (replace -4 1 :dir RL :hide? t) (("1" (replace -2 1 :hide? t) (("1" (replace -8 1) (("1" (use "Lbbox_Inclusion") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -3 2 :dir RL :hide? t) (("2" (replace -1 2 :hide? t) (("2" (replace -6 2 :hide? t) (("2" (use "Ubbox_Inclusion") (("2" (hide-all-but (-1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (propax) nil nil)) nil) ("2" (hide 5) (("2" (replaces -2 :dir RL) (("2" (expand "evaluate" 1) (("2" (assert) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subdiv_presound?") (("2" (skeep) (("2" (expand "denorm") (("2" (expand "branch") (("2" (expand "subdivide") (("2" (expand "sound?") (("2" (flatten) (("2" (expand "combine" -3) (("2" (lift-if -3) (("2" (assert) (("2" (split -3) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
       Proper?(mm(val(ans))) AND
        Safe2(Union)(mm(val(ans1)), mm(val(ans))) = Union(mm(val(ans1)), mm(val(ans)))") (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (assert) (("1" (replace -3 3 :hide? t) (("1" (flatten) (("1" (expand "combine") (("1" (expand "sound_dir") (("1" (case "FORALL (pox : ProperBox,v: nat):
      LET (bl,br) = split(v,pox) IN
      Inclusion?(bl,pox) AND Inclusion?(br,pox)") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (split 3) (("1" (skeep :preds? t) (("1" (inst - "vs") (("1" (rewrite "Union_inclusion") nil nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans1)`lb_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (assert) (("3" (split 1) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (box1, box2, box: Box):
        Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
         Inclusion?(box1, box)") (("1" (case "FORALL (box1, box2, box: Box):
        Inclusion?(box1, box2) AND Inclusion?(box2, box) IMPLIES
         Inclusion?(box1, box)") (("1" (inst -1 "val(ans1)`ub_box" "br" "dom") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (lemma "Inclusion_trans") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans)`lb_max") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -5 "vs") nil nil)) nil) ("2" (flatten) (("2" (inst -4 "vs") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -15) (("2" (inst -13 "vs") nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans)`ub_min") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst -6 "vs") nil nil)) nil) ("2" (flatten) (("2" (inst -5 "vs") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -15) (("2" (inst -14 "vs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (comment "box.split_Inclusion") (("2" (postpone) nil ";;; box.split_Inclusion")) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (comment "use interval.Proper_Safe2") (("2" (postpone) nil ";;; use interval.Proper_Safe2")) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subdiv_sound?") (("3" (skeep) (("3" (expand "denorm") (("3" (expand "branch") (("3" (expand "subdivide") (("3" (expand "sound?") (("3" (flatten) (("3" (expand "combine" -3) (("3" (lift-if -3) (("3" (assert) (("3" (split -3) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "Proper?(mm(val(ans1))) AND
       Proper?(mm(val(ans2))) AND
        Safe2(Union)(mm(val(ans1)), mm(val(ans2))) = Union(mm(val(ans1)), mm(val(ans2)))") (("1" (assert) (("1" (flatten) (("1" (expand "combine" 3 1) (("1" (replace -3 3 :hide? t) (("1" (case "FORALL (pox : ProperBox,v: nat):
      LET (bl,br) = split(v,pox) IN
      Inclusion?(bl,pox) AND Inclusion?(br,pox)") (("1" (inst? -1) (("1" (skoletin* -1 :old? t) (("1" (lemma "split_Proper") (("1" (inst? -1) (("1" (flatten) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (expand "combine") (("1" (split 3) (("1" (skeep :preds? t) (("1" (lemma "split_vars_in_box") (("1" (inst? -1) (("1" (inst?) (("1" (beta) (("1" (split -1) (("1" (inst? -11) (("1" (rewrite "Union_inclusion") nil nil) ("2" (assert) nil nil)) nil) ("2" (inst? -16) (("1" (rewrite "Union_inclusion") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`lb_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`lb_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (lemma "Inclusion_trans") (("1" (inst -1 "val(ans1)`ub_box" "bl" "dom") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "Inclusion_trans") (("2" (inst -1 "val(ans2)`ub_box" "br" "dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (expand "combine") (("4" (case "val(ans1)`lb_max < val(ans2)`lb_max") (("1" (assert) (("1" (inst -14 "vs") nil nil)) nil) ("2" (assert) (("2" (inst -18 "vs") nil nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (expand "combine") (("5" (case "val(ans1)`ub_min > val(ans2)`ub_min") (("1" (assert) (("1" (inst -15 "vs") nil nil)) nil) ("2" (assert) (("2" (inst -19 "vs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (comment "box.split_Inclusion") (("2" (postpone) nil ";;; box.split_Inclusion")) nil)) nil)) nil)) nil)) nil)) nil) ("2" (comment "use interval.Proper_Safe2") (("2" (postpone) nil ";;; use interval.Proper_Safe2")) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (numerical_soundness 0 (numerical_soundness-1 nil 3635261518 ("" (skeep) (("" (expand "numerical") (("" (rewrite "interval_minmax_soundness") nil nil)) nil)) nil) ((numerical const-decl "Output" affine_bandb_numerical nil) (DirVarSelector type-eq-decl nil branch_and_bound structures) (prune_mm const-decl "bool" affine_bandb_numerical nil) (le_mm const-decl "bool" affine_bandb_numerical nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (LocalExitPred type-eq-decl nil branch_and_bound structures) (ge_mm const-decl "bool" affine_bandb_numerical nil) (ExitPred type-eq-decl nil branch_and_bound structures) (DirVarStack type-eq-decl nil branch_and_bound structures) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (stack type-eq-decl nil stack structures) (DirVar type-eq-decl nil branch_and_bound structures) (IntervalMinMax type-eq-decl nil affine_bandb_numerical nil) (Maybe type-decl nil Maybe structures) (ProperInterval type-eq-decl nil interval interval_arith) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ProperBox type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (interval_minmax_soundness formula-decl nil affine_bandb_numerical nil)) shostak)))
