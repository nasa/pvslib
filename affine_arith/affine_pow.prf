(affine_pow (power_Epsilon_is_Epsilon_TCC1 0 (power_Epsilon_is_Epsilon_TCC1-1 nil 3631536291 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (power_Epsilon_is_Epsilon subtype "affine_pow.n" "{i: integers.int | booleans.OR(affine_pow.e /= 0, reals.>=(i, 0))}"))) (power_Epsilon_is_Epsilon 0 (power_Epsilon_is_Epsilon-2 nil 3631536340 ("" (skeep :preds? t) (("" (expand "^") (("" (case "n=0") (("1" (expand "expt") (("1" (assert) nil nil)) nil) ("2" (case "e=0") (("1" (replaces -1) (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil) ("2" (case "e=1") (("1" (replaces -1) (("1" (use "expt_1n_aux") (("1" (assert) nil nil)) nil)) nil) ("2" (case "e>0") (("1" (use "expt_lt1_bound1") (("1" (assert) (("1" (lemma "nnreal_exp") (("1" (inst -1 "e" "n") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (name "ebar" "-e") (("2" (case "e = (-1)*ebar") (("1" (replaces -1) (("1" (use "expt_of_mult") (("1" (replaces -1) (("1" (case "even?(n)") (("1" (use "even_m1_pow") (("1" (assert) (("1" (expand "^") (("1" (replaces -1) (("1" (use "one_times") (("1" (replaces -1) (("1" (case "ebar = 1") (("1" (replaces -1) (("1" (use "expt_1n_aux") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ebar > 0") (("1" (use "expt_lt1_bound1") (("1" (assert) (("1" (lemma "nnreal_exp") (("1" (inst -1 "ebar" "n") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "not_even_m1_pow") (("2" (assert) (("2" (expand "^") (("2" (replaces -1) (("2" (split 6) (("1" (lemma "both_sides_times_neg_le2") (("1" (inst -1 "-1" "1" "expt(ebar, n)") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (assert) nil nil) ("2" (case "ebar = 1") (("1" (replaces -1) (("1" (use "expt_1n_aux") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ebar > 0") (("1" (use "expt_lt1_bound1") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "both_sides_times_neg_le2") (("2" (inst -1 "-1" "expt(ebar, n)" "1") (("2" (flatten) (("2" (hide -1) (("2" (split -1) (("1" (assert) nil nil) ("2" (case "ebar = 1") (("1" (replaces -1) (("1" (use "expt_1n_aux") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ebar > 0") (("1" (lemma "nnreal_exp") (("1" (inst -1 "ebar" "n") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nnreal type-eq-decl nil real_types nil) (nnreal_exp judgement-tcc nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (e skolem-const-decl "Epsilon" affine_pow nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (expt_lt1_bound1 formula-decl nil exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_of_mult formula-decl nil exponentiation nil) (even? const-decl "bool" integers nil) (ebar skolem-const-decl "real" affine_pow nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (one_times formula-decl nil extra_tegies nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (even_m1_pow formula-decl nil exponentiation nil) (both_sides_times_neg_le2 formula-decl nil real_props nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (not_even_m1_pow formula-decl nil exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt_1n_aux formula-decl nil exponentiation nil) (expt def-decl "real" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (power_Epsilon_is_Epsilon-1 nil 3631536313 ("" (postpone) nil nil) nil shostak)) (power_Epsilon_judg 0 (power_Epsilon_judg-2 nil 3630864991 ("" (use "power_Epsilon_is_Epsilon") nil nil) ((power_Epsilon_is_Epsilon formula-decl nil affine_pow nil)) nil (power_Epsilon_judg subtype "exponentiation.^(affine_pow.e, affine_pow.n)" "Epsilon")) (power_Epsilon_judg-1 nil 3630864964 ("" (judgement-tcc) nil nil) nil nil (power_Epsilon_judg subtype "exponentiation.^(affine_pow.e, affine_pow.n)" "Epsilon"))) (pow_var_pd_TCC1 0 (pow_var_pd_TCC2-1 nil 3630864964 ("" (grind) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_idx const-decl "bool" indexed_list structures) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil)) nil (pow_var_pd assuming "structures@ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (pow_var_pd_TCC2 0 (pow_var_pd_TCC3-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil)) nil (pow_var_pd subtype "affine_pow.pds" "(list_adt[[nat, nzBaseType]].cons?)"))) (pow_var_pd_TCC3 0 (pow_var_pd_TCC4-2 "" 3789918245 ("" (grind) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ErrorTerms type-eq-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (pow_var_pd subtype "affine_pow.idxs" "(list_adt[nat].cons?)")) (pow_var_pd_TCC4-1 nil 3630864964 ("" (grind)) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ErrorTerms type-eq-decl nil affine nil)) nil (pow_var_pd subtype "affine_pow.idxs" "(list_adt[nat].cons?)"))) (pow_var_pd_TCC4 0 (pow_var_pd_TCC1-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil)) nil (pow_var_pd assuming "structures@ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (pow_var_pd_TCC5 0 (pow_var_pd_TCC5-1 nil 3630864964 ("" (subtype-tcc) nil nil) nil nil (pow_var_pd subtype "(number_fields.-)(affine_pow.n, affine_pow.k)" "naturalnumber"))) (pow_var_pd_TCC6 0 (pow_var_pd_TCC6-1 nil 3630864964 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (pow_var_pd subtype "affine_pow.idxs" "(list_adt[nat].cons?)"))) (pow_var_pd_TCC7 0 (pow_var_pd_TCC7-1 nil 3630864964 ("" (subtype-tcc) nil nil) nil nil (pow_var_pd subtype "affine_pow.k" "{i: integers.int | booleans.OR(affine_pow.pds_bt /= 0, reals.>=(i, 0))}"))) (pow_var_pd_TCC8 0 (pow_var_pd_TCC8-2 "" 3789918247 ("" (grind) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (lt_idx const-decl "bool" indexed_list structures) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (pow_var_pd subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((list_adt[nat].car(affine_pow.idxs), exponentiation.^(affine_pow.pds_bt, affine_pow.k)), list_adt[[nat, nzBaseType]].car(ol)))}")) (pow_var_pd_TCC8-1 nil 3630864964 ("" (grind)) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_idx const-decl "bool" indexed_list structures)) nil (pow_var_pd subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((list_adt[nat].car(affine_pow.idxs), exponentiation.^(affine_pow.pds_bt, affine_pow.k)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (pow_var_pd_TCC9 0 (pow_var_pd_TCC9-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (pow_var_pd subtype "ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cons_ol((list_adt[nat].car(affine_pow.idxs), exponentiation.^(affine_pow.pds_bt, affine_pow.k)), affine.empty_ErrorTerms)" "{pds: affine.ErrorTerms | booleans.AND((booleans.NOT)(list_adt[[nat, nzBaseType]].null?(pds)), reals.>=(list_adt[[nat, nzBaseType]].car(pds)`1, list_adt[nat].car(affine_pow.idxs)))}"))) (pow_var_pd_TCC10 0 (pow_var_pd_TCC10-1 nil 3630864964 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (pow_var_pd subtype "affine_pow.idxs" "(list_adt[nat].cons?)"))) (pow_var_pd_TCC11 0 (pow_var_pd_TCC11-2 "" 3789918249 ("" (skeep) (("" (typepred "idxs") (("" (expand "length" -3) (("" (grind) nil nil)) nil)) nil)) nil) ((subrange type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (> const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (pow_var_pd subtype "affine_pow.k" "{i: naturalnumbers.nat | reals.<=(i, affine_pow.n)}")) (pow_var_pd_TCC11-1 nil 3630864964 ("" (skeep) (("" (expand_ol) (("" (typepred "idxs") (("" (expand "length" -3) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak (pow_var_pd subtype "affine_pow.k" "{i: naturalnumbers.nat | reals.<=(i, affine_pow.n)}"))) (pow_var_pd_TCC12 0 (pow_var_pd_TCC12-2 "" 3789918249 ("" (grind) nil nil) nil shostak (pow_var_pd subtype "affine_pow.k" "{i: integers.int | booleans.OR(affine_pow.pds_bt /= 0, reals.>=(i, 0))}")) (pow_var_pd_TCC12-1 nil 3630864964 ("" (grind)) nil nil (pow_var_pd subtype "affine_pow.k" "{i: integers.int | booleans.OR(affine_pow.pds_bt /= 0, reals.>=(i, 0))}"))) (pow_var_pd_TCC13 0 (pow_var_pd_TCC13-2 "" 3789918250 ("" (skeep) (("" (typepred "idxs") (("" (expand "length" -3) (("" (grind) nil nil)) nil)) nil)) nil) ((subrange type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (> const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (pow_var_pd subtype "(number_fields.+)(affine_pow.k, 1)" "subrange(2, affine_pow.n)")) (pow_var_pd_TCC13-1 nil 3630864964 ("" (skeep) (("" (expand_ol) (("" (typepred "idxs") (("" (expand "length" -3) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak (pow_var_pd subtype "(number_fields.+)(affine_pow.k, 1)" "subrange(2, affine_pow.n)"))) (pow_var_pd_TCC14 0 (pow_var_pd_TCC14-1 nil 3631096818 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures)) nil (pow_var_pd subtype "affine_pow.idxs" "{ol | (booleans.NOT)(ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol?(ol))}"))) (pow_var_pd_TCC15 0 (pow_var_pd_TCC15-2 "" 3789918251 ("" (skeep) (("" (expand_ol) (("" (typepred "idxs") (("" (hide -1) (("" (case "NOT null?(idxs)") (("1" (expand "length" -2) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil)) shostak (pow_var_pd subtype "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].cdr_ol(affine_pow.idxs)" "{idxs_: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | reals.>(list_props[nat].length(idxs_), (number_fields.-)((number_fields.-)(affine_pow.n, 1), affine_pow.k))}")) (pow_var_pd_TCC15-1 nil 3631097939 ("" (skeep) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "idxs") (("" (hide -1) (("" (case "NOT null?(idxs)") (("1" (expand "length" -2) (("1" (assert) (("1" (typepred "k") (("1" (case "NOT null?(cdr(idxs))") (("1" (typepred "v(cv, pds_bt, n, 1 + k, cdr(idxs))") (("1" (expand "ordered_list?" -5) (("1" (propax) nil nil)) nil) ("2" (expand "ordered_list?" -3) (("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures)) shostak (pow_var_pd subtype "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].cdr_ol(affine_pow.idxs)" "{idxs_: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | reals.>(list_props[nat].length(idxs_), (number_fields.-)((number_fields.-)(affine_pow.n, 1), affine_pow.k))}"))) (pow_var_pd_TCC16 0 (pow_var_pd_TCC16-1 nil 3631097939 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (pow_var_pd termination "affine_pow.pow_var_pd(affine_pow.cv, affine_pow.pds_bt, affine_pow.n, (number_fields.+)(affine_pow.k, 1), ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].cdr_ol(affine_pow.idxs))" "nil"))) (pow_var_pd_TCC17 0 (pow_var_pd_TCC17-1 nil 3635094940 ("" (skeep) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "idxs") (("" (hide -1) (("" (case "NOT null?(idxs)") (("1" (expand "length" -2) (("1" (assert) (("1" (typepred "k") (("1" (case "NOT null?(cdr(idxs))") (("1" (typepred "v(cv, pds_bt, n, 1 + k, cdr(idxs))") (("1" (expand "ordered_list?" -5) (("1" (propax) nil nil)) nil) ("2" (expand "ordered_list?" -3) (("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (subrange type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (> const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_pd subtype "affine_pow.pow_var_pd(affine_pow.cv, affine_pow.pds_bt, affine_pow.n, (number_fields.+)(affine_pow.k, 1), ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].cdr_ol(affine_pow.idxs))" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((list_adt[nat].car(affine_pow.idxs), number_fields.*(number_fields.*(binomial.C(affine_pow.n, affine_pow.k), exponentiation.^(affine_pow.cv, ((number_fields.-)(affine_pow.n, affine_pow.k)))), exponentiation.^(affine_pow.pds_bt, affine_pow.k))), list_adt[[nat, nzBaseType]].car(ol)))}"))) (pow_var_pd_TCC18 0 (pow_var_pd_TCC18-1 nil 3635094940 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (^ const-decl "real" exponentiation nil) (C const-decl "posnat" binomial reals)) nil (pow_var_pd subtype "ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cons_ol((list_adt[nat].car(affine_pow.idxs), number_fields.*(number_fields.*(binomial.C(affine_pow.n, affine_pow.k), exponentiation.^(affine_pow.cv, ((number_fields.-)(affine_pow.n, affine_pow.k)))), exponentiation.^(affine_pow.pds_bt, affine_pow.k))), affine_pow.pow_var_pd(affine_pow.cv, affine_pow.pds_bt, affine_pow.n, (number_fields.+)(affine_pow.k, 1), ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].cdr_ol(affine_pow.idxs)))" "{pds: affine.ErrorTerms | booleans.AND((booleans.NOT)(list_adt[[nat, nzBaseType]].null?(pds)), reals.>=(list_adt[[nat, nzBaseType]].car(pds)`1, list_adt[nat].car(affine_pow.idxs)))}"))) (pow_var_ac_TCC1 0 (pow_var_ac_TCC2-2 "" 3789918255 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (pow_var_ac subtype "affine_pow.power" "{i: integers.int | booleans.OR(cv(affine_pow.Xa) /= 0, reals.>=(i, 0))}")) (pow_var_ac_TCC2-1 nil 3630864964 ("" (grind)) nil nil (pow_var_ac subtype "affine_pow.power" "{i: integers.int | booleans.OR(cv(affine_pow.Xa) /= 0, reals.>=(i, 0))}"))) (pow_var_ac_TCC2 0 (pow_var_ac_TCC3-2 "" 3789918255 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (last_idx const-decl "int" indexed_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (pow_var_ac subtype "(number_fields.-)(affine_pow.power, 2)" "below[length[nat](idxs)]")) (pow_var_ac_TCC3-1 nil 3630864964 ("" (grind)) ((BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) nil (pow_var_ac subtype "(number_fields.-)(affine_pow.power, 2)" "below[length[nat](idxs)]"))) (pow_var_ac_TCC3 0 (pow_var_ac_TCC4-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_ac subtype "0" "below[length[[nat, nzBaseType]](pd(Xa))]"))) (pow_var_ac_TCC4 0 (pow_var_ac_TCC5-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (^ const-decl "real" exponentiation nil) (lt_idx const-decl "bool" indexed_list structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_ac subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((list_props[nat].nth(affine_pow.idxs, (number_fields.-)(affine_pow.power, 2)), exponentiation.^(list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`2, affine_pow.power)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (pow_var_ac_TCC5 0 (pow_var_ac_TCC6-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_ac subtype "0" "below[length[[nat, nzBaseType]](pd(Xa))]"))) (pow_var_ac_TCC6 0 (pow_var_ac_TCC7-3 "" 3789918258 ("" (skeep) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (pow_var_ac subtype "((number_fields.-)(affine_pow.power, 1))" "{i: integers.int | booleans.OR(cv(affine_pow.Xa) /= 0, reals.>=(i, 0))}")) (pow_var_ac_TCC7-2 nil 3630865261 ("" (skeep) (("" (use "zero_times3") (("" (assert) (("" (hide -2) (("" (use "expt_nonzero") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (pow_var_ac subtype "((number_fields.-)(affine_pow.power, 1))" "{i: integers.int | booleans.OR(cv(affine_pow.Xa) /= 0, reals.>=(i, 0))}")) (pow_var_ac_TCC7-1 nil 3630864964 ("" (subtype-tcc) nil nil) nil nil (pow_var_ac subtype "((number_fields.-)(affine_pow.power, 1))" "{i: integers.int | booleans.OR(cv(affine_pow.Xa) /= 0, reals.>=(i, 0))}"))) (pow_var_ac_TCC7 0 (pow_var_ac_TCC8-1 nil 3630864964 ("" (skeep) (("" (use "nonzero_times3") (("1" (assert) nil nil) ("2" (hide -1) (("2" (use "expt_nonzero") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nonzero_times3 formula-decl nil real_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (power skolem-const-decl "nat" affine_pow nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (Xa skolem-const-decl "(represents_var?)" affine_pow nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (expt_nonzero formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (pow_var_ac subtype "number_fields.*(number_fields.*(affine_pow.power, exponentiation.^(cv(affine_pow.Xa), ((number_fields.-)(affine_pow.power, 1)))), list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`2)" "nzBaseType"))) (pow_var_ac_TCC8 0 (pow_var_ac_TCC9-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_ac subtype "cv(affine_pow.Xa)" "nzBaseType"))) (pow_var_ac_TCC9 0 (pow_var_ac_TCC10-3 "" 3789918259 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (pow_var_ac subtype "2" "subrange(2, affine_pow.power)")) (pow_var_ac_TCC10-2 nil 3630865308 ("" (grind)) ((BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak (pow_var_ac subtype "2" "subrange(2, affine_pow.power)")) (pow_var_ac_TCC10-1 nil 3630864964 ("" (subtype-tcc) nil nil) nil nil (pow_var_ac subtype "2" "subrange(2, affine_pow.power)"))) (pow_var_ac_TCC10 0 (pow_var_ac_TCC1-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (pow_var_ac subtype "affine_pow.idxs" "{idxs_: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | reals.>(list_props[nat].length(idxs_), (number_fields.-)(affine_pow.power, 2))}"))) (pow_var_ac_TCC11 0 (pow_var_ac_TCC12-1 nil 3631100791 ("" (skeep) (("" (typepred "pow_var_pd(cv(Xa), nth[[nat, nzBaseType]](pd(Xa), 0)`2,
                           power, 2, idxs)") (("" (expand "lt_idx") (("" (typepred "idxs") (("" (assert) (("" (flatten) (("" (split -4) (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (expand "nth") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (next_idx const-decl "nat" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ErrorTerms type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (ordered_list type-eq-decl nil ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (last_idx const-decl "int" indexed_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (car_ol const-decl "T" ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_ac subtype "affine_pow.pow_var_pd(cv(affine_pow.Xa), list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`2, affine_pow.power, 2, affine_pow.idxs)" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`1, number_fields.*(number_fields.*(affine_pow.power, exponentiation.^(cv(affine_pow.Xa), ((number_fields.-)(affine_pow.power, 1)))), list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`2)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (pow_var_ac_TCC12 0 (pow_var_ac_TCC13-1 nil 3632131382 ("" (subtype-tcc) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_idx const-decl "bool" indexed_list structures) (real_times_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pow_var_ac subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`1, number_fields.*(number_fields.*(affine_pow.power, exponentiation.^(cv(affine_pow.Xa), ((number_fields.-)(affine_pow.power, 1)))), list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`2)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (nats_TCC1 0 (nats_TCC1-1 nil 3631096818 ("" (subtype-tcc) nil nil) nil shostak (nats subtype "(number_fields.-)(affine_pow.e, affine_pow.s)" "naturalnumber"))) (nats_TCC2 0 (nats_TCC2-1 nil 3631096818 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth def-decl "T" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (nats subtype "(: affine_pow.e :)" "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.AND((booleans.NOT)(ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol?(r)), booleans.AND(ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].car_ol(r) = affine_pow.s, booleans.AND(list_props[nat].length(r) = (number_fields.-)((number_fields.+)(1, affine_pow.e), affine_pow.s), FORALL (i: naturalnumbers.below(list_props[nat].length(r))): list_props[nat].nth(r, i) = (number_fields.+)(i, affine_pow.s))))}"))) (nats_TCC3 0 (nats_TCC3-2 "" 3789918263 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (nats subtype "affine_pow.e" "{e: naturalnumbers.nat | reals.<=((number_fields.+)(1, affine_pow.s), e)}")) (nats_TCC3-1 nil 3631096818 ("" (grind)) nil nil (nats subtype "affine_pow.e" "{e: naturalnumbers.nat | reals.<=((number_fields.+)(1, affine_pow.s), e)}"))) (nats_TCC4 0 (nats_TCC4-1 nil 3631096818 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (nats termination "affine_pow.nats((number_fields.+)(affine_pow.s, 1), affine_pow.e)" "nil"))) (nats_TCC5 0 (nats_TCC5-1 nil 3631096818 ("" (skeep) (("" (typepred "v(s + 1, e)") (("1" (expand "car_ol") (("1" (assert) nil nil)) nil) ("2" (typepred "e") (("2" (assert) nil nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (car_ol const-decl "T" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (restrict const-decl "R" restrict nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (nats subtype "affine_pow.nats((number_fields.+)(affine_pow.s, 1), affine_pow.e)" "{ol | booleans.OR(list_adt[nat].null?(ol), reals.<(affine_pow.s, list_adt[nat].car(ol)))}"))) (nats_TCC6 0 (nats_TCC6-1 nil 3631096818 ("" (skeep) (("" (expand_ol) (("" (typepred "v(1 + s, e)") (("1" (split 3) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "nth" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (inst -5 "i-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "e") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (i skolem-const-decl "below(length(cons_ol[nat, restrict[[real, real], [nat, nat], bool](<)]
                 (s, v(1 + s, e))))" affine_pow nil) (v skolem-const-decl "[d1: {z: [s: nat, {e: nat | s <= e}] | z`2 - z`1 < e - s} ->
   {r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
      NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
       car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = d1`1
        AND
        length(r) = 1 - d1`1 + d1`2 AND
         FORALL (i: below(length(r))): nth(r, i) = i + d1`1}]" affine_pow nil) (e skolem-const-decl "{e: nat | s <= e}" affine_pow nil) (s skolem-const-decl "nat" affine_pow nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (nats subtype "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].cons_ol(affine_pow.s, affine_pow.nats((number_fields.+)(affine_pow.s, 1), affine_pow.e))" "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.AND((booleans.NOT)(ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol?(r)), booleans.AND(ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].car_ol(r) = affine_pow.s, booleans.AND(list_props[nat].length(r) = (number_fields.-)((number_fields.+)(1, affine_pow.e), affine_pow.s), FORALL (i: naturalnumbers.below(list_props[nat].length(r))): list_props[nat].nth(r, i) = (number_fields.+)(i, affine_pow.s))))}"))) (member_nats 0 (member_nats-1 nil 3632507443 ("" (skeep) (("" (typepred "nats(s,e)") (("" (use "member_nth[nat]") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (car_ol const-decl "T" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (member_nth formula-decl nil more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (take_nats_TCC1 0 (take_nats_TCC1-1 nil 3638804535 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (take_nats subtype "real_defs.min(affine_pow.e, (number_fields.-)((number_fields.+)(affine_pow.s, affine_pow.i), 1))" "{e: naturalnumbers.nat | reals.<=(affine_pow.s, e)}"))) (take_nats 0 (take_nats-1 nil 3638804538 ("" (skeep :preds? t) (("" (case "i>length(nats(s,e))") (("1" (use "take_prop_1[nat]") (("1" (replaces -1) (("1" (use "take_prop_2[nat]") (("1" (replaces -1) (("1" (typepred "nats(s, e)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "dif" "e - s") (("2" (merge-fnums *) (("1" (case "FORALL(dif:nat)(i: above(0), s: nat, e: nat | s <= e):
e - s = dif AND i > 0 AND s >= 0 AND s <= e IMPLIES
       i > length(nats(s, e)) OR
        take(nats(s, e), i) = nats(s, min(e, s + i - 1))") (("1" (inst?) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (induct "dif") (("1" (grind) nil nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (skolem 1 ("i_" "s_" "e_")) (("2" (flatten) (("2" (expand "take" 2) (("2" (assert) (("2" (typepred "nats(s_, e_)") (("2" (expand "car_ol") (("2" (replace -3) (("2" (expand "nats" 3 1) (("2" (expand_ol) (("2" (expand "nats" 3 2) (("2" (expand_ol) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (car_ol const-decl "T" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (TRUE const-decl "bool" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (take_prop_2 formula-decl nil more_list_props structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "above(0)" affine_pow nil) (s skolem-const-decl "nat" affine_pow nil) (e skolem-const-decl "{e: nat | s <= e}" affine_pow nil) (take_prop_1 formula-decl nil more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (take def-decl "list[T]" more_list_props structures) (cons_ol const-decl "ordered_list" ordered_list structures) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (i_ skolem-const-decl "above(0)" affine_pow nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (dif skolem-const-decl "int" affine_pow nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (next_idx_pow_var_ac_TCC1 0 (next_idx_pow_var_ac_TCC1-1 nil 3883590329 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (next_idx_pow_var_ac subtype "affine_pow.idxs" "(list_adt[nat].cons?)"))) (next_idx_pow_var_ac_TCC2 0 (next_idx_pow_var_ac_TCC1-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_idx_pow_var_ac subtype "(number_fields.-)(affine_pow.power, 2)" "below[length[nat](idxs)]"))) (next_idx_pow_var_ac 0 (next_idx_pow_var_ac-1 nil 3630865069 ("" (skeep) (("" (expand "pow_var_ac") (("" (lift-if 1) (("" (split 1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "cons_ol") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (expand "last_ol") (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (with-labels (case "cv(Xa) ^ (power - 1) * nth[[nat, nzBaseType]](pd(Xa), 0)`2 * power
          /= 0") (("useful-prop"))) (("1" (hide "useful-prop") (("1" (flatten) (("1" (typepred "idxs") (("1" (assert) (("1" (flatten) (("1" (hide -1 -2) (("1" (case "NOT null?(idxs)") (("1" (assert) (("1" (name "k" "2") (("1" (replace -1 (+ -2)) (("1" (case "2 <= k AND k < power") (("1" (hide -2) (("1" (name "k2" "power-k") (("1" (case "k= power-k2") (("1" (replace -1 (-3 2 -4) :hide? t) (("1" (hide -1) (("1" (assert) (("1" (generalize "idxs" "idxs" "{idxs:
                                   ordered_list
                                       [nat,
                                        restrict[[real, real], [nat, nat], boolean](<)] |
                                         (
                                           (NOT null?(idxs) IMPLIES
                                             car(idxs) >= next_idx(pd(Xa)))
                                           OR length(pd(Xa)) = 0)}") (("1" (generalize "k2" "k2" "nat") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (induct "k2" :name "NAT_induction") (("1" (skeep) (("1" (skeep) (("1" (expand "pow_var_pd" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "next_idx" 2) (("2" (expand "last_idx" 2) (("2" (expand_ol) (("2" (expand "last_ol" 2) (("2" (expand "last_ol" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr(idxs!1)") (("1" (expand "next_idx" -1 2) (("1" (expand "last_idx" -1) (("1" (expand "last_ol" -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (hide-all-but (-4 -3 5 1 4)) (("5" (typepred "idxs!1") (("5" (expand "ordered_list?") (("5" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "idxs!1") (("2" (expand ">=") (("2" (expand "ordered_list?") (("2" (split -2) (("1" (propax) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (hide-all-but (-1 1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (expand "lt_idx") (("3" (expand "nth") (("3" (skeep) (("3" (typepred "pow_var_pd(cv(Xa), car(pd(Xa))`2, power, power - k2!2, idxs!1)") (("3" (expand ">=") (("3" (expand "next_idx") (("3" (expand "last_idx") (("3" (lift-if -6) (("3" (split -6) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but -1) (("2" (reveal 4) (("2" (skeep) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (reveal "useful-prop") (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (grind) nil nil)) nil) ("7" (hide 2) (("7" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (hide 2) (("4" (expand "lt_idx") (("4" (expand "nth") (("4" (skeep) (("4" (expand ">=") (("4" (expand "next_idx") (("4" (expand "last_idx") (("4" (lift-if -4) (("4" (split -4) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but -1) (("2" (reveal 4) (("2" (skeep) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (grind) nil nil)) nil) ("6" (hide 2) (("6" (reveal "useful-prop") (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (grind) nil nil)) nil) ("8" (hide 2) (("8" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (expand "lt_idx") (("3" (expand "nth") (("3" (skeep) (("3" (expand ">=") (("3" (expand "next_idx") (("3" (expand "last_idx") (("3" (lift-if -4) (("3" (split -4) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but -1) (("2" (reveal 4) (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (reveal "useful-prop") (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (grind) nil nil)) nil) ("6" (hide 2) (("6" (grind) nil nil)) nil) ("7" (grind) nil nil) ("8" (reveal "useful-prop") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (use "zero_times3") (("2" (assert) (("2" (hide "useful-prop") (("2" (flatten) (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (use "expt_nonzero") (("1" (expand "/=") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "next_idx" 2 1) (("2" (expand_ol) (("2" (expand "last_idx") (("2" (expand "last_ol") (("2" (expand "nth") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (typepred "Xa") (("2" (expand "represents_var?") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "last_ol") (("1" (expand "length") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (ac_proj_pd formula-decl nil affine nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) ({\|\|} const-decl "AffineCombination" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (last_ol def-decl "T" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (above nonempty-type-eq-decl nil integers nil) (subrange type-eq-decl nil integers nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Xa skolem-const-decl "(represents_var?)" affine_pow nil) (power skolem-const-decl "nat" affine_pow nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (idxs!1 skolem-const-decl "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
   ((NOT null?(idxs) IMPLIES car(idxs) >= next_idx(pd(Xa))) OR
     length(pd(Xa)) = 0)}" affine_pow nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (j skolem-const-decl "nat" affine_pow nil) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (olidx_car_last formula-decl nil indexed_list structures) (car_ol const-decl "T" ordered_list structures) (k2 skolem-const-decl "int" affine_pow nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (zero_times3 formula-decl nil real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_nonzero formula-decl nil exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (idxs_ac_pow_var_ac_TCC1 0 (idxs_ac_pow_var_ac_TCC1-1 nil 3631471400 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (idxs_ac const-decl "list[nat]" affine nil)) nil (idxs_ac_pow_var_ac subtype "(number_fields.+)((number_fields.-)(affine_pow.power, 2), 1)" "nat"))) (idxs_ac_pow_var_ac 0 (idxs_ac_pow_var_ac-1 nil 3630865100 ("" (skeep) (("" (expand "pow_var_ac") (("" (lift-if -1) (("" (split -1) (("1" (flatten) (("1" (expand "idxs_ac" -2) (("1" (assert) (("1" (expand "idxs_pd") (("1" (expand_ol) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (expand "idxs_ac" -2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_ac" -1) (("2" (assert) (("2" (expand "idxs_pd") (("2" (expand_ol) (("2" (case "NOT null?(idxs)") (("1" (assert) (("1" (expand "member" -1) (("1" (split -1) (("1" (replace -1 6 :hide? t) (("1" (use "nth_take[nat]") (("1" (typepred "idxs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "idxs_pd") (("2" (expand_ol) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "idxs") (("2" (assert) (("2" (expand "length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_ac") (("1" (assert) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (case "NOT null?(idxs)") (("1" (assert) (("1" (typepred "idxs") (("1" (assert) (("1" (flatten) (("1" (hide -1 -2) (("1" (case "power - 1 = power - 2 + 1") (("1" (replaces -1) (("1" (name "k" "2") (("1" (replace -1) (("1" (case "2 <= k AND k <= power") (("1" (hide -2) (("1" (name "k2" "power-k") (("1" (case "k= power-k2") (("1" (replace -1 :hide? t) (("1" (hide -1) (("1" (assert) (("1" (generalize "idxs" "idxs" "{idxs:
                                                                       ordered_list
                                                                           [nat,
                                                                            restrict[[real, real], [nat, nat], boolean](<)] |
                                                                         
                                                                               NOT null?(idxs) AND
                                                                                 car(idxs) >= next_idx(pd(Xa))
                                                                              }") (("1" (generalize "k2" "k2" "nat") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (induct "k2" :name "NAT_induction") (("1" (skeep) (("1" (skeep) (("1" (expand "pow_var_pd" -7) (("1" (lift-if -7) (("1" (split -7) (("1" (flatten) (("1" (expand "member" -2) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (expand "nth" -2) (("1" (split -2) (("1" (replaces -1) (("1" (expand "idxs_pd" 5) (("1" (expand_ol) (("1" (case "NOT null?(pd(Xa))") (("1" (assert) (("1" (expand "member" 6) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "member" 6) (("2" (lift-if 6) (("2" (split 6) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "take" 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (expand "idxs_pd" -1) (("2" (expand_ol) (("2" (expand "member" -1) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr(idxs!1)") (("1" (expand "take" 7) (("1" (expand "member" 7) (("1" (flatten) (("1" (assert) (("1" (split 2) (("1" (grind) nil nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (typepred "idxs!1") (("1" (expand "ordered_list?" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred "idxs!1") (("3" (expand "ordered_list?" -2) (("3" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 2 -9)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_ac") (("2" (assert) (("2" (expand "idxs_pd") (("2" (expand_ol) (("2" (expand "member" -1) (("2" (split -1) (("1" (expand "nth") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pow_var_ac const-decl "AffineCombination" affine_pow nil) (idxs_ac const-decl "list[nat]" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (member def-decl "bool" list_props nil) (car_ol const-decl "T" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ac_proj_pd formula-decl nil affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) ({\|\|} const-decl "AffineCombination" affine nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (ErrorTerms type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (power skolem-const-decl "nat" affine_pow nil) (Xa skolem-const-decl "(represents_var?)" affine_pow nil) (idxs skolem-const-decl "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   (length(idxs) > power - 2 AND
     (NOT null?(idxs) IMPLIES car(idxs) >= next_idx(pd(Xa))))
    OR length(pd(Xa)) = 0}" affine_pow nil) (nth_take formula-decl nil more_list_props structures) (cons_ol const-decl "ordered_list" ordered_list structures) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (even? const-decl "bool" integers nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (k2 skolem-const-decl "int" affine_pow nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (last_idx const-decl "int" indexed_list structures) (j skolem-const-decl "nat" affine_pow nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (idxs!1 skolem-const-decl "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
   NOT null?(idxs) AND car(idxs) >= next_idx(pd(Xa))}" affine_pow nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (NAT_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (take def-decl "list[T]" more_list_props structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (subrange type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (idxs_ac_pow_var_ac_2_TCC1 0 (idxs_ac_pow_var_ac_2_TCC1-1 nil 3638782521 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (idxs_ac_pow_var_ac_2 subtype "(number_fields.+)((number_fields.-)(affine_pow.power, 2), 1)" "nat"))) (idxs_ac_pow_var_ac_2 0 (idxs_ac_pow_var_ac_2-1 nil 3638782521 ("" (skeep*) (("" (expand "pow_var_ac") (("" (expand "idxs_ac") (("" (assert) (("" (expand "idxs_pd" 4) (("" (expand_ol) (("" (expand "member" 4) (("" (flatten) (("" (typepred "idxs") (("" (assert) (("" (flatten) (("" (hide -1 -2) (("" (case "power-1 = power-2+1") (("1" (replace -1 -5 :hide? t) (("1" (name-replace "k" "2") (("1" (name "step" "power-k") (("1" (merge-fnums *) (("1" (case "FORALL(step:nat)(idxs: ordered_list[nat,<])(k: subrange(2,power)):
                       power - k = step AND length(idxs) > power - k
                              AND car(idxs) >= next_idx(pd(Xa)) AND k <= power
                              AND member(i, take[nat](idxs, power - k + 1))
                              IMPLIES
                                  length(pd(Xa)) = 0 OR null?(idxs) OR cv(Xa) = 0
                               OR i = nth(pd(Xa), 0)`1
                               OR member(i,
                                         idxs_pd(pow_var_pd(cv(Xa),
                                                            nth(pd(Xa), 0)`2,
                                                            power,
                                                            k,
                                                            idxs)))") (("1" (inst?) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (induct "step") (("1" (skeep*) (("1" (case "power=k!1") (("1" (replaces -1) (("1" (hide -1 -4) (("1" (assert) (("1" (expand "take" -3) (("1" (expand "take" -3) (("1" (assert) (("1" (typepred "length(cdr(idxs!1))") (("1" (assert) (("1" (expand "member" -4) (("1" (expand "member" -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skolem 1 "stp") (("2" (flatten) (("2" (skeep*) (("2" (expand "take" -6) (("2" (assert) (("2" (expand "member" -6) (("2" (split -6) (("1" (grind) nil nil) ("2" (inst -2 "cdr_ol[nat,<](idxs!1)") (("1" (inst -2 "k!1+1") (("1" (assert) (("1" (split -2) (("1" (expand "cdr_ol") (("1" (grind) nil nil)) nil) ("2" (expand "cdr_ol") (("2" (expand "pow_var_pd" 5) (("2" (expand "idxs_pd" 5) (("2" (expand_ol) (("2" (expand "member" 5) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "cdr_ol") (("3" (grind) nil nil)) nil) ("4" (expand "cdr_ol") (("4" (typepred "idxs!1") (("4" (expand "ordered_list?") (("4" (assert) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (expand "cdr_ol") (("5" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pow_var_ac const-decl "AffineCombination" affine_pow nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ac_proj_pd formula-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (last_idx const-decl "int" indexed_list structures) (step skolem-const-decl "int" affine_pow nil) (power skolem-const-decl "nat" affine_pow nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (idxs!1 skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine_pow nil) (nil application-judgement "above(n)" exp2 nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (<= const-decl "bool" reals nil) (take def-decl "list[T]" more_list_props structures) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (above nonempty-type-eq-decl nil integers nil) (subrange type-eq-decl nil integers nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (even? const-decl "bool" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ErrorTerms type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (idxs_pd def-decl "list[nat]" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (pow_var_compatible?_TCC1 0 (pow_var_compatible?_TCC1-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil)) nil (pow_var_compatible? subtype "affine_pow.i" "below[length[nat](nwidxs)]"))) (pow_var_compatible?_TCC2 0 (pow_var_compatible?_TCC2-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil)) nil (pow_var_compatible? subtype "0" "below[length[[nat, nzBaseType]](pd(Xa))]"))) (pow_var_compatible?_TCC3 0 (pow_var_compatible?_TCC3-1 nil 3631534893 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (pow_var_compatible? subtype "((number_fields.+)(affine_pow.i, 2))" "{i: integers.int | booleans.OR(affine.get_noise_by_idx(list_props[[nat, nzBaseType]].nth(pd(affine_pow.Xa), 0)`1, affine_pow.N) /= 0, reals.>=(i, 0))}"))) (containment_pow_var_ac_TCC1 0 (containment_pow_var_ac_TCC1-1 nil 3630864964 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nzBaseType type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_ac_noise const-decl "real" affine nil)) nil (containment_pow_var_ac subtype "pd(affine_pow.Xa)" "(list_adt[[nat, nzBaseType]].cons?)"))) (containment_pow_var_ac_TCC2 0 (containment_pow_var_ac_TCC2-1 nil 3631534893 ("" (subtype-tcc) nil nil) ((eval_ac_noise const-decl "real" affine nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (containment_pow_var_ac subtype "affine_pow.power" "{i: integers.int | booleans.OR(affine_pow.x /= 0, reals.>=(i, 0))}"))) (containment_pow_var_ac 0 (containment_pow_var_ac-3 "" 3789918328 ("" (skeep) (("" (expand "pow_var_ac") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (expand_ol) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (lift-if -1) (("2" (split 2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (replaces -2 :dir RL) (("1" (assert) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (case "cdr_ol(pd(Xa))=null") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -2) (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (split 1) (("1" (flatten) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (reveal -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 2 2) (("1" (expand "pow_var_compatible?") (("1" (inst -1 "power-2") (("1" (replaces -1) (("1" (assert) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "cdr_ol(pd(Xa))=null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (replaces -2 :dir RL) (("1" (use "binomial_theorem") (("1" (replaces -1) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (expand "sigma" 1) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (assert) (("1" (use "C_n") (("1" (replaces -1) (("1" (assert) (("1" (use "identity_mult") (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (expand "sigma") (("1" (expand "nth") (("1" (use "expt_x1") (("1" (replaces -1) (("1" (lemma "C_n_1") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (assert) (("1" (case "get_noise_by_idx(car(pd(Xa))`1, N) *
                                                                                                                                      (cv(Xa) ^ (power - 1) * car(pd(Xa))`2 * power) = (cv(Xa) ^ (power - 1)) * get_noise_by_idx(car(pd(Xa))`1, N) *
                                                                                                                                       car(pd(Xa))`2
                                                                                                                                       * power") (("1" (replaces -1) (("1" (assert) (("1" (typepred "nwidxs") (("1" (hide -1 -2) (("1" (assert) (("1" (flatten) (("1" (name "idxs" "nwidxs") (("1" (replace -1 (-2 -3 +)) (("1" (name "step" "2") (("1" (case "2<=step AND step<=power") (("1" (replaces -2 (1 -4)) (("1" (case "nwidxs = append(take[nat](nwidxs, step-2), idxs)") (("1" (name "bstep" "power - step") (("1" (case "step = power - bstep") (("1" (replace -2 (1 -6)) (("1" (replaces -1 (1 -3 -4)) (("1" (hide -1) (("1" (flatten) (("1" (hide -4) (("1" (generalize "idxs" "idxs_" "{idxs:ordered_list[nat,restrict[[real, real], [nat, nat], boolean](<)] | NOT null?(idxs) AND car(idxs) >= next_idx(pd(Xa)) }") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (generalize "bstep" "bstep" "{ bstep:nat | 2 <= power - bstep
                                                                                                                 AND power - bstep <= power}") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (induct "bstep" :name "NAT_induction") (("1" (ground) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "sigma" 1) (("2" (assert) (("2" (expand "pow_var_pd" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "j=0") (("1" (replaces -1) (("1" (assert) (("1" (hide -2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (inst -7 "power -2") (("1" (replaces -2) (("1" (case "nth(append(take[nat](nwidxs, power - 2), idxs_), power - 2) = car(idxs_)") (("1" (replaces -1) (("1" (replaces -6) (("1" (assert) (("1" (use "C_0") (("1" (replaces -1) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](nwidxs, power - 2), idxs_), power - 2) =
       nth(idxs_, power - 2 - length(take[nat](nwidxs, power - 2)))") (("1" (replaces -1) (("1" (case "length(take[nat](nwidxs, power - 2)) = power -2") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nwidxs") (("2" (assert) (("2" (flatten) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (assert) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (reveal -12) (("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (grind) nil nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (reveal -12) (("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr(idxs_)") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (inst -7 "-2 - j + power") (("1" (replace -2 -7) (("1" (case "nth(append(take[nat](nwidxs, -2 - j + power), idxs_), -2 - j + power) = car(idxs_)") (("1" (replace -1 -8) (("1" (replace -8 2) (("1" (lemma "C_symmetry") (("1" (inst -1 "power" "j") (("1" (replaces -1) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](nwidxs, -2 - j + power), idxs_), -2 - j + power) =
       nth(idxs_, -2 - j + power - length(take[nat](nwidxs, -2 - j + power)))") (("1" (replaces -1) (("1" (case "length(take[nat](nwidxs, - 2 - j + power)) = -2 - j + power") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nwidxs") (("2" (assert) (("2" (flatten) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (typepred "nwidxs") (("1" (assert) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (reveal -12) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (hide 4) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (reveal -12) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 7) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (case "-1 - j + power = -2 - j + power + 1") (("1" (replaces -1) (("1" (name "m" "-2 - j + power") (("1" (case "m >= 0") (("1" (replaces -2) (("1" (generalize "m" "m" "nat") (("1" (generalize "nwidxs" "l" "list[nat]") (("1" (generalize "idxs_" "l2" "(cons?[nat])") (("1" (induct "m" :name "NAT_induction") (("1" (skolem 1 "m_") (("1" (flatten) (("1" (skeep) (("1" (case "m_ = 0") (("1" (replaces -1) (("1" (hide -1 -2) (("1" (grind) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (expand "take" -3) (("2" (lift-if -3) (("2" (split -3) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) (("2" (inst -2 "m_-1") (("2" (assert) (("2" (expand "append" -1) (("2" (inst -2 "l2" "cdr(l)") (("2" (split -2) (("1" (expand "take" 3) (("1" (lift-if 3) (("1" (split 3) (("1" (flatten) (("1" (grind) (("1" (replace -2 :dir rl) (("1" (apply-extensionality :hide? t) nil nil)) nil) ("2" (replace -2 :dir rl) (("2" (apply-extensionality :hide? t) nil nil)) nil) ("3" (replace -2 :dir rl) (("3" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "append" 2) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "B" "append(take[nat](cdr(l), m_ - 1), l2)") (("2" (replaces -1) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("4" (expand "length" -5) (("4" (assert) nil nil)) nil)) nil) ("2" (split 1) (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (typepred "idxs_") (("2" (expand "ordered_list?" -2) (("2" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 -4 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (hide-all-but (-1 3 5)) (("2" (typepred "nth[[nat, nzBaseType]](pd(Xa), 0)`2") (("2" (expand "nth") (("2" (use "expt_nonzero") (("2" (expand "/=" :assert? none) (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (hide 1) (("1" (use "expt_nonzero") (("1" (expand "/=") (("1" (typepred "C(power, power - j)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil) ("7" (hide-all-but 1) (("7" (grind) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil) ("7" (flatten) (("7" (grind) nil nil)) nil) ("8" (hide-all-but 1) (("8" (grind) nil nil)) nil) ("9" (hide-all-but 1) (("9" (grind) nil nil)) nil) ("10" (hide-all-but 1) (("10" (grind) nil nil)) nil) ("11" (hide-all-but 1) (("11" (grind) nil nil)) nil) ("12" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (reveal -1) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (use "expt_nonzero") (("1" (expand "nth") (("1" (typepred "car(pd(Xa))`2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "power=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pow_var_ac const-decl "AffineCombination" affine_pow nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (eval_ac_noise const-decl "real" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (cons_ol const-decl "ordered_list" ordered_list structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (restrict const-decl "R" restrict nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (next_idx const-decl "nat" affine nil) (power skolem-const-decl "nat" affine_pow nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (mult_expt formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (N skolem-const-decl "Noise" affine_pow nil) (Xa skolem-const-decl "(represents_var?)" affine_pow nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (identity_mult formula-decl nil number_fields nil) (expt_x1 formula-decl nil exponentiation nil) (C_n_1 formula-decl nil binomial reals) (even_minus_even_is_even application-judgement "even_int" integers nil) (append def-decl "list[T]" list_props nil) (take def-decl "list[T]" more_list_props structures) (eval_pd_noise def-decl "real" affine nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (C const-decl "posnat" binomial reals) (member def-decl "bool" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (idxs skolem-const-decl "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   (length(nwidxs) > power - 2 AND
     (NOT null?(nwidxs) IMPLIES car(nwidxs) >= next_idx(pd(Xa))))
    OR length(pd(Xa)) = 0}" affine_pow nil) (nil application-judgement "above(n)" exp2 nil) (last_idx const-decl "int" indexed_list structures) (nwidxs skolem-const-decl "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   (length(nwidxs) > power - 2 AND
     (NOT null?(nwidxs) IMPLIES car(nwidxs) >= next_idx(pd(Xa))))
    OR length(pd(Xa)) = 0}" affine_pow nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (expt_nonzero formula-decl nil exponentiation nil) (zero_times3 formula-decl nil real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (idxs_ skolem-const-decl "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
   NOT null?(idxs) AND car(idxs) >= next_idx(pd(Xa))}" affine_pow nil) (m skolem-const-decl "int" affine_pow nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (list_cons_extensionality formula-decl nil list_adt nil) (C_symmetry formula-decl nil binomial reals) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (j skolem-const-decl "nat" affine_pow nil) (length_take formula-decl nil more_list_props structures) (factorial def-decl "posnat" factorial ints) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (length_append formula-decl nil list_props nil) (nth_append formula-decl nil more_list_props structures) (C_0 formula-decl nil binomial reals) (int_times_even_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_0_neg formula-decl nil sigma_nat reals) (bstep skolem-const-decl "int" affine_pow nil) (even? const-decl "bool" integers nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (subrange type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (C_n formula-decl nil binomial reals) (sigma def-decl "real" sigma reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (binomial_theorem formula-decl nil polynomials reals) (odd_minus_odd_is_even application-judgement "even_int" integers nil) ({\|\|} const-decl "AffineCombination" affine nil) (minus_int_is_int application-judgement "int" integers nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (containment_pow_var_ac-2 "" 3758874801 ("" (skeep) (("" (expand "pow_var_ac") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (expand_ol) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (lift-if -1) (("2" (split 2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (replaces -2 :dir RL) (("1" (assert) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (case "cdr_ol(pd(Xa))=null") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -2) (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (split 1) (("1" (flatten) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (reveal -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 2 2) (("1" (expand "pow_var_compatible?") (("1" (inst -1 "power-2") (("1" (replaces -1) (("1" (assert) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "cdr_ol(pd(Xa))=null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (replaces -2 :dir RL) (("1" (use "binomial_theorem") (("1" (replaces -1) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (expand "sigma" 1) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (assert) (("1" (use "C_n") (("1" (replaces -1) (("1" (assert) (("1" (use "identity_mult") (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (expand "sigma") (("1" (expand "nth") (("1" (use "expt_x1") (("1" (replaces -1) (("1" (lemma "C_n_1") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (assert) (("1" (case "get_noise_by_idx(car(pd(Xa))`1, N) *
                                                                                                                                      (cv(Xa) ^ (power - 1) * car(pd(Xa))`2 * power) = (cv(Xa) ^ (power - 1)) * get_noise_by_idx(car(pd(Xa))`1, N) *
                                                                                                                                       car(pd(Xa))`2
                                                                                                                                       * power") (("1" (replaces -1) (("1" (assert) (("1" (typepred "nwidxs") (("1" (hide -1 -2) (("1" (assert) (("1" (flatten) (("1" (name "idxs" "nwidxs") (("1" (replace -1 (-2 -3 +)) (("1" (name "step" "2") (("1" (case "2<=step AND step<=power") (("1" (replaces -2 (1 -4)) (("1" (case "nwidxs = append(take[nat](nwidxs, step-2), idxs)") (("1" (name "bstep" "power - step") (("1" (case "step = power - bstep") (("1" (replace -2 (1 -6)) (("1" (replaces -1 (1 -3 -4)) (("1" (hide -1) (("1" (flatten) (("1" (hide -4) (("1" (generalize "idxs" "idxs_" "{idxs:ordered_list[nat,restrict[[real, real], [nat, nat], boolean](<)] | NOT null?(idxs) AND car(idxs) >= next_idx(pd(Xa)) }") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (generalize "bstep" "bstep" "{ bstep:nat | 2 <= power - bstep
                                                                                                                 AND power - bstep <= power}") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (induct "bstep" :name "NAT_induction") (("1" (ground) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "sigma" 1) (("2" (assert) (("2" (expand "pow_var_pd" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "j=0") (("1" (replaces -1) (("1" (assert) (("1" (hide -2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (inst -7 "power -2") (("1" (replaces -2) (("1" (case "nth(append(take[nat](nwidxs, power - 2), idxs_), power - 2) = car(idxs_)") (("1" (replaces -1) (("1" (replaces -6) (("1" (assert) (("1" (use "C_0") (("1" (replaces -1) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](nwidxs, power - 2), idxs_), power - 2) =
       nth(idxs_, power - 2 - length(take[nat](nwidxs, power - 2)))") (("1" (replaces -1) (("1" (case "length(take[nat](nwidxs, power - 2)) = power -2") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nwidxs") (("2" (assert) (("2" (flatten) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (assert) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (reveal -12) (("2" (replaces -1) (("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (grind) nil nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (reveal -12) (("2" (replaces -1) (("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr(idxs_)") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (inst -7 "-2 - j + power") (("1" (replace -2 -7) (("1" (case "nth(append(take[nat](nwidxs, -2 - j + power), idxs_), -2 - j + power) = car(idxs_)") (("1" (replace -1 -8) (("1" (replace -8 2) (("1" (lemma "C_symmetry") (("1" (inst -1 "power" "j") (("1" (replaces -1) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](nwidxs, -2 - j + power), idxs_), -2 - j + power) =
       nth(idxs_, -2 - j + power - length(take[nat](nwidxs, -2 - j + power)))") (("1" (replaces -1) (("1" (case "length(take[nat](nwidxs, - 2 - j + power)) = -2 - j + power") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nwidxs") (("2" (assert) (("2" (flatten) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (typepred "nwidxs") (("1" (assert) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (reveal -12) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (hide 4) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (reveal -12) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 7) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (case "-1 - j + power = -2 - j + power + 1") (("1" (replaces -1) (("1" (name "m" "-2 - j + power") (("1" (case "m >= 0") (("1" (replaces -2) (("1" (generalize "m" "m" "nat") (("1" (generalize "nwidxs" "l" "list[nat]") (("1" (generalize "idxs_" "l2" "(cons?[nat])") (("1" (induct "m" :name "NAT_induction") (("1" (skolem 1 "m_") (("1" (flatten) (("1" (skeep) (("1" (case "m_ = 0") (("1" (replaces -1) (("1" (hide -1 -2) (("1" (grind) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (expand "take" -3) (("2" (lift-if -3) (("2" (split -3) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) (("2" (inst -2 "m_-1") (("2" (assert) (("2" (expand "append" -1) (("2" (inst -2 "l2" "cdr(l)") (("2" (split -2) (("1" (expand "take" 3) (("1" (lift-if 3) (("1" (split 3) (("1" (flatten) (("1" (grind) (("1" (replace -2 :dir rl) (("1" (apply-extensionality :hide? t) nil nil)) nil) ("2" (replace -2 :dir rl) (("2" (apply-extensionality :hide? t) nil nil)) nil) ("3" (replace -2 :dir rl) (("3" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "append" 2) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "B" "append(take[nat](cdr(l), m_ - 1), l2)") (("2" (replaces -1) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("4" (expand "length" -5) (("4" (assert) nil nil)) nil)) nil) ("2" (split 1) (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (typepred "idxs_") (("2" (expand "ordered_list?" -2) (("2" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 -4 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (hide-all-but (-1 3 5)) (("2" (typepred "nth[[nat, nzBaseType]](pd(Xa), 0)`2") (("2" (expand "nth") (("2" (use "expt_nonzero") (("2" (expand "/=" :assert? none) (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (hide 1) (("1" (use "expt_nonzero") (("1" (expand "/=") (("1" (typepred "C(power, power - j)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil) ("7" (hide-all-but 1) (("7" (grind) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil) ("7" (flatten) (("7" (grind) nil nil)) nil) ("8" (hide-all-but 1) (("8" (grind) nil nil)) nil) ("9" (hide-all-but 1) (("9" (grind) nil nil)) nil) ("10" (hide-all-but 1) (("10" (grind) nil nil)) nil) ("11" (hide-all-but 1) (("11" (grind) nil nil)) nil) ("12" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (reveal -1) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (use "expt_nonzero") (("1" (expand "nth") (("1" (typepred "car(pd(Xa))`2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "power=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (eval_ac_noise const-decl "real" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (next_idx const-decl "nat" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (C_n_1 formula-decl nil binomial reals) (take def-decl "list[T]" more_list_props structures) (eval_pd_noise def-decl "real" affine nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (C const-decl "posnat" binomial reals) (last_idx const-decl "int" indexed_list structures) (C_symmetry formula-decl nil binomial reals) (length_take formula-decl nil more_list_props structures) (factorial def-decl "posnat" factorial ints) (nth_append formula-decl nil more_list_props structures) (C_0 formula-decl nil binomial reals) (sigma_0_neg formula-decl nil sigma_nat reals) (C_n formula-decl nil binomial reals) (sigma def-decl "real" sigma reals) (binomial_theorem formula-decl nil polynomials reals) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (containment_pow_var_ac-1 nil 3630865140 ("" (skeep) (("" (expand "pow_var_ac") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (expand_ol) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (lift-if -1) (("2" (split 2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (replaces -2 :dir RL) (("1" (assert) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (case "cdr_ol(pd(Xa))=null") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -2) (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (split 1) (("1" (flatten) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (reveal -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 2 2) (("1" (expand "pow_var_compatible?") (("1" (inst -1 "power-2") (("1" (replaces -1) (("1" (assert) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "cdr_ol(pd(Xa))=null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (replaces -2 :dir RL) (("1" (use "binomial_theorem") (("1" (replaces -1) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (expand "sigma" 1) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (assert) (("1" (use "C_n") (("1" (replaces -1) (("1" (assert) (("1" (use "identity_mult") (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (expand "sigma") (("1" (expand "nth") (("1" (use "expt_x1") (("1" (replaces -1) (("1" (lemma "C_n_1") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (assert) (("1" (case "get_noise_by_idx(car(pd(Xa))`1, N) *
                                                                                                                                      (cv(Xa) ^ (power - 1) * car(pd(Xa))`2 * power) = (cv(Xa) ^ (power - 1)) * get_noise_by_idx(car(pd(Xa))`1, N) *
                                                                                                                                       car(pd(Xa))`2
                                                                                                                                       * power") (("1" (replaces -1) (("1" (assert) (("1" (typepred "nwidxs") (("1" (hide -1 -2) (("1" (assert) (("1" (flatten) (("1" (name "idxs" "nwidxs") (("1" (replace -1 (-2 -3 +)) (("1" (name "step" "2") (("1" (case "2<=step AND step<=power") (("1" (replaces -2 (1 -4)) (("1" (case "nwidxs = append(take[nat](nwidxs, step-2), idxs)") (("1" (name "bstep" "power - step") (("1" (case "step = power - bstep") (("1" (replace -2 (1 -6)) (("1" (replaces -1 (1 -3 -4)) (("1" (hide -1) (("1" (flatten) (("1" (hide -4) (("1" (generalize "idxs" "idxs_" "{idxs:ordered_list[nat,restrict[[real, real], [nat, nat], boolean](<)] | NOT null?(idxs) AND car(idxs) >= next_idx(pd(Xa)) }") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (generalize "bstep" "bstep" "{ bstep:nat | 2 <= power - bstep
                                                                                                                 AND power - bstep <= power}") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (induct "bstep" :name "NAT_induction") (("1" (ground) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "sigma" 1) (("2" (assert) (("2" (expand "pow_var_pd" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "j=0") (("1" (replaces -1) (("1" (assert) (("1" (hide -2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (inst -7 "power -2") (("1" (replaces -2) (("1" (case "nth(append(take[nat](nwidxs, power - 2), idxs_), power - 2) = car(idxs_)") (("1" (replaces -1) (("1" (replaces -6) (("1" (assert) (("1" (use "C_0") (("1" (replaces -1) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](nwidxs, power - 2), idxs_), power - 2) =
       nth(idxs_, power - 2 - length(take[nat](nwidxs, power - 2)))") (("1" (replaces -1) (("1" (case "length(take[nat](nwidxs, power - 2)) = power -2") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nwidxs") (("2" (assert) (("2" (flatten) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (assert) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (reveal -12) (("2" (replaces -1) (("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (grind) nil nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (reveal -12) (("2" (replaces -1) (("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr(idxs_)") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (inst -7 "-2 - j + power") (("1" (replace -2 -7) (("1" (case "nth(append(take[nat](nwidxs, -2 - j + power), idxs_), -2 - j + power) = car(idxs_)") (("1" (replace -1 -8) (("1" (replace -8 2) (("1" (lemma "C_symmetry") (("1" (inst -1 "power" "j") (("1" (replaces -1) (("1" (use "mult_expt") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](nwidxs, -2 - j + power), idxs_), -2 - j + power) =
       nth(idxs_, -2 - j + power - length(take[nat](nwidxs, -2 - j + power)))") (("1" (replaces -1) (("1" (case "length(take[nat](nwidxs, - 2 - j + power)) = -2 - j + power") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nwidxs") (("2" (assert) (("2" (flatten) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (typepred "nwidxs") (("1" (assert) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (reveal -12) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (hide 4) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (reveal -12) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" 7) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (case "-1 - j + power = -2 - j + power + 1") (("1" (replaces -1) (("1" (name "m" "-2 - j + power") (("1" (case "m >= 0") (("1" (replaces -2) (("1" (generalize "m" "m" "nat") (("1" (generalize "nwidxs" "l" "list[nat]") (("1" (generalize "idxs_" "l2" "(cons?[nat])") (("1" (induct "m" :name "NAT_induction") (("1" (skolem 1 "m_") (("1" (flatten) (("1" (skeep) (("1" (case "m_ = 0") (("1" (replaces -1) (("1" (hide -1 -2) (("1" (grind) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (expand "take" -3) (("2" (lift-if -3) (("2" (split -3) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) (("2" (inst -2 "m_-1") (("2" (assert) (("2" (expand "append" -1) (("2" (inst -2 "l2" "cdr(l)") (("2" (split -2) (("1" (expand "take" 3) (("1" (lift-if 3) (("1" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "append" 2) (("2" (replaces -1 :dir RL) (("2" (apply-extensionality 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "B" "append(take[nat](cdr(l), m_ - 1), l2)") (("2" (replaces -1) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("4" (expand "length" -5) (("4" (assert) nil nil)) nil)) nil) ("2" (split 1) (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (typepred "idxs_") (("2" (expand "ordered_list?" -2) (("2" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 -4 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (hide-all-but (-1 3 5)) (("2" (typepred "nth[[nat, nzBaseType]](pd(Xa), 0)`2") (("2" (expand "nth") (("2" (use "expt_nonzero") (("2" (expand "/=" :assert? none) (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (hide 1) (("1" (use "expt_nonzero") (("1" (expand "/=") (("1" (typepred "C(power, power - j)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil) ("7" (hide-all-but 1) (("7" (grind) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (grind) nil nil)) nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil) ("7" (flatten) (("7" (grind) nil nil)) nil) ("8" (hide-all-but 1) (("8" (grind) nil nil)) nil) ("9" (hide-all-but 1) (("9" (grind) nil nil)) nil) ("10" (hide-all-but 1) (("10" (grind) nil nil)) nil) ("11" (hide-all-but 1) (("11" (grind) nil nil)) nil) ("12" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (reveal -1) (("2" (replaces -1 :dir RL) (("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (use "zero_times3") (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (hide -2) (("1" (use "expt_nonzero") (("1" (expand "nth") (("1" (typepred "car(pd(Xa))`2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "power=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (binomial_theorem formula-decl nil polynomials reals) (sigma def-decl "real" sigma reals) (C_n formula-decl nil binomial reals) (sigma_0_neg formula-decl nil sigma_nat reals) (C_0 formula-decl nil binomial reals) (nth_append formula-decl nil more_list_props structures) (factorial def-decl "posnat" factorial ints) (length_take formula-decl nil more_list_props structures) (C_symmetry formula-decl nil binomial reals) (last_idx const-decl "int" indexed_list structures) (C const-decl "posnat" binomial reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (eval_pd_noise def-decl "real" affine nil) (take def-decl "list[T]" more_list_props structures) (C_n_1 formula-decl nil binomial reals) (get_noise_by_idx def-decl "Epsilon" affine nil) (next_idx const-decl "nat" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil)) nil)) (notmember_ol_nat_TCC1 0 (notmember_ol_nat_TCC1-1 nil 3632648611 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures)) nil (notmember_ol_nat subtype "affine_pow.ol" "(list_adt[nat].cons?)"))) (notmember_ol_nat 0 (notmember_ol_nat-1 nil 3632764378 ("" (induct "ol") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("h" "t")) (("3" (flatten) (("3" (skeep) (("3" (expand "member" -4) (("3" (split -4) (("1" (grind) nil nil) ("2" (split -2) (("1" (inst?) (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) shostak)) (pow_var_compatible_noise_TCC1 0 (pow_var_compatible_noise_TCC1-1 nil 3630864964 ("" (grind) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (last_idx const-decl "int" indexed_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) nil (pow_var_compatible_noise subtype "pd(affine_pow.Xa)" "(list_adt[[nat, nzBaseType]].cons?)"))) (pow_var_compatible_noise_TCC2 0 (pow_var_compatible_noise_TCC2-1 nil 3630864964 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (/= const-decl "boolean" notequal nil)) nil (pow_var_compatible_noise subtype "((number_fields.+)(2, affine_pow.i))" "{i: integers.int | booleans.OR(affine.get_noise_by_idx(list_adt[[nat, nzBaseType]].car(pd(affine_pow.Xa))`1, affine_pow.N) /= 0, reals.>=(i, 0))}"))) (pow_var_compatible_noise 0 (pow_var_compatible_noise-3 "" 3743879395 ("" (skeep) (("" (expand "pow_var_compatible?") (("" (skolem 1 "i") (("" (use "gnbi_updb") (("1" (replaces -1) (("1" (use "gnbi_updb_2") (("1" (split -1) (("1" (replaces -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 1) (("2" (expand "nth") (("2" (use "notmember_ol_nat") (("2" (assert) (("2" (typepred "nwidxs") (("2" (typepred "Xa") (("2" (assert) (("2" (flatten) (("2" (case "NOT null?(nwidxs)") (("1" (assert) (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(Xa))") (("1" (assert) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "Xa") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((pow_var_compatible? const-decl "bool" affine_pow nil) (gnbi_updb formula-decl nil affine nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (next_idx const-decl "nat" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ordered_list type-eq-decl nil ordered_list structures) (restrict const-decl "R" restrict nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (N skolem-const-decl "Noise" affine_pow nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (represents_var? const-decl "bool" affine nil) (> const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (Xa skolem-const-decl "{Xa | represents_var?(Xa) AND length(pd(Xa)) > 0}" affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (gnbi_updb_2 formula-decl nil affine nil) (notmember_ol_nat formula-decl nil affine_pow nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx const-decl "int" indexed_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (car_ol const-decl "T" ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (TRUE const-decl "bool" booleans nil) (nil application-judgement "above(n)" exp2 nil) (real_times_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (expt def-decl "real" exponentiation nil) (upd_noise_burst const-decl "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (pow_var_compatible_noise-2 "" 3632486994 ("" (skeep) (("" (expand "pow_var_compatible?") (("" (skolem 1 "i") (("" (use "gnbi_updb") (("1" (replaces -1) (("1" (use "gnbi_updb_2") (("1" (split -1) (("1" (replaces -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 1) (("2" (expand "nth") (("2" (use "notmember_ol_nat") (("2" (assert) (("2" (typepred "nwidxs") (("2" (typepred "Xa") (("2" (assert) (("2" (flatten) (("2" (case "NOT null?(nwidxs)") (("1" (assert) (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(Xa))") (("1" (assert) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "Xa") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((gnbi_updb formula-decl nil affine nil) (next_idx const-decl "nat" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (gnbi_updb_2 formula-decl nil affine nil) (last_idx const-decl "int" indexed_list structures) (car_ol const-decl "T" ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (upd_noise_burst const-decl "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (pow_var_compatible_noise-1 nil 3630865179 ("" (skeep) (("" (expand "pow_var_compatible?") (("" (induct "i_1") (("1" (flatten) (("1" (assert) (("1" (use "gnbi_updr") (("1" (assert) (("1" (replaces -1) (("1" (use "gnbi_updr_2") (("1" (assert) (("1" (hide 2) (("1" (typepred "newidx") (("1" (expand "next_idx") (("1" (flatten) (("1" (expand "last_idx") (("1" (typepred "Xa") (("1" (lift-if -3) (("1" (split -3) (("1" (flatten) (("1" (expand "nth") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (use "power_Epsilon_judg") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (use "power_Epsilon_judg") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (lemma "gnbi_updr") (("2" (inst? -1 :where 1) (("1" (assert) (("1" (replaces -1) (("1" (lemma "gnbi_updr_2") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (hide-all-but 1) (("1" (typepred "newidx") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (expand "nth") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "Xa") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (use "power_Epsilon_judg") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (use "power_Epsilon_judg") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (use "power_Epsilon_judg") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gnbi_updr formula-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (last_idx const-decl "int" indexed_list structures) (gnbi_updr_2 formula-decl nil affine nil) (upd_noise_range def-decl "Noise" affine nil) (next_idx const-decl "nat" affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil)) nil)) (powvar_comp_noise_extension_TCC1 0 (powvar_comp_noise_extension_TCC1-1 nil 3632131382 ("" (subtype-tcc) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (nzBaseType type-eq-decl nil affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (next_idx const-decl "nat" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (last_ol def-decl "T" ordered_list structures) (take def-decl "list[T]" more_list_props structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (powvar_comp_noise_extension subtype "(number_fields.-)(affine_pow.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_pow.nextfreeidx, e)}"))) (powvar_comp_noise_extension_TCC2 0 (powvar_comp_noise_extension_TCC2-1 nil 3632131382 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil)) nil (powvar_comp_noise_extension subtype "pd(affine_pow.varac)" "(list_adt[[nat, nzBaseType]].cons?)"))) (powvar_comp_noise_extension_TCC3 0 (powvar_comp_noise_extension_TCC3-1 nil 3632131382 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil)) nil (powvar_comp_noise_extension subtype "((number_fields.+)((number_fields.+)(1, affine_pow.i), affine_pow.power1))" "{i: integers.int | booleans.OR(affine.get_noise_by_idx(list_adt[[nat, nzBaseType]].car(pd(affine_pow.varac))`1, affine_pow.N) /= 0, reals.>=(i, 0))}"))) (powvar_comp_noise_extension_TCC4 0 (powvar_comp_noise_extension_TCC4-1 nil 3632131382 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil)) nil (powvar_comp_noise_extension subtype "(number_fields.-)(affine_pow.power1, 1)" "nat"))) (powvar_comp_noise_extension_TCC5 0 (powvar_comp_noise_extension_TCC5-2 nil 3632764282 ("" (skeep) (("" (typepred "varac") (("" (split 2) (("1" (name "app_" "append_ol[nat,<](take[nat](idxs, power1 - 1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "append_ol[nat, restrict[[real, real], [nat, nat], boolean](<)]
                      (take[nat](idxs, power1 - 1), nats(nextfreeidx, newoff - 1))") (("1" (expand "append_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1) (("1" (typepred "nextfreeidx") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "power2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "power2") (("3" (replaces -4) (("3" (case "nextfreeidx + (power2 - power1)  > 0") (("1" (assert) nil nil) ("2" (case "power2 - power1 >0") (("1" (case "nextfreeidx >= 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (use "take_ol[nat,<]") nil nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4) (("1" (typepred "idxs") (("1" (assert) (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "power2") (("2" (replaces -4) (("2" (case "nextfreeidx + (power2 - power1)  > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "nextfreeidx >= 0") (("1" (case "power2 - power1 >0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (typepred "power2") (("2" (case "nextfreeidx + (power2 - power1)  > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "nextfreeidx >= 0") (("1" (case "power2 - power1 >0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "car[nat]
                                (append[nat]
                                     (take[nat](idxs, power1 - 1),
                                      nats(nextfreeidx, newoff - 1))) = car(idxs)") (("1" (replaces -1) (("1" (typepred "idxs") (("1" (split -3) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (expand "length") (("2" (typepred "power1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (typepred "idxs") (("1" (assert) (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "take" 2 1) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (typepred "idxs") (("1" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "idxs") (("3" (assert) (("3" (typepred "power1") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (replaces -3) (("4" (typepred "power2") (("4" (case "nextfreeidx + (power2 - power1)  > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "nextfreeidx >= 0") (("1" (case "power2 - power1 >0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (append def-decl "list[T]" list_props nil) (length_append formula-decl nil list_props nil) (newoff skolem-const-decl "int" affine_pow nil) (length_take formula-decl nil more_list_props structures) (last_idx const-decl "int" indexed_list structures) (nil application-judgement "above(n)" exp2 nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (power1 skolem-const-decl "above(1)" affine_pow nil) (varac skolem-const-decl "{varac: (represents_var?) | NOT null?(pd(varac))}" affine_pow nil) (idxs skolem-const-decl "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   (length(idxs) > power1 - 2 AND
     (NOT null?(idxs) IMPLIES car(idxs) >= next_idx(pd(varac))))
    OR length(pd(varac)) = 0}" affine_pow nil) (nextfreeidx skolem-const-decl "above(last_ol[nat, restrict[[real, real], [nat, nat], bool](<)]
          (take[nat](idxs, power1 - 1)))" affine_pow nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (last_ol def-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (ordered_list type-eq-decl nil ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (first_ol const-decl "T" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (cons_ol const-decl "ordered_list" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (take_ol formula-decl nil ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (powvar_comp_noise_extension subtype "list_props[nat].append(more_list_props[nat].take(affine_pow.idxs, (number_fields.-)(affine_pow.power1, 1)), affine_pow.nats(affine_pow.nextfreeidx, (number_fields.-)(affine_pow.newoff, 1)))" "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(nwidxs), (number_fields.-)(affine_pow.power2, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(nwidxs)), reals.>=(list_adt[nat].car(nwidxs), affine.next_idx(pd(affine_pow.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_pow.varac)) = 0)}")) (powvar_comp_noise_extension_TCC5-1 nil 3632131382 ("" (subtype-tcc) nil nil) nil nil (powvar_comp_noise_extension subtype "list_props[nat].append(more_list_props[nat].take(affine_pow.idxs, (number_fields.-)(affine_pow.power1, 1)), affine_pow.nats(affine_pow.nextfreeidx, (number_fields.-)(affine_pow.newoff, 1)))" "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(nwidxs), (number_fields.-)(affine_pow.power2, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(nwidxs)), reals.>=(list_adt[nat].car(nwidxs), affine.next_idx(pd(affine_pow.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_pow.varac)) = 0)}"))) (powvar_comp_noise_extension 0 (powvar_comp_noise_extension-2 "" 3789918349 ("" (deftactic solve_tcc1 (then (typepred "power2") (hide-all-but (-1 1)) (spread (case "-1 - power1 + nextfreeidx + power2 = nextfreeidx + ((power2 - power1) - 1)") ((then (replaces -1) (spread (case "((power2 - power1) - 1) >= 0") ((then (hide -2) (name-replace "A" "((power2 - power1) - 1)") (typepred "nextfreeidx") (grind)) (grind)))) (assert))))) (("" (skeep) (("" (beta) (("" (flatten) (("" (expand "pow_var_compatible?" (-1 1)) (("" (flatten) (("" (assert) (("" (skolem 1 "i2") (("" (use "gnbi_updb_2") (("1" (split -1) (("1" (replaces -1) (("1" (case "i2<power1-1") (("1" (inst -2 "i2") (("1" (case "nth(append(take(idxs, power1 - 1),
                 nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)),
          i2)
       = nth(take(idxs, power1 - 1), i2)") (("1" (replaces -1) (("1" (lemma "nth_take2[nat]") (("1" (inst -1 "idxs" "power1-1" "i2") (("1" (replaces -1) (("1" (use "gnbi_updb_2") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide 1) (("2" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (lemma "last_take_nth[nat,<]") (("1" (inst? -1 :where -2) (("1" (assert) (("1" (replaces -1) (("1" (expand ">") (("1" (case "i2 = power1 - 2") (("1" (replaces -1 :dir RL) (("1" (assert) nil nil)) nil) ("2" (case "i2 < power1 - 2") (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "idxs" "power1-2" "i2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (solve_tcc1) nil nil)) nil) ("3" (hide-all-but (1 -3)) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "i2 < length[nat](take[nat](idxs, power1 - 1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (solve_tcc1) nil nil)) nil)) nil) ("3" (hide 2) (("3" (use "length_take[nat]") (("3" (replaces -1) (("3" (typepred "idxs") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (solve_tcc1) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (case "nth(append(take(idxs, power1 - 1),
                 nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)),
          i2)
       =
       nth(nats(nextfreeidx, -1 - power1 + nextfreeidx + power2),
           i2 - length(take(idxs, power1 - 1)))") (("1" (replaces -1) (("1" (case "length(take(idxs, power1 - 1)) = power1 -1 ") (("1" (replaces -1) (("1" (case "nth(nats(nextfreeidx, -1 - power1 + nextfreeidx + power2),
                                                                                       i2 - (power1 - 1)) = nextfreeidx + i2 - (power1 - 1)") (("1" (replaces -1) (("1" (lemma "gnbi_updb") (("1" (inst -1 "N" "nextfreeidx + i2 - (power1 - 1)" "LAMBDA (i: nat):
                                                                               (get_noise_by_idx(car(pd(varac))`1, N) ^
                                                                                 (1 + i + power1))" "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)" "i2 - (power1 - 1)") (("1" (split -1) (("1" (replace -1 2 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (split 1) (("1" (grind) nil nil) ("2" (typepred "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)") (("2" (replace -4 2 :hide? t) (("2" (typepred "i2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (solve_tcc1) nil nil)) nil) ("4" (hide 3) (("4" (hide-all-but (1 -1)) (("4" (skeep) (("4" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (typepred "nextfreeidx") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)") (("2" (typepred "i2") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (case "length(take(idxs, power1 - 1)) = power1 -1 ") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (typepred "power2") (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("3" (split 1) (("1" (hide 3) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (typepred "idxs") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (typepred "power2") (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (solve_tcc1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (use "last_take_nth[nat,<]") (("1" (assert) (("1" (replaces -1) (("1" (typepred "idxs") (("1" (assert) (("1" (flatten) (("1" (split -4) (("1" (expand ">=") (("1" (expand ">") (("1" (case "car(pd(varac))`1 <= next_idx(pd(varac))") (("1" (case "nextfreeidx <= next_idx(pd(varac))") (("1" (case "nextfreeidx <=  car(idxs)") (("1" (case "car(idxs) <= nth(idxs, power1 - 2)") (("1" (assert) nil nil) ("2" (typepred "power1") (("2" (case "power1=2") (("1" (replaces -1) (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "nth_ol[nat,<]") (("2" (inst -1 "idxs" "power1 - 2" "0") (("1" (expand "nth" -1 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (solve_tcc1) nil nil)) nil) ("3" (hide-all-but (1 -2)) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (append def-decl "list[T]" list_props nil) (nth_take2 formula-decl nil more_list_props structures) (expt def-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (last_idx const-decl "int" indexed_list structures) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (member_nats formula-decl nil affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (last_take_nth formula-decl nil ordered_list structures) (nil application-judgement "above(n)" exp2 nil) (length_take formula-decl nil more_list_props structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (i2 skolem-const-decl "below(power2 - 1)" affine_pow nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gnbi_updb formula-decl nil affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (upd_noise_burst const-decl "Noise" affine nil) (upd_noise_burst_ def-decl "Noise" affine nil) (length_append formula-decl nil list_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (olidx_car_last formula-decl nil indexed_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (power1 skolem-const-decl "above(1)" affine_pow nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (N skolem-const-decl "Noise" affine_pow nil) (varac skolem-const-decl "{varac: (represents_var?) | NOT null?(pd(varac))}" affine_pow nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (power2 skolem-const-decl "above(power1)" affine_pow nil) (nextfreeidx skolem-const-decl "above(last_ol[nat, restrict[[real, real], [nat, nat], bool](<)]
          (take(idxs, power1 - 1)))" affine_pow nil) (idxs skolem-const-decl "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   (length(idxs) > power1 - 2 AND
     (NOT null?(idxs) IMPLIES car(idxs) >= next_idx(pd(varac))))
    OR length(pd(varac)) = 0}" affine_pow nil) (next_idx const-decl "nat" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (take def-decl "list[T]" more_list_props structures) (last_ol def-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (below type-eq-decl nil naturalnumbers nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (gnbi_updb_2 formula-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (powvar_comp_noise_extension-1 nil 3632649341 ("" (deftactic solve_tcc1 (then (typepred "power2") (hide-all-but (-1 1)) (spread (case "-1 - power1 + nextfreeidx + power2 = nextfreeidx + ((power2 - power1) - 1)") ((then (replaces -1) (spread (case "((power2 - power1) - 1) >= 0") ((then (hide -2) (name-replace "A" "((power2 - power1) - 1)") (typepred "nextfreeidx") (grind)) (grind)))) (assert))))) (("" (skeep) (("" (beta) (("" (flatten) (("" (expand "pow_var_compatible?" (-1 1)) (("" (flatten) (("" (assert) (("" (skolem 1 "i2") (("" (use "gnbi_updb_2") (("1" (split -1) (("1" (replaces -1) (("1" (case "i2<power1-1") (("1" (inst -2 "i2") (("1" (case "nth(append(take(idxs, power1 - 1),
                 nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)),
          i2)
       = nth(take(idxs, power1 - 1), i2)") (("1" (replaces -1) (("1" (lemma "nth_take2[nat]") (("1" (inst -1 "idxs" "power1-1" "i2") (("1" (replaces -1) (("1" (use "gnbi_updb_2") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide 1) (("2" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (lemma "last_take_nth[nat,<]") (("1" (inst? -1 :where -2) (("1" (assert) (("1" (replaces -1) (("1" (expand ">") (("1" (case "i2 = power1 - 2") (("1" (replaces -1 :dir RL) (("1" (assert) nil nil)) nil) ("2" (case "i2 < power1 - 2") (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "idxs" "power1-2" "i2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (solve_tcc1) nil nil)) nil) ("3" (hide-all-but (1 -3)) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "i2 < length[nat](take[nat](idxs, power1 - 1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (solve_tcc1) nil nil)) nil)) nil) ("3" (hide 2) (("3" (use "length_take[nat]") (("3" (replaces -1) (("3" (typepred "idxs") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (solve_tcc1) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (case "nth(append(take(idxs, power1 - 1),
                 nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)),
          i2)
       =
       nth(nats(nextfreeidx, -1 - power1 + nextfreeidx + power2),
           i2 - length(take(idxs, power1 - 1)))") (("1" (replaces -1) (("1" (case "length(take(idxs, power1 - 1)) = power1 -1 ") (("1" (replaces -1) (("1" (case "nth(nats(nextfreeidx, -1 - power1 + nextfreeidx + power2),
                                                                                       i2 - (power1 - 1)) = nextfreeidx + i2 - (power1 - 1)") (("1" (replaces -1) (("1" (lemma "gnbi_updb") (("1" (inst -1 "N" "nextfreeidx + i2 - (power1 - 1)" "LAMBDA (i: nat):
                                                                               (get_noise_by_idx(car(pd(varac))`1, N) ^
                                                                                 (1 + i + power1))" "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)" "i2 - (power1 - 1)") (("1" (split -1) (("1" (replace -1 2 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (split 1) (("1" (grind) nil nil) ("2" (typepred "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)") (("1" (replace -4 2 :hide? t) (("1" (typepred "i2") (("1" (grind) nil nil)) nil)) nil) ("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (solve_tcc1) nil nil)) nil) ("4" (hide 3) (("4" (hide-all-but (1 -1)) (("4" (skeep) (("4" (use "power_Epsilon_is_Epsilon") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 3) (("5" (typepred "nextfreeidx") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "nats(nextfreeidx, -1 - power1 + nextfreeidx + power2)") (("2" (typepred "i2") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (case "length(take(idxs, power1 - 1)) = power1 -1 ") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (typepred "power2") (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("3" (split 1) (("1" (hide 3) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (typepred "idxs") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1) (("1" (use "length_take[nat]") (("1" (replaces -1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand ">") (("2" (typepred "idxs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (typepred "power2") (("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (solve_tcc1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (use "last_take_nth[nat,<]") (("1" (assert) (("1" (replaces -1) (("1" (typepred "idxs") (("1" (assert) (("1" (flatten) (("1" (split -4) (("1" (expand ">=") (("1" (expand ">") (("1" (case "car(pd(varac))`1 <= next_idx(pd(varac))") (("1" (case "nextfreeidx <= next_idx(pd(varac))") (("1" (case "nextfreeidx <=  car(idxs)") (("1" (case "car(idxs) <= nth(idxs, power1 - 2)") (("1" (assert) nil nil) ("2" (typepred "power1") (("2" (case "power1=2") (("1" (replaces -1) (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "nth_ol[nat,<]") (("2" (inst -1 "idxs" "power1 - 2" "0") (("1" (expand "nth" -1 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "idxs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (solve_tcc1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (solve_tcc1) nil nil)) nil) ("3" (hide-all-but (1 -2)) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nth_take2 formula-decl nil more_list_props structures) (last_idx const-decl "int" indexed_list structures) (nth_ol formula-decl nil ordered_list structures) (last_take_nth formula-decl nil ordered_list structures) (length_take formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (gnbi_updb formula-decl nil affine nil) (upd_noise_burst const-decl "Noise" affine nil) (upd_noise_burst_ def-decl "Noise" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (represents_var? const-decl "bool" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (take def-decl "list[T]" more_list_props structures) (last_ol def-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (gnbi_updb_2 formula-decl nil affine nil)) shostak)))
