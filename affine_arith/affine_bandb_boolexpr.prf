(affine_bandb_boolexpr (evaluate_TCC1 0 (evaluate_TCC1-1 nil 3639820331 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (ProperBox type-eq-decl nil box interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (band? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bor? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (brel? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bite? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (BoolExpr type-eq-decl nil IntervalExpr_adt interval_arith) (listn_0 name-judgement "listn[real](0)" affine_bandb_boolexpr nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (first_noise_idx_available_box const-decl "nat" affine_boolexpr nil) (mk_CDBB const-decl "CDBB(initial_bexpr, initial_box, first_added_idx)" affine_boolexpr nil) (BEval_Box const-decl "CDBB(initial_bexpr, initial_box, first_added_idx)" affine_boolexpr nil) (slice const-decl "real" interval interval_arith) (midpoint const-decl "real" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith) (real_plus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (evaluate subtype "IF booleans.AND(Maybe[bool].some?(affine_bandb_boolexpr.bef), (booleans.NOT)(Maybe[bool].val(affine_bandb_boolexpr.bef))) THEN list_adt_map[Interval, real].map(LAMBDA (i: interval.Interval): interval.midpoint(i))(affine_bandb_boolexpr.box) ELSE list_adt[real].null ENDIF" "{l: list_adt[real].list | booleans.IMPLIES(list_adt[real].cons?(l), booleans.AND(Maybe[bool].some?(affine_bandb_boolexpr.bef), (booleans.NOT)((Maybe[bool].val(affine_bandb_boolexpr.bef)))))}"))) (bandb_boolexpr_soundness 0 (bandb_boolexpr_soundness-2 "" 3640114012 ("" (skeep) (("" (lemma "b_and_b_id_sound") (("" (expand "bandb_boolexpr") (("" (inst?) (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "accomodates?") (("1" (skeep) (("1" (expand "sound?") (("1" (flatten) (("1" (name-replace "ev" "evaluate(dom, obj)" :hide? nil) (("1" (copy -1) (("1" (expand "evaluate" -1 :assert? none) (("1" (skoletin* -1) (("1" (decompose-equality -1) (("1" (lemma "BEval_inclusion_Proper____") (("1" (case "some?(bet)") (("1" (case "some?(bev) AND some?(val(bev))") (("1" (flatten) (("1" (assert) (("1" (replaces -8) (("1" (inst? -) (("1" (assert) (("1" (flatten) (("1" (typepred "ev`counterex") (("1" (hide -1) (("1" (assert) (("1" (assert) (("1" (case-replace "list2array(0)(counterex(ev)) = midvars(dom)") (("1" (assert) (("1" (skeep) (("1" (lemma "BEval_inclusion____") (("1" (inst -1 "dom" "midvars(dom)" "obj") (("1" (beta) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (lemma "map_length[Interval,real]") (("2" (inst?) (("2" (decompose-equality 1) (("2" (lemma "list2array_sound") (("2" (inst?) (("2" (expand "midvars") (("2" (case-replace "x!1 < length(counterex(ev))") (("1" (assert) (("1" (replaces -2) (("1" (replaces -3 :dir rl) (("1" (rewrite "map_nth_rw") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 -1 :hide? t) (("2" (lift-if -1) (("2" (assert) (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "some?(BEval_(obj, Midbox(dom))) AND
           some?(val(BEval_(obj, Midbox(dom)))) AND
            NOT val(val(BEval_(obj, Midbox(dom))))") (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (case-replace "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (skeep) (("1" (rewrite "length_Midbox") (("1" (inst? -1) (("1" (lemma "Midbox_Inclusion") (("1" (inst?) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? -) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (lemma "BEval_inclusion____") (("2" (inst? - :where -7) (("2" (inst? -) (("1" (beta) (("1" (assert) (("1" (case-replace "list2array(0)(counterex(ev)) = midvars(dom)") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (lemma "map_length[Interval,real]") (("2" (inst?) (("2" (decompose-equality 1) (("2" (lemma "list2array_sound") (("2" (inst?) (("2" (expand "midvars") (("2" (case-replace "x!1 < length(counterex(ev))") (("1" (assert) (("1" (replaces -2) (("1" (replaces -3 :dir rl) (("1" (rewrite "map_nth_rw") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_in_box?" 1) (("2" (skeep) (("2" (expand "Midbox" 1) (("2" (rewrite "map_nth_rw") (("2" (replaces -4 1 :dir rl) (("2" (lemma "list2array_sound") (("2" (inst?) (("2" (rewrite "map_length") (("2" (replaces -1) (("2" (assert) (("2" (rewrite "map_nth_rw") (("2" (rewrite "r2i_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subdiv_presound?") (("2" (skeep) (("2" (expand "denorm") (("2" (expand "branch") (("2" (expand "subdivide") (("2" (expand "sound?") (("2" (flatten) (("2" (name-replace "COMB" "combine(v,ans1,ans)" :hide? nil) (("2" (expand "combine" -1) (("2" (case-replace "(some?(ans1`answer) AND NOT val(ans1`answer)) OR
                                                  (some?(ans`answer) AND NOT val(ans`answer))") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (beta) (("1" (flatten) (("1" (case-replace "some?(ans1`answer) AND NOT val(ans1`answer)") (("1" (flatten) (("1" (expand "sound_dir") (("1" (assert) (("1" (split -5) (("1" (flatten) (("1" (case "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (replace -1) (("1" (case-replace "length(split(v, dom)`1) = length(dom)") (("1" (skeep) (("1" (inst? -) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case-replace "cons?(ans1`counterex)") (("1" (flatten) (("1" (assert) (("1" (hide -6) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? :where 5) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (typepred "ans`counterex") (("2" (hide -1) (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (replace -1) (("1" (case-replace "length(split(v, dom)`2) = length(dom)") (("1" (skeep) (("1" (inst?) (("1" (hide -4) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case-replace "cons?(ans1`counterex)") (("1" (flatten) (("1" (assert) (("1" (hide -4) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? :where 6) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (typepred "ans`counterex") (("2" (hide -1) (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (assert) (("2" (hide -5) (("2" (flatten) (("2" (replace 3) (("2" (typepred "ans1`counterex") (("2" (hide -1) (("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case-replace "some?(ans1`answer) AND some?(ans`answer)") (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (beta) (("1" (assert) (("1" (typepred "ans1`counterex") (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (replaces -1 :dir rl) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subdiv_sound?") (("3" (skeep) (("3" (expand "denorm") (("3" (expand "branch") (("3" (expand "subdivide") (("3" (expand "sound?") (("3" (flatten) (("3" (name-replace "COMB" "combine(v,ans1,ans2)" :hide? nil) (("3" (expand "combine" -1) (("3" (lemma "split_Inclusion") (("3" (inst?) (("3" (beta) (("3" (flatten) (("3" (case-replace "(some?(ans1`answer) AND NOT val(ans1`answer)) OR
                                                  (some?(ans2`answer) AND NOT val(ans2`answer))") (("1" (case-replace "some?(ans1`answer) AND NOT val(ans1`answer)") (("1" (flatten) (("1" (assert) (("1" (replaces -4 :dir rl) (("1" (assert) (("1" (flatten) (("1" (case-replace "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (hide -4) (("1" (case-replace "length(split(v, dom)`1) = length(dom)") (("1" (skeep) (("1" (inst?) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case "cons?(ans1`counterex)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? :where 5) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -4) (("2" (typepred "ans2`counterex") (("2" (hide -1) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "vars_in_box_Inclusion") (("2" (inst? :where 8) (("2" (hide -4) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (assert) (("2" (flatten) (("2" (case-replace "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (hide -3) (("1" (case-replace "length(split(v, dom)`2) = length(dom)") (("1" (skeep) (("1" (inst? :where 3) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case "cons?(ans1`counterex)") (("1" (assert) (("1" (typepred "ans1`counterex") (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "vars_in_box_Inclusion") (("2" (inst? :where 7) (("2" (hide -3) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case-replace "some?(ans1`answer) AND some?(ans2`answer)") (("1" (flatten) (("1" (assert) (("1" (replaces -7 :dir rl) (("1" (assert) (("1" (typepred "ans1`counterex") (("1" (hide -1) (("1" (assert) (("1" (typepred "ans2`counterex") (("1" (hide -1) (("1" (assert) (("1" (skeep) (("1" (lemma "split_vars_in_box") (("1" (inst? -1) (("1" (inst?) (("1" (beta) (("1" (case-replace "length(split(v, dom)`1) = length(dom)") (("1" (case-replace "length(split(v, dom)`2) = length(dom)") (("1" (hide -7 -9) (("1" (hide (-1 -2)) (("1" (split -1) (("1" (hide -7) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -6) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (replaces -3 :dir rl) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (ProperBox type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (IntervalOutput type-eq-decl nil gbandb_boolexpr interval_arith) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (NOT const-decl "[bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (Maybe type-decl nil Maybe structures) (BoolExpr type-eq-decl nil IntervalExpr_adt interval_arith) (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bite? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (brel? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bor? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (band? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (b_and_b_id_sound formula-decl nil branch_and_bound structures) (Accumulator type-eq-decl nil branch_and_bound structures) (accumulate const-decl "IntervalOutput" gbandb_boolexpr interval_arith) (Brancher type-eq-decl nil branch_and_bound structures) (branch const-decl "[BoolExpr, BoolExpr]" gbandb_boolexpr interval_arith) (Combiner type-eq-decl nil branch_and_bound structures) (combine const-decl "IntervalOutput" gbandb_boolexpr interval_arith) (DirVar type-eq-decl nil branch_and_bound structures) (DenormAns type-eq-decl nil branch_and_bound structures) (denorm const-decl "IntervalOutput" gbandb_boolexpr interval_arith) (Evaluator type-eq-decl nil branch_and_bound structures) (evaluate const-decl "IntervalOutput" affine_bandb_boolexpr nil) (stack type-eq-decl nil stack structures) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (DirVarStack type-eq-decl nil branch_and_bound structures) (ExitPred type-eq-decl nil branch_and_bound structures) (ge_chk const-decl "bool" gbandb_boolexpr interval_arith) (LocalExitPred type-eq-decl nil branch_and_bound structures) (le_chk const-decl "bool" gbandb_boolexpr interval_arith) (prune_chk const-decl "bool" gbandb_boolexpr interval_arith) (DirVarSelector type-eq-decl nil branch_and_bound structures) (SoundPred type-eq-decl nil branch_and_bound structures) (sound? const-decl "bool" affine_bandb_boolexpr nil) (SubdivDomain type-eq-decl nil branch_and_bound structures) (subdivide const-decl "[ProperBox, ProperBox]" gbandb_boolexpr interval_arith) (subdiv_sound? const-decl "bool" branch_and_bound structures) (vs skolem-const-decl "(vars_in_box?(dom))" affine_bandb_boolexpr nil) (split_vars_in_box formula-decl nil interval_expr interval_arith) (dom skolem-const-decl "ProperBox" affine_bandb_boolexpr nil) (v skolem-const-decl "nat" affine_bandb_boolexpr nil) (vs skolem-const-decl "(vars_in_box?(split(v, dom)`1))" affine_bandb_boolexpr nil) (vs skolem-const-decl "(vars_in_box?(split(v, dom)`2))" affine_bandb_boolexpr nil) (subdiv_presound? const-decl "bool" branch_and_bound structures) (split_Inclusion formula-decl nil interval_expr interval_arith) (sound_dir const-decl "bool" branch_and_bound structures) (split def-decl "{lrb: [Box, Box] |
   LET (lb, rb) = lrb IN
     length(lb) = length(box) AND
      length(rb) = length(box) AND
       FORALL (i: below(length(box))):
         IF i = v
           THEN nth(lb, i) = HalfLeft(nth(box, i)) AND
                 nth(rb, i) = HalfRight(nth(box, i))
         ELSE nth(lb, i) = nth(box, i) AND nth(rb, i) = nth(box, i)
         ENDIF}" interval_expr interval_arith) (HalfRight const-decl "Interval" interval interval_arith) (HalfLeft const-decl "Interval" interval interval_arith) (dom skolem-const-decl "ProperBox" affine_bandb_boolexpr nil) (v skolem-const-decl "nat" affine_bandb_boolexpr nil) (vs skolem-const-decl "(vars_in_box?(split(v, dom)`1))" affine_bandb_boolexpr nil) (vs skolem-const-decl "(vars_in_box?(split(v, dom)`2))" affine_bandb_boolexpr nil) (split_Proper application-judgement "[ProperBox, ProperBox]" interval_expr interval_arith) (accomodates? const-decl "bool" branch_and_bound structures) (midvars const-decl "(vars_in_box?(pox))" box interval_arith) (vars_in_box? const-decl "bool" box interval_arith) (Env type-eq-decl nil box interval_arith) (list2array def-decl "T" array2list structures) (BEval_inclusion____ formula-decl nil affine_boolexpr nil) (map_length formula-decl nil more_map_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list2array_sound formula-decl nil array2list structures) (ev skolem-const-decl "IntervalOutput" affine_bandb_boolexpr nil) ([\|\|] const-decl "Interval" interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (r2i_inclusion formula-decl nil interval interval_arith) (dom skolem-const-decl "ProperBox" affine_bandb_boolexpr nil) (vs skolem-const-decl "(vars_in_box?(Midbox(dom)))" affine_bandb_boolexpr nil) (vars_in_box_Inclusion formula-decl nil box interval_arith) (Midbox_Inclusion formula-decl nil box interval_arith) (length_Midbox formula-decl nil box interval_arith) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (beval__ const-decl "bool" affine_boolexpr nil) (BEval_inclusion_Proper____ formula-decl nil affine_boolexpr nil) (listn_0 name-judgement "listn[real](0)" affine_bandb_boolexpr nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Midbox_Proper application-judgement "ProperBox" box interval_arith) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (None adt-constructor-decl "(none?)" Maybe structures) (Midbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (BEval_ const-decl "Maybe[Maybe[bool]]" affine_boolexpr nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (midpoint const-decl "real" interval interval_arith) (map adt-def-decl "list[T1]" list_adt_map nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bandb_boolexpr const-decl "Output" affine_bandb_boolexpr nil)) shostak) (bandb_boolexpr_soundness-1 nil 3639822946 ("" (skeep) (("" (lemma "b_and_b_id_sound") (("" (expand "bandb_boolexpr") (("" (inst?) (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "accomodates?") (("1" (skeep) (("1" (expand "sound?") (("1" (flatten) (("1" (name-replace "ev" "evaluate(dom, obj)" :hide? nil) (("1" (copy -1) (("1" (expand "evaluate" -1 :assert? none) (("1" (skoletin* -1) (("1" (decompose-equality -1) (("1" (lemma "BEval_inclusion_Proper____") (("1" (case "some?(bet)") (("1" (assert) (("1" (replaces -5) (("1" (inst? -) (("1" (assert) (("1" (flatten) (("1" (typepred "ev`counterex") (("1" (hide -1) (("1" (assert) (("1" (assert) (("1" (case-replace "list2array(0)(counterex(ev)) = midvars(dom)") (("1" (assert) (("1" (skeep) (("1" (lemma "BEval_inclusion____") (("1" (inst -1 "dom" "midvars(dom)" "obj") (("1" (beta) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (lemma "map_length[Interval,real]") (("2" (inst?) (("2" (decompose-equality 1) (("2" (lemma "list2array_sound") (("2" (inst?) (("2" (expand "midvars") (("2" (case-replace "x!1 < length(counterex(ev))") (("1" (assert) (("1" (replaces -2) (("1" (replaces -3 :dir rl) (("1" (rewrite "map_nth_rw") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "some?(BEval_(obj, Midbox(dom))) AND NOT val(BEval_(obj, Midbox(dom)))") (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (case-replace "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (skeep) (("1" (rewrite "length_Midbox") (("1" (inst? -1) (("1" (lemma "Midbox_Inclusion") (("1" (inst?) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? -) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (lemma "BEval_inclusion____") (("2" (inst? - :where -5) (("2" (inst? -) (("1" (beta) (("1" (assert) (("1" (case-replace "list2array(0)(counterex(ev)) = midvars(dom)") (("1" (assert) nil nil) ("2" (hide-all-but (-3 1)) (("2" (lemma "map_length[Interval,real]") (("2" (inst?) (("2" (decompose-equality 1) (("2" (lemma "list2array_sound") (("2" (inst?) (("2" (expand "midvars") (("2" (case-replace "x!1 < length(counterex(ev))") (("1" (assert) (("1" (replaces -2) (("1" (replaces -3 :dir rl) (("1" (rewrite "map_nth_rw") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vars_in_box?" 1) (("2" (skeep) (("2" (expand "Midbox" 1) (("2" (rewrite "map_nth_rw") (("2" (replaces -3 1 :dir rl) (("2" (lemma "list2array_sound") (("2" (inst?) (("2" (rewrite "map_length") (("2" (replaces -1) (("2" (assert) (("2" (rewrite "map_nth_rw") (("2" (rewrite "r2i_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subdiv_presound?") (("2" (skeep) (("2" (expand "denorm") (("2" (expand "branch") (("2" (expand "subdivide") (("2" (expand "sound?") (("2" (flatten) (("2" (name-replace "COMB" "combine(v,ans1,ans)" :hide? nil) (("2" (expand "combine" -1) (("2" (case-replace "(some?(ans1`answer) AND NOT val(ans1`answer)) OR
                                              (some?(ans`answer) AND NOT val(ans`answer))") (("1" (replaces -2 :dir rl) (("1" (assert) (("1" (lemma "split_Inclusion") (("1" (inst? -1) (("1" (beta) (("1" (flatten) (("1" (case-replace "some?(ans1`answer) AND NOT val(ans1`answer)") (("1" (flatten) (("1" (expand "sound_dir") (("1" (assert) (("1" (split -5) (("1" (flatten) (("1" (case "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (replace -1) (("1" (case-replace "length(split(v, dom)`1) = length(dom)") (("1" (skeep) (("1" (inst? -) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case-replace "cons?(ans1`counterex)") (("1" (flatten) (("1" (assert) (("1" (hide -6) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? :where 5) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (typepred "ans`counterex") (("2" (hide -1) (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (replace -1) (("1" (case-replace "length(split(v, dom)`2) = length(dom)") (("1" (skeep) (("1" (inst?) (("1" (hide -4) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case-replace "cons?(ans1`counterex)") (("1" (flatten) (("1" (assert) (("1" (hide -4) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? :where 6) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (typepred "ans`counterex") (("2" (hide -1) (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (assert) (("2" (hide -5) (("2" (flatten) (("2" (replace 3) (("2" (typepred "ans1`counterex") (("2" (hide -1) (("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case-replace "some?(ans1`answer) AND some?(ans`answer)") (("1" (flatten) (("1" (assert) (("1" (replaces -5 :dir rl) (("1" (beta) (("1" (assert) (("1" (typepred "ans1`counterex") (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (replaces -1 :dir rl) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subdiv_sound?") (("3" (skeep) (("3" (expand "denorm") (("3" (expand "branch") (("3" (expand "subdivide") (("3" (expand "sound?") (("3" (flatten) (("3" (name-replace "COMB" "combine(v,ans1,ans2)" :hide? nil) (("3" (expand "combine" -1) (("3" (lemma "split_Inclusion") (("3" (inst?) (("3" (beta) (("3" (flatten) (("3" (case-replace "(some?(ans1`answer) AND NOT val(ans1`answer)) OR
                                              (some?(ans2`answer) AND NOT val(ans2`answer))") (("1" (case-replace "some?(ans1`answer) AND NOT val(ans1`answer)") (("1" (flatten) (("1" (assert) (("1" (replaces -4 :dir rl) (("1" (assert) (("1" (flatten) (("1" (case-replace "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (hide -4) (("1" (case-replace "length(split(v, dom)`1) = length(dom)") (("1" (skeep) (("1" (inst?) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case "cons?(ans1`counterex)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst? :where 5) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -4) (("2" (typepred "ans2`counterex") (("2" (hide -1) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "vars_in_box_Inclusion") (("2" (inst? :where 8) (("2" (hide -4) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (assert) (("2" (replaces -4 :dir rl) (("2" (assert) (("2" (flatten) (("2" (case-replace "FORALL (vs: (vars_in_box?(dom))): beval__(obj, vs, length(dom))") (("1" (hide -3) (("1" (case-replace "length(split(v, dom)`2) = length(dom)") (("1" (skeep) (("1" (inst? :where 3) (("1" (lemma "vars_in_box_Inclusion") (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (case "cons?(ans1`counterex)") (("1" (assert) (("1" (typepred "ans1`counterex") (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "vars_in_box_Inclusion") (("2" (inst? :where 7) (("2" (hide -3) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case-replace "some?(ans1`answer) AND some?(ans2`answer)") (("1" (flatten) (("1" (assert) (("1" (replaces -7 :dir rl) (("1" (assert) (("1" (typepred "ans1`counterex") (("1" (hide -1) (("1" (assert) (("1" (typepred "ans2`counterex") (("1" (hide -1) (("1" (assert) (("1" (skeep) (("1" (lemma "split_vars_in_box") (("1" (inst? -1) (("1" (inst?) (("1" (beta) (("1" (case-replace "length(split(v, dom)`1) = length(dom)") (("1" (case-replace "length(split(v, dom)`2) = length(dom)") (("1" (hide -7 -9) (("1" (hide (-1 -2)) (("1" (split -1) (("1" (hide -7) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -6) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (subtype-tcc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (replaces -3 :dir rl) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ProperBox type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (IntervalOutput type-eq-decl nil gbandb_boolexpr interval_arith) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (BoolExpr type-eq-decl nil IntervalExpr_adt interval_arith) (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bite? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (brel? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bor? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (band? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (b_and_b_id_sound formula-decl nil branch_and_bound structures) (Accumulator type-eq-decl nil branch_and_bound structures) (accumulate const-decl "IntervalOutput" gbandb_boolexpr interval_arith) (Brancher type-eq-decl nil branch_and_bound structures) (branch const-decl "[BoolExpr, BoolExpr]" gbandb_boolexpr interval_arith) (Combiner type-eq-decl nil branch_and_bound structures) (combine const-decl "IntervalOutput" gbandb_boolexpr interval_arith) (DirVar type-eq-decl nil branch_and_bound structures) (DenormAns type-eq-decl nil branch_and_bound structures) (denorm const-decl "IntervalOutput" gbandb_boolexpr interval_arith) (Evaluator type-eq-decl nil branch_and_bound structures) (stack type-eq-decl nil stack structures) (DirVarStack type-eq-decl nil branch_and_bound structures) (ExitPred type-eq-decl nil branch_and_bound structures) (ge_chk const-decl "bool" gbandb_boolexpr interval_arith) (LocalExitPred type-eq-decl nil branch_and_bound structures) (le_chk const-decl "bool" gbandb_boolexpr interval_arith) (prune_chk const-decl "bool" gbandb_boolexpr interval_arith) (DirVarSelector type-eq-decl nil branch_and_bound structures) (SoundPred type-eq-decl nil branch_and_bound structures) (SubdivDomain type-eq-decl nil branch_and_bound structures) (subdivide const-decl "[ProperBox, ProperBox]" gbandb_boolexpr interval_arith) (subdiv_sound? const-decl "bool" branch_and_bound structures) (split_vars_in_box formula-decl nil interval_expr interval_arith) (subdiv_presound? const-decl "bool" branch_and_bound structures) (split_Inclusion formula-decl nil interval_expr interval_arith) (sound_dir const-decl "bool" branch_and_bound structures) (split def-decl "{lrb: [Box, Box] |
   LET (lb, rb) = lrb IN
     length(lb) = length(box) AND
      length(rb) = length(box) AND
       FORALL (i: below(length(box))):
         IF i = v
           THEN nth(lb, i) = HalfLeft(nth(box, i)) AND
                 nth(rb, i) = HalfRight(nth(box, i))
         ELSE nth(lb, i) = nth(box, i) AND nth(rb, i) = nth(box, i)
         ENDIF}" interval_expr interval_arith) (HalfRight const-decl "Interval" interval interval_arith) (HalfLeft const-decl "Interval" interval interval_arith) (split_Proper application-judgement "[ProperBox, ProperBox]" interval_expr interval_arith) (accomodates? const-decl "bool" branch_and_bound structures) (midvars const-decl "(vars_in_box?(pox))" box interval_arith) (vars_in_box? const-decl "bool" box interval_arith) (Env type-eq-decl nil box interval_arith) (list2array def-decl "T" array2list structures) (BEval_inclusion____ formula-decl nil affine_boolexpr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (list2array_sound formula-decl nil array2list structures) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (r2i_inclusion formula-decl nil interval interval_arith) (vars_in_box_Inclusion formula-decl nil box interval_arith) (Midbox_Inclusion formula-decl nil box interval_arith) (length_Midbox formula-decl nil box interval_arith) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (beval__ const-decl "bool" affine_boolexpr nil) (BEval_inclusion_Proper____ formula-decl nil affine_boolexpr nil) (Midbox_Proper application-judgement "ProperBox" box interval_arith) (Midbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (BEval_ const-decl "Maybe[Maybe[bool]]" affine_boolexpr nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (midpoint const-decl "real" interval interval_arith)) nil)))
