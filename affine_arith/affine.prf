(affine (ErrorTerms_TCC1 0 (ErrorTerms_TCC1-1 nil 3635094734 ("" (assuming-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_idx const-decl "bool" indexed_list structures) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil)) nil (ErrorTerms assuming "structures@ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (null_is_ErrorTerms 0 (null_is_ErrorTerms-1 nil 3637506941 ("" (expand "ordered_list?") (("" (propax) nil nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (null_is_ErrorTerms subtype "list_adt[[nat, nzBaseType]].null" "ErrorTerms"))) (idxs_pd_TCC1 0 (idxs_pd_TCC1-1 nil 3628272610 ("" (termination-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (idxs_pd termination "affine.idxs_pd(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds))" "nil"))) (idxs_pd_append 0 (idxs_pd_append-1 nil 3628944396 ("" (induct "pds1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((first_ol const-decl "T" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (last_ol def-decl "T" ordered_list structures) (< const-decl "bool" reals nil) (pds2!1 skolem-const-decl "{pd: ErrorTerms | appendable_ol?(cons(cons1_var!1, cons2_var!1), pd)}" affine nil) (cons1_var!1 skolem-const-decl "[nat, nzBaseType]" affine nil) (cons2_var!1 skolem-const-decl "list[[nat, nzBaseType]]" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (append def-decl "list[T]" list_props nil) (append_ol const-decl "ordered_list" ordered_list structures) (idxs_pd def-decl "list[nat]" affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil)) shostak)) (add_ET_TCC1 0 (add_ET_TCC1-2 "" 3789916262 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (/= const-decl "boolean" notequal nil)) shostak (add_ET subtype "affine.x" "nzBaseType")) (add_ET_TCC1-1 nil 3621075711 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (add_ET subtype "affine.x" "nzBaseType"))) (add_ET_TCC2 0 (add_ET_TCC2-2 "" 3789916263 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_idx const-decl "bool" indexed_list structures)) shostak (add_ET subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(affine.ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.x), list_adt[[nat, nzBaseType]].car(affine.ol)))}")) (add_ET_TCC2-1 nil 3621075711 ("" (tcc)) ((null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) nil (add_ET subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(affine.ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.x), list_adt[[nat, nzBaseType]].car(affine.ol)))}"))) (add_ET_TCC3 0 (add_ET_TCC3-2 "" 3789916263 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (/= const-decl "boolean" notequal nil)) shostak (add_ET subtype "affine.x" "nzBaseType")) (add_ET_TCC3-1 nil 3621075711 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (add_ET subtype "affine.x" "nzBaseType"))) (add_ET_TCC4 0 (add_ET_TCC4-2 "" 3789916264 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) shostak (add_ET subtype "affine.pds" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(affine.ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.x), list_adt[[nat, nzBaseType]].car(affine.ol)))}")) (add_ET_TCC4-1 nil 3621075711 ("" (tcc)) ((ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) nil (add_ET subtype "affine.pds" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(affine.ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.x), list_adt[[nat, nzBaseType]].car(affine.ol)))}"))) (last_idx_append 0 (last_idx_append-2 "" 3789916267 ("" (induct "pds1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (expand "last_idx" 1 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (expand "last_idx" 2 1) (("1" (expand "append_ol" 2) (("1" (expand "append" 2) (("1" (expand "last_ol" 2 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "last_ol" 2 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (expand "append_ol") (("1" (case "max(hpds`1, last_idx(pds2)) = last_idx(pds2)") (("1" (grind) nil nil) ("2" (hide-all-but (1 -1 3)) (("2" (typepred "pds2") (("2" (expand "appendable_ol?") (("2" (case "NOT null?(pds2)") (("1" (assert) (("1" (expand "lt_idx") (("1" (expand "last_ol") (("1" (expand "last_idx") (("1" (expand "first_ol") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "null_append[[nat,nzBaseType]]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (inst? -1) (("1" (expand "last_idx" -1 1) (("1" (expand "append_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_ol def-decl "T" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (< const-decl "bool" reals nil) (pds2 skolem-const-decl "{pd: ErrorTerms | appendable_ol?(cons(hpds, tpds), pd)}" affine nil) (hpds skolem-const-decl "[nat, nzBaseType]" affine nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (tpds skolem-const-decl "list[[nat, nzBaseType]]" affine nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (olidx_car_last formula-decl nil indexed_list structures) (car_ol const-decl "T" ordered_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (null_append formula-decl nil more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (first_ol const-decl "T" ordered_list structures) (minus_odd_is_odd application-judgement "odd_int" integers nil) (append def-decl "list[T]" list_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (append_ol const-decl "ordered_list" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil)) shostak) (last_idx_append-1 nil 3629028963 ("" (induct "pds1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (expand "last_idx" 1 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (expand "last_idx" 2 1) (("1" (expand "append_ol" 2) (("1" (expand "append" 2) (("1" (expand "last_ol" 2 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "last_ol" 2 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (split -2) (("1" (inst?) (("1" (expand "last_idx" -1 1) (("1" (expand "append_ol") (("1" (replaces -1) (("1" (case "max(hpds`1, last_idx(pds2)) = last_idx(pds2)") (("1" (grind) nil nil) ("2" (hide-all-but (1 -1 3)) (("2" (typepred "pds2") (("2" (expand "appendable_ol?") (("2" (case "NOT null?(pds2)") (("1" (assert) (("1" (expand "lt_idx") (("1" (expand "last_ol") (("1" (expand "last_idx") (("1" (expand "first_ol") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "null_append[[nat,nzBaseType]]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil) ("2" (expand "ordered_list?" -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (inst? -1) (("1" (expand "last_idx" -1 1) (("1" (expand "append_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_ol def-decl "T" ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (car_ol const-decl "T" ordered_list structures) (null_append formula-decl nil more_list_props structures) (first_ol const-decl "T" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) shostak)) (last_error_TCC1 0 (last_error_TCC1-2 "" 3789916268 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (non_empty? const-decl "bool" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) shostak (last_error subtype "(number_fields.-)(list_props[[nat, nzBaseType]].length(affine.pds), 1)" "below[length[[nat, nzBaseType]](pds)]")) (last_error_TCC1-1 nil 3620397935 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures)) nil (last_error subtype "(number_fields.-)(list_props[[nat, nzBaseType]].length(affine.pds), 1)" "below[length[[nat, nzBaseType]](pds)]"))) (ac_proj_cv 0 (ac_proj_cv-1 nil 3621349067 ("" (grind) nil nil) (({\|\|} const-decl "AffineCombination" affine nil)) shostak)) (ac_proj_pd 0 (ac_proj_pd-1 nil 3621349072 ("" (grind) nil nil) (({\|\|} const-decl "AffineCombination" affine nil)) shostak)) (last_idx_acs_TCC1 0 (last_idx_acs_TCC1-1 nil 3628272610 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx const-decl "int" indexed_list structures)) nil (last_idx_acs termination "affine.last_idx_acs(affine.t)" "nil"))) (search_error_term_by_idx_TCC1 0 (search_error_term_by_idx_TCC1-2 "" 3789916270 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (search_error_term_by_idx subtype "affine.t" "ErrorTerms")) (search_error_term_by_idx_TCC1-1 nil 3619884608 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures)) nil (search_error_term_by_idx subtype "affine.t" "ErrorTerms"))) (search_error_term_by_idx_TCC2 0 (search_error_term_by_idx_TCC2-2 "" 3789916271 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) shostak (search_error_term_by_idx termination "affine.search_error_term_by_idx(affine.t, affine.i)" "nil")) (search_error_term_by_idx_TCC2-1 nil 3620572108 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures)) nil (search_error_term_by_idx termination "affine.search_error_term_by_idx(affine.t, affine.i)" "nil"))) (setbi_nnull_member 0 (setbi_nnull_member-1 nil 3628609596 ("" (induct "pds") (("1" (typepred "pds!1") (("1" (propax) nil nil)) nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (split -1) (("1" (expand "idxs_pd" 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "member" 2) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (inst?) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil)) shostak)) (next_idx_TCC1 0 (next_idx_TCC1-2 "" 3789916272 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (last_idx const-decl "int" indexed_list structures)) shostak (next_idx subtype "(number_fields.+)(indexed_list[nzBaseType].last_idx(affine.pds), 1)" "nat")) (next_idx_TCC1-1 nil 3620471172 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (last_idx const-decl "int" indexed_list structures)) nil (next_idx subtype "(number_fields.+)(indexed_list[nzBaseType].last_idx(affine.pds), 1)" "nat"))) (beyond_last_idx_notmember 0 (beyond_last_idx_notmember-1 nil 3635010030 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skolem 1 "ol") (("2" (flatten) (("2" (skeep*) (("2" (expand "last_idx" -2) (("2" (expand "last_ol" -2) (("2" (lift-if -2) (("2" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "last_idx" -2) (("2" (inst?) (("2" (assert) (("2" (expand "idxs_pd" -2) (("2" (expand_ol) (("2" (expand "member" -2) (("2" (typepred "x::[nat, nzBaseType]") (("2" (expand "ordered_list?" -1) (("2" (expand "lt_idx") (("2" (expand ">") (("2" (use "olidx_car_last[nzBaseType]") (("2" (assert) (("2" (expand "car_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (last_ol def-decl "T" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (olidx_car_last formula-decl nil indexed_list structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (idxs_pd def-decl "list[nat]" affine nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (last_idx const-decl "int" indexed_list structures) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (pred type-eq-decl nil defined_types nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil)) shostak)) (Noise_TCC1 0 (Noise_TCC1-1 nil 3635094734 ("" (assuming-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_idx const-decl "bool" indexed_list structures) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil)) nil (Noise assuming "structures@ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (null_is_noise 0 (null_is_noise-2 "" 3789916274 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (null_is_noise subtype "list_adt[[nat, nzEpsilon]].null" "Noise")) (null_is_noise-1 nil 3620496072 ("" (tcc)) ((ordered_list? def-decl "bool" ordered_list structures)) nil (null_is_noise subtype "list_adt[[nat, nzEpsilon]].null" "Noise"))) (idxs_noise_TCC1 0 (idxs_noise_TCC1-1 nil 3628272610 ("" (skeep) (("" (expand_ol) (("" (expand "length" 2 2) (("" (lift-if 2) (("" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (abstract-and-then 2 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (idxs_noise termination "affine.idxs_noise(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.N))" "nil"))) (empty_noise_is_ol 0 (empty_noise_is_ol-2 "" 3789916275 ("" (ground) (("" (expand "empty_noise") (("" (propax) nil nil)) nil)) nil) ((empty_noise const-decl "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (empty_noise_is_ol-1 nil 3621867992 ("" (ground) (("" (expand "empty_noise") (("" (grind) nil nil)) nil)) nil) nil shostak)) (add_N_TCC1 0 (add_N_TCC1-2 "" 3789916276 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Epsilon type-eq-decl nil affine nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (/= const-decl "boolean" notequal nil)) shostak (add_N subtype "affine.e" "nzEpsilon")) (add_N_TCC1-1 nil 3621614428 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (add_N subtype "affine.e" "nzEpsilon"))) (add_N_TCC2 0 (add_N_TCC2-2 "" 3789916276 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (lt_idx const-decl "bool" indexed_list structures)) shostak (add_N subtype "affine.empty_noise" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(affine.ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(affine.ol)))}")) (add_N_TCC2-1 nil 3621614428 ("" (tcc)) ((null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) nil (add_N subtype "affine.empty_noise" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(affine.ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(affine.ol)))}"))) (add_N_TCC3 0 (add_N_TCC3-2 "" 3789916277 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (/= const-decl "boolean" notequal nil)) shostak (add_N subtype "affine.e" "nzEpsilon")) (add_N_TCC3-1 nil 3621614428 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (add_N subtype "affine.e" "nzEpsilon"))) (add_N_TCC4 0 (add_N_TCC4-2 "" 3789916278 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) shostak (add_N subtype "affine.N" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(affine.ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(affine.ol)))}")) (add_N_TCC4-1 nil 3621614428 ("" (tcc)) ((ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) nil (add_N subtype "affine.N" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(affine.ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(affine.ol)))}"))) (extend_N_prop1 0 (extend_N_prop1-1 nil 3621792343 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_N const-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil)) shostak)) (get_noise_by_idx_TCC1 0 (get_noise_by_idx_TCC1-2 "" 3789916279 ("" (skeep*) (("" (typepred "N") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil) ((Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (get_noise_by_idx termination "affine.get_noise_by_idx(affine.n, affine.t)" "nil")) (get_noise_by_idx_TCC1-1 nil 3619963656 ("" (skeep*) (("" (typepred "N") (("" (assert) (("" (grind) (("" (use "list_cons_eta[[nat, nzEpsilon]]") (("" (replace -1 4 :dir RL :hide? t) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (get_noise_by_idx termination "affine.get_noise_by_idx(affine.n, affine.t)" "nil"))) (upd_noise_TCC1 0 (upd_noise_TCC1-1 nil 3628272610 ("" (skeep* :preds? t) (("" (assert) (("" (flatten) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_N const-decl "Noise" affine nil) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (upd_noise subtype "affine.add_N(affine.n, affine.e, affine.empty_noise)" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}"))) (upd_noise_TCC2 0 (upd_noise_TCC2-1 nil 3628272610 ("" (skeep*) (("" (expand_ol) (("" (expand "lt_idx") (("" (replaces -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_idx const-decl "bool" indexed_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (upd_noise subtype "affine.N" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(ol)))}"))) (upd_noise_TCC3 0 (upd_noise_TCC3-1 nil 3628272610 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (/= const-decl "boolean" notequal nil) (cons_ol const-decl "ordered_list" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (upd_noise subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol((affine.n, affine.e), affine.N)" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}"))) (upd_noise_TCC4 0 (upd_noise_TCC4-1 nil 3628272610 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (/= const-decl "boolean" notequal nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (upd_noise subtype "affine.N" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}"))) (upd_noise_TCC5 0 (upd_noise_TCC5-2 "" 3803780696 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand* "null_ol?" "car_ol" "cdr_ol") (("" (replaces -7) (("" (replaces -6) (("" (expand "ordered_list?") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (upd_noise subtype "affine.tN" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(ol)))}")) (upd_noise_TCC5-1 nil 3628272610 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand* "null_ol?" "car_ol" "cdr_ol") (("" (replaces -8) (("" (replaces -6) (("" (replaces -6 :dir RL) (("" (hide 3) (("" (expand "ordered_list?") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (upd_noise subtype "affine.tN" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.e), list_adt[[nat, nzEpsilon]].car(ol)))}"))) (upd_noise_TCC6 0 (upd_noise_TCC6-1 nil 3628852553 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (/= const-decl "boolean" notequal nil) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (upd_noise subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol((affine.n, affine.e), affine.tN)" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}"))) (upd_noise_TCC7 0 (upd_noise_TCC7-2 "" 3803780995 ("" (skeep* :preds? t) (("" (expand_ol) (("" (replaces (-6 -7)) (("" (replaces -6 :dir RL) (("" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "car_ol(N)`1 < car_ol(cdr_ol(N))`1") (("1" (grind) nil nil) ("2" (expand "ordered_list?" -2) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (upd_noise subtype "affine.tN" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}")) (upd_noise_TCC7-1 nil 3628852553 ("" (skeep* :preds? t) (("" (expand_ol) (("" (replaces (-6 -9)) (("" (replaces -7 :dir RL) (("" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "car_ol(N)`1 < car_ol(cdr_ol(N))`1") (("1" (grind) nil nil) ("2" (expand "ordered_list?" -2) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (upd_noise subtype "affine.tN" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}"))) (upd_noise_TCC8 0 (upd_noise_TCC8-5 "" 3789916284 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "v(tN,n,e)") (("" (replaces -) (("" (case "null_ol?(cdr_ol(N))") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (expand_ol) (("2" (assert) (("2" (hide -2) (("2" (split -2) (("1" (flatten) (("1" (expand "ordered_list?" -5) (("1" (replaces -2) (("1" (hide-all-but (-4 6 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (rewrite "min") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "<=") (("2" (split -1) (("1" (expand "ordered_list?" -4 :assert? none) (("1" (lift-if -4) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir RL) (("2" (expand "ordered_list?" -3) (("2" (hide-all-but (-3 7 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (upd_noise subtype "affine.upd_noise(affine.tN, affine.n, affine.e)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.hN, list_adt[[nat, nzEpsilon]].car(ol)))}")) (upd_noise_TCC8-4 nil 3685211931 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "v(tN,n,e)") (("" (replaces -) (("" (case "null_ol?(cdr_ol(N))") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (expand_ol) (("2" (assert) (("2" (hide -2) (("2" (split -2) (("1" (flatten) (("1" (expand "ordered_list?" -5) (("1" (replaces -2) (("1" (hide-all-but (-4 6 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (rewrite "min") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "<=") (("2" (split -1) (("1" (expand "ordered_list?" -4 :assert? none) (("1" (lift-if -4) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) (("2" (hide-all-but (-1 -3 8)) (("2" (name-replace "A" "car(N)`1") (("2" (name-replace "B" "car(cdr(N))`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir RL) (("2" (expand "ordered_list?" -3) (("2" (hide-all-but (-3 7 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (upd_noise subtype "affine.upd_noise(affine.tN, affine.n, affine.e)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.hN, list_adt[[nat, nzEpsilon]].car(ol)))}")) (upd_noise_TCC8-3 nil 3629576957 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "v(tN,n,e)") (("" (replaces -) (("" (case "null_ol?(cdr_ol(N))") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (expand_ol) (("2" (assert) (("2" (hide -2) (("2" (split -2) (("1" (flatten) (("1" (expand "ordered_list?" -5) (("1" (replaces -2) (("1" (hide-all-but (-4 6 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (rewrite "min") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "<=") (("2" (split -1) (("1" (expand "ordered_list?" -4 :assert? none) (("1" (lift-if -4) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir RL) (("2" (expand "ordered_list?" -3) (("2" (hide-all-but (-3 7 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (upd_noise subtype "affine.upd_noise(affine.tN, affine.n, affine.e)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.hN, list_adt[[nat, nzEpsilon]].car(ol)))}")) (upd_noise_TCC8-2 nil 3629576231 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "v(tN,n,e)") (("" (replaces -) (("" (case "null_ol?(cdr_ol(N))") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (expand_ol) (("2" (assert) (("2" (hide -2) (("2" (split -2) (("1" (flatten) (("1" (expand "ordered_list?" -5) (("1" (replaces -2) (("1" (hide-all-but (-4 6 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (rewrite "min") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "<=") (("2" (split -1) (("1" (expand "ordered_list?" -4 :assert? none) (("1" (expand "lt_idx") (("1" (lift-if -4) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir RL) (("2" (expand "ordered_list?" -3) (("2" (hide-all-but (-3 7 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (upd_noise subtype "affine.upd_noise(affine.tN, affine.n, affine.e)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.hN, list_adt[[nat, nzEpsilon]].car(ol)))}")) (upd_noise_TCC8-1 nil 3628852553 ("" (skeep* :preds? t) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "v(tN,n,e)") (("" (replaces -) (("" (case "null_ol?(cdr_ol(N))") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (expand_ol) (("2" (assert) (("2" (hide -2) (("2" (split -2) (("1" (flatten) (("1" (expand "ordered_list?" -5) (("1" (replaces -2) (("1" (hide-all-but (-4 6 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (rewrite "min") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "<=") (("2" (split -1) (("1" (expand "ordered_list?" -4) (("1" (expand "lt_idx") (("1" (hide-all-but (-1 -4 7 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -1 :dir RL) (("2" (expand "ordered_list?" -3) (("2" (hide-all-but (-3 7 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (upd_noise subtype "affine.upd_noise(affine.tN, affine.n, affine.e)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.hN, list_adt[[nat, nzEpsilon]].car(ol)))}"))) (upd_noise_TCC9 0 (upd_noise_TCC9-1 nil 3628852553 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (upd_noise subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol(affine.hN, affine.upd_noise(affine.tN, affine.n, affine.e))" "{N_: affine.Noise | booleans.AND((booleans.IMPLIES(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), (booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)))), (booleans.IMPLIES((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.OR((booleans.AND(reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = affine.n)), booleans.OR((booleans.AND(reals.>(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1)), reals.>=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1, real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, affine.n)))))))))}"))) (upd_noise_range_TCC1 0 (upd_noise_range_TCC1-1 nil 3630426729 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (upd_noise_range subtype "(number_fields.-)(affine.i, 1)" "nat"))) (upd_noise_range_TCC2 0 (upd_noise_range_TCC2-1 nil 3630426729 ("" (termination-tcc) nil nil) nil nil (upd_noise_range termination "affine.upd_noise_range(affine.N, affine.starting_idx, (number_fields.-)(affine.i, 1), affine.upd)" "nil"))) (upd_noise_burst__TCC1 0 (upd_noise_burst__TCC1-1 nil 3632162810 ("" (termination-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (upd_noise_burst_ termination "affine.upd_noise_burst_(affine.N, affine.t, affine.upd, (number_fields.+)(affine.n, 1))" "nil"))) (gnbi_upd 0 (gnbi_upd-1 nil 3628852150 ("" (induct "N") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (skeep) (("3" (split -1) (("1" (expand "upd_noise" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (replaces -2 :dir RL) (("2" (expand "get_noise_by_idx" 1) (("2" (expand "null_ol?") (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (replaces -1) (("2" (split 2) (("1" (flatten) (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (add_N const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_upd_2 0 (gnbi_upd_2-2 "" 3789916289 ("" (induct "N") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (skeep) (("3" (split -1) (("1" (inst -1 "e" "i" "n") (("1" (assert) (("1" (expand "upd_noise" 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lift-if 2) (("1" (split 2) (("1" (grind) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "cons_ol") (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand ">") (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "tN = null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add_N const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (gnbi_upd_2-1 nil 3628517751 ("" (induct "N") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (skeep) (("3" (split -1) (("1" (inst -1 "e" "i" "n") (("1" (assert) (("1" (expand "upd_noise" 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lift-if 2) (("1" (split 2) (("1" (grind) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "add_N") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "get_noise_by_idx" 1 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cdr_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">") (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (case "tN = null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) shostak)) (gnbi_updr_TCC1 0 (gnbi_updr_TCC1-1 nil 3630758897 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (gnbi_updr subtype "(number_fields.-)(affine.i, affine.start)" "nat"))) (gnbi_updr 0 (gnbi_updr-1 nil 3630762148 ("" (skeep :but "n") (("" (induct "n") (("1" (flatten) (("1" (case "i=start") (("1" (replaces -1 :dir RL) (("1" (hide -) (("1" (expand "upd_noise_range") (("1" (use "gnbi_upd") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "upd_noise_range" 1) (("2" (case "i = 1 + j + start") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_upd") nil nil)) nil)) nil) ("2" (assert) (("2" (use "gnbi_upd_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (i skolem-const-decl "nat" affine nil) (start skolem-const-decl "nat" affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (upd_noise_range def-decl "Noise" affine nil) (nat_induction formula-decl nil naturalnumbers nil) (gnbi_upd formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (gnbi_upd_2 formula-decl nil affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_updr_2 0 (gnbi_updr_2-1 nil 3630762350 ("" (skeep :but "n") (("" (induct "n") (("1" (flatten) (("1" (expand "upd_noise_range") (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "upd_noise_range" 1) (("2" (use "gnbi_upd_2") (("2" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (upd_noise_range def-decl "Noise" affine nil) (nat_induction formula-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gnbi_upd_2 formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_updb__TCC1 0 (gnbi_updb__TCC1-1 nil 3635094734 ("" (assuming-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil)) nil (gnbi_updb_ assuming "structures@ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (gnbi_updb_ 0 (gnbi_updb_-1 nil 3635073667 ("" (skeep*) (("" (name "l" "length(nwidxs)+n+k") (("" (generalize-skolem-constants) (("" (induct "l_1") (("1" (grind) nil nil) ("2" (skolem 1 "l_") (("2" (flatten) (("2" (skeep) (("2" (expand "nth" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (hide -1) (("1" (expand "upd_noise_burst_" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (use "gnbi_upd") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "upd_noise_burst_" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (hide -1) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (inst -1 "N_1" "k_1+1" "n_1-1" "cdr(nwidxs_1)" "upd_fun_1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (typepred "nwidxs_1") (("2" (expand "ordered_list?" -2) (("2" (expand "ordered_list?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 2 4 -3)) (("2" (lemma "nth_ol[nat,<]") (("2" (inst -1 "nwidxs_1" "n_1" "0") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (gnbi_upd formula-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (gnbi_upd_2 formula-decl nil affine nil) (n_1 skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (nth_ol formula-decl nil ordered_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nwidxs_1 skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (upd_noise_burst_ def-decl "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_updb 0 (gnbi_updb-1 nil 3635011259 ("" (skeep) (("" (expand "upd_noise_burst") (("" (use "gnbi_updb_") (("" (typepred "n") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((upd_noise_burst const-decl "Noise" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (gnbi_updb_ formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_updb_2_ 0 (gnbi_updb_2_-1 nil 3635089637 ("" (induct "nwidxs") (("1" (grind) nil nil) ("2" (skolem 1 ("idx" "idxs")) (("2" (flatten) (("2" (skeep) (("2" (expand "member" 1) (("2" (flatten) (("2" (expand "upd_noise_burst_" 3) (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (replaces -1) (("2" (inst -1 "N" "i" "upd_fun" "k+1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (gnbi_upd_2 formula-decl nil affine nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_ol? const-decl "bool" ordered_list structures) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upd_noise_burst_ def-decl "Noise" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (gnbi_updb_2 0 (gnbi_updb_2-1 nil 3635089734 ("" (skeep) (("" (expand "upd_noise_burst") (("" (use "gnbi_updb_2_") (("" (assert) nil nil)) nil)) nil)) nil) ((upd_noise_burst const-decl "Noise" affine nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (gnbi_updb_2_ formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (restrict_by_idxs_TCC1 0 (restrict_by_idxs_TCC1-1 nil 3628272610 ("" (subtype-tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) nil (restrict_by_idxs subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol" "{N_: affine.Noise | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), reals.<=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1))))}"))) (restrict_by_idxs_TCC2 0 (restrict_by_idxs_TCC2-1 nil 3628355849 ("" (skeep*) (("" (expand "lt_idx") (("" (expand_ol) (("" (typepred "v(cdr_ol(N), idxs)") (("1" (expand_ol) (("1" (assert) (("1" (flatten) (("1" (case "car_ol(N)`1 < car_ol(cdr_ol(N))`1") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (typepred "N") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (abstract-and-then 2 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (restrict_by_idxs subtype "affine.restrict_by_idxs(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.N), affine.idxs)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N), list_adt[[nat, nzEpsilon]].car(ol)))}"))) (restrict_by_idxs_TCC3 0 (restrict_by_idxs_TCC3-1 nil 3628355849 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (restrict_by_idxs subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N), affine.restrict_by_idxs(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.N), affine.idxs))" "{N_: affine.Noise | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), reals.<=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1))))}"))) (restrict_by_idxs_TCC4 0 (restrict_by_idxs_TCC4-1 "" 3803781227 ("" (skeep*) (("" (expand_ol) (("" (assert) (("" (typepred "v(cdr_ol(N), idxs)") (("1" (expand_ol) (("1" (flatten) (("1" (typepred "N") (("1" (expand "ordered_list?" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (hide-all-but (-1 -4 6)) (("2" (name-label* ("A_64" "car(N)`1" "B_65" "car(cdr(N))`1") :hide? t :label (:pairing (|wfn:3977| |A:3975|) (|wfn:3977| |B:3976|)) :tcc-label nil :tcc-step nil) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (hide-all-but (1 2)) (("2" (expand "length" 1 2 :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (abstract-and-then 2 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil) nil shostak (restrict_by_idxs subtype "affine.restrict_by_idxs(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.N), affine.idxs)" "{N_: affine.Noise | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), reals.<=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1))))}")) (restrict_by_idxs_TCC4-2 nil 3629577924 ("" (skeep*) (("" (expand_ol) (("" (assert) (("" (typepred "v(cdr_ol(N), idxs)") (("1" (expand_ol) (("1" (flatten) (("1" (typepred "N") (("1" (expand "ordered_list?" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (hide-all-but (-1 -4 6)) (("2" (name-label* ("A_64" "car(N)`1" "B_65" "car(cdr(N))`1") :hide? t :label (:pairing (|wfn:3977| |A:3975|) (|wfn:3977| |B:3976|)) :tcc-label nil :tcc-step nil) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (hide-all-but (1 3)) (("2" (expand "length" 1 2 :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (abstract-and-then 2 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (restrict_by_idxs subtype "affine.restrict_by_idxs(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.N), affine.idxs)" "{N_: affine.Noise | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N)), reals.<=(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1))))}"))) (eval_pd_noise_TCC1 0 (eval_pd_noise_TCC1-2 "" 3803781398 ("" (skeep*) (("" (replaces -2) (("" (case "length[[nat, nzBaseType]](cdr_ol(pds)) < length[[nat, nzBaseType]](pds)") (("1" (case "length[[nat, nzEpsilon]](cdr_ol[[nat, nzEpsilon], lt_idx[nzEpsilon]](noise)) < length[[nat, nzEpsilon]](noise)") (("1" (assert) nil nil) ("2" (hide-all-but (1 3)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (eval_pd_noise termination "affine.eval_pd_noise(affine.t, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.noise))" "nil")) (eval_pd_noise_TCC1-1 nil 3619884927 ("" (skeep*) (("" (replaces -3) (("" (case "length[[nat, nzBaseType]](cdr_ol(pds)) < length[[nat, nzBaseType]](pds)") (("1" (case "length[[nat, nzEpsilon]](cdr_ol[[nat, nzEpsilon], lt_idx[nzEpsilon]](noise)) < length[[nat, nzEpsilon]](noise)") (("1" (assert) nil nil) ("2" (hide-all-but (1 3)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_cdr_ol formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (eval_pd_noise termination "affine.eval_pd_noise(affine.t, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.noise))" "nil"))) (eval_pd_noise_TCC2 0 (eval_pd_noise_TCC2-2 "" 3789916300 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (eval_pd_noise termination "affine.eval_pd_noise(affine.t, affine.noise)" "nil")) (eval_pd_noise_TCC2-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (eval_pd_noise termination "affine.eval_pd_noise(affine.t, affine.noise)" "nil"))) (eval_pd_noise_TCC3 0 (eval_pd_noise_TCC3-2 "" 3789916301 ("" (skeep*) (("" (assert) nil nil)) nil) ((length_cdr_ol formula-decl nil ordered_list structures) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (eval_pd_noise termination "affine.eval_pd_noise(affine.pds, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.noise))" "nil")) (eval_pd_noise_TCC3-1 nil 3619884927 ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((length_cdr_ol formula-decl nil ordered_list structures)) shostak (eval_pd_noise termination "affine.eval_pd_noise(affine.pds, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cdr_ol(affine.noise))" "nil"))) (epn_pds_monotony 0 (epn_pds_monotony-2 "" 3789916301 ("" (skeep*) (("" (expand "eval_pd_noise" 3 2) (("" (lift-if) (("" (expand "null_ol?") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((eval_pd_noise def-decl "real" affine nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (null_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (epn_pds_monotony-1 nil 3621261987 ("" (skeep*) (("" (expand "eval_pd_noise" 3 2) (("" (lift-if) (("" (expand "null_ol?") (("" (assert) (("" (expand "car_ol") (("" (assert) (("" (expand "cdr_ol") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures)) shostak)) (epn_noise_monotony 0 (epn_noise_monotony-1 nil 3621415031 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak)) (eval_pd_noise_rec_pds_def 0 (eval_pd_noise_rec_pds_def-3 "" 3789916304 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (expand "null_ol?") (("" (skolem 1 ("pds_" "N_")) (("" (flatten) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (hide -2) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_noise" 2 1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) (("1" (case "get_noise_by_idx(car_ol(pds_)`1, N_) = car_ol(N_)`2") (("1" (expand_ol) (("1" (replaces -1) (("1" (auto-rewrite "null_ol?") (("1" (case "car_ol(pds_)`2 * car_ol(N_)`2 = car_ol(N_)`2 * car_ol(pds_)`2") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (case "null_ol?(cdr_ol(pds_))") (("1" (hide-all-but (-1 1)) (("1" (expand_ol) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "epn_noise_monotony") (("2" (inst -1 "N_" "cdr_ol(pds_)") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 :dir RL) (("2" (typepred "pds_") (("2" (expand "ordered_list?" -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4 5)) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) (("1" (hide-all-but (-1 1 3 4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst? -1 :where 2) (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car_ol(pds_)`1, N_)= get_noise_by_idx(car_ol(pds_)`1, cdr_ol(N_))") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_noise_monotony") (("1" (inst? -1 :where 5) (("1" (inst? -1 :where 2) (("1" (expand_ol) (("1" (split 1) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "pds_") (("2" (expand "ordered_list?") (("2" (split -1) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand "null_ol?") (("4" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 6)) (("2" (expand "length" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (epn_noise_monotony formula-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (eval_pd_noise def-decl "real" affine nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (eval_pd_noise_rec_pds_def-2 nil 3629629684 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (expand "null_ol?") (("" (skolem 1 ("pds_" "N_")) (("" (flatten) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (hide -2) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_noise" 2 1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) (("1" (case "get_noise_by_idx(car_ol(pds_)`1, N_) = car_ol(N_)`2") (("1" (expand_ol) (("1" (replaces -1) (("1" (auto-rewrite "null_ol?") (("1" (case "car_ol(pds_)`2 * car_ol(N_)`2 = car_ol(N_)`2 * car_ol(pds_)`2") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (case "null_ol?(cdr_ol(pds_))") (("1" (hide-all-but (-1 1)) (("1" (expand_ol) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "epn_noise_monotony") (("2" (inst -1 "N_" "cdr_ol(pds_)") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 :dir RL) (("2" (typepred "pds_") (("2" (expand "ordered_list?" -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4 5)) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) (("1" (hide-all-but (-1 1 3 4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst? -1 :where 2) (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car_ol(pds_)`1, N_)= get_noise_by_idx(car_ol(pds_)`1, cdr_ol(N_))") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_noise_monotony") (("1" (inst? -1 :where 5) (("1" (inst? -1 :where 2) (("1" (expand_ol) (("1" (split 1) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "pds_") (("2" (expand "ordered_list?") (("2" (split -1) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand "null_ol?") (("4" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 6)) (("2" (expand "length" -1 1) (("2" (assert) (("2" (lift-if -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil) (eval_pd_noise_rec_pds_def-1 nil 3621268877 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (expand "null_ol?") (("" (skolem 1 ("pds_" "N_")) (("" (flatten) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (hide -2) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_noise" 2 1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) (("1" (case "get_noise_by_idx(car_ol(pds_)`1, N_) = car_ol(N_)`2") (("1" (expand_ol) (("1" (replaces -1) (("1" (case "car_ol(pds_)`2 * car_ol(N_)`2 = car_ol(N_)`2 * car_ol(pds_)`2") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (case "null_ol?(cdr_ol(pds_))") (("1" (hide-all-but (-1 1)) (("1" (expand_ol) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "epn_noise_monotony") (("2" (inst -1 "N_" "cdr_ol(pds_)") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 :dir RL) (("2" (typepred "pds_") (("2" (expand "ordered_list?" -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4 5)) (("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) (("1" (hide-all-but (-1 1 3 4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst? -1 :where 2) (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car(pds_)`1, N_)= get_noise_by_idx(car(pds_)`1, cdr(N_))") (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_noise_monotony") (("1" (inst? -1 :where 5) (("1" (inst? -1 :where 2) (("1" (expand_ol) (("1" (split 1) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "pds_") (("2" (expand "ordered_list?") (("2" (split -1) (("1" (expand "eval_pd_noise") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 6)) (("2" (expand "length" -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak)) (eval_pd_noise_rec_N_def 0 (eval_pd_noise_rec_N_def-2 nil 3629635262 ("" (skolem!) (("" (name "L" "length(N!1)+length(pds!1)") (("" (generalize "pds!1" "pds") (("" (generalize "N!1" "N") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cdr_ol") (("" (expand "eval_pd_noise" 1 1) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (lift-if 1) (("" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (case "pds=null") (("1" (replaces -1) (("1" (hide -1) (("1" (expand "eval_pd_noise" 1) (("1" (expand "null_ol?") (("1" (expand "search_error_term_by_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (auto-rewrite "null_ol?") (("1" (inst -1 "cdr_ol(N)" "pds") (("1" (expand "cdr_ol" :assert? none) (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "car_ol") (("1" (replace -1 1) (("1" (case "search_error_term_by_idx(pds, car_ol(N)`1) = car_ol(pds)`2") (("1" (expand "car_ol" :assert? none) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car_ol(N)`1, cdr_ol(N)) * car_ol(pds)`2 = 0") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (expand "get_noise_by_idx" 1) (("2" (expand "null_ol?") (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (hide -2) (("2" (hide 2) (("2" (flatten) (("2" (expand_ol) (("2" (typepred "N") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "lt_idx") (("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (replaces -1) (("1" (hide-all-but (-1)) (("1" (invoke (with-fresh-names ((A "%1")) (assert)) (! -1 1)) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (replaces -1 :dir rl) (("2" (expand "search_error_term_by_idx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (use "eval_pd_noise_rec_pds_def" ("pds" "pds")) (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (auto-rewrite "null_ol?") (("1" (case "get_noise_by_idx(car_ol(pds)`1, cdr_ol(N))=0") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "search_error_term_by_idx" 1) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst? -2 :where 1) (("1" (split -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "get_noise_by_idx" 1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil) ("2" (expand "lt_idx") (("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (expand "cdr_ol" :assert? none) (("1" (replaces -1) (("1" (hide-all-but (-1 -3)) (("1" (invoke (with-fresh-names ((A "%1") (B "%2")) (assert)) (! -1 1) (! -1 2)) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cdr_ol" :assert? none) (("2" (hide-all-but (-1 -3 1)) (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (TRUE const-decl "bool" booleans nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (N skolem-const-decl "Noise" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (eval_pd_noise def-decl "real" affine nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (BaseType type-eq-decl nil affine nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil) (eval_pd_noise_rec_N_def-1 nil 3628609806 ("" (skolem!) (("" (name "L" "length(N!1)+length(pds!1)") (("" (generalize "pds!1" "pds") (("" (generalize "N!1" "N") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cdr_ol") (("" (expand "eval_pd_noise" 1 1) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (lift-if 1) (("" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (case "pds=null") (("1" (replaces -1) (("1" (hide -1) (("1" (expand "eval_pd_noise" 1) (("1" (expand "null_ol?") (("1" (expand "search_error_term_by_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "cdr(N)" "pds") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replace -1 1) (("1" (case "search_error_term_by_idx(pds, car(N)`1) = car(pds)`2") (("1" (replaces -1) (("1" (case "get_noise_by_idx(car(N)`1, cdr(N)) * car(pds)`2 = 0") (("1" (assert) nil nil) ("2" (expand "get_noise_by_idx" 1) (("2" (expand "null_ol?") (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N") (("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (use "eval_pd_noise_rec_pds_def" ("pds" "pds")) (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "get_noise_by_idx(car(pds)`1, cdr(N))=0") (("1" (replaces -1) (("1" (assert) (("1" (expand "search_error_term_by_idx" 1) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst? -2 :where 1) (("1" (split -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" 1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N") (("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak)) (appendable_Noises_1 0 (appendable_Noises_1-3 "" 3789916307 ("" (skeep) (("" (use "olidx_car_last[nzEpsilon]") (("" (expand_ol) (("" (assert) (("" (expand "appendable_ol?") (("" (expand "lt_idx") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (olidx_car_last formula-decl nil indexed_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (first_ol const-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (appendable_Noises_1-2 nil 3629629861 ("" (skeep) (("" (use "olidx_car_last[nzEpsilon]") (("" (expand_ol) (("" (assert) (("" (expand "appendable_ol?") (("" (expand "lt_idx") (("" (grind) nil)))))))))))) nil) ((olidx_car_last formula-decl nil indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (first_ol const-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil) (appendable_Noises_1-1 nil 3621261906 ("" (grind) (("" (use "olidx_car_last[nzEpsilon]") (("" (grind) nil nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures)) shostak)) (eval_pd_noise_noise_append_2 0 (eval_pd_noise_noise_append_2-6 "" 3750581789 ("" (induct "n" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "append_ol") (("" (expand "append" 1) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_noise" 2 1) (("2" (expand "null_ol?") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but (1 -1)) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (expand "eval_pd_noise" 1 2) (("1" (expand "null_ol?") (("1" (lift-if) (("1" (assert) (("1" (expand "car_ol") (("1" (inst -2 "j-2") (("1" (assert) (("1" (auto-rewrite "null_ol?") (("1" (inst -2 "cdr_ol(N1)" "N2" "cdr_ol(pds)") (("1" (assert) (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (case "NOT null_ol?(N2)") (("1" (lemma "epn_pds_monotony") (("1" (inst -1 "N2" "pds") (("1" (prop) (("1" (expand "cdr_ol") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil) ("3" (expand "null_ol?") (("3" (use "appendable_Noises_1") (("3" (assert) (("3" (expand "car_ol") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3 4)) (("2" (replace -1 1 :hide? t) (("2" (expand "length" 1 1) (("2" (expand "length" 1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (case "eval_pd_noise(pds, N1) + eval_pd_noise(pds, N2) = eval_pd_noise(cdr_ol(pds), append_ol(N1,N2))") (("1" (replaces -1) (("1" (expand "append_ol") (("1" (expand "append" 1 2) (("1" (hide-all-but (1 4)) (("1" (lift-if 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N1" "N2" "cdr_ol(pds)") (("1" (expand "cdr_ol") (("1" (assert) (("1" (prop) (("1" (expand "append_ol") (("1" (replaces -1) (("1" (lemma "epn_pds_monotony") (("1" (inst -1 "N1" "pds") (("1" (case "NOT null_ol?(pds) AND
                                                 NOT null_ol?(N1) AND car_ol(pds)`1 < car_ol(N1)`1") (("1" (split -2) (("1" (hide -2) (("1" (expand "cdr_ol" :assert? none) (("1" (replaces -1) (("1" (lemma "epn_pds_monotony") (("1" (inst -1 "N2" "pds") (("1" (expand "cdr_ol" :assert? none) (("1" (expand "car_ol" :assert? none) (("1" (expand "null_ol?" :assert? none) (("1" (case "null_ol?(N2)") (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil) ("2" (prop) (("1" (expand "appendable_ol?") (("1" (assert) nil nil)) nil) ("2" (expand_ol) nil nil) ("3" (lemma "olidx_car_last[nzEpsilon]") (("3" (inst -1 "N1") (("3" (assert) (("3" (expand "appendable_ol?" :assert? none) (("3" (expand_ol) (("3" (assert) (("3" (expand "lt_idx") (("3" (expand "first_ol") (("3" (hide-all-but (-1 -2 -4 1 6)) (("3" (name-replace "A" "car(N1)") (("3" (name-replace "B" "last_ol(N1)") (("3" (case "A`1 = B`1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (case "A`1 < B`1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil) ("3" (flatten) nil nil) ("4" (flatten) nil nil)) nil) ("2" (hide -1) (("2" (expand "null_ol?" :assert? none) (("2" (expand "car_ol" :assert? none) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (inst -1 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (inst -1 "cdr_ol(N1)" "N2" "pds") (("1" (expand "cdr_ol") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (use "epn_noise_monotony") (("1" (expand "null_ol?") (("1" (assert) (("1" (auto-rewrite "null_ol?") (("1" (case "null_ol?(cdr_ol(N1))") (("1" (expand_ol) (("1" (assert) (("1" (hide -2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (assert) (("2" (expand "eval_pd_noise" 3 2 :assert? none) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "length" -1 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (car_ol const-decl "T" ordered_list structures) (N1 skolem-const-decl "Noise" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (epn_noise_monotony formula-decl nil affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (olidx_car_last formula-decl nil indexed_list structures) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (epn_pds_monotony formula-decl nil affine nil) (appendable_Noises_1 formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (length_cdr_ol formula-decl nil ordered_list structures) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (append def-decl "list[T]" list_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (NAT_induction formula-decl nil naturalnumbers nil) (append_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise def-decl "real" affine nil) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak)) (eval_pd_noise_noise_append 0 (eval_pd_noise_noise_append-1 nil 3621187208 ("" (skeep) (("" (use "eval_pd_noise_noise_append_2") (("" (assert) nil nil)) nil)) nil) ((eval_pd_noise_noise_append_2 formula-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_pd_noise_append 0 (eval_pd_noise_append-1 nil 3621413347 ("" (skeep) (("" (name "lengths" "length(pds1)+length(pds2)") (("" (generalize "pds1" "pds1") (("" (generalize "pds2" "pds2") (("" (generalize "N" "N") (("" (generalize "lengths" "lengths") (("" (induct "lengths" :name "NAT_induction") (("" (skeep) (("" (skolem 1 ("N_" "pds2_" "pds1_")) (("" (flatten) (("" (expand "append_ol") (("" (expand "append" 1 1) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (hide -2) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "car_ol") (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "N_" "pds2_" "cdr_ol(pds1_)") (("1" (split -1) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(cdr(pds1_), N_) + eval_pd_noise(pds2_, N_) + get_noise_by_idx(car(pds1_)`1, N_) * car(pds1_)`2 = eval_pd_noise(cdr(pds1_), N_) + get_noise_by_idx(car(pds1_)`1, N_) * car(pds1_)`2+ eval_pd_noise(pds2_, N_)") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N_" "pds1_") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1 :dir RL) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (append def-decl "list[T]" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil) (car_ol const-decl "T" ordered_list structures) (get_noise_by_idx def-decl "Epsilon" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (last_ol def-decl "T" ordered_list structures) (pds1_ skolem-const-decl "ErrorTerms" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (NAT_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_ac_partial_ext 0 (eval_ac_partial_ext-1 nil 3628362410 ("" (skeep) (("" (expand "eval_ac_noise") (("" (expand "idxs_ac") (("" (generalize "pd(Xa)" "pds") (("" (induct "pds") (("1" (typepred "pds!1") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_noise") (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skolem 1 ("pdsh" "pdst")) (("3" (flatten) (("3" (use "eval_pd_noise_rec_pds_def") (("3" (expand "null_ol?") (("3" (replaces -1) (("3" (expand "cdr_ol") (("3" (expand "car_ol") (("3" (use "eval_pd_noise_rec_pds_def" ("N" "N2" "pds" "cons(pdsh, pdst)")) (("3" (replaces -1) (("3" (expand "null_ol?") (("3" (expand "cdr_ol") (("3" (expand "car_ol") (("3" (expand "ordered_list?" -2) (("3" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) (("2" (case "eval_pd_noise(pdst, N1) = eval_pd_noise(pdst, N2)") (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "pdsh`1") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (hide 1) (("2" (skeep) (("2" (inst? -4) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_ac_noise const-decl "real" affine nil) (eval_pd_noise def-decl "real" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (AffineCombination type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (car_ol const-decl "T" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (idxs_ac const-decl "list[nat]" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_upd_no_idxs_ac 0 (eval_upd_no_idxs_ac-1 nil 3628517071 ("" (skeep) (("" (expand "eval_ac_noise") (("" (expand "idxs_ac") (("" (generalize "pd(Xa)" "pds") (("" (induct "pds") (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "eval_pd_noise") (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (use "eval_pd_noise_rec_pds_def") (("3" (replaces -1) (("3" (lift-if 2) (("3" (expand "null_ol?") (("3" (expand "cdr_ol") (("3" (expand "car_ol") (("3" (use "eval_pd_noise_rec_pds_def" ("N" "N" "pds" "cons(hpds,tpds)")) (("3" (replaces -1) (("3" (expand "null_ol?") (("3" (expand "cdr_ol") (("3" (expand "car_ol") (("3" (expand "idxs_pd" 1) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "member" 1) (("3" (flatten) (("3" (expand "cdr_ol") (("3" (split -1) (("1" (propax) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (use "gnbi_upd_2") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_ac_noise const-decl "real" affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (eval_pd_noise def-decl "real" affine nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (AffineCombination type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gnbi_upd_2 formula-decl nil affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (list_induction formula-decl nil list_adt nil) (idxs_ac const-decl "list[nat]" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_updb_no_idxs_ 0 (eval_updb_no_idxs_-1 nil 3635090130 ("" (induct "nwidxs") (("1" (grind) nil nil) ("2" (skolem 1 ("idx" "idxs")) (("2" (flatten) (("2" (skeep) (("2" (expand "upd_noise_burst_" 1) (("2" (use "eval_upd_no_idxs_ac") (("2" (split -1) (("1" (replaces -1) (("1" (inst?) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upd_noise_burst_ def-decl "Noise" affine nil) (eval_ac_noise const-decl "real" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (idxs_ac const-decl "list[nat]" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (eval_updb_no_idxs 0 (eval_updb_no_idxs-1 nil 3635089975 ("" (skeep) (("" (expand "upd_noise_burst") (("" (use "eval_updb_no_idxs_") (("" (grind) nil nil)) nil)) nil)) nil) ((upd_noise_burst const-decl "Noise" affine nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (eval_updb_no_idxs_ formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (mergeable?_TCC1 0 (mergeable?_TCC1-1 nil 3628272610 ("" (skeep*) (("" (replaces -) (("" (expand "cdr_ol") (("" (expand "null_ol?") (("" (expand "length" 3 3 :assert? none) (("" (lift-if 3) (("" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (name-replace "A" "length(cdr(N1))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (length def-decl "nat" list_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (mergeable? termination "affine.mergeable?(affine.t1)(affine.N2)" "nil"))) (mergeable?_TCC2 0 (mergeable?_TCC2-1 nil 3628272610 ("" (skeep*) (("" (replaces -) (("" (expand "cdr_ol") (("" (expand "null_ol?") (("" (expand "length" 4 4 :assert? none) (("" (lift-if 4) (("" (split 4) (("1" (flatten) nil nil) ("2" (flatten) (("2" (name-replace "A" "length(cdr(N2))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (length def-decl "nat" list_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (mergeable? termination "affine.mergeable?(affine.N1)(affine.t2)" "nil"))) (mergeable?_TCC3 0 (mergeable?_TCC3-1 nil 3628272610 ("" (skeep*) (("" (replaces -) (("" (expand "null_ol?") (("" (expand "cdr_ol") (("" (expand "length" 5 (3 4) :assert? none) (("" (lift-if 5) (("" (split 5) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (name-replace "A" "length(cdr(N1))") (("2" (name-replace "B" "length(cdr(N2))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (minus_odd_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (mergeable? termination "affine.mergeable?(affine.t1)(affine.t2)" "nil"))) (mergeable_wrt_pd?_TCC1 0 (mergeable_wrt_pd?_TCC1-1 nil 3628272610 ("" (termination-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (mergeable_wrt_pd? termination "affine.mergeable_wrt_pd?(affine.pdst, affine.N1)" "nil"))) (mergeable_wrt_pd?_nonrec_def 0 (mergeable_wrt_pd?_nonrec_def-1 nil 3628608581 ("" (skeep) (("" (iff) (("" (split 1) (("1" (generalize "pds" "pds") (("1" (induct "pds") (("1" (beta) (("1" (propax) nil nil)) nil) ("2" (typepred "pds!1") (("2" (propax) nil nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "idxs_pd") (("3" (expand "null_ol?") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 ("hpds" "tpds")) (("4" (flatten) (("4" (skeep) (("4" (expand "idxs_pd" -4) (("4" (expand "null_ol?") (("4" (expand "car_ol") (("4" (expand "member" -4) (("4" (split -4) (("1" (expand "mergeable_wrt_pd?" -4) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (split -2) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (expand "mergeable_wrt_pd?" -3) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "ordered_list?" -2) (("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (generalize "pds" "pds") (("2" (induct "pds") (("1" (beta) (("1" (propax) nil nil)) nil) ("2" (typepred "pds!1") (("2" (propax) nil nil)) nil) ("3" (flatten) (("3" (expand "mergeable_wrt_pd?") (("3" (expand "null_ol?") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (skolem 1 ("hpds" "tpds")) (("4" (flatten) (("4" (expand "mergeable_wrt_pd?" 1) (("4" (expand "null_ol?") (("4" (split 1) (("1" (flatten) (("1" (expand "car_ol") (("1" (inst -3 "hpds`1") (("1" (split -3) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (expand "idxs_pd" 1) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "member" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) (("2" (split -1) (("1" (skeep) (("1" (inst?) (("1" (split -3) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (expand "idxs_pd" 1) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "member" 1) (("3" (expand "cdr_ol") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (mergeable_wrt_pd? def-decl "bool" affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (member def-decl "bool" list_props nil) (idxs_pd def-decl "list[nat]" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (merge_TCC1 0 (merge_TCC1-1 nil 3628272610 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (merge subtype "affine.N2" "{N_: affine.Noise | booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1)))), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1))))))))}"))) (merge_TCC2 0 (merge_TCC2-1 nil 3628272610 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures)) nil (merge subtype "affine.N1" "{N_: affine.Noise | booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1)))), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1))))))))}"))) (merge_TCC3 0 (merge_TCC3-2 "" 3789916320 ("" (skeep*) (("" (expand "cdr_ol") (("" (expand "length" 3 3) (("" (expand "null_ol?") (("" (lift-if 3) (("" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (replaces -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (merge termination "affine.merge(affine.N1, affine.t2)" "nil")) (merge_TCC3-1 nil 3628272610 ("" (skeep*) (("" (expand "cdr_ol") (("" (expand "length" 3 3) (("" (expand "null_ol?") (("" (lift-if 3) (("" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (replaces -5) (("2" (assert) (("2" (name-replace "A" "length(cdr(N2))") (("2" (name-replace "B" "length[[nat, nzEpsilon]](N1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (merge termination "affine.merge(affine.N1, affine.t2)" "nil"))) (merge_TCC4 0 (merge_TCC4-2 "" 3803782519 ("" (skeep*) (("" (expand "lt_idx") (("" (typepred "v(N1,t2)") (("" (assert) (("" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (replaces -1) (("2" (expand "cdr_ol") (("2" (replaces -5) (("2" (replaces -4) (("2" (replaces -2) (("2" (case "car_ol(N2)`1 < car_ol(cdr_ol(N2))`1") (("1" (grind) nil nil) ("2" (expand_ol) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (merge subtype "affine.merge(affine.N1, affine.t2)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.h2, list_adt[[nat, nzEpsilon]].car(ol)))}")) (merge_TCC4-1 nil 3628272610 ("" (skeep*) (("" (expand "lt_idx") (("" (typepred "v(N1,t2)") (("" (assert) (("" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (replaces -1) (("2" (expand "cdr_ol") (("2" (replaces -6) (("2" (replaces -4) (("2" (replaces -2) (("2" (case "car_ol(N2)`1 < car_ol(cdr_ol(N2))`1") (("1" (grind) nil nil) ("2" (expand_ol) (("2" (hide-all-but (1 4 2)) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (car_ol const-decl "T" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (merge subtype "affine.merge(affine.N1, affine.t2)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.h2, list_adt[[nat, nzEpsilon]].car(ol)))}"))) (merge_TCC5 0 (merge_TCC5-1 nil 3628337988 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (merge subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol(affine.h2, affine.merge(affine.N1, affine.t2))" "{N_: affine.Noise | booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1)))), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1))))))))}"))) (merge_TCC6 0 (merge_TCC6-5 nil 3629482527 ("" (skeep*) (("" (replaces -) (("" (expand_ol) (("" (expand "length" 4 3) (("" (lift-if 4) (("" (split 4) (("1" (flatten) nil nil) ("2" (flatten) (("2" (apply (then (assert) (name-replace "A" "length(cdr(N1))") (name-replace "B" "length[[nat, nzEpsilon]](N2)") (assert))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (merge termination "affine.merge(affine.t1, affine.N2)" "nil"))) (merge_TCC7 0 (merge_TCC7-1 nil 3628337988 ("" (skeep*) (("" (expand "lt_idx") (("" (replaces -) (("" (typepred "v(cdr_ol(N1), N2)") (("" (expand_ol) (("" (assert) (("" (flatten) (("" (replaces -2) (("" (case "car_ol(N1)`1 < car_ol(cdr_ol(N1))`1") (("1" (expand_ol) (("1" (hide-all-but (-1 -3 6)) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "N1") (("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (merge subtype "affine.merge(affine.t1, affine.N2)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.h1, list_adt[[nat, nzEpsilon]].car(ol)))}"))) (merge_TCC8 0 (merge_TCC8-1 nil 3628337988 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (merge subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol(affine.h1, affine.merge(affine.t1, affine.N2))" "{N_: affine.Noise | booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1)))), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1))))))))}"))) (merge_TCC9 0 (merge_TCC9-1 nil 3628339943 ("" (skeep*) (("" (replaces -) (("" (expand_ol) (("" (expand "length" 5 (3 4)) (("" (lift-if 5) (("" (split 5) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (abstract-and-then 2 2 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (merge termination "affine.merge(affine.t1, affine.t2)" "nil"))) (merge_TCC10 0 (merge_TCC10-1 nil 3628339943 ("" (skeep*) (("" (expand "lt_idx") (("" (replaces -) (("" (typepred "v(cdr_ol(N1), cdr_ol(N2))") (("" (expand "null_ol?") (("" (assert) (("" (split -2) (("1" (expand_ol) (("1" (flatten) (("1" (replaces -2) (("1" (case "car_ol(N2)`1 = car_ol(N1)`1") (("1" (expand_ol) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replaces -2) (("2" (typepred "N1") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) (("3" (flatten) (("3" (replaces -1) (("3" (case "car_ol(N1)`1 < car_ol(cdr_ol(N2))`1") (("1" (case "car_ol(N1)`1 < car_ol(cdr_ol(N1))`1") (("1" (grind) nil nil) ("2" (expand_ol) (("2" (typepred "N1") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil) ("2" (case "car_ol(N2)`1 = car_ol(N1)`1") (("1" (expand_ol) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (expand_ol) nil nil) ("4" (expand_ol) nil nil) ("5" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (merge subtype "affine.merge(affine.t1, affine.t2)" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx(affine.h1, list_adt[[nat, nzEpsilon]].car(ol)))}"))) (merge_TCC11 0 (merge_TCC11-1 nil 3628339943 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (merge subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol(affine.h1, affine.merge(affine.t1, affine.t2))" "{N_: affine.Noise | booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1)))), booleans.OR((booleans.AND(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1)))), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N1)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N2)), booleans.AND((booleans.NOT)(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(N_)), ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(N_)`1 = real_defs.min(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N1)`1, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N2)`1))))))))}"))) (merge_prop1 0 (merge_prop1-2 nil 3629642538 ("" (skeep) (("" (name "L" "length(N1)+length(N2)") (("" (generalize "N1" "N1") (("" (generalize "N2" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "get_noise_by_idx" 1 1) (("" (expand "null_ol?") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (expand "merge" -1) (("1" (lift-if -1) (("1" (expand "null_ol?") (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (case "N1!1=empty_noise") (("1" (replaces -1) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (case "N2!1=empty_noise") (("1" (replaces -1) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "merge" -2) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (replaces -2 :dir RL) (("1" (replaces -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "merge" -2) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (replaces -2 :dir RL) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "car_ol(N2!1)`1 = car_ol(N1!1)`1") (("1" (expand "cons_ol") (("1" (expand "merge" -2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cons_ol") (("1" (replaces -2 :dir RL) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" -1) (("1" (expand "null_ol?") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand ">") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand ">") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "merge" 2) (("2" (expand "null_ol?") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(N2!1)" "N1!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "merge" 5) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "cons_ol") (("3" (expand "get_noise_by_idx" -3 2) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "merge" 6) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "cons_ol") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2!1" "cdr_ol(N1!1)") (("1" (split -2) (("1" (expand "merge" (5 6)) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr_ol(N2!1)" "cdr_ol(N1!1)") (("1" (split -1) (("1" (replaces -1) (("1" (expand "merge" (6 7)) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "cdr_ol") (("2" (expand "length" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (3 -1)) (("2" (abstract-and-then 1 2 (assert)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (N2!1 skolem-const-decl "Noise" affine nil) (length_cdr_ol formula-decl nil ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (aat__21 skolem-const-decl "even_posnat" affine nil) (aat__20 skolem-const-decl "nat" affine nil) (aat__19 skolem-const-decl "nat" affine nil) (aat__18 skolem-const-decl "nat" affine nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (even_posnat nonempty-type-eq-decl nil naturalnumbers nil) (even? const-decl "bool" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (empty_noise const-decl "Noise" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (merge def-decl "{N_: Noise |
   (null_ol?(N1) AND null_ol?(N2) AND null_ol?(N_)) OR
    (null_ol?(N1) AND
      NOT null_ol?(N2) AND
       NOT null_ol?(N_) AND car_ol(N_)`1 = car_ol(N2)`1)
     OR
     (null_ol?(N2) AND
       NOT null_ol?(N1) AND
        NOT null_ol?(N_) AND car_ol(N_)`1 = car_ol(N1)`1)
      OR
      (NOT null_ol?(N1) AND
        NOT null_ol?(N2) AND
         NOT null_ol?(N_) AND
          car_ol(N_)`1 = min(car_ol(N1)`1, car_ol(N2)`1))}" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil) (merge_prop1-1 nil 3628614543 ("" (skeep) (("" (name "L" "length(N1)+length(N2)") (("" (generalize "N1" "N1") (("" (generalize "N2" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "get_noise_by_idx" 1 1) (("" (expand "null_ol?") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (expand "merge" -1) (("1" (lift-if -1) (("1" (expand "null_ol?") (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (case "N1!1=null") (("1" (replaces -1) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (case "N2!1=null") (("1" (replaces -1) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "merge" -2) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (replaces -2 :dir RL) (("1" (replaces -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "merge" -2) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (replaces -2 :dir RL) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "car(N2!1)`1 = car(N1!1)`1") (("1" (expand "cons_ol") (("1" (expand "merge" -2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cons_ol") (("1" (replaces -2 :dir RL) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" -1) (("1" (expand "null_ol?") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand ">") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand ">") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "merge" 2) (("2" (expand "null_ol?") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(N2!1)" "N1!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "merge" 5) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "cons_ol") (("3" (expand "get_noise_by_idx" -3 2) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "merge" 6) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "cons_ol") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2!1" "cdr_ol(N1!1)") (("1" (split -2) (("1" (expand "merge" (5 6)) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (assert) (("2" (name-replace "A" "length(N2!1)") (("2" (name "B" "length(cdr_ol(N1!1))") (("1" (grind) nil nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr_ol(N2!1)" "cdr_ol(N1!1)") (("1" (split -1) (("1" (replaces -1) (("1" (expand "merge" (6 7)) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "cdr_ol") (("2" (name "B" "length(cdr_ol(N2!1))") (("1" (name "A" "length(cdr_ol(N1!1))") (("1" (expand "cdr_ol") (("1" (expand "length" -3) (("1" (lift-if -3) (("1" (assert) (("1" (lift-if -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "length" -1) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (length_cdr_ol formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak)) (mergeable_wrt_null_all_idxs_zero 0 (mergeable_wrt_null_all_idxs_zero-2 "" 3789916332 ("" (induct "pds") (("1" (typepred "pds!1") (("1" (propax) nil nil)) nil) ("2" (expand "idxs_pd") (("2" (expand "null_ol?") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep*) (("3" (expand "idxs_pd" -4 :assert? none) (("3" (expand_ol) (("3" (expand "member" -4) (("3" (split -1) (("1" (split -4) (("1" (replaces -1) (("1" (hide -1) (("1" (expand "mergeable_wrt_pd?" :assert? none) (("1" (expand_ol) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (replaces -1 :dir RL) (("2" (expand "get_noise_by_idx") (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "N") (("2" (expand "mergeable_wrt_pd?" -4 :assert? none) (("2" (expand_ol) (("2" (flatten) (("2" (split -2) (("1" (inst? -1 :where -2) (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (split -1) (("1" (expand "ordered_list?" 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (idxs_pd def-decl "list[nat]" affine nil) (member def-decl "bool" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mergeable_wrt_pd? def-decl "bool" affine nil) (ErrorTerms type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (mergeable_wrt_null_all_idxs_zero-1 nil 3628596850 ("" (induct "pds") (("1" (typepred "pds!1") (("1" (propax) nil nil)) nil) ("2" (expand "idxs_pd") (("2" (expand "null_ol?") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep*) (("3" (expand "idxs_pd" -4 :assert? none) (("3" (expand_ol) (("3" (expand "member" -4) (("3" (split -1) (("1" (split -4) (("1" (replaces -1) (("1" (hide -1) (("1" (expand "mergeable_wrt_pd?" :assert? none) (("1" (expand_ol) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (replaces -1 :dir RL) (("2" (expand "get_noise_by_idx") (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "N") (("2" (expand "mergeable_wrt_pd?" -4 :assert? none) (("2" (expand_ol) (("2" (flatten) (("2" (split -2) (("1" (inst? -1 :where -2) (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (split -1) (("1" (expand "ordered_list?" 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) shostak)) (mergeable_wrt_null_eval_zero 0 (mergeable_wrt_null_eval_zero-2 "" 3789916333 ("" (skolem 1 ("N" "_")) (("" (induct "pds") (("1" (typepred "pds!1") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (hide-all-but (1)) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (expand "eval_pd_noise" 1) (("3" (expand "null_ol?") (("3" (lift-if 1) (("3" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (use "mergeable_wrt_null_all_idxs_zero") (("2" (assert) (("2" (split -2) (("1" (split 2) (("1" (flatten) (("1" (case "eval_pd_noise(tpds, cdr(N))=0") (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "hpds`1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 -2)) (("2" (expand "eval_pd_noise" -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (lift-if -1) (("2" (split -1) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (reveal -1) (("2" (replaces -1 :dir RL) (("2" (reveal -3) (("2" (expand "ordered_list?") (("2" (assert) (("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "car_ol") (("2" (case "eval_pd_noise(tpds, cdr(N)) = 0") (("1" (replaces -1) (("1" (assert) (("1" (inst -2 "hpds`1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "eval_pd_noise" -1) (("2" (expand "null_ol?") (("2" (lift-if -1) (("2" (split -1) (("1" (hide-all-but (1 -1)) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mergeable_wrt_pd?" -3) (("2" (expand "null_ol?") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "ordered_list?" -2) (("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (mergeable_wrt_pd? def-decl "bool" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (eval_pd_noise def-decl "real" affine nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list_induction formula-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (car_ol const-decl "T" ordered_list structures) (mergeable_wrt_null_all_idxs_zero formula-decl nil affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (TRUE const-decl "bool" booleans nil) (idxs_pd def-decl "list[nat]" affine nil) (member def-decl "bool" list_props nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (mergeable_wrt_null_eval_zero-1 nil 3628597794 ("" (skolem 1 ("N" "_")) (("" (induct "pds") (("1" (typepred "pds!1") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (hide-all-but (1)) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (expand "eval_pd_noise" 1) (("3" (expand "null_ol?") (("3" (lift-if 1) (("3" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (use "mergeable_wrt_null_all_idxs_zero") (("2" (assert) (("2" (split -2) (("1" (split 2) (("1" (flatten) (("1" (case "eval_pd_noise(tpds, cdr(N))=0") (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "hpds`1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 -2)) (("2" (expand "eval_pd_noise" -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (lift-if -1) (("2" (split -1) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (reveal -1) (("2" (replaces -1 :dir RL) (("2" (reveal -3) (("2" (expand "ordered_list?") (("2" (assert) (("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "car_ol") (("2" (case "eval_pd_noise(tpds, cdr(N)) = 0") (("1" (replaces -1) (("1" (assert) (("1" (inst -2 "hpds`1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "eval_pd_noise" -1) (("2" (expand "null_ol?") (("2" (lift-if -1) (("2" (split -1) (("1" (hide-all-but (1 -1)) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mergeable_wrt_pd?" -3) (("2" (expand "null_ol?") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "ordered_list?" -2) (("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak)) (mergeable_noises_respect_eval 0 (mergeable_noises_respect_eval-4 "" 3789916337 ("" (skolem!) (("" (name "L" "length(N1!1)+length(N2!1)") (("" (generalize "N1!1" "N1") (("" (generalize "N2!1" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "merge" 1) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cdr_ol") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (case "N1=empty_noise") (("1" (replaces -1) (("1" (hide -1) (("1" (expand "eval_ac_noise") (("1" (expand "eval_pd_noise" 1 2) (("1" (expand_ol) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_null_eval_zero") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(N2)" "N1") (("1" (split -2) (("1" (assert) (("1" (expand "mergeable_wrt_ac?") (("1" (case "search_error_term_by_idx(pd(Xa!1), car_ol(N2)`1) /= 0") (("1" (hide 1) (("1" (use "setbi_nnull_member") (("1" (assert) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (assert) (("1" (inst -1 "car_ol(N2)`1") (("1" (expand_ol) (("1" (assert) (("1" (case "get_noise_by_idx(car_ol(N2)`1, N2) = 0") (("1" (assert) (("1" (hide -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (typepred "car_ol(N2)`2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -1 1) (("2" (expand_ol) (("2" (split -1) (("1" (typepred "car_ol(N2)`2") (("1" (expand_ol) (("1" (expand "/=") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx") (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (expand "/=") (("2" (with-tccs (name-replace* ("ABS_123" (typechecked "search_error_term_by_idx(pd(Xa!1), car(N2)`1)" "BaseType") "ABS_124" (typechecked "0" "real")))) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 3)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (beta) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand_ol) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (expand_ol) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "i=car_ol(N2)`1") (("1" (replaces -1) (("1" (hide 2) (("1" (expand "get_noise_by_idx" 1) (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" 3 1) (("2" (expand_ol) (("2" (assert) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (expand ">") (("1" (expand "get_noise_by_idx" 3) (("1" (expand "null_ol?") (("1" (lift-if 3) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "lt_idx") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 3)) (("3" (expand_ol) (("3" (expand "length" -1 2 :assert? none) (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand "length" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand_ol) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2" "cdr_ol(N1)") (("1" (split -2) (("1" (expand_ol) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 5)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (propax) nil nil) ("2" (case "i = car_ol(N1)`1") (("1" (replaces -1) (("1" (reveal (-6 3)) (("1" (hide-all-but (-1 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 5)) (("3" (expand "length" -1 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise") (("2" (use "eval_pd_noise_rec_N_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr(N2)" "cdr(N1)") (("1" (split -1) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "car(N2)`1 = car(N1)`1") (("1" (hide-all-but (-1 -3 1 5 6)) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (split -3) (("1" (hide-all-but (-1 1 3)) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (typepred "car(N2)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" -1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (replace -2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replace -1 1 :dir RL) (("1" (replace -3 1 :dir RL) (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (replace -2 -1 :dir RL) (("1" (expand "get_noise_by_idx" 2) (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 -1 5 6)) (("3" (expand "length" -1 :assert? none) (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (even_nat nonempty-type-eq-decl nil naturalnumbers nil) (even? const-decl "bool" integers nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mergeable_wrt_pd?_nonrec_def formula-decl nil affine nil) (setbi_nnull_member formula-decl nil affine nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (N2 skolem-const-decl "Noise" affine nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (eval_pd_noise_rec_N_def formula-decl nil affine nil) (N1 skolem-const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (mergeable_wrt_null_eval_zero formula-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (empty_noise const-decl "Noise" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (mergeable_wrt_ac? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (merge def-decl "{N_: Noise |
   (null_ol?(N1) AND null_ol?(N2) AND null_ol?(N_)) OR
    (null_ol?(N1) AND
      NOT null_ol?(N2) AND
       NOT null_ol?(N_) AND car_ol(N_)`1 = car_ol(N2)`1)
     OR
     (null_ol?(N2) AND
       NOT null_ol?(N1) AND
        NOT null_ol?(N_) AND car_ol(N_)`1 = car_ol(N1)`1)
      OR
      (NOT null_ol?(N1) AND
        NOT null_ol?(N2) AND
         NOT null_ol?(N_) AND
          car_ol(N_)`1 = min(car_ol(N1)`1, car_ol(N2)`1))}" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (mergeable_noises_respect_eval-3 "" 3629628859 ("" (skolem!) (("" (name "L" "length(N1!1)+length(N2!1)") (("" (generalize "N1!1" "N1") (("" (generalize "N2!1" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "merge" 1) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cdr_ol") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (case "N1=empty_noise") (("1" (replaces -1) (("1" (hide -1) (("1" (expand "eval_ac_noise") (("1" (expand "eval_pd_noise" 1 2) (("1" (expand_ol) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_null_eval_zero") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(N2)" "N1") (("1" (split -2) (("1" (replaces -1) (("1" (assert) (("1" (expand "mergeable_wrt_ac?") (("1" (case "search_error_term_by_idx(pd(Xa!1), car_ol(N2)`1) /= 0") (("1" (hide 1) (("1" (use "setbi_nnull_member") (("1" (assert) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (assert) (("1" (inst -1 "car_ol(N2)`1") (("1" (expand_ol) (("1" (assert) (("1" (case "get_noise_by_idx(car_ol(N2)`1, N2) = 0") (("1" (assert) (("1" (hide -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (typepred "car_ol(N2)`2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -1 1) (("2" (expand_ol) (("2" (split -1) (("1" (typepred "car_ol(N2)`2") (("1" (expand_ol) (("1" (expand "/=") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx") (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (expand "/=") (("2" (with-tccs (name-replace* ("ABS_123" (typechecked "search_error_term_by_idx(pd(Xa!1), car(N2)`1)" "BaseType") "ABS_124" (typechecked "0" "real")))) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 3)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (beta) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand_ol) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (expand_ol) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "i=car_ol(N2)`1") (("1" (replaces -1) (("1" (hide 2) (("1" (expand "get_noise_by_idx" 1) (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" 3 1) (("2" (expand_ol) (("2" (assert) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (expand ">") (("1" (expand "get_noise_by_idx" 3) (("1" (expand "null_ol?") (("1" (lift-if 3) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "lt_idx") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 3)) (("3" (expand_ol) (("3" (expand "length" -1 2 :assert? none) (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand "length" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand_ol) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2" "cdr_ol(N1)") (("1" (split -2) (("1" (expand_ol) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 5)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (propax) nil nil) ("2" (case "i = car_ol(N1)`1") (("1" (replaces -1) (("1" (reveal (-6 3)) (("1" (hide-all-but (-1 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 5)) (("3" (expand "length" -1 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise") (("2" (use "eval_pd_noise_rec_N_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr(N2)" "cdr(N1)") (("1" (split -1) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "car(N2)`1 = car(N1)`1") (("1" (hide-all-but (-1 -3 1 5 6)) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (split -3) (("1" (hide-all-but (-1 1 3)) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (typepred "car(N2)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" -1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (replace -2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replace -1 1 :dir RL) (("1" (replace -3 1 :dir RL) (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (replace -2 -1 :dir RL) (("1" (expand "get_noise_by_idx" 2) (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 -1 5 6)) (("3" (expand "length" -1 :assert? none) (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures)) nil) (mergeable_noises_respect_eval-2 "" 3629490441 ("" (skolem!) (("" (name "L" "length(N1!1)+length(N2!1)") (("" (generalize "N1!1" "N1") (("" (generalize "N2!1" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "merge" 1) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cdr_ol") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (case "N1=empty_noise") (("1" (replaces -1) (("1" (hide -1) (("1" (expand "eval_ac_noise") (("1" (expand "eval_pd_noise" 1 2) (("1" (expand_ol) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_null_eval_zero") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(N2)" "N1") (("1" (split -2) (("1" (replaces -1) (("1" (assert) (("1" (expand "mergeable_wrt_ac?") (("1" (case "search_error_term_by_idx(pd(Xa!1), car_ol(N2)`1) /= 0") (("1" (hide 1) (("1" (use "setbi_nnull_member") (("1" (assert) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (assert) (("1" (inst -1 "car_ol(N2)`1") (("1" (expand_ol) (("1" (assert) (("1" (case "get_noise_by_idx(car_ol(N2)`1, N2) = 0") (("1" (assert) (("1" (hide -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (typepred "car_ol(N2)`2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -1 1) (("2" (expand_ol) (("2" (split -1) (("1" (typepred "car_ol(N2)`2") (("1" (expand_ol) (("1" (expand "/=") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx") (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (expand "/=") (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 3)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (beta) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand_ol) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (expand_ol) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "i=car_ol(N2)`1") (("1" (replaces -1) (("1" (hide 2) (("1" (expand "get_noise_by_idx" 1) (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" 3 1) (("2" (expand_ol) (("2" (assert) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (expand ">") (("1" (expand "get_noise_by_idx" 3) (("1" (expand "null_ol?") (("1" (lift-if 3) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "lt_idx") (("2" (flatten) (("2" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 3)) (("3" (expand_ol) (("3" (expand "length" -1 2 :assert? none) (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand "length" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand_ol) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2" "cdr_ol(N1)") (("1" (split -2) (("1" (expand_ol) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 5)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (propax) nil nil) ("2" (case "i = car(N1)`1") (("1" (replaces -1) (("1" (reveal (-6 3)) (("1" (hide-all-but (-1 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 5)) (("3" (expand "length" -1 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise") (("2" (use "eval_pd_noise_rec_N_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr(N2)" "cdr(N1)") (("1" (split -1) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "car(N2)`1 = car(N1)`1") (("1" (hide-all-but (-1 -3 1 5 6)) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (split -3) (("1" (hide-all-but (-1 1 3)) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (typepred "car(N2)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" -1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (replace -2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replace -1 1 :dir RL) (("1" (replace -3 1 :dir RL) (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (replace -2 -1 :dir RL) (("1" (expand "get_noise_by_idx" 2) (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 -1 5 6)) (("3" (expand "length" -1 :assert? none) (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak) (mergeable_noises_respect_eval-1 nil 3628593395 ("" (skolem!) (("" (name "L" "length(N1!1)+length(N2!1)") (("" (generalize "N1!1" "N1") (("" (generalize "N2!1" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "merge" 1) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cdr_ol") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (case "N1=null") (("1" (replaces -1) (("1" (hide -1) (("1" (expand "eval_ac_noise") (("1" (expand "eval_pd_noise" 1 2) (("1" (expand "null_ol?") (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_null_eval_zero") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr(N2)" "N1") (("1" (split -2) (("1" (replaces -1) (("1" (assert) (("1" (expand "mergeable_wrt_ac?") (("1" (case "search_error_term_by_idx(pd(Xa!1), car(N2)`1) /= 0") (("1" (hide 1) (("1" (use "setbi_nnull_member") (("1" (assert) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (assert) (("1" (inst -1 "car(N2)`1") (("1" (assert) (("1" (case "get_noise_by_idx(car(N2)`1, N2) = 0") (("1" (assert) (("1" (hide -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (typepred "car(N2)`2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -1 1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (expand "/=") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 3)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (beta) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "i=car(N2)`1") (("1" (replaces -1) (("1" (hide 2) (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" 3 1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (assert) (("2" (expand "cdr_ol") (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 3)) (("3" (expand "length" -1 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand "length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "eval_ac_noise") (("1" (use "eval_pd_noise_rec_N_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2" "cdr(N1)") (("1" (split -2) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 5)) (("2" (expand "mergeable_wrt_ac?") (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (use "mergeable_wrt_pd?_nonrec_def") (("2" (replaces -1) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (split -2) (("1" (propax) nil nil) ("2" (case "i = car(N1)`1") (("1" (replaces -1) (("1" (reveal (-6 3)) (("1" (hide-all-but (-1 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 5)) (("3" (expand "length" -1 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise") (("2" (use "eval_pd_noise_rec_N_def") (("2" (replaces -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr(N2)" "cdr(N1)") (("1" (split -1) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_N_def") (("1" (inst -1 "N1" "pd(Xa!1)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "car(N2)`1 = car(N1)`1") (("1" (hide-all-but (-1 -3 1 5 6)) (("1" (expand "mergeable_wrt_ac?") (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (use "mergeable_wrt_pd?_nonrec_def") (("1" (replaces -1) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (split -3) (("1" (hide-all-but (-1 1 3)) (("1" (expand "get_noise_by_idx" -1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (typepred "car(N2)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "get_noise_by_idx" -1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (replace -2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replace -1 1 :dir RL) (("1" (replace -3 1 :dir RL) (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (replace -2 -1 :dir RL) (("1" (expand "get_noise_by_idx" 2) (("1" (expand "null_ol?") (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N2") (("1" (expand "ordered_list?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N2") (("2" (expand "ordered_list?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1 5 6)) (("3" (expand "length" -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures)) shostak)) (mergeable_suff_conditions 0 (mergeable_suff_conditions-1 nil 3628592586 ("" (skeep) (("" (expand "mergeable_wrt_ac?") (("" (expand "mergeable_wrt_pd?") (("" (expand "null_ol?") (("" (flatten) (("" (expand "idxs_ac") (("" (generalize "pd(Xa)" "pda") (("1" (induct "pda") (("1" (typepred "pda!1") (("1" (propax) nil nil)) nil) ("2" (typepred "pda!1") (("2" (propax) nil nil)) nil) ("3" (grind) nil nil) ("4" (skolem 1 ("hpda" "tpda")) (("4" (flatten) (("4" (expand "car_ol") (("4" (expand "cdr_ol") (("4" (split 1) (("1" (flatten) (("1" (inst -3 "hpda`1") (("1" (assert) (("1" (hide-all-but 3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "mergeable_wrt_pd?" 1) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (expand "ordered_list?" -2) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (split -1) (("1" (split 2) (("1" (flatten) (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (skeep) (("2" (inst?) (("2" (split -4) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (grind) nil nil) ("6" (hide-all-but (2 3)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (3 4)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (3 2)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (3 4)) (("9" (grind) nil nil)) nil) ("10" (hide-all-but (3 2)) (("10" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil) ("5" (hide 3) (("5" (grind) nil nil)) nil) ("6" (hide 3) (("6" (grind) nil nil)) nil) ("7" (hide 3) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mergeable_wrt_ac? const-decl "bool" affine nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (N1 skolem-const-decl "Noise" affine nil) (N2 skolem-const-decl "Noise" affine nil) (list_induction formula-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (mergeable_wrt_pd? def-decl "bool" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (merge_commutativity 0 (merge_commutativity-3 nil 3629647010 ("" (skeep) (("" (name "L" "length(N1)+length(N2)") (("" (generalize "N1" "N1") (("" (generalize "N2" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "merge" 1 1) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (expand "merge" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1 2) (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (expand_ol) (("1" (case "merge(N1!1, cdr(N2!1)) = merge(cdr(N2!1), N1!1)") (("1" (inst? -3 :where -1) (("1" (split -3) (("1" (assert) nil nil) ("2" (hide-all-but (1 -3 3)) (("2" (expand "length" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst? -2 :where 1) (("2" (assert) (("2" (split 5) (("1" (hide-all-but (-2 1 4)) (("1" (expand "length" -1 2 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (case "get_noise_by_idx(i, N2!1) = 0") (("1" (assert) (("1" (hide -4) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "car_ol") (("1" (expand ">") (("1" (typepred "N2!1") (("1" (expand "ordered_list?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -3 2) (("2" (lift-if -3) (("2" (split -3) (("1" (expand "car_ol") (("1" (flatten) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1 2) (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (expand_ol) (("1" (case "merge(cdr(N1!1), N2!1) = merge(N2!1, cdr(N1!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (inst? -2 :where 1) (("2" (split -2) (("1" (propax) nil nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (case "get_noise_by_idx(i, N1!1) = 0") (("1" (assert) (("1" (hide -4) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (typepred "car_ol(N1!1)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N1!1") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -3 1) (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 2 1) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "car_ol") (("1" (typepred "N1!1") (("1" (expand "ordered_list?") (("1" (hide-all-but (-1 -2 2 9)) (("1" (expand "null_ol?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "get_noise_by_idx" -1) (("2" (typepred "car_ol(N1!1)`2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (expand "null_ol?") (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "j-2") (("1" (assert) (("1" (expand_ol) (("1" (case "merge(cdr(N1!1), cdr(N2!1)) =
                                                          merge(cdr(N2!1), cdr(N1!1))") (("1" (expand "merge" 2 2 :assert? none) (("1" (expand_ol) (("1" (assert) (("1" (replaces -1) (("1" (hide -1) (("1" (case "car_ol(N2!1)`1=car_ol(N1!1)`1") (("1" (inst -3 "car_ol(N2!1)`1") (("1" (split -3) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "get_noise_by_idx" -1 2) (("3" (replace -2 -1) (("3" (expand "get_noise_by_idx" -1 1) (("3" (case "car_ol(N1!1) = car_ol(N2!1)") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 -1 -2)) (("2" (expand_ol) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -1 :where 1) (("2" (assert) (("2" (split 7) (("1" (hide-all-but (-1 1 6 7)) (("1" (expand "length" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (abstract-and-then 3 2 (assert)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(i, N1!1) = 0") (("1" (hide -3) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N1!1") (("1" (expand "ordered_list?" :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N1!1") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "get_noise_by_idx(i, N2!1) = 0") (("1" (hide -3) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -2 1) (("2" (lift-if -2) (("2" (split -2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 3) (("1" (lift-if 3) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (typepred "N1!1") (("1" (expand "ordered_list?" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N1!1") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "get_noise_by_idx" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 6) (("1" (lift-if 6) (("1" (split 6) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "null_ol?") (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (posnat nonempty-type-eq-decl nil integers nil) (even? const-decl "bool" integers nil) (even_posnat nonempty-type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (aat__22 skolem-const-decl "nat" affine nil) (aat__23 skolem-const-decl "nat" affine nil) (aat__24 skolem-const-decl "nat" affine nil) (aat__25 skolem-const-decl "even_posnat" affine nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (merge def-decl "{N_: Noise |
   (null_ol?(N1) AND null_ol?(N2) AND null_ol?(N_)) OR
    (null_ol?(N1) AND
      NOT null_ol?(N2) AND
       NOT null_ol?(N_) AND car_ol(N_)`1 = car_ol(N2)`1)
     OR
     (null_ol?(N2) AND
       NOT null_ol?(N1) AND
        NOT null_ol?(N_) AND car_ol(N_)`1 = car_ol(N1)`1)
      OR
      (NOT null_ol?(N1) AND
        NOT null_ol?(N2) AND
         NOT null_ol?(N_) AND
          car_ol(N_)`1 = min(car_ol(N1)`1, car_ol(N2)`1))}" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil) (merge_commutativity-2 nil 3629646061 ("" (skeep) (("" (name "L" "length(N1)+length(N2)") (("" (generalize "N1" "N1") (("" (generalize "N2" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "merge" 1 1) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (expand "merge" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1 2) (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (expand_ol) (("1" (case "merge(N1!1, cdr(N2!1)) = merge(cdr(N2!1), N1!1)") (("1" (inst? -3 :where -1) (("1" (split -3) (("1" (assert) nil nil) ("2" (hide-all-but (1 -3 3)) (("2" (expand "length" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst? -2 :where 1) (("2" (assert) (("2" (split 5) (("1" (hide-all-but (-2 1 4)) (("1" (expand "length" -1 2 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (case "get_noise_by_idx(i, N2!1) = 0") (("1" (assert) (("1" (hide -4) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "car_ol") (("1" (expand ">") (("1" (typepred "N2!1") (("1" (expand "ordered_list?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -3 2) (("2" (lift-if -3) (("2" (split -3) (("1" (expand "car_ol") (("1" (flatten) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1 2) (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (expand_ol) (("1" (case "merge(cdr(N1!1), N2!1) = merge(N2!1, cdr(N1!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (inst? -2 :where 1) (("2" (split -2) (("1" (propax) nil nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "length" -1 1) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (case "get_noise_by_idx(i, N1!1) = 0") (("1" (assert) (("1" (hide -4) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (typepred "car_ol(N1!1)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N1!1") (("2" (expand "ordered_list?" :assert? none) (("2" (lift-if -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -3 1) (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 2 1) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "car_ol") (("1" (typepred "N1!1") (("1" (expand "ordered_list?") (("1" (hide-all-but (-1 -2 2 9)) (("1" (expand "null_ol?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "get_noise_by_idx" -1) (("2" (typepred "car_ol(N1!1)`2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (expand "null_ol?") (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "j-2") (("1" (assert) (("1" (expand_ol) (("1" (case "merge(cdr(N1!1), cdr(N2!1)) =
                        merge(cdr(N2!1), cdr(N1!1))") (("1" (expand "merge" 2 2 :assert? none) (("1" (expand_ol) (("1" (assert) (("1" (replaces -1) (("1" (hide -1) (("1" (case "car_ol(N2!1)`1=car_ol(N1!1)`1") (("1" (inst -3 "car_ol(N2!1)`1") (("1" (split -3) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "get_noise_by_idx" -1 2) (("3" (replace -2 -1) (("3" (expand "get_noise_by_idx" -1 1) (("3" (case "car_ol(N1!1) = car_ol(N2!1)") (("1" (expand_ol) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 -1 -2)) (("2" (expand_ol) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -1 :where 1) (("2" (assert) (("2" (split 7) (("1" (hide-all-but (-1 1 6 7)) (("1" (expand "length" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(i, N1!1) = 0") (("1" (hide -3) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N1!1") (("1" (expand "ordered_list?") (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N1!1") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "get_noise_by_idx(i, N2!1) = 0") (("1" (hide -3) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -2 1) (("2" (lift-if -2) (("2" (split -2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 3) (("1" (lift-if 3) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (typepred "N1!1") (("1" (expand "ordered_list?" -1 :assert? none) (("1" (lift-if -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N1!1") (("2" (expand "ordered_list?" -1 :assert? none) (("2" (lift-if -1) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (expand "lt_idx") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "get_noise_by_idx" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 6) (("1" (lift-if 6) (("1" (split 6) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "null_ol?") (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) nil) (merge_commutativity-1 nil 3628617821 ("" (skeep) (("" (name "L" "length(N1)+length(N2)") (("" (generalize "N1" "N1") (("" (generalize "N2" "N2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "merge" 1 1) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (expand "merge" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1 2) (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(N2!1)" "N1!1") (("1" (split -2) (("1" (assert) nil nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "cdr_ol") (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (case "get_noise_by_idx(i, N2!1) = 0") (("1" (assert) (("1" (hide -4) (("1" (expand "cdr_ol") (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "car_ol") (("1" (expand ">") (("1" (typepred "N2!1") (("1" (expand "ordered_list?") (("1" (expand "null_ol?") (("1" (lift-if -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "cons_ol") (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (expand "get_noise_by_idx" -3 2) (("2" (lift-if -3) (("2" (split -3) (("1" (expand "car_ol") (("1" (flatten) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 3)) (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "merge" 1 2) (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "N2!1" "cdr_ol(N1!1)") (("1" (split -2) (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -2 5)) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (expand "length" -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (case "get_noise_by_idx(i, N1!1) = 0") (("1" (assert) (("1" (hide -4) (("1" (expand "cdr_ol") (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (typepred "car_ol(N1!1)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (lift-if 2) (("1" (assert) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (typepred "N1!1") (("2" (expand "ordered_list?") (("2" (lift-if -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (flatten) (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -3 1) (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 2 1) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (typepred "N1!1") (("1" (expand "ordered_list?") (("1" (hide-all-but (-1 -2 2 9)) (("1" (expand "null_ol?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "get_noise_by_idx" -1) (("2" (typepred "car_ol(N1!1)`2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (expand "null_ol?") (("2" (expand "length" -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "j-2") (("1" (assert) (("1" (inst -1 "cdr_ol(N2!1)" "cdr_ol(N1!1)") (("1" (split -1) (("1" (expand "merge" 2 2) (("1" (replaces -1) (("1" (case "car_ol(N2!1)`1=car_ol(N1!1)`1") (("1" (inst -3 "car_ol(N2!1)`1") (("1" (split -3) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "get_noise_by_idx" -1 2) (("3" (replace -2 -1) (("3" (expand "get_noise_by_idx" -1 1) (("3" (case "car_ol(N1!1) = car_ol(N2!1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 -1 -2)) (("2" (expand "car_ol") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "cdr_ol") (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst?) (("3" (case "get_noise_by_idx(i, N1!1) = 0") (("1" (hide -3) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (expand "get_noise_by_idx" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (typepred "N1!1") (("1" (expand "ordered_list?") (("1" (lift-if -1) (("1" (expand "null_ol?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N1!1") (("2" (expand "ordered_list?") (("2" (lift-if -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "get_noise_by_idx(i, N2!1) = 0") (("1" (hide -3) (("1" (expand "get_noise_by_idx" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "get_noise_by_idx" -2 1) (("2" (lift-if -2) (("2" (split -2) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 3) (("1" (lift-if 3) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (typepred "N1!1") (("1" (expand "ordered_list?") (("1" (lift-if -1) (("1" (expand "null_ol?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (typepred "N1!1") (("2" (expand "ordered_list?") (("2" (lift-if -1) (("2" (expand "null_ol?") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "get_noise_by_idx" -1 2) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replaces -1 :dir RL) (("1" (expand "get_noise_by_idx" 6) (("1" (lift-if 6) (("1" (split 6) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 5 6)) (("2" (expand "null_ol?") (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak)) (map_error_TCC1 0 (map_error_TCC1-2 "" 3789916343 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (BaseType type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (map_error termination "affine.map_error(affine.pds1, affine.t2, affine.op)" "nil")) (map_error_TCC1-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (map_error termination "affine.map_error(affine.pds1, affine.t2, affine.op)" "nil"))) (map_error_TCC2 0 (map_error_TCC2-2 "" 3789916343 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (map_error termination "affine.map_error(affine.t1, affine.pds2, affine.op)" "nil")) (map_error_TCC2-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (map_error termination "affine.map_error(affine.t1, affine.pds2, affine.op)" "nil"))) (map_error_TCC3 0 (map_error_TCC3-2 "" 3789916344 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (map_error termination "affine.map_error(affine.t1, affine.t2, affine.op)" "nil")) (map_error_TCC3-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (map_error termination "affine.map_error(affine.t1, affine.t2, affine.op)" "nil"))) (map_error_TCC4 0 (map_error_TCC4-2 "" 3789916345 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (map_error termination "affine.map_error(affine.t1, affine.pds2, affine.op)" "nil")) (map_error_TCC4-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (map_error termination "affine.map_error(affine.t1, affine.pds2, affine.op)" "nil"))) (map_error_TCC5 0 (map_error_TCC5-2 "" 3789916346 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (map_error termination "affine.map_error(affine.pds1, affine.t2, affine.op)" "nil")) (map_error_TCC5-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (map_error termination "affine.map_error(affine.pds1, affine.t2, affine.op)" "nil"))) (nol_mp_1 0 (nol_mp_1-1 nil 3622387225 ("" (skeep) (("" (expand "map_error") (("" (assert) (("" (expand "null_ol") (("" (expand "null_ol?") (("" (expand "add_ET") (("" (lift-if) (("" (split -1) (("1" (flatten) (("1" (inst -3 "car_ol(pds2)`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((map_error def-decl "ErrorTerms" affine nil) (null_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (me_ordered_1 0 (me_ordered_1-2 "" 3789916347 ("" (skolem 1 ("op" "_")) (("" (induct "pds2" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep*) (("2" (hide 1) (("2" (expand "map_error" 2 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (split 2) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (split -2) (("1" (expand "car_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 2 3)) (("2" (expand "map_error" 2) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (flatten) (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (assert) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (assert) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "map_error" 6) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (pred type-eq-decl nil defined_types nil) (ErrorTerms type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (BaseType type-eq-decl nil affine nil) (map_error def-decl "ErrorTerms" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ol_ind_sch formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (add_ET const-decl "ErrorTerms" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (TRUE const-decl "bool" booleans nil)) shostak) (me_ordered_1-1 nil 3622463893 ("" (skolem 1 ("op" "_")) (("" (induct "pds2" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep*) (("2" (hide 1) (("2" (expand "map_error" 2 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (split 2) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (split -2) (("1" (expand "car_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 2 3)) (("2" (expand "map_error" 2) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (flatten) (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (assert) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (assert) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "map_error" 6) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but 3) (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (hide-all-but 2) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) shostak)) (me_ordered_1b 0 (me_ordered_1b-1 nil 3622468980 ("" (skolem 1 ("op" "_")) (("" (induct "pds1" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep*) (("2" (hide 1) (("2" (expand "map_error" 2 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (split 2) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "null_ol") (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (split -2) (("1" (expand "car_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 2 3)) (("2" (expand "map_error" 2) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (expand "cdr_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (flatten) (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (assert) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cons_ol") (("2" (split 2) (("1" (flatten) (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (assert) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "map_error" 6) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (pred type-eq-decl nil defined_types nil) (ErrorTerms type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (BaseType type-eq-decl nil affine nil) (map_error def-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ol_ind_sch formula-decl nil ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (add_ET const-decl "ErrorTerms" affine nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (TRUE const-decl "bool" booleans nil)) shostak)) (me_ordered_2 0 (me_ordered_2-1 nil 3622469209 ("" (skolem 1 ("op" "pds1_" "pds2_")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "map_error" 3) (("" (split 3) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (expand "null_ol?") (("1" (expand "empty_ErrorTerms") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (split 2) (("1" (flatten) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) <= min(car_ol(pds1)`1, car_ol(cdr_ol(pds2))`1)") (("1" (expand "map_error" 5) (("1" (expand "add_ET") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 5 3)) (("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3 5 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 5) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "cons_ol") (("1" (expand "car_ol") (("1" (hide-all-but (5 4 2)) (("1" (typepred "pds2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (6 3 4 5)) (("1" (typepred "pds2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "map_error" 8) (("1" (expand "add_ET") (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) <= min(car_ol(pds1)`1, car_ol(cdr_ol(pds2))`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 7 8 6)) (("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 6 7 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "map_error" 5) (("1" (expand "add_ET") (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1)<=min(car_ol(cdr_ol(pds1))`1, car_ol(pds2)`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 3 4 5)) (("2" (typepred "pds1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 5) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (5 3 4 2)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "cons_ol") (("1" (expand "car_ol") (("1" (hide-all-but (5 3 4 6)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "map_error" 8) (("1" (expand "add_ET") (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1)<=min(car_ol(cdr_ol(pds1))`1, car_ol(pds2)`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 6 7 8)) (("2" (typepred "pds1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) < min(car_ol(cdr_ol(pds1))`1, car_ol(cdr_ol(pds2))`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 3 4 5 6)) (("2" (typepred "pds1" "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (6 4 5 3)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "cons_ol") (("1" (expand "car_ol") (("1" (hide-all-but (7 4 5 6)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-2") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "map_error" 9) (("1" (expand "add_ET") (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) < min(car_ol(cdr_ol(pds1))`1, car_ol(cdr_ol(pds2))`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 6 7 8 9)) (("2" (typepred "pds1" "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "map_error" 7) (("1" (expand "add_ET") (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) <= min(car_ol(cdr_ol(pds1))`1, car_ol(pds2)`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 4 5 6 7)) (("2" (typepred "pds1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (7 3 4 5 6)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (8 4 5 6 7)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 10) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) <= min(car_ol(cdr_ol(pds1))`1, car_ol(pds2)`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 7 8 9 10)) (("2" (typepred "pds1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (split 2) (("1" (flatten) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) <= min(car_ol(pds1)`1, car_ol(cdr_ol(pds2))`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 5 6 7 8)) (("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 5 6 7 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (8 4 5 6 7)) (("1" (typepred "pds2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 9) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (9 8 7 6 5)) (("1" (typepred "pds2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 11) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "min(car_ol(pds1)`1, car_ol(pds2)`1) <= min(car_ol(pds1)`1, car_ol(cdr_ol(pds2))`1)") (("1" (assert) nil nil) ("2" (hide-all-but (1 8 9 10 11)) (("2" (typepred "pds2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 8 9 10 11)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (add_ET const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_cdr_ol formula-decl nil ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (BaseType type-eq-decl nil affine nil) (map_error def-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (me_ordered_3 0 (me_ordered_3-1 nil 3622473500 ("" (skolem 1 ("op" "pds1_" "pds2_")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "map_error" 3) (("" (split 3) (("1" (flatten) (("1" (assert) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 4) (("1" (expand "add_ET") (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds2))") (("1" (assert) (("1" (hide-all-but (4 5 1 -4 3)) (("1" (typepred "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 4) (("1" (expand "add_ET") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 5) (("1" (expand "add_ET") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 7) (("2" (expand "add_ET") (("2" (assert) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds2))") (("1" (assert) (("1" (hide-all-but (6 -3 7 8 1)) (("1" (typepred "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 6 7 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds2))") (("1" (assert) (("1" (hide-all-but (5 1 4 6 7 -4 -2)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 4) (("2" (lemma "me_ordered_1b") (("2" (inst -1 "op" "cdr_ol(pds1)") (("2" (assert) (("2" (case "cdr_ol(pds2) = null") (("1" (replaces -1) (("1" (expand "null_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (6 4 3)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (hide-all-but (7 5 4)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 9) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-2") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds2))") (("1" (assert) (("1" (hide-all-but (8 -1 -3 9 10 7 1)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds2) = null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1b") (("1" (inst -1 "op" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "null_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 6 7 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 10) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (split 2) (("1" (flatten) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds2))") (("1" (assert) (("1" (hide-all-but (7 3 4 8 9 6 1 -3)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds2) = null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1b") (("1" (inst -1 "op" "pds1") (("1" (assert) (("1" (expand "null_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 9) (("1" (assert) (("1" (expand "add_ET") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 11) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds2))") (("1" (assert) (("1" (hide-all-but (10 6 7 -2 11 12 9 1)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds2) = null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1b") (("1" (inst -1 "op" "pds1") (("1" (assert) (("1" (expand "null_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (me_ordered_1b formula-decl nil affine nil) (null_ol const-decl "ordered_list" ordered_list structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (add_ET const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (length_cdr_ol formula-decl nil ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (BaseType type-eq-decl nil affine nil) (map_error def-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (me_ordered_4 0 (me_ordered_4-1 nil 3622476284 ("" (skolem 1 ("op" "pds1_" "pds2_")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "map_error" 3) (("" (assert) (("" (split 3) (("1" (flatten) (("1" (assert) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 4) (("1" (expand "add_ET") (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds1))") (("1" (assert) (("1" (hide-all-but (4 5 1 -4 3)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds1) =null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "pds2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 4) (("1" (expand "add_ET") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 5) (("1" (expand "add_ET") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 7) (("2" (expand "add_ET") (("2" (assert) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds1))") (("1" (assert) (("1" (hide-all-but (6 -3 7 8 1)) (("1" (typepred "pds1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds1) =null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "pds2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 6 7 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 5) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds1))") (("1" (assert) (("1" (hide-all-but (4 -2 -4 5 6 3 1)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds1) =null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "cdr_ol(pds2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 5) (("1" (expand "add_ET") (("1" (assert) (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 6) (("1" (expand "add_ET") (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "map_error" 7) (("2" (expand "add_ET") (("2" (assert) (("2" (inst -2 "j-2") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds1))") (("1" (assert) (("1" (hide-all-but (8 -3 -1 1 5 7 8 6)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds1) =null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "cdr_ol(pds2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (split 1) (("1" (flatten) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds1))") (("1" (assert) (("1" (hide-all-but (5 -2 -4 1 4 6 7)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds1) =null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "pds2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 6) (("1" (assert) (("1" (expand "add_ET") (("1" (expand ("cons_ol" "car_ol")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 7) (("1" (expand "add_ET") (("1" (assert) (("1" (expand ("cons_ol" "car_ol")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 9) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (case "NOT null_ol?(cdr_ol(pds1))") (("1" (assert) (("1" (hide-all-but (8 -1 -3 1 7 9 10)) (("1" (typepred "pds1" "pds2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr_ol(pds1) =null") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "pds2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (split 2) (("1" (flatten) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (typepred "pds2") (("1" (hide-all-but (-3 7 -1 6 4)) (("1" (expand "ordered_list?") (("1" (lift-if) (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "lt_idx") (("1" (assert) (("1" (prop) (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 6 7 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 7) (("1" (assert) (("1" (expand "add_ET") (("1" (expand ("cons_ol" "car_ol")) (("1" (typepred "pds2") (("1" (hide-all-but (-1 7 6 4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide 1) (("1" (expand "map_error" 8) (("1" (assert) (("1" (expand "add_ET") (("1" (expand ("cons_ol" "car_ol")) (("1" (typepred "pds2") (("1" (hide-all-but (8 7 5 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "map_error" 10) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2)" "pds1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 -1 9 10)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_cdr_ol formula-decl nil ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (me_ordered_1 formula-decl nil affine nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (BaseType type-eq-decl nil affine nil) (map_error def-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (epn_me_null_1 0 (epn_me_null_1-1 nil 3622479053 ("" (skolem 1 ("N" "pds1_" "pds2_" "op")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep*) (("" (expand "map_error" -3) (("" (lift-if) (("" (split -3) (("1" (flatten) (("1" (split -2) (("1" (expand "empty_ErrorTerms") (("1" (hide -3) (("1" (typepred "op") (("1" (case "eval_pd_noise(pds1, N)=0") (("1" (replaces -1) (("1" (case "eval_pd_noise(pds2, N)=0") (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -5)) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -6)) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (replaces -1) (("1" (assert) (("1" (typepred "op") (("1" (inst -2 "car_ol(pds2)`2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "cons_ol") (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (case "pds1=null") (("1" (replaces -1) (("1" (lemma "me_ordered_1") (("1" (inst -1 "op" "pds2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split -2) (("1" (flatten) (("1" (typepred "op") (("1" (inst -2 "car_ol(pds1)`2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split -2) (("1" (flatten) (("1" (inst -4 "j-2") (("1" (assert) (("1" (inst -4 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (typepred "op") (("1" (inst? -4) (("1" (replaces -4) (("1" (replaces -7) (("1" (assert) (("1" (replaces -6) (("1" (inst? -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split -2) (("1" (flatten) (("1" (typepred "op") (("1" (inst -2 "car_ol(pds1)`2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (use "me_ordered_3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (typepred "op") (("1" (inst -2 "car_ol(pds2)`2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (use "me_ordered_4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (add_ET const-decl "ErrorTerms" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (me_ordered_1 formula-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (get_noise_by_idx def-decl "Epsilon" affine nil) (length_cdr_ol formula-decl nil ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (me_ordered_2 formula-decl nil affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (me_ordered_3 formula-decl nil affine nil) (me_ordered_4 formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (BaseType type-eq-decl nil affine nil) (map_error def-decl "ErrorTerms" affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (next_idx_const_ac 0 (next_idx_const_ac-1 nil 3628945177 ("" (grind) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (const_ac const-decl "AffineCombination" affine nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) shostak)) (var_ac_TCC1 0 (var_ac_TCC1-2 "" 3789916367 ("" (tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_idx const-decl "bool" indexed_list structures) (real_minus_real_is_real application-judgement "real" reals nil)) shostak (var_ac subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.n, number_fields./(((number_fields.-)(ub(affine.Xi), lb(affine.Xi))), 2)), list_adt[[nat, nzBaseType]].car(ol)))}")) (var_ac_TCC1-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures)) nil (var_ac subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.n, number_fields./(((number_fields.-)(ub(affine.Xi), lb(affine.Xi))), 2)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (eval_var_ac 0 (eval_var_ac-1 nil 3628888567 ("" (skeep) (("" (expand "eval_ac_noise") (("" (use "eval_pd_noise_rec_pds_def") (("" (expand "null_ol?") (("" (replaces -1) (("" (expand "var_ac") (("" (assert) (("" (lift-if 1) (("" (lift-if 1) (("" (lift-if 1) (("" (assert) (("" (split 1) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise def-decl "real" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_pd_i_TCC1 0 (eval_pd_i_TCC1-2 "" 3789916368 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (eval_pd_i termination "affine.eval_pd_i(affine.t)" "nil")) (eval_pd_i_TCC1-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (eval_pd_i termination "affine.eval_pd_i(affine.t)" "nil"))) (eval_pd_i_TCC2 0 (eval_pd_i_TCC2-1 nil 3635263855 ("" (skeep*) (("" (typepred "v(t)") (("" (case "Proper?(Mult([|h`2|], [|-1, 1|]))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (ProperInterval type-eq-decl nil interval interval_arith) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Proper? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (Ge const-decl "bool" interval interval_arith) (Le const-decl "bool" interval interval_arith) (pXm const-decl "Interval" interval interval_arith) (Neg const-decl "Interval" interval interval_arith) (nXm const-decl "Interval" interval interval_arith) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (mXm const-decl "Interval" interval interval_arith) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (Add const-decl "Interval" interval interval_arith) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) ([\|\|] const-decl "Interval" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Mult const-decl "Interval" interval interval_arith) (minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (eval_pd_i subtype "interval.Add(interval.Mult([|affine.h`2|], [|(number_fields.-)(1), 1|]), affine.eval_pd_i(affine.t))" "ProperInterval"))) (ebi_var_ac 0 (ebi_var_ac-2 "" 3789916370 ("" (skeep) (("" (expand "var_ac") (("" (expand "eval_by_intervals") (("" (assert) (("" (lift-if 1) (("" (split 1) (("1" (expand "empty_ErrorTerms") (("1" (flatten) (("1" (expand "eval_pd_i") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "eval_pd_i") (("1" (expand "cdr_ol") (("1" (expand "null_ol?") (("1" (expand "Mult") (("1" (expand "Ge") (("1" (assert) (("1" (expand "Le") (("1" (assert) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) (("1" (apply-extensionality) nil nil) ("2" (typepred "pXi") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_i") (("2" (expand "null_ol?") (("2" (expand "Add") (("2" (assert) (("2" (hide -1) (("2" (expand "[||]") (("2" (expand "empty_ErrorTerms") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (var_ac const-decl "AffineCombination" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (Proper_Add application-judgement "ProperInterval" interval interval_arith) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (Mult const-decl "Interval" interval interval_arith) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (lb_r2i formula-decl nil interval interval_arith) (ub_r2i formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (cons_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Add const-decl "Interval" interval interval_arith) (nXm const-decl "Interval" interval interval_arith) (pXm const-decl "Interval" interval interval_arith) (Neg const-decl "Interval" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (r2i_Nneg application-judgement "(NonNeg?)" interval interval_arith) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (Proper? const-decl "bool" interval interval_arith) (ProperInterval type-eq-decl nil interval interval_arith) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (Le const-decl "bool" interval interval_arith) (Ge const-decl "bool" interval interval_arith) (car_ol const-decl "T" ordered_list structures) (eval_pd_i def-decl "ProperInterval" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (eval_by_intervals const-decl "ProperInterval" affine nil)) shostak) (ebi_var_ac-1 nil 3629202517 ("" (skeep) (("" (expand "var_ac") (("" (expand "eval_by_intervals") (("" (assert) (("" (lift-if 1) (("" (split 1) (("1" (expand "empty_ErrorTerms") (("1" (flatten) (("1" (expand "eval_pd_i") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "eval_pd_i") (("1" (expand "cdr_ol") (("1" (expand "null_ol?") (("1" (expand "Mult") (("1" (expand "Ge") (("1" (assert) (("1" (expand "Le") (("1" (assert) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) (("1" (apply-extensionality) nil nil) ("2" (typepred "pXi") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_i") (("2" (expand "null_ol?") (("2" (expand "Add") (("2" (assert) (("2" (replaces -1) (("2" (hide -1) (("2" (expand "[||]") (("2" (expand "empty_ErrorTerms") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((r2i_Proper application-judgement "ProperInterval" interval interval_arith) (Proper_Add application-judgement "ProperInterval" interval interval_arith) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (Mult const-decl "Interval" interval interval_arith) (lb_r2i formula-decl nil interval interval_arith) (ub_r2i formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (cons_ol const-decl "ordered_list" ordered_list structures) (Add const-decl "Interval" interval interval_arith) (nXm const-decl "Interval" interval interval_arith) (pXm const-decl "Interval" interval interval_arith) (Neg const-decl "Interval" interval interval_arith) (r2i_Nneg application-judgement "(NonNeg?)" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (Proper? const-decl "bool" interval interval_arith) (ProperInterval type-eq-decl nil interval interval_arith) (Le const-decl "bool" interval interval_arith) (Ge const-decl "bool" interval interval_arith) (car_ol const-decl "T" ordered_list structures)) shostak)) (idxs_ac_var_ac 0 (idxs_ac_var_ac-1 nil 3628514454 ("" (skeep) (("" (grind) nil nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (idxs_ac const-decl "list[nat]" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (member def-decl "bool" list_props nil)) shostak)) (updated_noise_on_varac1 0 (updated_noise_on_varac1-1 nil 3628516132 ("" (skeep) (("" (use "eval_upd_no_idxs_ac") (("" (assert) (("" (use "idxs_ac_var_ac") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((eval_upd_no_idxs_ac formula-decl nil affine nil) (var_ac const-decl "AffineCombination" affine nil) (Interval type-eq-decl nil interval interval_arith) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (idxs_ac_var_ac formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (updated_noise_on_varac2_TCC1 0 (updated_noise_on_varac2_TCC1-1 nil 3628272610 ("" (subtype-tcc) nil nil) ((empty_noise const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) nil (updated_noise_on_varac2 subtype "affine.empty_noise" "{N | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), reals.<(affine.n, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1))}"))) (updated_noise_on_varac2 0 (updated_noise_on_varac2-1 nil 3629202385 ("" (skeep) (("" (use "eval_var_ac") (("" (replaces -1) (("" (use "eval_var_ac") (("" (replaces -1) (("" (assert) (("" (use "gnbi_upd") (("" (replaces -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_var_ac formula-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (extend_N const-decl "Noise" affine nil) (empty_noise const-decl "Noise" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (add_N const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (gnbi_upd formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (updated_noise_range_on_v1 0 (updated_noise_range_on_v1-1 nil 3630759314 ("" (skeep :but "n") (("" (induct "n") (("1" (flatten) (("1" (assert) (("1" (expand "upd_noise_range") (("1" (use "updated_noise_on_varac1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "upd_noise_range" 1) (("2" (use "updated_noise_on_varac1") (("2" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (Interval type-eq-decl nil interval interval_arith) (var_ac const-decl "AffineCombination" affine nil) (upd_noise_range def-decl "Noise" affine nil) (nat_induction formula-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (updated_noise_on_varac1 formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (updated_noise_range_on_v2_TCC1 0 (updated_noise_range_on_v2_TCC1-1 nil 3630427738 ("" (subtype-tcc) nil nil) ((empty_noise const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) nil (updated_noise_range_on_v2 subtype "affine.empty_noise" "{N | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), reals.<(affine.i, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1))}"))) (updated_noise_range_on_v2 0 (updated_noise_range_on_v2-1 nil 3630760717 ("" (skeep :but "n") (("" (induct "n") (("1" (flatten) (("1" (expand "upd_noise_range" 1) (("1" (case "i=start") (("1" (replaces -1 :dir RL) (("1" (use "updated_noise_on_varac2") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "upd_noise_range" 1) (("2" (case "i = start + j + 1") (("1" (replaces -1 :dir RL) (("1" (use "updated_noise_on_varac2") (("1" (replaces -1) (("1" (reveal -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replaces -1 :dir RL) (("2" (use "updated_noise_on_varac1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand_ol) nil nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (i skolem-const-decl "nat" affine nil) (start skolem-const-decl "nat" affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (empty_noise const-decl "Noise" affine nil) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (Interval type-eq-decl nil interval interval_arith) (var_ac const-decl "AffineCombination" affine nil) (upd_noise_range def-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (updated_noise_on_varac2 formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (updated_noise_on_varac1 formula-decl nil affine nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (containment_var 0 (containment_var-2 "" 3789916377 ("" (skeep) (("" (expand "var_ac") (("" (expand "eval_ac_noise") (("" (use "ac_proj_cv") (("1" (replaces -1) (("1" (use "ac_proj_pd") (("1" (replaces -1) (("1" (case "(ub(Xi) - lb(Xi)) / 2 /= 0") (("1" (assert) (("1" (inst 1 "(x-((lb(Xi) + ub(Xi)) / 2))/((ub(Xi) - lb(Xi)) / 2)") (("1" (grind) (("1" (name-replace "nor1" "(lb(Xi) + ub(Xi)) / 2") (("1" (name-replace "nor2" "(ub(Xi) - lb(Xi)) / 2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "abs((x - ((lb(Xi) + ub(Xi)) / 2)) / ((ub(Xi) - lb(Xi)) / 2)) <= 1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (case "abs((x - ((lb(Xi) + ub(Xi)) / 2)) / ((ub(Xi) - lb(Xi)) / 2)) = abs((x - ((lb(Xi) + ub(Xi)) / 2))) / abs(((ub(Xi) - lb(Xi)) / 2))") (("1" (replaces -1) (("1" (lemma "both_sides_times_pos_neg_le1") (("1" (inst -1 "abs(((ub(Xi) - lb(Xi)) / 2))" "abs((x - ((lb(Xi) + ub(Xi)) / 2))) / abs(((ub(Xi) - lb(Xi)) / 2))" "1") (("1" (assert) (("1" (hide 2) (("1" (use "div_cancel2") (("1" (replaces -1) (("1" (use "identity_mult") (("1" (replaces -1) (("1" (case "((ub(Xi) - lb(Xi)) / 2) = ((ub(Xi) + ub(Xi) - lb(Xi) - ub(Xi)) / 2)") (("1" (replaces -1) (("1" (case "((ub(Xi) + ub(Xi) - lb(Xi) - ub(Xi)) / 2) = ub(Xi) - ((lb(Xi) + ub(Xi)) / 2)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "abs_div") nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (var_ac const-decl "AffineCombination" affine nil) (ac_proj_cv formula-decl nil affine nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (BaseType type-eq-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (IF const-decl "[boolean, T, T -> T]" if_def nil) (ordered_list type-eq-decl nil ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (Xi skolem-const-decl "Interval" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (n skolem-const-decl "nat" affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ac_proj_pd formula-decl nil affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (x skolem-const-decl "BaseType" affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (eval_pd_noise def-decl "real" affine nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (|##| const-decl "bool" interval interval_arith) (empty_noise const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (add_N const-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (abs_div formula-decl nil real_props nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (identity_mult formula-decl nil number_fields nil) (div_cancel2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_neg_le1 formula-decl nil extra_real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (eval_ac_noise const-decl "real" affine nil)) shostak) (containment_var-1 nil 3622370597 ("" (skeep) (("" (expand "var_ac") (("" (expand "eval_ac_noise") (("" (use "ac_proj_cv") (("1" (replaces -1) (("1" (use "ac_proj_pd") (("1" (replaces -1) (("1" (case "(ub(Xi) - lb(Xi)) / 2 /= 0") (("1" (assert) (("1" (inst 1 "(x-((lb(Xi) + ub(Xi)) / 2))/((ub(Xi) - lb(Xi)) / 2)") (("1" (grind) (("1" (name-replace "nor1" "(lb(Xi) + ub(Xi)) / 2") (("1" (name-replace "nor2" "(ub(Xi) - lb(Xi)) / 2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "abs((x - ((lb(Xi) + ub(Xi)) / 2)) / ((ub(Xi) - lb(Xi)) / 2)) <= 1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (case "abs((x - ((lb(Xi) + ub(Xi)) / 2)) / ((ub(Xi) - lb(Xi)) / 2)) = abs((x - ((lb(Xi) + ub(Xi)) / 2))) / abs(((ub(Xi) - lb(Xi)) / 2))") (("1" (replaces -1) (("1" (lemma "both_sides_times_pos_neg_le1") (("1" (inst -1 "abs(((ub(Xi) - lb(Xi)) / 2))" "abs((x - ((lb(Xi) + ub(Xi)) / 2))) / abs(((ub(Xi) - lb(Xi)) / 2))" "1") (("1" (assert) (("1" (hide 2) (("1" (use "div_cancel2") (("1" (replaces -1) (("1" (use "identity_mult") (("1" (replaces -1) (("1" (case "((ub(Xi) - lb(Xi)) / 2) = ((ub(Xi) + ub(Xi) - lb(Xi) - ub(Xi)) / 2)") (("1" (replaces -1) (("1" (case "((ub(Xi) + ub(Xi) - lb(Xi) - ub(Xi)) / 2) = ub(Xi) - ((lb(Xi) + ub(Xi)) / 2)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "abs_div") nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ((cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (|##| const-decl "bool" interval interval_arith) (null_ol? const-decl "bool" ordered_list structures)) shostak)) (containment_var_single_interval 0 (containment_var_single_interval-1 nil 3629201620 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (SingInterval? const-decl "bool" affine nil) (|##| const-decl "bool" interval interval_arith) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (empty_noise const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_pd_noise def-decl "real" affine nil) (eval_ac_noise const-decl "real" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak)) (containment_var_simple 0 (containment_var_simple-1 nil 3630083755 ("" (skeep) (("" (expand "containment") (("" (use "containment_var") (("" (assert) (("" (skeep) (("" (inst? 1 :where -1) nil nil)) nil)) nil)) nil)) nil)) nil) ((containment const-decl "bool" affine nil) (empty_noise const-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (containment_var formula-decl nil affine nil)) shostak)) (containment_cnt 0 (containment_cnt-1 nil 3621854167 ("" (grind) (("" (expand "eval_pd_noise") (("" (grind) nil nil)) nil)) nil) ((eval_pd_noise def-decl "real" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (const_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) shostak)) (containment_pd_interval 0 (containment_pd_interval-1 nil 3621856388 ("" (skolem 1 ("N" "_")) (("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (expand "eval_pd_noise") (("1" (expand "eval_pd_i") (("1" (grind) nil nil)) nil)) nil) ("2" (skeep*) (("2" (use "eval_pd_noise_rec_pds_def" ("pds" "cons_ol(x,ol)")) (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "eval_pd_i" 2) (("2" (expand "null_ol?") (("2" (lemma "Add_inclusion") (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (inst -1 "Mult([|x`2|], [|-1, 1|])" "eval_pd_i(ol)" "get_noise_by_idx(x`1, N) * x`2" "eval_pd_noise(ol, N)") (("2" (assert) (("2" (hide 3) (("2" (use "Mult_inclusion" ("X" "[|x`2|]" "Y" "[|-1, 1|]" "y" "get_noise_by_idx(x`1, N)" "x" "x`2")) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x::[nat,nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (pred type-eq-decl nil defined_types nil) (ErrorTerms type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (|##| const-decl "bool" interval interval_arith) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (Proper? const-decl "bool" interval interval_arith) (ProperInterval type-eq-decl nil interval interval_arith) (eval_pd_i def-decl "ProperInterval" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ol_ind_sch formula-decl nil ordered_list structures) (r2i_Nneg application-judgement "(NonNeg?)" interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) ([\|\|] const-decl "Interval" interval interval_arith) (null_ol? const-decl "bool" ordered_list structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (real_times_real_is_real application-judgement "real" reals nil) (Add_inclusion formula-decl nil interval interval_arith) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (Mult_inclusion formula-decl nil interval interval_arith) (Mult const-decl "Interval" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (car_ol const-decl "T" ordered_list structures) (Add const-decl "Interval" interval interval_arith) (mXm const-decl "Interval" interval interval_arith) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nXm const-decl "Interval" interval interval_arith) (Neg const-decl "Interval" interval interval_arith) (pXm const-decl "Interval" interval interval_arith) (Le const-decl "bool" interval interval_arith) (Ge const-decl "bool" interval interval_arith) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (containment_interval 0 (containment_interval-1 nil 3621855220 ("" (skeep) (("" (expand "containment") (("" (skeep) (("" (expand "eval_by_intervals") (("" (expand "eval_ac_noise") (("" (use "Add_inclusion") (("" (assert) (("" (hide 2) (("" (prop) (("1" (use "r2i_inclusion") nil nil) ("2" (hide -1) (("2" (use "containment_pd_interval") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((containment const-decl "bool" affine nil) (eval_by_intervals const-decl "ProperInterval" affine nil) (Add_inclusion formula-decl nil interval interval_arith) (eval_pd_noise def-decl "real" affine nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Interval type-eq-decl nil interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Proper? const-decl "bool" interval interval_arith) (ProperInterval type-eq-decl nil interval interval_arith) (eval_pd_i def-decl "ProperInterval" affine nil) (containment_pd_interval formula-decl nil affine nil) (r2i_inclusion formula-decl nil interval interval_arith) (real_plus_real_is_real application-judgement "real" reals nil) (Proper_Add application-judgement "ProperInterval" interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (eval_ac_noise const-decl "real" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (ean_in_ebi 0 (ean_in_ebi-1 nil 3638118476 ("" (skeep) (("" (use "containment_interval") (("" (assert) (("" (expand "containment") (("" (inst 1 "N") nil nil)) nil)) nil)) nil)) nil) ((containment_interval formula-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (containment const-decl "bool" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (epn_app 0 (epn_app-1 nil 3622393060 ("" (skolem 1 ("N" "pds1_" "pds2_")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "add_pd_pd") (("" (expand "map_error" 1) (("" (case "null_ol?(pds1)") (("1" (assert) (("1" (case "null_ol?(pds2)") (("1" (assert) (("1" (hide -3) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "opadd" "restrict[[numfield, numfield],
                                      [BaseType, BaseType],
                                      numfield]
                                     (+)") (("2" (replaces -1) (("2" (case "opadd(0, car_ol(pds2)`2)=car_ol(pds2)`2") (("1" (replaces -1) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, car_ol(pds2)`2), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(empty_ErrorTerms, N)=0") (("1" (replaces -1) (("1" (assert) (("1" (case "pds1=null") (("1" (replaces -1) (("1" (hide -2) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "null_ol" "cdr_ol(pds2)" "opadd") (("1" (expand "null_ol") (("1" (expand "cdr_ol") (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, car_ol(pds2)`2),
                            map_error(pds1, cdr_ol(pds2), opadd))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (assert) (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "pds1=null") (("1" (replaces -1) (("1" (hide -1) (("1" (use "me_ordered_1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "null_ol?(pds2)") (("1" (assert) (("1" (name "opadd" "restrict[[numfield, numfield],
                                                 [BaseType, BaseType],
                                                 numfield]
                                                (+)") (("1" (replaces -1) (("1" (case "opadd(car_ol(pds1)`2, 0)=car_ol(pds1)`2") (("1" (replaces -1) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, car_ol(pds1)`2), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(empty_ErrorTerms, N)=0") (("1" (replaces -1) (("1" (assert) (("1" (case "pds2=null") (("1" (replaces -1) (("1" (hide -2) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "null_ol" "opadd") (("1" (expand "null_ol") (("1" (expand "cdr_ol") (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, car_ol(pds1)`2),
                                        map_error(cdr_ol(pds1), pds2, opadd))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (assert) (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "pds2=null") (("1" (replaces -1) (("1" (hide -1) (("1" (use "me_ordered_1b") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "null_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (name "opadd" "restrict[[numfield, numfield],
                                      [BaseType, BaseType],
                                      numfield]
                                     (+)") (("2" (replaces -1) (("2" (split 3) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst-cp -1 "N" "pds2") (("1" (replaces -2) (("1" (assert) (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (expand "opadd") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1,
                             opadd(car_ol(pds1)`2, car_ol(pds2)`2)),
                            empty_ErrorTerms)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (expand "car_ol") (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "cdr_ol(pds2)" "opadd") (("1" (split -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst-cp -1 "N" "pds2") (("1" (replaces -2) (("1" (assert) (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (case "eval_pd_noise(cdr(pds1), N) + eval_pd_noise(cdr(pds2), N) = 0") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) (("1" (replaces -2) (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1,
                             opadd(car_ol(pds1)`2, car_ol(pds2)`2)),
                            map_error(cdr_ol(pds1), cdr_ol(pds2), opadd))") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -2) (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -3) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "pds2" "opadd") (("1" (expand "null_ol?") (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, opadd(car_ol(pds1)`2, 0)),
                                          empty_ErrorTerms)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (case "eval_pd_noise(cdr_ol(pds1), N) + eval_pd_noise(pds2, N)=0") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty_ErrorTerms") (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, opadd(car_ol(pds1)`2, 0)),
                            map_error(cdr_ol(pds1), pds2, opadd))") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opadd(0, car_ol(pds2)`2)), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "pds1" "cdr_ol(pds2)" "opadd") (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "opadd") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opadd(0, car_ol(pds2)`2)),
                            map_error(pds1, cdr_ol(pds2), opadd))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -2) (("1" (assert) (("1" (expand "opadd") (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opadd") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (map_error def-decl "ErrorTerms" affine nil) (opadd skolem-const-decl "[[BaseType, BaseType] -> numfield]" affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pds1 skolem-const-decl "ErrorTerms" affine nil) (pds2 skolem-const-decl "ErrorTerms" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (me_ordered_2 formula-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_minus_real_is_real application-judgement "real" reals nil) (me_ordered_3 formula-decl nil affine nil) (me_ordered_4 formula-decl nil affine nil) (me_ordered_1b formula-decl nil affine nil) (opadd skolem-const-decl "[[BaseType, BaseType] -> numfield]" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (me_ordered_1 formula-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_cdr_ol formula-decl nil ordered_list structures) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (opadd skolem-const-decl "[[BaseType, BaseType] -> numfield]" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (null_ol const-decl "ordered_list" ordered_list structures) (epn_me_null_1 formula-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (add_ET const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (BaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (add_pd_pd const-decl "ErrorTerms" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (containment_add 0 (containment_add-1 nil 3622374465 ("" (skeep) (("" (expand "add_ac_ac") (("" (expand "eval_ac_noise" 1) (("" (assert) (("" (expand "eval_ac_noise") (("" (replaces -1 :dir RL) (("" (replaces -1 :dir RL) (("" (assert) (("" (use "epn_app") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add_ac_ac const-decl "AffineCombination" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (epn_app formula-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (next_idx_add_ac_ac 0 (next_idx_add_ac_ac-1 nil 3628957217 ("" (deftactic applyih (len num ihfnum lfnum thfnum nnfnum) (spread (inst ihfnum len) ((then (assert) (expand "last_idx" ihfnum 1) (inst? ihfnum :where thfnum) (expand "length" lfnum num) (assert) (expand "last_idx" thfnum num) (expand "last_ol" thfnum num) (expand "last_idx" ihfnum num) (hide-all-but (list ihfnum thfnum nnfnum)) (lift-if 1) (lift-if -1) (grind)) (let ((nlfnum (+ lfnum 1)) (nnnfnum (if (listp nnfnum) (mapcar (lambda (n) (+ n 1)) nnfum) (+ nnfnum 1)))) (then (hide-all-but (list 1 nnnfnum nlfnum)) (grind)))))) (("" (skeep) (("" (expand "add_ac_ac") (("" (assert) (("" (expand "next_idx") (("" (name-replace "pds1_" "pd(Xa1)") (("" (name-replace "pds2_" "pd(Xa2)") (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "add_pd_pd") (("" (expand "map_error" 1) (("" (expand_ol) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (expand_ol) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 (1 2)) (("1" (assert) (("1" (expand "last_ol") (("1" (hide-all-but (1 3)) (("1" (typepred "pds2") (("1" (rewrite "max") (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1 1) (("1" (assert) (("1" (applyih "j-1" 2 -3 -4 1 4) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx" 2 1) (("2" (assert) (("2" (applyih "j-1" 2 -2 -3 2 5) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 (1 3)) (("1" (assert) (("1" (expand "last_ol") (("1" (hide-all-but (1 3)) (("1" (typepred "pds1") (("1" (rewrite "max") (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1) (("1" (assert) (("1" (applyih "j-1" 1 -3 -4 1 4) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx" 2 1) (("2" (assert) (("2" (applyih "j-1" 1 -2 -3 2 5) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (label "lengths" -4) (("1" (label "ind-hyp" -3) (("1" (label "thesis" 1) (("1" (label "not null" (2 3)) (("1" (inst "ind-hyp" "j-2") (("1" (assert) (("1" (inst? "ind-hyp" :where "thesis") (("1" (expand "length" "lengths") (("1" (assert) (("1" (case "cdr(pds1)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "cdr(pds2)=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if "thesis") (("1" (split thesis) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (thesis ind-hyp)) (("2" (name-replace "A" "last_idx(map_error(null, cdr(pds2),
                          
                              (+)))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "cdr(pds2)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if thesis) (("1" (split thesis) (("1" (flatten) (("1" (hide-all-but (thesis ind-hyp)) (("1" (name-replace "A" "last_idx(map_error(cdr(pds1), null,
                          
                              (+)))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1) (("1" (expand "last_idx" 1 (2 1)) (("1" (assert) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (hide-all-but (-1 1 3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1 1) (("1" (assert) (("1" (expand "last_idx" -3 1) (("1" (label "lengths" -4) (("1" (label "ind-hyp" -3) (("1" (label "thesis" 1) (("1" (label "not null" (4 5)) (("1" (inst "ind-hyp" "j-2") (("1" (assert) (("1" (inst? "ind-hyp" :where "thesis") (("1" (expand "length" "lengths") (("1" (assert) (("1" (case "cdr(pds1)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "cdr(pds2)=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "last_idx" "thesis" 1) (("2" (expand "last_idx" "ind-hyp" 1) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if "thesis") (("1" (split thesis) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (thesis ind-hyp)) (("2" (name-replace "A" "last_ol(map_error(null, cdr(pds2),

                                                  (+)))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 1) (("2" (expand "last_idx" "ind-hyp" 1) (("2" (assert) (("2" (case "cdr(pds2)=null") (("1" (expand "last_idx" "thesis" 1) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 1) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if thesis) (("1" (split thesis) (("1" (flatten) (("1" (hide-all-but (thesis ind-hyp)) (("1" (name-replace "A" "last_ol(map_error(cdr(pds1), null,

                                                  (+)))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 1) (("2" (expand "last_idx" "ind-hyp" 1) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (label "lengths" -3) (("2" (label "ind-hyp" -2) (("2" (label "thesis" 2) (("2" (label "not null" (5 6)) (("2" (inst "ind-hyp" "j-2") (("1" (assert) (("1" (inst? "ind-hyp" :where "thesis") (("1" (expand "length" "lengths") (("1" (assert) (("1" (case "cdr(pds1)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "cdr(pds2)=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if "thesis") (("1" (split thesis) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (thesis ind-hyp)) (("2" (name-replace "A" "last_idx(map_error(null, cdr(pds2),

                                                  (+)))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "cdr(pds2)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if thesis) (("1" (split thesis) (("1" (flatten) (("1" (hide-all-but (thesis ind-hyp)) (("1" (name-replace "A" "last_idx(map_error(cdr(pds1), null,

                                                  (+)))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol") (("1" (expand "last_idx" 1) (("1" (assert) (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "cons_ol") (("1" (expand "last_ol" 1) (("1" (assert) (("1" (expand "null_ol?") (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (expand "last_idx" -3 1) (("1" (inst? -3 :where 1) (("1" (expand "length" -4 1) (("1" (assert) (("1" (case "last_idx(cdr(pds1)) <= last_idx(pds1)") (("1" (name-replace "A" "1 +
       last_ol(map_error(cdr(pds1), pds2,(+)))`1") (("1" (hide-all-but (-1 -4 1)) (("1" (name-replace "B" "last_idx(cdr(pds1))") (("1" (name-replace "C" "last_idx(pds1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx" 2 1) (("2" (expand "null_ol?") (("2" (assert) (("2" (inst -2 "j-1") (("1" (assert) (("1" (expand "last_idx" -2 1) (("1" (inst? -2 :where 2) (("1" (expand "length" -3 1) (("1" (assert) (("1" (case "last_idx(cdr(pds1)) <= last_idx(pds1)") (("1" (name-replace "A" "1 +
                           last_ol(map_error(cdr(pds1), pds2,(+)))`1") (("1" (hide-all-but (-1 -3 2)) (("1" (name-replace "B" "last_idx(cdr(pds1))") (("1" (name-replace "C" "last_idx(pds1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst? -2 :where 1) (("1" (expand "length" -3 2) (("1" (assert) (("1" (case "last_idx(cdr(pds2)) <= last_idx(pds2)") (("1" (name-replace "A" "1 +
                           last_idx(map_error(pds1, cdr(pds2),(+)))") (("1" (hide-all-but (-1 -3 1)) (("1" (name-replace "B" "last_idx(cdr(pds2))") (("1" (name-replace "C" "last_idx(pds2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1) (("1" (expand "cons_ol") (("1" (assert) (("1" (expand "last_ol" 1 1) (("1" (expand "empty_ErrorTerms") (("1" (use "olidx_car_last[nzBaseType]" ("ol" "pds2")) (("1" (hide-all-but (-1 1 5 6)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1 1) (("1" (expand "null_ol?") (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (expand "last_idx" -2 1) (("1" (inst? -2 :where 1) (("1" (expand "length" -3 2) (("1" (assert) (("1" (case "last_idx(cdr(pds2)) <= last_idx(pds2)") (("1" (name-replace "A" "1 +
                           last_ol(map_error(pds1, cdr(pds2),(+)))`1") (("1" (hide-all-but (-1 -3 1)) (("1" (name-replace "B" "last_idx(cdr(pds2))") (("1" (name-replace "C" "last_idx(pds2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst? -1 :where 2) (("1" (expand "length" -2 2) (("1" (assert) (("1" (case "last_idx(cdr(pds2)) <= last_idx(pds2)") (("1" (name-replace "A" "1 +
                           last_idx(map_error(pds1, cdr(pds2),(+)))") (("1" (hide-all-but (-1 -2 2)) (("1" (name-replace "B" "last_idx(cdr(pds2))") (("1" (name-replace "C" "last_idx(pds2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ac_proj_pd formula-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (map_error def-decl "ErrorTerms" affine nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (restrict const-decl "R" restrict nil) (last_ol def-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (olidx_car_last formula-decl nil indexed_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add_ET const-decl "ErrorTerms" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car_ol const-decl "T" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (add_pd_pd const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (next_idx const-decl "nat" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil) (TRUE const-decl "bool" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (idxs_ac_add_ac_ac 0 (idxs_ac_add_ac_ac-1 nil 3628936675 ("" (skeep) (("" (expand "add_ac_ac") (("" (expand "idxs_ac") (("" (assert) (("" (generalize "pd(Xa1)" "pds1") (("" (generalize "pd(Xa2)" "pds2") (("" (skolem 1 ("pds2_" "pds1_")) (("" (name "L" "length(pds1_) + length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "add_pd_pd") (("" (expand "map_error" -3) (("" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("" (lift-if -3) (("" (split -3) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "add_ET" -1) (("2" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -2) (("1" (expand "length" -5 2) (("1" (assert) (("1" (hide-all-but (-4 3 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5 2) (("1" (assert) (("1" (hide-all-but (-4 3 5)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 2) (("1" (assert) (("1" (hide-all-but (-3 4 6)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (expand "idxs_pd" -2) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (expand "idxs_pd" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") nil nil) ("2" (flatten) (("2" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("2" (expand "member" -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5 1) (("1" (assert) (("1" (hide-all-but (4 5 -4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 1) (("1" (assert) (("1" (hide-all-but (4 5 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (inst -4 "j-2") (("1" (assert) (("1" (inst? -4 :where -2) (("1" (expand "length" -5) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "member" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (expand "idxs_pd" -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (inst -4 "j-2") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-2") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -2) (("1" (expand "length" -5 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand* "null_ol?" "cons_ol" "car_ol" "cdr_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -2) (("1" (expand "length" -4 2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (lift-if -2) (("1" (expand* "null_ol?" "cons_ol" "car_ol" "cdr_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 2) (("1" (assert) (("1" (hide-all-but (-3 5 8)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst? -2 :where -1) (("1" (expand "length" -3 2) (("1" (assert) (("1" (hide-all-but (-2 6 9)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add_ac_ac const-decl "AffineCombination" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (ac_proj_pd formula-decl nil affine nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (map_error def-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_ET const-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (add_pd_pd const-decl "ErrorTerms" affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (idxs_ac const-decl "list[nat]" affine nil)) nil)) (epn_spp 0 (epn_spp-2 "" 3789916410 ("" (skolem 1 ("N" "pds1_" "pds2_")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "sub_pd_pd") (("" (expand "map_error" 1) (("" (case "null_ol?(pds1)") (("1" (assert) (("1" (case "null_ol?(pds2)") (("1" (assert) (("1" (hide -3) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "opsub" "restrict[[numfield, numfield],
                                                 [BaseType, BaseType],
                                                 numfield]
                                                (-)") (("2" (replaces -1) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(empty_ErrorTerms, N)=0") (("1" (replaces -1) (("1" (assert) (("1" (case "pds1=null") (("1" (replaces -1) (("1" (hide -2) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "null_ol" "cdr_ol(pds2)" "opsub") (("1" (expand "null_ol") (("1" (expand "cdr_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)),
                                        map_error(pds1, cdr_ol(pds2), opsub))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (assert) (("1" (expand "car_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "pds1=null") (("1" (replaces -1) (("1" (hide -1) (("1" (use "me_ordered_1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "null_ol?(pds2)") (("1" (assert) (("1" (name "opsub" "restrict[[numfield, numfield],
                                                            [BaseType, BaseType],
                                                            numfield]
                                                           (-)") (("1" (replaces -1) (("1" (case "opsub(car_ol(pds1)`2, 0)=car_ol(pds1)`2") (("1" (replaces -1) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, car_ol(pds1)`2), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(empty_ErrorTerms, N)=0") (("1" (replaces -1) (("1" (assert) (("1" (case "pds2=null") (("1" (replaces -1) (("1" (hide -2) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "null_ol" "opsub") (("1" (expand "null_ol") (("1" (expand "cdr_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, car_ol(pds1)`2),
                                                    map_error(cdr_ol(pds1), pds2, opsub))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (assert) (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "pds2=null") (("1" (replaces -1) (("1" (hide -1) (("1" (use "me_ordered_1b") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "null_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (name "opsub" "restrict[[numfield, numfield],
                                                 [BaseType, BaseType],
                                                 numfield]
                                                (-)") (("2" (replaces -1) (("2" (split 3) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst-cp -1 "N" "pds2") (("1" (replaces -2) (("1" (assert) (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (expand "opsub") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1,
                                         opsub(car_ol(pds1)`2, car_ol(pds2)`2)),
                                        empty_ErrorTerms)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (expand "car_ol") (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "cdr_ol(pds2)" "opsub") (("1" (split -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst-cp -1 "N" "pds2") (("1" (replaces -2) (("1" (assert) (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (case "eval_pd_noise(cdr(pds1), N) - eval_pd_noise(cdr(pds2), N) = 0") (("1" (case "eval_pd_noise(cdr(pds1), N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2
        - eval_pd_noise(cdr(pds2), N)
        - get_noise_by_idx(car_ol(pds2)`1, N) * car_ol(pds2)`2 = 
eval_pd_noise(cdr(pds1), N) - eval_pd_noise(cdr(pds2), N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2
        
        - get_noise_by_idx(car_ol(pds2)`1, N) * car_ol(pds2)`2") (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -1) (("1" (assert) (("1" (replaces -2) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1,
                                           opsub(car_ol(pds1)`2, car_ol(pds2)`2)),
                                          map_error(cdr_ol(pds1), cdr_ol(pds2), opsub))") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -2) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -3) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "pds2" "opsub") (("1" (expand "null_ol?") (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, opsub(car_ol(pds1)`2, 0)),
                                                          empty_ErrorTerms)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (case "eval_pd_noise(cdr_ol(pds1), N) - eval_pd_noise(pds2, N)=0") (("1" (case "eval_pd_noise(cdr_ol(pds1), N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2
        - eval_pd_noise(pds2, N) =

eval_pd_noise(cdr_ol(pds1), N) - eval_pd_noise(pds2, N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2") (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -1) (("1" (assert) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty_ErrorTerms") (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, opsub(car_ol(pds1)`2, 0)),
                                            map_error(cdr_ol(pds1), pds2, opsub))") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "pds1" "cdr_ol(pds2)" "opsub") (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)),
                                            map_error(pds1, cdr_ol(pds2), opsub))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -2) (("1" (assert) (("1" (expand "opsub") (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (map_error def-decl "ErrorTerms" affine nil) (opsub skolem-const-decl "[[BaseType, BaseType] -> numfield]" affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pds1 skolem-const-decl "ErrorTerms" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (me_ordered_2 formula-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (me_ordered_3 formula-decl nil affine nil) (me_ordered_4 formula-decl nil affine nil) (me_ordered_1b formula-decl nil affine nil) (opsub skolem-const-decl "[[BaseType, BaseType] -> numfield]" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (me_ordered_1 formula-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_cdr_ol formula-decl nil ordered_list structures) (j skolem-const-decl "nat" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (pds2 skolem-const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (null_ol const-decl "ordered_list" ordered_list structures) (epn_me_null_1 formula-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (opsub skolem-const-decl "[[BaseType, BaseType] -> numfield]" affine nil) (car_ol const-decl "T" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (restrict const-decl "R" restrict nil) (BaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (sub_pd_pd const-decl "ErrorTerms" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (epn_spp-1 nil 3622483873 ("" (skolem 1 ("N" "pds1_" "pds2_")) (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "sub_pd_pd") (("" (expand "map_error" 1) (("" (case "null_ol?(pds1)") (("1" (assert) (("1" (case "null_ol?(pds2)") (("1" (assert) (("1" (hide -3) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "opsub" "restrict[[numfield, numfield],
                                                 [BaseType, BaseType],
                                                 numfield]
                                                (-)") (("2" (replaces -1) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(empty_ErrorTerms, N)=0") (("1" (replaces -1) (("1" (assert) (("1" (case "pds1=null") (("1" (replaces -1) (("1" (hide -2) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "null_ol" "cdr_ol(pds2)" "opsub") (("1" (expand "null_ol") (("1" (expand "cdr_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)),
                                        map_error(pds1, cdr_ol(pds2), opsub))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (assert) (("1" (expand "car_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "pds1=null") (("1" (replaces -1) (("1" (hide -1) (("1" (use "me_ordered_1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "null_ol?(pds2)") (("1" (assert) (("1" (name "opsub" "restrict[[numfield, numfield],
                                                            [BaseType, BaseType],
                                                            numfield]
                                                           (-)") (("1" (replaces -1) (("1" (case "opsub(car_ol(pds1)`2, 0)=car_ol(pds1)`2") (("1" (replaces -1) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, car_ol(pds1)`2), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "eval_pd_noise(empty_ErrorTerms, N)=0") (("1" (replaces -1) (("1" (assert) (("1" (case "pds2=null") (("1" (replaces -1) (("1" (hide -2) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "null_ol" "opsub") (("1" (expand "null_ol") (("1" (expand "cdr_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, car_ol(pds1)`2),
                                                    map_error(cdr_ol(pds1), pds2, opsub))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (assert) (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "pds2=null") (("1" (replaces -1) (("1" (hide -1) (("1" (use "me_ordered_1b") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "null_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (name "opsub" "restrict[[numfield, numfield],
                                                 [BaseType, BaseType],
                                                 numfield]
                                                (-)") (("2" (replaces -1) (("2" (split 3) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst-cp -1 "N" "pds2") (("1" (replaces -2) (("1" (assert) (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (expand "opsub") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1,
                                         opsub(car_ol(pds1)`2, car_ol(pds2)`2)),
                                        empty_ErrorTerms)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (expand "car_ol") (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "cdr_ol(pds2)" "opsub") (("1" (split -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst-cp -1 "N" "pds2") (("1" (replaces -2) (("1" (assert) (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (case "eval_pd_noise(cdr(pds1), N) - eval_pd_noise(cdr(pds2), N) = 0") (("1" (case "eval_pd_noise(cdr(pds1), N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2
        - eval_pd_noise(cdr(pds2), N)
        - get_noise_by_idx(car_ol(pds2)`1, N) * car_ol(pds2)`2 = 
eval_pd_noise(cdr(pds1), N) - eval_pd_noise(cdr(pds2), N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2
        
        - get_noise_by_idx(car_ol(pds2)`1, N) * car_ol(pds2)`2") (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -1) (("1" (assert) (("1" (replaces -2) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1,
                                           opsub(car_ol(pds1)`2, car_ol(pds2)`2)),
                                          map_error(cdr_ol(pds1), cdr_ol(pds2), opsub))") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -2) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -3) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "cdr_ol(pds1)" "pds2" "opsub") (("1" (expand "null_ol?") (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, opsub(car_ol(pds1)`2, 0)),
                                                          empty_ErrorTerms)") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (replaces -1) (("1" (assert) (("1" (case "eval_pd_noise(cdr_ol(pds1), N) - eval_pd_noise(pds2, N)=0") (("1" (case "eval_pd_noise(cdr_ol(pds1), N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2
        - eval_pd_noise(pds2, N) =

eval_pd_noise(cdr_ol(pds1), N) - eval_pd_noise(pds2, N) +
        get_noise_by_idx(car_ol(pds1)`1, N) * car_ol(pds1)`2") (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -1) (("1" (assert) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty_ErrorTerms") (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds1)`1, opsub(car_ol(pds1)`2, 0)),
                                            map_error(cdr_ol(pds1), pds2, opsub))") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -3) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds1") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but -1) (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)), empty_ErrorTerms)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "eval_pd_noise(empty_ErrorTerms, N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "epn_me_null_1") (("1" (inst -1 "N" "pds1" "cdr_ol(pds2)" "opsub") (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "opsub") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car_ol(pds2)`1, opsub(0, car_ol(pds2)`2)),
                                            map_error(pds1, cdr_ol(pds2), opsub))") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (replaces -1) (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "pds2") (("1" (assert) (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (replaces -2) (("1" (assert) (("1" (expand "opsub") (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "opsub") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "me_ordered_4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length_cdr_ol formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures)) shostak)) (containment_sub 0 (containment_sub-1 nil 3622486764 ("" (skeep) (("" (expand "sub_ac_ac") (("" (expand "eval_ac_noise" 1) (("" (assert) (("" (expand "eval_ac_noise") (("" (replaces -1 :dir RL) (("" (replaces -1 :dir RL) (("" (assert) (("" (use "epn_spp") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sub_ac_ac const-decl "AffineCombination" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (epn_spp formula-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (next_idx_sub_ac_ac 0 (next_idx_sub_ac_ac-1 nil 3629025578 ("" (deftactic applyih (len num ihfnum lfnum thfnum nnfnum) (spread (inst ihfnum len) ((then (assert) (expand "last_idx" ihfnum 1) (inst? ihfnum :where thfnum) (expand "length" lfnum num) (assert) (expand "last_idx" thfnum num) (expand "last_ol" thfnum num) (expand "last_idx" ihfnum num) (hide-all-but (list ihfnum thfnum nnfnum)) (lift-if 1) (lift-if -1) (grind)) (let ((nlfnum (+ lfnum 1)) (nnnfnum (if (listp nnfnum) (mapcar (lambda (n) (+ n 1)) nnfum) (+ nnfnum 1)))) (then (hide-all-but (list 1 nnnfnum nlfnum)) (grind)))))) (("" (skeep) (("" (expand "sub_ac_ac") (("" (assert) (("" (expand "next_idx") (("" (name-replace "pds1_" "pd(Xa1)") (("" (name-replace "pds2_" "pd(Xa2)") (("" (name "L" "length(pds1_)+length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "sub_pd_pd") (("" (expand "map_error" 1) (("" (expand_ol) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (expand_ol) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 (1 2)) (("1" (assert) (("1" (expand "last_ol") (("1" (hide-all-but (1 3)) (("1" (typepred "pds2") (("1" (rewrite "max") (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1 1) (("1" (assert) (("1" (applyih "j-1" 2 -3 -4 1 4) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx" 2 1) (("2" (assert) (("2" (applyih "j-1" 2 -2 -3 2 5) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 (1 3)) (("1" (assert) (("1" (expand "last_ol") (("1" (hide-all-but (1 3)) (("1" (typepred "pds1") (("1" (rewrite "max") (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1) (("1" (assert) (("1" (applyih "j-1" 1 -3 -4 1 4) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx" 2 1) (("2" (assert) (("2" (applyih "j-1" 1 -2 -3 2 5) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (expand_ol) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (label "lengths" -4) (("1" (label "ind-hyp" -3) (("1" (label "thesis" 1) (("1" (label "not null" (2 3)) (("1" (inst "ind-hyp" "j-2") (("1" (assert) (("1" (inst? "ind-hyp" :where "thesis") (("1" (expand "length" "lengths") (("1" (assert) (("1" (case "cdr(pds1)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "cdr(pds2)=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if "thesis") (("1" (split thesis) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (thesis ind-hyp)) (("2" (name-replace "A" "last_idx(map_error(null, cdr(pds2),

                                                  (-)))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "cdr(pds2)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if thesis) (("1" (split thesis) (("1" (flatten) (("1" (hide-all-but (thesis ind-hyp)) (("1" (name-replace "A" "last_idx(map_error(cdr(pds1), null,

                                                  (-)))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1) (("1" (expand "last_idx" 1 (2 1)) (("1" (assert) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (hide-all-but (-1 1 3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1 1) (("1" (assert) (("1" (expand "last_idx" -3 1) (("1" (label "lengths" -4) (("1" (label "ind-hyp" -3) (("1" (label "thesis" 1) (("1" (label "not null" (4 5)) (("1" (inst "ind-hyp" "j-2") (("1" (assert) (("1" (inst? "ind-hyp" :where "thesis") (("1" (expand "length" "lengths") (("1" (assert) (("1" (case "cdr(pds1)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "cdr(pds2)=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "last_idx" "thesis" 1) (("2" (expand "last_idx" "ind-hyp" 1) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if "thesis") (("1" (split thesis) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (thesis ind-hyp)) (("2" (name-replace "A" "last_ol(map_error(null, cdr(pds2),
                                                                          (-)))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 1) (("2" (expand "last_idx" "ind-hyp" 1) (("2" (assert) (("2" (case "cdr(pds2)=null") (("1" (expand "last_idx" "thesis" 1) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 1) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if thesis) (("1" (split thesis) (("1" (flatten) (("1" (hide-all-but (thesis ind-hyp)) (("1" (name-replace "A" "last_ol(map_error(cdr(pds1), null,
                                                                          (-)))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 1) (("2" (expand "last_idx" "ind-hyp" 1) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (label "lengths" -3) (("2" (label "ind-hyp" -2) (("2" (label "thesis" 2) (("2" (label "not null" (5 6)) (("2" (inst "ind-hyp" "j-2") (("1" (assert) (("1" (inst? "ind-hyp" :where "thesis") (("1" (expand "length" "lengths") (("1" (assert) (("1" (case "cdr(pds1)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "cdr(pds2)=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if "thesis") (("1" (split thesis) (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (thesis ind-hyp)) (("2" (name-replace "A" "last_idx(map_error(null, cdr(pds2),
                                                                          (-)))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "cdr(pds2)=null") (("1" (expand "last_idx" "thesis" 2) (("1" (replaces -1) (("1" (expand "last_idx" "ind-hyp" 2) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if thesis) (("1" (split thesis) (("1" (flatten) (("1" (hide-all-but (thesis ind-hyp)) (("1" (name-replace "A" "last_idx(map_error(cdr(pds1), null,
                                                                          (-)))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" "thesis" 2) (("2" (expand "last_idx" "ind-hyp" 2) (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1)) = last_ol(pds1) ") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2)) = last_ol(pds2) ") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol") (("1" (expand "last_idx" 1) (("1" (assert) (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1 1) (("1" (expand "cons_ol") (("1" (expand "last_ol" 1) (("1" (assert) (("1" (expand "null_ol?") (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (expand "last_idx" -3 1) (("1" (inst? -3 :where 1) (("1" (expand "length" -4 1) (("1" (assert) (("1" (case "last_idx(cdr(pds1)) <= last_idx(pds1)") (("1" (name-replace "A" "1 +
                           last_ol(map_error(cdr(pds1), pds2,(-)))`1") (("1" (hide-all-but (-1 -4 1)) (("1" (name-replace "B" "last_idx(cdr(pds1))") (("1" (name-replace "C" "last_idx(pds1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx" 2 1) (("2" (expand "null_ol?") (("2" (assert) (("2" (inst -2 "j-1") (("1" (assert) (("1" (expand "last_idx" -2 1) (("1" (inst? -2 :where 2) (("1" (expand "length" -3 1) (("1" (assert) (("1" (case "last_idx(cdr(pds1)) <= last_idx(pds1)") (("1" (name-replace "A" "1 +
                                               last_ol(map_error(cdr(pds1), pds2,(-)))`1") (("1" (hide-all-but (-1 -3 2)) (("1" (name-replace "B" "last_idx(cdr(pds1))") (("1" (name-replace "C" "last_idx(pds1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst? -2 :where 1) (("1" (expand "length" -3 2) (("1" (assert) (("1" (case "last_idx(cdr(pds2)) <= last_idx(pds2)") (("1" (name-replace "A" "1 +
                                           last_idx(map_error(pds1, cdr(pds2),(-)))") (("1" (hide-all-but (-1 -3 1)) (("1" (name-replace "B" "last_idx(cdr(pds2))") (("1" (name-replace "C" "last_idx(pds2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "last_idx" 1) (("1" (expand "cons_ol") (("1" (assert) (("1" (expand "last_ol" 1 1) (("1" (expand "empty_ErrorTerms") (("1" (use "olidx_car_last[nzBaseType]" ("ol" "pds2")) (("1" (hide-all-but (-1 1 5 6)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "last_idx" 1 1) (("1" (expand "last_ol" 1 1) (("1" (expand "null_ol?") (("1" (assert) (("1" (inst -2 "j-1") (("1" (assert) (("1" (expand "last_idx" -2 1) (("1" (inst? -2 :where 1) (("1" (expand "length" -3 2) (("1" (assert) (("1" (case "last_idx(cdr(pds2)) <= last_idx(pds2)") (("1" (name-replace "A" "1 +
                                               last_ol(map_error(pds1, cdr(pds2),(-)))`1") (("1" (hide-all-but (-1 -3 1)) (("1" (name-replace "B" "last_idx(cdr(pds2))") (("1" (name-replace "C" "last_idx(pds2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst? -1 :where 2) (("1" (expand "length" -2 2) (("1" (assert) (("1" (case "last_idx(cdr(pds2)) <= last_idx(pds2)") (("1" (name-replace "A" "1 +
                                               last_idx(map_error(pds1, cdr(pds2),(-)))") (("1" (hide-all-but (-1 -2 2)) (("1" (name-replace "B" "last_idx(cdr(pds2))") (("1" (name-replace "C" "last_idx(pds2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ac_proj_pd formula-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (map_error def-decl "ErrorTerms" affine nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (restrict const-decl "R" restrict nil) (last_ol def-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (olidx_car_last formula-decl nil indexed_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add_ET const-decl "ErrorTerms" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car_ol const-decl "T" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sub_pd_pd const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (next_idx const-decl "nat" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil) (TRUE const-decl "bool" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (idxs_ac_sub_ac_ac 0 (idxs_ac_sub_ac_ac-1 nil 3628933543 ("" (skeep) (("" (expand "sub_ac_ac") (("" (expand "idxs_ac") (("" (assert) (("" (generalize "pd(Xa1)" "pds1") (("" (generalize "pd(Xa2)" "pds2") (("" (skolem 1 ("pds2_" "pds1_")) (("" (name "L" "length(pds1_) + length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "sub_pd_pd") (("" (expand "map_error" -3) (("" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("" (lift-if -3) (("" (split -3) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "add_ET" -1) (("2" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -2) (("1" (expand "length" -5 2) (("1" (assert) (("1" (hide-all-but (-4 3 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5 2) (("1" (assert) (("1" (hide-all-but (-4 3 5)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 2) (("1" (assert) (("1" (hide-all-but (-3 4 6)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (expand "idxs_pd" -2) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (expand "idxs_pd" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") nil nil) ("2" (flatten) (("2" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("2" (expand "member" -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5 1) (("1" (assert) (("1" (hide-all-but (4 5 -4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 1) (("1" (assert) (("1" (hide-all-but (4 5 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (inst -4 "j-2") (("1" (assert) (("1" (inst? -4 :where -2) (("1" (expand "length" -5) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "member" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (expand "idxs_pd" -1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (inst -4 "j-2") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-2") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET" -2) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -2) (("1" (expand "length" -5 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand* "null_ol?" "cons_ol" "car_ol" "cdr_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (inst -4 "j-1") (("1" (assert) (("1" (inst? -4 :where -1) (("1" (expand "length" -5 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -2) (("1" (expand "length" -4 2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (lift-if -2) (("1" (expand* "null_ol?" "cons_ol" "car_ol" "cdr_ol") (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (inst -3 "j-1") (("1" (assert) (("1" (inst? -3 :where -1) (("1" (expand "length" -4 2) (("1" (assert) (("1" (hide-all-but (-3 5 8)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst? -2 :where -1) (("1" (expand "length" -3 2) (("1" (assert) (("1" (hide-all-but (-2 6 9)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sub_ac_ac const-decl "AffineCombination" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (ac_proj_pd formula-decl nil affine nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (map_error def-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (add_ET const-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (sub_pd_pd const-decl "ErrorTerms" affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (idxs_ac const-decl "list[nat]" affine nil)) shostak)) (car_mul_s_ac_TCC1 0 (car_mul_s_ac_TCC1-1 nil 3630083031 ("" (expand_ol) (("" (grind) nil nil)) nil) ((/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mul_s_pd def-decl "ErrorTerms" affine nil) (add_ET const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures)) nil (car_mul_s_ac subtype "affine.mul_s_pd(affine.x2, affine.pds)" "(list_adt[[nat, nzBaseType]].cons?)"))) (car_mul_s_ac_TCC2 0 (car_mul_s_ac_TCC2-1 nil 3630083031 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (/= const-decl "boolean" notequal nil)) nil (car_mul_s_ac subtype "affine.pds" "(list_adt[[nat, nzBaseType]].cons?)"))) (car_mul_s_ac 0 (car_mul_s_ac-1 nil 3630083174 ("" (induct "pds") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (expand_ol) (("3" (hide 2) (("3" (case "tpds=null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (split -1) (("1" (inst? -1 :where 2) (("1" (assert) (("1" (expand "mul_s_pd" 3) (("1" (expand_ol) (("1" (expand "add_ET") (("1" (expand_ol) (("1" (lift-if 3) (("1" (split 3) (("1" (flatten) (("1" (typepred "hpds`2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (expand "ordered_list?") (("2" (flatten) (("2" (expand "lt_idx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (split -1) (("1" (expand "ordered_list?" 1) (("1" (assert) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ((TRUE const-decl "bool" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (BaseType type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ErrorTerms type-eq-decl nil affine nil) (mul_s_pd def-decl "ErrorTerms" affine nil)) shostak)) (containment_mul_s 0 (containment_mul_s-2 "" 3789916431 ("" (skeep) (("" (expand "mul_s_ac") (("" (expand "eval_ac_noise") (("" (assert) (("" (generalize "pd(Xa)" "pds") (("" (generalize "cv(Xa)" "c") (("" (generalize "x1" "x1") (("" (generalize "x2" "x2") (("" (induct "pds") (("1" (grind) nil nil) ("2" (flatten) (("2" (skeep) (("2" (expand "mul_s_pd") (("2" (expand_ol) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (split -1) (("1" (expand "mul_s_pd" 1) (("1" (expand_ol) (("1" (expand "add_ET") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -5) (("1" (expand_ol) (("1" (replaces -1) (("1" (inst -2 "x2!1" "x1!1 - get_noise_by_idx(hpds`1, N) * hpds`2" "c") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (split 2) (("1" (flatten) (("1" (case "tpds = null") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -5) (("1" (replaces -1) (("1" (expand_ol) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (expand_ol) (("1" (replaces -4 :dir RL) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where 1) (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "x2!1=0") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (expand_ol) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -5) (("1" (replaces -1) (("1" (expand_ol) (("1" (inst -2 "x2!1" "x1!1 - get_noise_by_idx(hpds`1, N) * hpds`2" "c") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "ordered_list?") (("2" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (case "x2!1 = 0") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (case "tpds = null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (case "car(mul_s_pd(x2!1, tpds))`1 = car(tpds)`1") (("1" (replaces -1) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil) ("2" (use "car_mul_s_ac") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mul_s_ac const-decl "AffineCombination" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (add_ET const-decl "ErrorTerms" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car_mul_s_ac formula-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (hpds skolem-const-decl "[nat, nzBaseType]" affine nil) (x2!1 skolem-const-decl "BaseType" affine nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (TRUE const-decl "bool" booleans nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (list_induction formula-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (mul_s_pd def-decl "ErrorTerms" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (eval_ac_noise const-decl "real" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (containment_mul_s-1 nil 3623140076 ("" (skeep) (("" (expand "mul_s_ac") (("" (expand "eval_ac_noise") (("" (assert) (("" (generalize "pd(Xa)" "pds") (("" (generalize "cv(Xa)" "c") (("" (generalize "x1" "x1") (("" (generalize "x2" "x2") (("" (induct "pds") (("1" (grind) nil nil) ("2" (flatten) (("2" (skeep) (("2" (expand "mul_s_pd") (("2" (expand_ol) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (split -1) (("1" (expand "mul_s_pd" 1) (("1" (expand_ol) (("1" (expand "add_ET") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -5) (("1" (expand_ol) (("1" (replaces -1) (("1" (inst -2 "x2!1" "x1!1 - get_noise_by_idx(hpds`1, N) * hpds`2" "c") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (split 2) (("1" (flatten) (("1" (case "tpds = null") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -5) (("1" (replaces -1) (("1" (expand_ol) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (expand_ol) (("1" (replaces -4 :dir RL) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where 1) (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "x2!1=0") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where 1) (("1" (replaces -1) (("1" (expand_ol) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -5) (("1" (replaces -1) (("1" (expand_ol) (("1" (inst -2 "x2!1" "x1!1 - get_noise_by_idx(hpds`1, N) * hpds`2" "c") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "ordered_list?") (("2" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (case "x2!1 = 0") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (case "tpds = null") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (case "car(mul_s_pd(x2!1, tpds))`1 = car(tpds)`1") (("1" (replaces -1) (("1" (expand "lt_idx") (("1" (propax) nil nil)) nil)) nil) ("2" (use "car_mul_s_ac") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (assert) (("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak)) (containment_add_s 0 (containment_add_s-1 nil 3623096441 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (add_s_ac const-decl "AffineCombination" affine nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak)) (neg_pd_TCC1 0 (neg_pd_TCC1-1 nil 3623095639 ("" (skeep*) (("" (typepred "pds") (("" (grind) nil nil)) nil)) nil) ((ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (neg_pd subtype "affine.pds" "{ol | (booleans.NOT)(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].null_ol?(ol))}"))) (neg_pd_TCC2 0 (neg_pd_TCC2-1 nil 3629195921 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures)) nil (neg_pd subtype "affine.rpd" "{ol | (booleans.NOT)(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].null_ol?(ol))}"))) (neg_pd_TCC3 0 (neg_pd_TCC3-1 nil 3629195921 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures)) nil (neg_pd subtype "affine.empty_ErrorTerms" "{rpd: affine.ErrorTerms | booleans.AND((booleans.IFF(list_adt[[nat, nzBaseType]].null?(affine.pds), list_adt[[nat, nzBaseType]].null?(rpd))), (booleans.IMPLIES((booleans.NOT)(list_adt[[nat, nzBaseType]].null?(rpd)), ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(affine.pds)`1 = ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(rpd)`1)))}"))) (neg_pd_TCC4 0 (neg_pd_TCC4-1 nil 3629195921 ("" (skeep* :preds? t) (("" (typepred "v(t)") (("" (assert) (("" (expand "lt_idx") (("" (expand_ol) (("" (replaces -6) (("" (replaces -2 :dir RL) (("" (replaces -4) (("" (expand "ordered_list?" -3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (neg_pd subtype "affine.neg_pd(affine.t)" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.h`1, (number_fields.-)(affine.h`2)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (neg_pd_TCC5 0 (neg_pd_TCC5-1 nil 3629195921 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) nil (neg_pd subtype "ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cons_ol((affine.h`1, (number_fields.-)(affine.h`2)), affine.neg_pd(affine.t))" "{rpd: affine.ErrorTerms | booleans.AND((booleans.IFF(list_adt[[nat, nzBaseType]].null?(affine.pds), list_adt[[nat, nzBaseType]].null?(rpd))), (booleans.IMPLIES((booleans.NOT)(list_adt[[nat, nzBaseType]].null?(rpd)), ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(affine.pds)`1 = ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(rpd)`1)))}"))) (containment_neg 0 (containment_neg-1 nil 3629032893 ("" (skeep) (("" (expand "eval_ac_noise") (("" (expand "neg_ac") (("" (assert) (("" (generalize "pd(Xa)" "pds") (("" (generalize "x1" "x") (("" (induct "pds") (("1" (grind) nil nil) ("2" (flatten) (("2" (skeep) (("2" (expand "neg_pd") (("2" (expand_ol) (("2" (expand "eval_pd_noise") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (skeep) (("3" (expand "neg_pd" 1) (("3" (expand_ol) (("3" (lemma "eval_pd_noise_rec_pds_def") (("3" (inst? -1 :where 1) (("3" (replaces -1) (("3" (expand_ol) (("3" (split -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst? -1 :where -4) (("1" (replaces -1) (("1" (expand_ol) (("1" (inst -1 "x-get_noise_by_idx(hpds`1, N) * hpds`2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_ac_noise const-decl "real" affine nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (neg_pd def-decl "{rpd: ErrorTerms |
   (null?(pds) IFF null?(rpd)) AND
    (NOT null?(rpd) IMPLIES car_ol(pds)`1 = car_ol(rpd)`1)}" affine nil) (neg_ac const-decl "AffineCombination" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (next_idx_neg_ac 0 (next_idx_neg_ac-1 nil 3628945045 ("" (skeep) (("" (expand "neg_ac") (("" (assert) (("" (name-replace "pd1" "pd(Xa)") (("" (generalize "pd1" "pds") (("" (induct "pds") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((neg_ac const-decl "AffineCombination" affine nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (list_induction formula-decl nil list_adt nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_ol def-decl "T" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (neg_pd def-decl "{rpd: ErrorTerms |
   (null?(pds) IFF null?(rpd)) AND
    (NOT null?(rpd) IMPLIES car_ol(pds)`1 = car_ol(rpd)`1)}" affine nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (next_idx const-decl "nat" affine nil) (ac_proj_pd formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (minus_real_is_real application-judgement "real" reals nil)) shostak)) (idxs_ac_neg_ac 0 (idxs_ac_neg_ac-1 nil 3628936839 ("" (skeep) (("" (expand "neg_ac") (("" (expand "idxs_ac") (("" (assert) (("" (generalize "pd(Xa)" "pds") (("" (induct "pds") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hpds" "tpds")) (("3" (flatten) (("3" (expand "idxs_pd" 1) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (expand "member" 1) (("3" (flatten) (("3" (expand "cdr_ol") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((neg_ac const-decl "AffineCombination" affine nil) (minus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (ac_proj_pd formula-decl nil affine nil) (list_induction formula-decl nil list_adt nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (idxs_pd def-decl "list[nat]" affine nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (neg_pd def-decl "{rpd: ErrorTerms |
   (null?(pds) IFF null?(rpd)) AND
    (NOT null?(rpd) IMPLIES car_ol(pds)`1 = car_ol(rpd)`1)}" affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil)) shostak)) (mult_pd_pd_TCC1 0 (mult_pd_pd_TCC1-2 "" 3789916437 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.pds1, affine.tl2)" "nil")) (mult_pd_pd_TCC1-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.pds1, affine.tl2)" "nil"))) (mult_pd_pd_TCC2 0 (mult_pd_pd_TCC2-2 "" 3789916438 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.pds2)" "nil")) (mult_pd_pd_TCC2-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.pds2)" "nil"))) (mult_pd_pd_TCC3 0 (mult_pd_pd_TCC3-2 "" 3789916439 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.tl2)" "nil")) (mult_pd_pd_TCC3-1 nil 3619884927 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.tl2)" "nil"))) (mult_pd_pd_TCC4 0 (mult_pd_pd_TCC4-3 "" 3789916439 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.pds2)" "nil")) (mult_pd_pd_TCC4-2 "" 3621076804 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.pds2)" "nil")) (mult_pd_pd_TCC4-1 nil 3619884927 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "v(cv1, cv2, pds1, tl2)") (("" (assert) (("" (split -3) (("1" (assert) (("1" (split -3) (("1" (grind) nil nil) ("2" (case "hd2`1 < car(tl2)`1") (("1" (grind) nil nil) ("2" (typepred "pds2") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.tl1, affine.pds2)" "nil"))) (mult_pd_pd_TCC5 0 (mult_pd_pd_TCC5-3 "" 3789916440 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.pds1, affine.tl2)" "nil")) (mult_pd_pd_TCC5-2 "" 3621076829 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.pds1, affine.tl2)" "nil")) (mult_pd_pd_TCC5-1 nil 3619884927 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak (mult_pd_pd termination "affine.mult_pd_pd(affine.cv1, affine.cv2, affine.pds1, affine.tl2)" "nil"))) (mult_pd_pd_preserves_order_1_TCC1 0 (mult_pd_pd_preserves_order_1_TCC1-2 "" 3789916441 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_preserves_order_1 subtype "affine.mult_pd_pd(affine.cv1, affine.cv2, ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds), list_adt[[nat, nzBaseType]].null)" "(list_adt[[nat, nzBaseType]].cons?)")) (mult_pd_pd_preserves_order_1_TCC1-1 nil 3621160483 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_preserves_order_1 subtype "affine.mult_pd_pd(affine.cv1, affine.cv2, ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds), list_adt[[nat, nzBaseType]].null)" "(list_adt[[nat, nzBaseType]].cons?)"))) (mult_pd_pd_preserves_order_1 0 (mult_pd_pd_preserves_order_1-2 "" 3789916442 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (skeep) (("1" (expand "null_ol?") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep*) (("2" (inst?) (("2" (inst -1 "cv2") (("2" (hide 1) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (prop) (("1" (expand "car_ol") (("1" (expand "mult_pd_pd" 1) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "null_ol") (("1" (prop) (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "cons_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (expand "mult_pd_pd" 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "null_ol") (("2" (prop) (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "cdr_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cdr_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 3) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "car_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "cons_ol") (("2" (typepred "x::[nat,nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x::[nat,nzBaseType]") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (expand "null_ol?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((null_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (car_ol const-decl "T" ordered_list structures) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (mult_pd_pd def-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (mult_pd_pd_preserves_order_1-1 nil 3621160527 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (skeep) (("1" (expand "null_ol?") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep*) (("2" (inst?) (("2" (inst -1 "cv2") (("2" (hide 1) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (prop) (("1" (expand "car_ol") (("1" (expand "mult_pd_pd" 1) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "null_ol") (("1" (prop) (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "cons_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (expand "mult_pd_pd" 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "null_ol") (("2" (prop) (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "cdr_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cdr_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 3) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "car_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "cons_ol") (("2" (typepred "x::[nat,nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x::[nat,nzBaseType]") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (expand "null_ol?") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (expand "ordered_list?") (("4" (propax) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (expand "ordered_list?") (("5" (propax) nil nil)) nil)) nil)) nil) ((null_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (car_ol const-decl "T" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) nil)) (mult_pd_pd_preserves_order_2_TCC1 0 (mult_pd_pd_preserves_order_2_TCC1-1 nil 3621105899 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_preserves_order_2 subtype "affine.mult_pd_pd(affine.cv1, affine.cv2, list_adt[[nat, nzBaseType]].null, ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds2))" "(list_adt[[nat, nzBaseType]].cons?)"))) (mult_pd_pd_preserves_order_2 0 (mult_pd_pd_preserves_order_2-2 "" 3789916443 ("" (induct "pds2" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (skeep) (("1" (expand "null_ol?") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep*) (("2" (inst?) (("2" (inst -1 "cv2") (("2" (hide 1) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (prop) (("1" (expand "car_ol") (("1" (expand "mult_pd_pd" 1) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "null_ol") (("1" (prop) (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "cons_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (expand "mult_pd_pd" 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "null_ol") (("2" (prop) (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "cdr_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cdr_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 3) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "car_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "cons_ol") (("2" (typepred "x::[nat,nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x::[nat,nzBaseType]") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (expand "null_ol?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((null_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (car_ol const-decl "T" ordered_list structures) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (mult_pd_pd def-decl "ErrorTerms" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (mult_pd_pd_preserves_order_2-1 nil 3621105900 ("" (induct "pds2" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (skeep) (("1" (expand "null_ol?") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep*) (("2" (inst?) (("2" (inst -1 "cv2") (("2" (hide 1) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (prop) (("1" (expand "car_ol") (("1" (expand "mult_pd_pd" 1) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "null_ol") (("1" (prop) (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "cons_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (expand "mult_pd_pd" 1) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "null_ol") (("2" (prop) (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "cdr_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (prop) (("1" (expand "mult_pd_pd" 3) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cdr_ol") (("1" (typepred "x::[nat,nzBaseType]") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 3) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "car_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (expand "cons_ol") (("2" (typepred "x::[nat,nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x::[nat,nzBaseType]") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (expand "null_ol?") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (expand "ordered_list?") (("4" (propax) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (expand "ordered_list?") (("5" (propax) nil nil)) nil)) nil)) nil) ((null_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (car_ol const-decl "T" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures)) shostak)) (mult_pd_pd_preserves_order_3_TCC1 0 (mult_pd_pd_preserves_order_3_TCC1-2 "" 3789916444 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (BaseType type-eq-decl nil affine nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_preserves_order_3 subtype "affine.mult_pd_pd(affine.cv1, affine.cv2, ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds1), ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds2))" "(list_adt[[nat, nzBaseType]].cons?)")) (mult_pd_pd_preserves_order_3_TCC1-1 nil 3621163685 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_preserves_order_3 subtype "affine.mult_pd_pd(affine.cv1, affine.cv2, ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds1), ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cdr_ol(affine.pds2))" "(list_adt[[nat, nzBaseType]].cons?)"))) (mult_pd_pd_preserves_order_3 0 (mult_pd_pd_preserves_order_3-1 nil 3621163872 ("" (skeep) (("" (name "j" "length(pds1)+length(pds2)") (("" (generalize "pds1" "pds1") (("1" (generalize "pds2" "pds2") (("1" (generalize "j" "j") (("1" (induct "j" :name "NAT_induction") (("1" (skeep) (("1" (skeep) (("1" (expand "mult_pd_pd" 3) (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (prop) (("1" (grind) nil nil) ("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (inst -3 "j_1 -1") (("1" (assert) (("1" (inst -3 "cdr(pds2!1)" "pds1!1") (("1" (assert) (("1" (prop) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(pds1!1)`1, car(cdr(pds2!1))`1)") (("1" (expand "car_ol") (("1" (expand "mult_pd_pd" 5) (("1" (lift-if) (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (expand "cdr_ol") (("1" (hide-all-but (-1 -2 5)) (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(pds1!1), cdr(cdr(pds2!1))))`1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds2!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 4 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 4 5)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (inst -2 "j_1 -1") (("1" (assert) (("1" (inst -2 "cdr(pds2!1)" "pds1!1") (("1" (assert) (("1" (split -2) (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "mult_pd_pd" 6) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "add_ET") (("1" (lift-if) (("1" (expand "car_ol") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "cons_ol") (("1" (hide-all-but 6) (("1" (typepred "pds2!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 6) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "car_ol") (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "cons_ol") (("1" (hide-all-but 6) (("1" (typepred "pds2!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "cons_ol") (("2" (split 6) (("1" (flatten) (("1" (hide-all-but 1) (("1" (typepred "pds2!1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but (-1 2)) (("2" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(pds1!1)`1, car(cdr(pds2!1))`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(pds1!1), cdr(cdr(pds2!1))))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds2!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 5 6)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 5 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "add_ET") (("3" (lift-if) (("3" (expand "car_ol") (("3" (inst -2 "j_1-1") (("1" (assert) (("1" (inst -2 "pds2!1" "cdr_ol(pds1!1)") (("1" (expand "cdr_ol") (("1" (split -2) (("1" (expand "mult_pd_pd" 5) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (hide-all-but 6) (("2" (typepred "pds1!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 5) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "add_ET") (("2" (lift-if) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (split 1) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (5 -2)) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(cdr(pds1!1))`1, car(pds2!1)`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(cdr(pds1!1)), cdr(pds2!1)))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds1!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "null_ol?") (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "cons_ol") (("1" (hide-all-but 6) (("1" (typepred "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "cons_ol") (("1" (hide-all-but 7) (("1" (typepred "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (7 -1)) (("2" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(cdr(pds1!1))`1, car(pds2!1)`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(cdr(pds1!1)), cdr(pds2!1)))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds1!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -2 4 5)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "car_ol") (("4" (expand "add_ET") (("4" (lift-if) (("4" (inst -2 "j_1 -2 ") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2!1)" "cdr_ol(pds1!1)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "mult_pd_pd" 6) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand "cdr_ol") (("1" (hide-all-but (6 -3)) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) < min(car(cdr(pds1!1))`1, car(cdr(pds2!1))`1)") (("1" (name-replace "dummy" " car(mult_pd_pd(cv1, cv2, cdr(cdr(pds1!1)), cdr(cdr(pds2!1))))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds1!1") (("2" (typepred "pds2!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "null_ol?") (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (assert) (("1" (hide-all-but 7) (("1" (typepred "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cons_ol") (("1" (hide-all-but 8) (("1" (typepred "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (assert) (("2" (hide-all-but (8 -2)) (("2" (case "min(car(pds1!1)`1, car(pds2!1)`1) < min(car(cdr(pds1!1))`1, car(cdr(pds2!1))`1)") (("1" (name-replace "dummy" " car(mult_pd_pd(cv1, cv2, cdr(cdr(pds1!1)), cdr(cdr(pds2!1))))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds1!1") (("2" (typepred "pds2!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 5 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "car_ol") (("5" (expand "add_ET") (("5" (lift-if) (("5" (inst -2 "j_1  -1") (("1" (assert) (("1" (inst -2 "pds2!1" "cdr_ol(pds1!1)") (("1" (assert) (("1" (expand "mult_pd_pd" 7) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand "cdr_ol") (("1" (hide-all-but (-3 7)) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(cdr(pds1!1))`1, car(pds2!1)`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(cdr(pds1!1)), cdr(pds2!1)))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds1!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "cons_ol") (("1" (hide-all-but 8) (("1" (typepred "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cons_ol") (("1" (hide-all-but 9) (("1" (typepred "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "car_ol") (("2" (assert) (("2" (hide-all-but (9 -2)) (("2" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(cdr(pds1!1))`1, car(pds2!1)`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(cdr(pds1!1)), cdr(pds2!1)))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds1!1") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 6 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "add_ET") (("6" (lift-if) (("6" (expand "mult_pd_pd" 8) (("6" (lift-if) (("6" (expand "null_ol?") (("6" (assert) (("6" (expand "add_ET") (("6" (lift-if) (("6" (expand "car_ol") (("6" (expand "cdr_ol") (("6" (expand "cons_ol") (("6" (inst -1 "j_1-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2!1)" "pds1!1") (("1" (assert) (("1" (expand "cdr_ol") (("1" (split 2) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (8 -2)) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(pds1!1)`1, car(cdr(pds2!1))`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(pds1!1), cdr(cdr(pds2!1))))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds2!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "null_ol?") (("2" (split 8) (("1" (flatten) (("1" (hide-all-but 1) (("1" (typepred "pds2!1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but 1) (("1" (typepred "pds2!1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but (2 -1)) (("2" (case "min(car(pds1!1)`1, car(pds2!1)`1) <= min(car(pds1!1)`1, car(cdr(pds2!1))`1)") (("1" (name-replace "bla" "car(mult_pd_pd(cv1, cv2, cdr(pds1!1), cdr(cdr(pds2!1))))`1") (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "pds2!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 7 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep*) (("2" (expand "null_ol?") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (cv1 skolem-const-decl "BaseType" affine nil) (cv2 skolem-const-decl "BaseType" affine nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (real_times_real_is_real application-judgement "real" reals nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (length_cdr_ol formula-decl nil ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j_1 skolem-const-decl "nat" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons_ol const-decl "ordered_list" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (BaseType type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (mult_pd_pd_last_bound__null_nnull_TCC1 0 (mult_pd_pd_last_bound__null_nnull_TCC1-1 nil 3621276799 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound__null_nnull subtype "affine.mult_pd_pd(affine.x1, affine.x2, affine.empty_ErrorTerms, affine.pds)" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound__null_nnull_TCC2 0 (mult_pd_pd_last_bound__null_nnull_TCC2-1 nil 3621276799 ("" (subtype-tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound__null_nnull subtype "affine.pds" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound__null_nnull 0 (mult_pd_pd_last_bound__null_nnull-1 nil 3621276800 ("" (expand "null_ol?") (("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skolem 1 ("pds")) (("2" (flatten) (("2" (skolem 1 "x_") (("2" (skeep) (("2" (inst?) (("2" (inst -1 "x2") (("2" (expand "mult_pd_pd" (1 2)) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (expand "add_ET" (1 2)) (("2" (lift-if) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (expand "cons_ol") (("2" (expand "empty_ErrorTerms") (("2" (split 1) (("1" (flatten) (("1" (assert) (("1" (case "NOT null?[[nat, nzBaseType]](pds)") (("1" (assert) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cons(x_, pds))") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (assert) (("1" (hide -2) (("1" (expand "null_ol?") (("1" (expand "last_ol") (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "mult_pd_pd") (("2" (lift-if) (("2" (expand "null_ol?") (("2" (assert) (("2" (expand "add_ET") (("2" (lift-if) (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (assert) (("1" (case "null_ol?(pds)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "null_ol?") (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cons(x_, pds))") (("1" (replaces -1) (("1" (expand "last_ol" 4 1) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "null_ol?(pds)") (("1" (grind) nil nil) ("2" (expand "null_ol?") (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cons(x_, pds))") (("1" (replaces -1) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (pred type-eq-decl nil defined_types nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (<= const-decl "bool" reals nil) (last_ol def-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ol_ind_sch formula-decl nil ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures)) shostak)) (mult_pd_pd_last_bound__nnull_null_TCC1 0 (mult_pd_pd_last_bound__nnull_null_TCC1-2 "" 3789916454 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound__nnull_null subtype "affine.mult_pd_pd(affine.x1, affine.x2, affine.pds, affine.empty_ErrorTerms)" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}")) (mult_pd_pd_last_bound__nnull_null_TCC1-1 nil 3621280662 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_last_bound__nnull_null subtype "affine.mult_pd_pd(affine.x1, affine.x2, affine.pds, affine.empty_ErrorTerms)" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound__nnull_null_TCC2 0 (mult_pd_pd_last_bound__nnull_null_TCC2-2 "" 3789916455 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound__nnull_null subtype "affine.pds" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}")) (mult_pd_pd_last_bound__nnull_null_TCC2-1 nil 3621280662 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_last_bound__nnull_null subtype "affine.pds" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound__nnull_null 0 (mult_pd_pd_last_bound__nnull_null-1 nil 3621350074 ("" (expand "null_ol?") (("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skolem 1 ("pds")) (("2" (flatten) (("2" (skolem 1 "x_") (("2" (skeep) (("2" (inst?) (("2" (inst -1 "x2") (("2" (expand "mult_pd_pd" (1 2)) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (expand "add_ET" (1 2)) (("2" (lift-if) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (expand "cons_ol") (("2" (expand "empty_ErrorTerms") (("2" (split 1) (("1" (flatten) (("1" (assert) (("1" (case "NOT null?[[nat, nzBaseType]](pds)") (("1" (assert) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cons(x_, pds))") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (assert) (("1" (hide -2) (("1" (expand "null_ol?") (("1" (expand "last_ol") (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "mult_pd_pd") (("2" (lift-if) (("2" (expand "null_ol?") (("2" (assert) (("2" (expand "add_ET") (("2" (lift-if) (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split 2) (("1" (assert) (("1" (case "null_ol?(pds)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "null_ol?") (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cons(x_, pds))") (("1" (replaces -1) (("1" (expand "last_ol" 4 1) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "null_ol?(pds)") (("1" (grind) nil nil) ("2" (expand "null_ol?") (("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cons(x_, pds))") (("1" (replaces -1) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (pred type-eq-decl nil defined_types nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (<= const-decl "bool" reals nil) (last_ol def-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ol_ind_sch formula-decl nil ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures)) nil)) (mult_pd_pd_last_bound_TCC1 0 (mult_pd_pd_last_bound_TCC1-2 "" 3789916457 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound subtype "affine.mult_pd_pd(affine.x1, affine.x2, affine.pds1, affine.pds2)" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}")) (mult_pd_pd_last_bound_TCC1-1 nil 3621274735 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_last_bound subtype "affine.mult_pd_pd(affine.x1, affine.x2, affine.pds1, affine.pds2)" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound_TCC2 0 (mult_pd_pd_last_bound_TCC2-2 "" 3789916457 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound subtype "affine.pds1" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}")) (mult_pd_pd_last_bound_TCC2-1 nil 3621274735 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_last_bound subtype "affine.pds1" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound_TCC3 0 (mult_pd_pd_last_bound_TCC3-2 "" 3789916458 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (mult_pd_pd_last_bound subtype "affine.pds2" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}")) (mult_pd_pd_last_bound_TCC3-1 nil 3621275306 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mult_pd_pd_last_bound subtype "affine.pds2" "{ol | (booleans.NOT)(list_adt[[nat, nzBaseType]].null?(ol))}"))) (mult_pd_pd_last_bound 0 (mult_pd_pd_last_bound-1 nil 3621275044 ("" (skeep) (("" (name "L" "length(pds1)+length(pds2)") (("" (expand "null_ol?") (("" (generalize "pds1" "pds1") (("" (generalize "pds2" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skolem 1 ("pds2_" "pds1_")) (("" (flatten) (("" (expand "mult_pd_pd" 4) (("" (lift-if) (("" (expand "null_ol?") (("" (assert) (("" (expand "car_ol") (("" (split 4) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2_)" "cdr_ol(pds1_)") (("1" (assert) (("1" (expand "cdr_ol") (("1" (assert) (("1" (case "null?[[nat, nzBaseType]](cdr(pds1_))") (("1" (case "null?[[nat, nzBaseType]](mult_pd_pd(x1, x2, cdr(pds1_), cdr(pds2_)))") (("1" (hide -5) (("1" (expand "mult_pd_pd" 4) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cdr(pds1_)=null") (("1" (replaces -1) (("1" (hide -1) (("1" (hide -3) (("1" (case "null?[[nat, nzBaseType]](cdr(pds2_))") (("1" (grind) nil nil) ("2" (lemma "mult_pd_pd_last_bound__null_nnull") (("2" (inst -1 "cdr_ol(pds2_)" "x1" "x2") (("1" (expand "cdr_ol") (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "empty_ErrorTerms") (("1" (reveal -4) (("1" (expand "last_ol" 3 2) (("1" (lift-if) (("1" (assert) (("1" (typepred "pds2_") (("1" (hide-all-but (-1 -3 -5 3 4 5)) (("1" (replaces -3) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst -1 "pds2_") (("1" (assert) (("1" (expand "car_ol") (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds2_) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2_))") (("1" (replaces -1 :dir RL) (("1" (name-replace "dontRW" "mult_pd_pd(x1, x2, null, cdr(pds2_))") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (case "null?[[nat, nzBaseType]](cdr(pds2_))") (("1" (case "null?[[nat, nzBaseType]](mult_pd_pd(x1, x2, cdr(pds1_), cdr(pds2_)))") (("1" (grind) nil nil) ("2" (case "cdr(pds2_) = null") (("1" (replace -1 + :hide? t) (("1" (lemma "mult_pd_pd_last_bound__nnull_null") (("1" (inst -1 "cdr(pds1_)" "x1" "x2") (("1" (expand "null_ol?") (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "last_ol" 3 3) (("1" (case "max(last_ol(pds1_)`1, car(pds2_)`1) = last_ol(pds1_)`1") (("1" (replaces -1) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds1_) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1_))") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds1_) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1_))") (("1" (replaces -1) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds2_) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2_))") (("1" (replaces -1) (("1" (assert) (("1" (expand "mult_pd_pd" 6) (("1" (lift-if) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten 1) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "last_ol" 1 1) (("1" (expand "empty_ErrorTerms") (("1" (hide-all-but (1 3 4)) (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "last_ol" 2 1) (("2" (lift-if) (("2" (assert) (("2" (expand "cons_ol") (("2" (inst -2 "j-2") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2_)" "cdr_ol(pds1_)") (("1" (expand "cdr_ol") (("1" (assert) (("1" (case "null_ol?(cdr_ol(pds1_))") (("1" (case "null_ol?(cdr_ol(pds2_))") (("1" (grind) nil nil) ("2" (expand "null_ol?") (("2" (case "cdr(pds1_)=null") (("1" (replace -1 + :hide? t) (("1" (expand "cdr_ol") (("1" (lemma "mult_pd_pd_last_bound__null_nnull") (("1" (inst -1 "cdr_ol(pds2_)" "x1" "x2") (("1" (expand "empty_ErrorTerms") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "last_ol" 3 (2 3)) (("1" (replaces -3) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2_))`1=last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2_))`1") (("1" (replaces -1) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst -1 "cdr_ol(pds2_)") (("1" (expand "cdr_ol") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (case "null_ol?(cdr_ol(pds2_))") (("1" (case "cdr(pds2_)=null") (("1" (replace -1 + :hide? t) (("1" (lemma "mult_pd_pd_last_bound__nnull_null") (("1" (inst -1 "cdr_ol(pds1_)" "x1" "x2") (("1" (assert) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_ol" 3 (2 3)) (("1" (lift-if) (("1" (assert) (("1" (replaces -3 :dir RL) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1_))=last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds1_)") (("1" (replaces -1) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst -1 "pds1_") (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (assert) (("2" (prop) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1_))=last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds1_)") (("1" (replaces -1) (("1" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2_))=last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds2_)") (("1" (replaces -1) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide-all-but (-2 1 7 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2_" "cdr_ol(pds1_)") (("1" (assert) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (case "null_ol?(cdr_ol(pds1_))") (("1" (case "null?[[nat, nzBaseType]](mult_pd_pd(x1, x2, cdr_ol(pds1_), pds2_))") (("1" (expand "null_ol?") (("1" (expand "mult_pd_pd" 5) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mult_pd_pd_last_bound__null_nnull") (("2" (inst -1 "pds2_" "x1" "x2") (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (split -1) (("1" (hide -5) (("1" (case "cdr(pds1_)=null") (("1" (expand "cdr_ol") (("1" (replace -1 + :hide? t) (("1" (expand "last_ol" 2 2) (("1" (assert) (("1" (case "max(car(pds1_)`1, last_ol(pds2_)`1) = max(car(pds2_)`1, last_ol(pds2_)`1)") (("1" (replaces -1) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst -1 "pds2_") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (expand "cdr_ol") (("2" (case "cdr(pds1_)=null") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (assert) (("2" (case "null?[[nat, nzBaseType]](mult_pd_pd(x1, x2, cdr(pds1_), pds2_))") (("1" (expand "mult_pd_pd" 6) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1_)) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds1_)") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "cdr_ol") (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_ol" 1 1) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst -1 "pds1_") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "null?[[nat, nzBaseType]](cdr(pds1_))") (("1" (hide -3) (("1" (expand "cons_ol") (("1" (expand "last_ol" 2 1) (("1" (case "cdr(pds1_)=null") (("1" (replace -1 + :hide? t) (("1" (lemma "mult_pd_pd_last_bound__null_nnull") (("1" (inst -1 "pds2_" "x1" "x2") (("1" (expand "null_ol?") (("1" (expand "empty_ErrorTerms") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "last_ol" 3 1) (("2" (expand "cons_ol") (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds1_)) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds1_)") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2_)" "pds1_") (("1" (expand "cdr_ol") (("1" (expand "length" -2 2) (("1" (assert) (("1" (case "null?[[nat, nzBaseType]](cdr(pds2_))") (("1" (split 2) (("1" (flatten) (("1" (case "null?[[nat, nzBaseType]](mult_pd_pd(x1, x2, pds1_, cdr(pds2_)))") (("1" (hide -4) (("1" (expand "mult_pd_pd" 6) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (assert) (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cdr(pds2_)=null") (("1" (replace -1 + :hide? t) (("1" (lemma "mult_pd_pd_last_bound__nnull_null") (("1" (inst -1 "pds1_" "x1" "x2") (("1" (expand "null_ol?") (("1" (expand "empty_ErrorTerms") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_ol" 1 1) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst -1 "pds1_") (("1" (assert) (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cons_ol") (("2" (expand "last_ol" 1 1) (("2" (flatten) (("2" (expand "null_ol?") (("2" (assert) (("2" (hide -2) (("2" (case "cdr(pds2_)=null") (("1" (replace -1 + :hide? t) (("1" (lemma "mult_pd_pd_last_bound__nnull_null") (("1" (inst -1 "pds1_" "x1" "x2") (("1" (expand "null_ol?") (("1" (expand "empty_ErrorTerms") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "null?[[nat, nzBaseType]](mult_pd_pd(x1, x2, pds1_, cdr_ol(pds2_)))") (("1" (expand "mult_pd_pd" 7) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "add_ET") (("1" (expand "cdr_ol") (("1" (assert) (("1" (split 3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (hide 8) (("2" (hide -2) (("2" (expand "cons_ol") (("2" (expand "empty_ErrorTerms") (("2" (expand "last_ol" 2 1) (("2" (lemma "olidx_car_last[nzBaseType]") (("2" (inst -1 "pds1_") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdr_ol") (("2" (assert) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (expand "last_ol" 4 4) (("2" (case "last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](cdr(pds2_)) = last_ol[[nat,nzBaseType],lt_idx[nzBaseType]](pds2_)") (("1" (replaces -1) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "null_ol?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 5 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (last_ol def-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (<= const-decl "bool" reals nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (BaseType type-eq-decl nil affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (add_ET const-decl "ErrorTerms" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null_ol const-decl "ordered_list" ordered_list structures) (pds2_ skolem-const-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (mult_pd_pd_last_bound__null_nnull formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (mult_pd_pd_last_bound__nnull_null formula-decl nil affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_minus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons_ol const-decl "ordered_list" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_cdr_ol formula-decl nil ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pds1_ skolem-const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (NAT_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (search_ET_on_add_ET_TCC1 0 (search_ET_on_add_ET_TCC1-2 "" 3789916465 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (search_ET_on_add_ET subtype "affine.pds" "(list_adt[[nat, nzBaseType]].cons?)")) (search_ET_on_add_ET_TCC1-1 nil 3621103906 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (search_ET_on_add_ET subtype "affine.pds" "(list_adt[[nat, nzBaseType]].cons?)"))) (search_ET_on_add_ET 0 (search_ET_on_add_ET-1 nil 3621103923 ("" (grind) (("" (expand "search_error_term_by_idx") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (add_ET const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak)) (search_ET_car 0 (search_ET_car-1 nil 3621104073 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (null_ol? const-decl "bool" ordered_list structures)) shostak)) (search_ET_not_car_TCC1 0 (search_ET_not_car_TCC1-2 "" 3789916467 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (null_ol? const-decl "bool" ordered_list structures)) shostak (search_ET_not_car subtype "list_adt[[nat, nzBaseType]].cdr(affine.pds)" "ErrorTerms")) (search_ET_not_car_TCC1-1 nil 3621104193 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (search_ET_not_car subtype "list_adt[[nat, nzBaseType]].cdr(affine.pds)" "ErrorTerms"))) (search_ET_not_car 0 (search_ET_not_car-1 nil 3621104193 ("" (grind) (("" (expand "search_error_term_by_idx") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (null_ol? const-decl "bool" ordered_list structures)) shostak)) (search_ET_in_mult_pd_pd 0 (search_ET_in_mult_pd_pd-2 "" 3621105813 ("" (skeep) (("" (name "lens" "length(pds1)+length(pds2)") (("" (generalize "pds1" "pds1") (("" (generalize "pds2" "pds2") (("" (generalize "lens" "lens") (("" (induct "lens" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (case "null_ol?(pds1!1)") (("1" (case "null_ol?(pds2!1)") (("1" (grind) nil nil) ("2" (expand "mult_pd_pd" 2 1) (("2" (lift-if) (("2" (assert) (("2" (use "search_ET_on_add_ET") (("2" (split -1) (("1" (replaces -1) (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (replaces -1) (("1" (lemma "search_ET_car") (("1" (inst -1 "pds2!1") (("1" (assert) (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds1!1, car(pds2!1)`1)=0") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2!1)" "pds1!1") (("1" (expand "cdr_ol") (("1" (prop) (("1" (replaces -1) (("1" (lemma "search_ET_not_car") (("1" (inst -1 "n" "pds2!1") (("1" (expand "car_ol") (("1" (expand "null_ol?") (("1" (expand "/=") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 -1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mult_pd_pd_preserves_order_2") (("2" (inst -1 "cv1" "cv2" "pds2!1") (("2" (assert) (("2" (case "pds1!1 = null") (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "null_ol?(pds2!1)") (("1" (expand "mult_pd_pd" 2 1) (("1" (lift-if) (("1" (assert) (("1" (use "search_ET_on_add_ET") (("1" (split -1) (("1" (replaces -1) (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (replaces -1) (("1" (lemma "search_ET_car") (("1" (inst -1 "pds1!1") (("1" (assert) (("1" (expand "car_ol") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds2!1, car(pds1!1)`1)=0") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2!1" "cdr_ol(pds1!1)") (("1" (expand "cdr_ol") (("1" (prop) (("1" (replaces -1) (("1" (lemma "search_ET_not_car") (("1" (inst -1 "n" "pds1!1") (("1" (expand "car_ol") (("1" (expand "null_ol?") (("1" (expand "/=") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 -1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 -2 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mult_pd_pd_preserves_order_1") (("2" (inst -1 "cv1" "cv2" "pds1!1") (("2" (assert) (("2" (case "pds2!1 = null") (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "car_ol(pds1!1)`1 = car_ol(pds2!1)`1") (("1" (expand "mult_pd_pd" 3 1) (("1" (lift-if) (("1" (assert) (("1" (use "search_ET_on_add_ET") (("1" (split -1) (("1" (replaces -1) (("1" (lift-if) (("1" (split 3) (("1" (flatten) (("1" (hide -3) (("1" (hide -3) (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds2!1, car_ol(pds1!1)`1) = search_error_term_by_idx(pds2!1, car_ol(pds2!1)`1)") (("1" (replaces -1) (("1" (use "search_ET_car") (("1" (assert) (("1" (expand "car_ol") (("1" (replaces -1) (("1" (use "search_ET_car") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-2") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2!1)" "cdr_ol(pds1!1)") (("1" (expand "cdr_ol") (("1" (prop) (("1" (replaces -1) (("1" (lemma "search_ET_not_car") (("1" (inst -1 "n" "pds2!1") (("1" (expand "null_ol?") (("1" (expand "/=") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) (("1" (replaces -1) (("1" (lemma "search_ET_not_car") (("1" (inst -1 "n" "pds1!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "mult_pd_pd_preserves_order_3") (("2" (inst -1 "cv1" "cv2" "pds1!1" "pds2!1") (("2" (assert) (("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult_pd_pd" 4) (("2" (lift-if) (("2" (expand "null_ol?") (("2" (assert) (("2" (expand "car_ol") (("2" (split 4) (("1" (flatten) (("1" (lemma "search_ET_on_add_ET") (("1" (inst -1 "min(car(pds1!1)`1,car(pds2!1)`1)" "n" "mult_pd_pd
                                      (cv1, cv2, cdr_ol(pds1!1), pds2!1)" "car(pds1!1)`2 * cv2") (("1" (split -1) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) = car(pds1!1)`1") (("1" (replaces -1) (("1" (replaces -1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (use "search_ET_car") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds2!1, car(pds1!1)`1) = 0") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2!1" "cdr_ol(pds1!1)") (("1" (expand "cdr_ol") (("1" (assert) (("1" (split -2) (("1" (replaces -1) (("1" (lemma "search_ET_not_car") (("1" (inst -1 "n" "pds1!1") (("1" (expand "null_ol?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 5 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 5 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (lemma "mult_pd_pd_preserves_order_3") (("2" (inst -1 "cv1" "cv2" "pds1!1" "cons_ol(car(pds1!1), pds2!1)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) = car(pds1!1)`1") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "search_ET_on_add_ET") (("2" (inst -1 "min(car(pds1!1)`1,car(pds2!1)`1)" "n" "mult_pd_pd
                                      (cv1, cv2, pds1!1, cdr_ol(pds2!1))" "car(pds2!1)`2 * cv1") (("2" (split -1) (("1" (case "min(car(pds1!1)`1, car(pds2!1)`1) = car(pds2!1)`1") (("1" (replaces -1) (("1" (replaces -1) (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (replaces -) (("1" (use "search_ET_car") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds1!1, car(pds2!1)`1) = 0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2!1)" "pds1!1") (("1" (expand "cdr_ol") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (lemma "search_ET_not_car") (("1" (inst -1 "n" "pds2!1") (("1" (expand "null_ol?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 6 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 3) (("2" (case "min(car(pds1!1)`1, car(pds2!1)`1) = car(pds2!1)`1") (("1" (replaces -1) (("1" (lemma "mult_pd_pd_preserves_order_3") (("1" (inst -1 "cv1" "cv2" "cons_ol(car(pds2!1), pds1!1)" "pds2!1") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (mult_pd_pd_preserves_order_1 formula-decl nil affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pds2!1 skolem-const-decl "ErrorTerms" affine nil) (pds1!1 skolem-const-decl "ErrorTerms" affine nil) (add_ET const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_minus_real_is_real application-judgement "real" reals nil) (mult_pd_pd_preserves_order_3 formula-decl nil affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (null_ol const-decl "ordered_list" ordered_list structures) (search_ET_on_add_ET formula-decl nil affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (mult_pd_pd_preserves_order_2 formula-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (TRUE const-decl "bool" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (search_ET_car formula-decl nil affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (search_ET_not_car formula-decl nil affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (BaseType type-eq-decl nil affine nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (search_ET_in_mult_pd_pd-1 nil 3621089248 ("" (skeep) (("" (name "lens" "length(pds1)+length(pds2)") (("" (generalize "pds1" "pds1") (("" (generalize "pds2" "pds2") (("" (generalize "lens" "lens") (("" (induct "lens") (("1" (skeep) (("1" (case "null_ol?(pds1!1) AND null_ol?(pds2!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "mult_pd_pd" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (case "cv2 * search_error_term_by_idx(pds1!1, n) = 0") (("1" (replaces -1) (("1" (assert) (("1" (expand "add_ET") (("1" (lift-if) (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (replaces -3) (("1" (assert) (("1" (expand "search_error_term_by_idx" 1 2) (("1" (lift-if) (("1" (assert) (("1" (expand "null_ol?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "car_ol(pds2!1)`1 = n") (("1" (expand "cons_ol") (("1" (expand "search_error_term_by_idx" 1 1) (("1" (assert) (("1" (hide -4) (("1" (expand "search_error_term_by_idx" 1 1) (("1" (lift-if) (("1" (assert) (("1" (expand "null_ol?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (case "cv1 * search_error_term_by_idx(pds2!1, n) = 0") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(cons_ol((car_ol(pds2!1)`1,
                                                                              car_ol(pds2!1)`2 * cv1),
                                                                             empty_ErrorTerms),
                                                                     n) = 0") (("1" (propax) nil nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil) ("3" (expand "car_ol") (("3" (expand "/=") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (5 2 -1 1)) (("2" (case "cons?(pds2!1)") (("1" (generalize "pds2!1" "pds2_1" :fnums (-1 -2 2 1)) (("1" (hide 2) (("1" (induct "pds2_1" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep) (("2" (skolem 1 "x_") (("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "mult_pd_pd" -2) (("2" (lift-if) (("2" (split -2) (("1" (assert) (("1" (flatten) (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (hide -3) (("1" (expand "search_error_term_by_idx") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (expand "cdr_ol") (("1" (assert) (("1" (expand "null_ol?") (("1" (assert) (("1" (prop) (("1" (expand "search_error_term_by_idx" 2) (("1" (assert) (("1" (expand "car_ol") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "search_error_term_by_idx" 2) (("2" (expand "car_ol") (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (expand "search_error_term_by_idx" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "null_ol?") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (assert) (("4" (expand "null_ol?") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "cons_ol") (("3" (expand "car_ol") (("3" (expand "cdr_ol") (("3" (expand "null_ol?") (("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (sum_of_modules_TCC1 0 (sum_of_modules_TCC1-2 "" 3789916474 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) shostak (sum_of_modules termination "affine.sum_of_modules(affine.tl)" "nil")) (sum_of_modules_TCC1-1 nil 3621077069 ("" (tcc)) nil nil (sum_of_modules termination "affine.sum_of_modules(affine.tl)" "nil"))) (sum_of_modules_nnreal 0 (sum_of_modules_nnreal-1 nil 3620056534 ("" (induct "pds") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ErrorTerms type-eq-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (sum_of_modules def-decl "BaseType" affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil)) shostak (sum_of_modules_nnreal subtype "affine.sum_of_modules(affine.pds)" "nonneg_real"))) (sum_of_modules_append 0 (sum_of_modules_append-1 nil 3621186862 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skolem 1 ("h_" "t_")) (("2" (flatten) (("2" (skeep) (("2" (expand "append" 1) (("2" (expand "sum_of_modules" 1 1) (("2" (expand "sum_of_modules" 1 2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (append def-decl "list[T]" list_props nil) (sum_of_modules def-decl "BaseType" affine nil) (BaseType type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil)) shostak)) (first_noises_TCC1 0 (first_noises_TCC1-1 nil 3620579570 ("" (skeep) (("" (use "first_is_ol[nzEpsilon]") nil nil)) nil) ((Noise type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (first_is_ol formula-decl nil indexed_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (first_noises subtype "indexed_list[nzEpsilon].first(affine.N, affine.n)" "Noise"))) (first_noises_upd 0 (first_noises_upd-2 nil 3629578919 ("" (induct "N") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (skeep) (("3" (expand "upd_noise" 1) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (lift-if 1) (("3" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "first_noises" 1 2) (("2" (expand "first" 1) (("2" (assert) (("2" (expand "first_noises" 1) (("2" (expand "first" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (split 2) (("1" (replaces -3 :dir RL) (("1" (hide-all-but (-1 -4 1)) (("1" (expand "ordered_list?" -2 :assert? none) (("1" (lift-if -2) (("1" (split -2) (("1" (assert) nil nil) ("2" (flatten) (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "lt_idx") (("2" (flatten) (("2" (hide-all-but (-1 -3)) (("2" (invoke (with-fresh-names ((A "%1") (B "%2")) (assert)) (! -1 1) (! -1 2)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (first def-decl "(prefixes(l))" indexed_list structures) (add_N const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (first_noises const-decl "Noise" affine nil) (Noise type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil) (first_noises_upd-1 nil 3628853122 ("" (induct "N") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (skeep) (("3" (expand "upd_noise" 1) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (lift-if 1) (("3" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "first_noises" 1 2) (("2" (expand "first" 1) (("2" (assert) (("2" (expand "first_noises" 1) (("2" (expand "first" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak)) (first_ET_TCC1 0 (first_ET_TCC1-1 nil 3621012759 ("" (skeep) (("" (use "first_is_ol[nzBaseType]") nil nil)) nil) ((ErrorTerms type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (first_is_ol formula-decl nil indexed_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (first_ET subtype "indexed_list[nzBaseType].first(affine.pds, affine.n)" "ErrorTerms"))) (last_first_ET 0 (last_first_ET-1 nil 3621079802 ("" (use "last_up_to_idx[nzBaseType]") (("" (grind) nil nil)) nil) ((first_ET const-decl "ErrorTerms" affine nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (last_up_to_idx formula-decl nil indexed_list structures)) shostak)) (last_first_noises 0 (last_first_noises-2 "" 3620752993 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skeep*) (("2" (grind) (("2" (expand "last_ol" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (< const-decl "bool" reals nil) (first_noises const-decl "Noise" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (pred type-eq-decl nil defined_types nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil)) shostak) (last_first_noises-1 nil 3620566666 ("" (induct "N") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("n_" "N_")) (("3" (flatten) (("3" (skeep) (("3" (use "ol_suffix[[nat, nzEpsilon], lt_idx[nzEpsilon]]") (("3" (assert) (("3" (inst?) (("3" (prop) (("1" (grind) (("1" (expand "last_ol" 1) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep*) (("4" (use "Noise_as_list") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ((cons_ol const-decl "ordered_list" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak)) (gnbi_lt_first_idem 0 (gnbi_lt_first_idem-1 nil 3621712240 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "first_noises") (("2" (expand "first" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (first_noises const-decl "Noise" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (pred type-eq-decl nil defined_types nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil)) shostak)) (first_noises_zero_prop 0 (first_noises_zero_prop-1 nil 3620665660 ("" (grind) (("" (expand "first") (("" (lift-if) (("" (assert) (("" (prop) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((first def-decl "(prefixes(l))" indexed_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (empty_noise const-decl "Noise" affine nil) (first_noises const-decl "Noise" affine nil)) shostak)) (first_error_terms_recursive_def_TCC1 0 (first_error_terms_recursive_def_TCC1-2 "" 3789916481 ("" (tcc) nil nil) ((first_ET const-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (first_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) shostak (first_error_terms_recursive_def subtype "affine.empty_ErrorTerms" "{ol2 | ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].appendable_ol?(affine.first_ET(affine.pds, affine.n), ol2)}")) (first_error_terms_recursive_def_TCC1-1 nil 3621005252 ("" (tcc)) ((first_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) nil (first_error_terms_recursive_def subtype "affine.empty_ErrorTerms" "{ol2 | ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].appendable_ol?(affine.first_ET(affine.pds, affine.n), ol2)}"))) (first_error_terms_recursive_def_TCC2 0 (first_error_terms_recursive_def_TCC2-2 "" 3789916482 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil)) shostak (first_error_terms_recursive_def subtype "affine.search_error_term_by_idx(affine.pds, affine.n)" "nzBaseType")) (first_error_terms_recursive_def_TCC2-1 nil 3621005252 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures)) nil (first_error_terms_recursive_def subtype "affine.search_error_term_by_idx(affine.pds, affine.n)" "nzBaseType"))) (first_error_terms_recursive_def_TCC3 0 (first_error_terms_recursive_def_TCC3-2 "" 3789916482 ("" (tcc) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_idx const-decl "bool" indexed_list structures)) shostak (first_error_terms_recursive_def subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.search_error_term_by_idx(affine.pds, affine.n)), list_adt[[nat, nzBaseType]].car(ol)))}")) (first_error_terms_recursive_def_TCC3-1 nil 3621005252 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures)) nil (first_error_terms_recursive_def subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.search_error_term_by_idx(affine.pds, affine.n)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (first_error_terms_recursive_def_TCC4 0 (first_error_terms_recursive_def_TCC4-1 nil 3621005252 ("" (skeep*) (("" (grind) (("" (use "last_first_ET") (("" (assert) nil nil)) nil)) nil)) nil) ((first_ET const-decl "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (last_first_ET formula-decl nil affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (first_error_terms_recursive_def subtype "ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cons_ol((affine.n, affine.search_error_term_by_idx(affine.pds, affine.n)), affine.empty_ErrorTerms)" "{ol2 | ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].appendable_ol?(affine.first_ET(affine.pds, affine.n), ol2)}"))) (first_error_terms_recursive_def 0 (first_error_terms_recursive_def-2 "" 3750581915 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skolem 1 "pds_") (("2" (flatten) (("2" (skolem 1 "pd_") (("2" (skeep) (("2" (expand "first_ET" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_ET" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(pd_,
                                                                     append_ol(first_ET(pds_, n),
                                                                               IF search_error_term_by_idx(pds_, n) = 0 THEN empty_ErrorTerms
                                                                               ELSE cons_ol((n, search_error_term_by_idx(pds_, n)),
                                                                                            empty_ErrorTerms)
                                                                               ENDIF)) =
                                                                     append_ol(cons_ol(pd_,first_ET(pds_, n)),
                                                                               IF search_error_term_by_idx(pds_, n) = 0 THEN empty_ErrorTerms
                                                                               ELSE cons_ol((n, search_error_term_by_idx(pds_, n)),
                                                                                            empty_ErrorTerms)
                                                                               ENDIF)") (("1" (replaces -1) (("1" (typepred "pd_") (("1" (case "pd_`1 = n") (("1" (assert) (("1" (case "first(pds_, n) = null") (("1" (replaces -1) (("1" (case "first(cons(pd_, pds_), n) = null") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(cons(pd_, pds_),n) = pd_`2") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds_, n) = 0") (("1" (replaces -1) (("1" (case "NOT pd_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "pd_ = (pd_`1,pd_`2)") (("1" (grind) (("1" (decompose-equality 2) nil nil) ("2" (decompose-equality 2) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "pd_ = (pd_`1,pd_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (hide 2) (("2" (expand "search_error_term_by_idx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "pd_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null?(pds_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "pd_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (lemma "last_first_ET") (("2" (assert) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (grind) (("5" (typepred "pd_") (("5" (expand "ordered_list?") (("5" (expand "lt_idx") (("5" (grind) (("5" (hide -2) (("5" (expand "first" 2) (("5" (lift-if) (("5" (case "NOT null?(pds_)") (("1" (assert) (("1" (case "car(pds_)`1 < n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (prop) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (lemma "last_first_ET") (("6" (assert) (("6" (inst?) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) (("3" (lemma "last_first_ET") (("3" (assert) (("3" (inst?) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (last_ol def-decl "T" ordered_list structures) (last_first_ET formula-decl nil affine nil) (first_ol const-decl "T" ordered_list structures) (null adt-constructor-decl "(null?)" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (IF const-decl "[boolean, T, T -> T]" if_def nil) (append_ol const-decl "ordered_list" ordered_list structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (first_ET const-decl "ErrorTerms" affine nil) (pred type-eq-decl nil defined_types nil) (cons_ol const-decl "ordered_list" ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (BaseType type-eq-decl nil affine nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (prefixes const-decl "bool" more_list_props structures) (first def-decl "(prefixes(l))" indexed_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (first_error_terms_recursive_def-1 nil 3621005274 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skolem 1 "pds_") (("2" (flatten) (("2" (skolem 1 "pd_") (("2" (skeep) (("2" (expand "first_ET" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_ET" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(pd_,
                                                                     append_ol(first_ET(pds_, n),
                                                                               IF search_error_term_by_idx(pds_, n) = 0 THEN empty_ErrorTerms
                                                                               ELSE cons_ol((n, search_error_term_by_idx(pds_, n)),
                                                                                            empty_ErrorTerms)
                                                                               ENDIF)) =
                                                                     append_ol(cons_ol(pd_,first_ET(pds_, n)),
                                                                               IF search_error_term_by_idx(pds_, n) = 0 THEN empty_ErrorTerms
                                                                               ELSE cons_ol((n, search_error_term_by_idx(pds_, n)),
                                                                                            empty_ErrorTerms)
                                                                               ENDIF)") (("1" (replaces -1) (("1" (typepred "pd_") (("1" (case "pd_`1 = n") (("1" (assert) (("1" (case "first(pds_, n) = null") (("1" (replaces -1) (("1" (case "first(cons(pd_, pds_), n) = null") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(cons(pd_, pds_),n) = pd_`2") (("1" (replaces -1) (("1" (case "search_error_term_by_idx(pds_, n) = 0") (("1" (replaces -1) (("1" (case "NOT pd_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "pd_ = (pd_`1,pd_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "pd_ = (pd_`1,pd_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (hide 2) (("2" (expand "search_error_term_by_idx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "pd_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null?(pds_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "pd_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (lemma "last_first_ET") (("2" (assert) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (grind) (("5" (typepred "pd_") (("5" (expand "ordered_list?") (("5" (expand "lt_idx") (("5" (grind) (("5" (hide -2) (("5" (expand "first" 2) (("5" (lift-if) (("5" (case "NOT null?(pds_)") (("1" (assert) (("1" (case "car(pds_)`1 < n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (prop) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (lemma "last_first_ET") (("6" (assert) (("6" (inst?) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) (("3" (lemma "last_first_ET") (("3" (assert) (("3" (inst?) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((first def-decl "(prefixes(l))" indexed_list structures) (prefixes const-decl "bool" more_list_props structures) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures)) nil)) (first_noises_recursive_def_TCC1 0 (first_noises_recursive_def_TCC1-2 "" 3789916485 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (first_noises const-decl "Noise" affine nil) (empty_noise const-decl "Noise" affine nil) (first_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) shostak (first_noises_recursive_def subtype "affine.empty_noise" "{ol2 | ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].appendable_ol?(affine.first_noises(affine.N, affine.n), ol2)}")) (first_noises_recursive_def_TCC1-1 nil 3620558244 ("" (tcc)) ((null_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) nil (first_noises_recursive_def subtype "affine.empty_noise" "{ol2 | ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].appendable_ol?(affine.first_noises(affine.N, affine.n), ol2)}"))) (first_noises_recursive_def_TCC2 0 (first_noises_recursive_def_TCC2-2 "" 3789916486 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (/= const-decl "boolean" notequal nil)) shostak (first_noises_recursive_def subtype "affine.get_noise_by_idx(affine.n, affine.N)" "nzEpsilon")) (first_noises_recursive_def_TCC2-1 nil 3620558244 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (first_noises_recursive_def subtype "affine.get_noise_by_idx(affine.n, affine.N)" "nzEpsilon"))) (first_noises_recursive_def_TCC3 0 (first_noises_recursive_def_TCC3-2 "" 3789916486 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (lt_idx const-decl "bool" indexed_list structures)) shostak (first_noises_recursive_def subtype "affine.empty_noise" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.get_noise_by_idx(affine.n, affine.N)), list_adt[[nat, nzEpsilon]].car(ol)))}")) (first_noises_recursive_def_TCC3-1 nil 3620579570 ("" (tcc)) ((null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) nil (first_noises_recursive_def subtype "affine.empty_noise" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.get_noise_by_idx(affine.n, affine.N)), list_adt[[nat, nzEpsilon]].car(ol)))}"))) (first_noises_recursive_def_TCC4 0 (first_noises_recursive_def_TCC4-1 nil 3620579570 ("" (skeep) (("" (expand "appendable_ol?") (("" (flatten) (("" (hide 3) (("" (grind) (("" (use "last_first_noises") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((appendable_ol? const-decl "bool" ordered_list structures) (last_first_noises formula-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_idx const-decl "bool" indexed_list structures) (first_ol const-decl "T" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (first_noises const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (first_noises_recursive_def subtype "ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].cons_ol((affine.n, affine.get_noise_by_idx(affine.n, affine.N)), affine.empty_noise)" "{ol2 | ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].appendable_ol?(affine.first_noises(affine.N, affine.n), ol2)}"))) (first_noises_recursive_def 0 (first_noises_recursive_def-6 "" 3789916489 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skolem 1 "N_") (("2" (flatten) (("2" (skolem 1 "ep_") (("2" (skeep) (("2" (expand "first_noises" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_noises" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(ep_,
                                                                     append_ol(first_noises(N_, n),
                                                                               IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                               ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                            empty_noise)
                                                                               ENDIF)) =
                                                                     append_ol(cons_ol(ep_,first_noises(N_, n)),
                                                                               IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                               ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                            empty_noise)
                                                                               ENDIF)") (("1" (replaces -1) (("1" (typepred "ep_") (("1" (case "ep_`1 = n") (("1" (expand "first_noises" 1 2) (("1" (case "first_noises(N_, n) = empty_noise") (("1" (replaces -1) (("1" (expand "first" 1 1 :assert? none) (("1" (assert) (("1" (case "get_noise_by_idx(n, cons_ol(ep_, N_)) = ep_`2") (("1" (case "get_noise_by_idx(n, N_) = 0") (("1" (replaces -1) (("1" (case "NOT ep_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) (("1" (assert :flush? t) (("1" (decompose-equality 2) nil nil)) nil) ("2" (decompose-equality 2) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -2 :dir RL) (("2" (expand "get_noise_by_idx" 1 :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (beta) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "ordered_list?" -3 :assert? none) (("1" (assert) (("1" (split -3) (("1" (expand_ol) nil nil) ("2" (expand "lt_idx") (("2" (replaces -2 :dir RL) (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (assert) (("2" (split -2) (("1" (expand_ol) nil nil) ("2" (expand "lt_idx") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first_noises") (("2" (expand "first") (("2" (lift-if 1) (("2" (split 1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (hide 2) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (lift-if -2) (("2" (split -2) (("1" (assert) nil nil) ("2" (flatten) (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "lt_idx") (("2" (reveal 1) (("2" (replaces -2) (("2" (split 1) (("1" (flatten) (("1" (abstract-and-then -1 1 (assert)) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ep_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null_ol?(N_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "ep_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (use "last_first_noises") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (typepred "ep_") (("5" (expand "ordered_list?") (("5" (flatten) (("5" (case "N_ = null") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "lt_idx") (("2" (expand "first_noises" 3) (("2" (expand "first") (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (use "last_first_noises") (("6" (grind) nil nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (case "last_ol(first_noises(N,n))`1 < n") (("1" (grind) nil nil) ("2" (use "last_first_noises") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((TRUE const-decl "bool" booleans nil) (last_ol def-decl "T" ordered_list structures) (last_first_noises formula-decl nil affine nil) (first_ol const-decl "T" ordered_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (car_ol const-decl "T" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (prefixes const-decl "bool" more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (< const-decl "bool" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (first def-decl "(prefixes(l))" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (append def-decl "list[T]" list_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (IF const-decl "[boolean, T, T -> T]" if_def nil) (append_ol const-decl "ordered_list" ordered_list structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (pred type-eq-decl nil defined_types nil) (cons_ol const-decl "ordered_list" ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (first_noises const-decl "Noise" affine nil) (empty_noise const-decl "Noise" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (first_noises_recursive_def-5 "" 3750581960 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skolem 1 "N_") (("2" (flatten) (("2" (skolem 1 "ep_") (("2" (skeep) (("2" (expand "first_noises" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_noises" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(ep_,
                                                                     append_ol(first_noises(N_, n),
                                                                               IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                               ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                            empty_noise)
                                                                               ENDIF)) =
                                                                     append_ol(cons_ol(ep_,first_noises(N_, n)),
                                                                               IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                               ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                            empty_noise)
                                                                               ENDIF)") (("1" (replaces -1) (("1" (typepred "ep_") (("1" (case "ep_`1 = n") (("1" (expand "first_noises" 1 2) (("1" (case "first_noises(N_, n) = empty_noise") (("1" (replaces -1) (("1" (expand "first" 1 1 :assert? none) (("1" (assert) (("1" (case "get_noise_by_idx(n, cons_ol(ep_, N_)) = ep_`2") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, N_) = 0") (("1" (replaces -1) (("1" (case "NOT ep_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) (("1" (assert :flush? t) (("1" (decompose-equality 2) nil nil)) nil) ("2" (decompose-equality 2) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -2 :dir RL) (("2" (expand "get_noise_by_idx" 1 :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (beta) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "ordered_list?" -3 :assert? none) (("1" (assert) (("1" (split -3) (("1" (expand_ol) nil nil) ("2" (expand "lt_idx") (("2" (replaces -2 :dir RL) (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (assert) (("2" (split -2) (("1" (expand_ol) nil nil) ("2" (expand "lt_idx") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first_noises") (("2" (expand "first") (("2" (lift-if 1) (("2" (split 1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (hide 2) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (lift-if -2) (("2" (split -2) (("1" (assert) nil nil) ("2" (flatten) (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "lt_idx") (("2" (reveal 1) (("2" (replaces -2) (("2" (split 1) (("1" (flatten) (("1" (abstract-and-then -1 1 (assert)) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ep_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null_ol?(N_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "ep_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (use "last_first_noises") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (typepred "ep_") (("5" (expand "ordered_list?") (("5" (flatten) (("5" (case "N_ = null") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "lt_idx") (("2" (expand "first_noises" 3) (("2" (expand "first") (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (use "last_first_noises") (("6" (grind) nil nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (case "last_ol(first_noises(N,n))`1 < n") (("1" (grind) nil nil) ("2" (use "last_first_noises") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (prefixes const-decl "bool" more_list_props structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) shostak) (first_noises_recursive_def-4 "" 3629634143 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skolem 1 "N_") (("2" (flatten) (("2" (skolem 1 "ep_") (("2" (skeep) (("2" (expand "first_noises" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_noises" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(ep_,
                                                                     append_ol(first_noises(N_, n),
                                                                               IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                               ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                            empty_noise)
                                                                               ENDIF)) =
                                                                     append_ol(cons_ol(ep_,first_noises(N_, n)),
                                                                               IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                               ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                            empty_noise)
                                                                               ENDIF)") (("1" (replaces -1) (("1" (typepred "ep_") (("1" (case "ep_`1 = n") (("1" (expand "first_noises" 1 2) (("1" (case "first_noises(N_, n) = empty_noise") (("1" (replaces -1) (("1" (expand "first" 1 1 :assert? none) (("1" (assert) (("1" (case "get_noise_by_idx(n, cons_ol(ep_, N_)) = ep_`2") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, N_) = 0") (("1" (replaces -1) (("1" (case "NOT ep_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -2 :dir RL) (("2" (expand "get_noise_by_idx" 1 :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (beta) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "ordered_list?" -3 :assert? none) (("1" (assert) (("1" (split -3) (("1" (expand_ol) nil nil) ("2" (expand "lt_idx") (("2" (replaces -2 :dir RL) (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (assert) (("2" (split -2) (("1" (expand_ol) nil nil) ("2" (expand "lt_idx") (("2" (expand "car_ol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first_noises") (("2" (expand "first") (("2" (lift-if 1) (("2" (split 1) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (hide 2) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (lift-if -2) (("2" (split -2) (("1" (assert) nil nil) ("2" (flatten) (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "lt_idx") (("2" (reveal 1) (("2" (replaces -2) (("2" (split 1) (("1" (flatten) (("1" (abstract-and-then -1 1 (assert)) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ep_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null_ol?(N_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "ep_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (use "last_first_noises") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (typepred "ep_") (("5" (expand "ordered_list?") (("5" (flatten) (("5" (case "N_ = null") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "lt_idx") (("2" (expand "first_noises" 3) (("2" (expand "first") (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (use "last_first_noises") (("6" (grind) nil nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (case "last_ol(first_noises(N,n))`1 < n") (("1" (grind) nil nil) ("2" (use "last_first_noises") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (prefixes const-decl "bool" more_list_props structures) (car_ol const-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures)) nil) (first_noises_recursive_def-3 "" 3629580724 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil) ("2" (skolem 1 "N_") (("2" (flatten) (("2" (skolem 1 "ep_") (("2" (skeep) (("2" (expand "first_noises" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_noises" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(ep_,
                                                          append_ol(first_noises(N_, n),
                                                                    IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                    ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                 empty_noise)
                                                                    ENDIF)) =
                                                          append_ol(cons_ol(ep_,first_noises(N_, n)),
                                                                    IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                                    ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                                 empty_noise)
                                                                    ENDIF)") (("1" (replaces -1) (("1" (typepred "ep_") (("1" (case "ep_`1 = n") (("1" (expand "first_noises" 1 2) (("1" (assert) (("1" (case "first_noises(N_, n) = empty_noise") (("1" (replaces -1) (("1" (case "first[nzEpsilon](cons_ol(ep_, N_), n) = null") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, cons_ol(ep_, N_)) = ep_`2") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, N_) = 0") (("1" (replaces -1) (("1" (case "NOT ep_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil) ("2" (grind) nil))))))) ("2" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil) ("2" (grind) nil))))))) ("2" (grind) (("2" (hide 2) (("2" (expand "get_noise_by_idx") (("2" (grind) nil))))))))))) ("2" (hide 2) (("2" (grind) nil))))))) ("2" (hide 2) (("2" (grind) nil))) ("3" (hide 2) (("3" (grind) nil))))))) ("2" (hide 2) (("2" (expand "first_noises") (("2" (expand "first") (("2" (lift-if 1) (("2" (split 1) (("1" (expand_ol) nil) ("2" (flatten) (("2" (hide 2) (("2" (expand "ordered_list?" -2 :assert? none) (("2" (lift-if -2) (("2" (split -2) (("1" (assert) nil) ("2" (flatten) (("2" (split -1) (("1" (assert) nil) ("2" (expand "lt_idx") (("2" (reveal 1) (("2" (replaces -2) (("2" (split 1) (("1" (flatten) (("1" (abstract-and-then -1 1 (assert)) nil))) ("2" (flatten) (("2" (expand_ol) nil))))))))))))))))))))))))))))))))))))))))) ("2" (case "ep_`1 < n") (("1" (hide -3 1) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))) ("3" (hide 2) (("3" (case "null_ol?(N_)") (("1" (grind) nil) ("2" (flatten) (("2" (typepred "ep_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (use "last_first_noises") (("2" (assert) nil))))))))))))))))))))))))))))))) ("4" (hide-all-but 1) (("4" (grind) nil))) ("5" (hide 2) (("5" (typepred "ep_") (("5" (grind) (("5" (expand "first" 2 1) (("5" (assert) (("5" (lift-if) (("5" (assert) (("5" (assert) (("5" (prop) (("5" (assert) nil))))))))))))))))))) ("6" (hide 2) (("6" (flatten) (("6" (use "last_first_noises") (("6" (grind) nil))))))) ("7" (grind) nil) ("8" (grind) nil) ("9" (grind) nil))))))))) ("2" (grind) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (case "last_ol(first_noises(N,n))`1 < n") (("1" (grind) nil) ("2" (use "last_first_noises") (("2" (grind) nil))) ("3" (grind) nil))))))) ("4" (grind) nil) ("5" (grind) nil) ("6" (grind) nil)) nil) ((appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures)) nil) (first_noises_recursive_def-2 "" 3620752169 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skolem 1 "N_") (("2" (flatten) (("2" (skolem 1 "ep_") (("2" (skeep) (("2" (expand "first_noises" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_noises" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(ep_,
                                               append_ol(first_noises(N_, n),
                                                         IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                         ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                      empty_noise)
                                                         ENDIF)) =
                                               append_ol(cons_ol(ep_,first_noises(N_, n)),
                                                         IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                                         ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                                      empty_noise)
                                                         ENDIF)") (("1" (replaces -1) (("1" (typepred "ep_") (("1" (case "ep_`1 = n") (("1" (expand "first_noises" 1 2) (("1" (assert) (("1" (case "first_noises(N_, n) = null") (("1" (replaces -1) (("1" (case "first[nzEpsilon](cons(ep_, N_), n) = null") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, cons(ep_, N_)) = ep_`2") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, N_) = 0") (("1" (replaces -1) (("1" (case "NOT ep_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (hide 2) (("2" (expand "get_noise_by_idx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first_noises") (("2" (expand "first") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ep_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null?(N_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "ep_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (use "last_first_noises") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (typepred "ep_") (("5" (grind) (("5" (expand "first" 2 1) (("5" (assert) (("5" (lift-if) (("5" (assert) (("5" (assert) (("5" (prop) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (use "last_first_noises") (("6" (grind) nil nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (case "last_ol(first_noises(N,n))`1 < n") (("1" (grind) nil nil) ("2" (use "last_first_noises") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) shostak) (first_noises_recursive_def-1 nil 3620558269 ("" (induct "N" :name "ol_ind_sch[[nat,nzEpsilon],lt_idx[nzEpsilon]]") (("1" (grind) nil nil) ("2" (skolem 1 "N_") (("2" (flatten) (("2" (skolem 1 "ep_") (("2" (skeep) (("2" (expand "first_noises" 1 1) (("2" (expand "first" 1 1) (("2" (lift-if) (("2" (prop) (("1" (inst -2 "n") (("1" (expand "first_noises" -2 1) (("1" (replaces -2) (("1" (case "cons_ol(ep_,
                         append_ol(first_noises(N_, n),
                                   IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                   ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                empty_noise)
                                   ENDIF)) =
                         append_ol(cons_ol(ep_,first_noises(N_, n)),
                                   IF get_noise_by_idx(n, N_) = 0 THEN empty_noise
                                   ELSE cons_ol((n, get_noise_by_idx(n, N_)),
                                                empty_noise)
                                   ENDIF)") (("1" (replaces -1) (("1" (typepred "ep_") (("1" (case "ep_`1 = n") (("1" (expand "first_noises" 1 2) (("1" (assert) (("1" (case "first_noises(N_, n) = null") (("1" (replaces -1) (("1" (case "first[nzEpsilon](cons(ep_, N_), n) = null") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, cons(ep_, N_)) = ep_`2") (("1" (replaces -1) (("1" (case "get_noise_by_idx(n, N_) = 0") (("1" (replaces -1) (("1" (case "NOT ep_`2 = 0") (("1" (assert) (("1" (replaces -1 :dir RL) (("1" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "ep_=(ep_`1, ep_`2)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (hide 2) (("2" (expand "get_noise_by_idx") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "first_noises") (("2" (expand "first") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ep_`1 < n") (("1" (hide -3 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (case "null?(N_)") (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "ep_") (("2" (expand "appendable_ol?") (("2" (assert) (("2" (prop) (("2" (expand "lt_idx") (("2" (expand "last_ol" 5 1) (("2" (hide 3 4) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (use "last_first_noises") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (typepred "ep_") (("5" (grind) (("5" (expand "first" 2 1) (("5" (assert) (("5" (lift-if) (("5" (assert) (("5" (assert) (("5" (prop) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (flatten) (("6" (use "last_first_noises") (("6" (grind) nil nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (case "last_ol(first_noises(N,n))`1 < n") (("1" (grind) nil nil) ("2" (case "FORALL (Noise: Noise):

                    null?[[nat, nzEpsilon]](first_noises(Noise, n)) OR last_ol(first_noises(Noise, n))`1 < n") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (induct "Noise") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("n_" "N_")) (("3" (flatten) (("3" (use "ol_suffix[[nat, nzEpsilon], lt_idx[nzEpsilon]]") (("3" (assert) (("3" (prop) (("1" (grind) nil nil) ("2" (grind) (("2" (expand "last_ol" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (use "Noise_as_list") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (use "Noise_as_list") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ((last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures)) nil)) (eval_pd_noise_incremental 0 (eval_pd_noise_incremental-3 "" 3789916492 ("" (skeep) (("" (rewrites "first_noises_recursive_def") (("" (rewrites "eval_pd_noise_noise_append") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (generalize-skolem-constants) (("1" (induct "pds1_1") (("1" (grind) nil nil) ("2" (prop) (("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (skolem 1 ("N1" "n1")) (("3" (prop) (("1" (expand "eval_pd_noise" 2) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (inst?) (("2" (assert) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (inst?) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (lemma "last_first_noises") (("2" (inst -1 "N" "n") (("2" (expand "first_noises") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil) ((odd_minus_odd_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (first_noises_recursive_def formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (last_first_noises formula-decl nil affine nil) (first_ol const-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (eval_pd_noise def-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (list_induction formula-decl nil list_adt nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (BaseType type-eq-decl nil affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (empty_noise const-decl "Noise" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (first_noises const-decl "Noise" affine nil) (eval_pd_noise_noise_append formula-decl nil affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (eval_pd_noise_incremental-2 "" 3620468671 ("" (skeep) (("" (rewrites "first_noises_recursive_def") (("" (rewrites "eval_pd_noise_noise_append") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (generalize-skolem-constants) (("1" (induct "pds1_1") (("1" (grind) nil nil) ("2" (prop) (("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (skolem 1 ("N1" "n1")) (("3" (prop) (("1" (expand "eval_pd_noise" 2) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (inst?) (("2" (assert) (("2" (replaces -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (inst?) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (lemma "last_first_noises") (("2" (inst -1 "N" "n") (("2" (expand "first_noises") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (first_ol const-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures)) shostak) (eval_pd_noise_incremental-1 nil 3620400909 ("" (skeep) (("" (expand "eval_pd_noise" 1 1) (("" (lift-if) (("" (split 1) (("1" (prop) (("1" (lemma "first_null_prop[Epsilon]") (("1" (inst? -1 ("m" "n")) (("1" (assert) (("1" (replaces -1) (("1" (grind) (("1" (use "first_Noise_null_prop") (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (split 2) (("1" (prop) (("1" (use "eval_pd_noise_null_prop") (("1" (prop) (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (split 2) (("1" (prop) (("1" (case "n > last_idx(N)") (("1" (use "first_all_prop[Epsilon]") (("1" (assert) (("1" (replaces -1) (("1" (use "first_all_prop[Epsilon]") (("1" (assert) (("1" (replaces -1) (("1" (use "get_noise_by_idx_zero_prop") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">") (("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (partial_eval_pd_noise_upper_bound 0 (partial_eval_pd_noise_upper_bound-2 "" 3789916494 ("" (skolem 1 ("N" "_" "pds")) (("" (induct "n") (("1" (use "first_noises_zero_prop") (("1" (replaces -1) (("1" (use "first_zero_prop[nzBaseType]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (use "eval_pd_noise_incremental") (("2" (replaces -1) (("2" (case "abs(eval_pd_noise(pds, first_noises(N, j))) + abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N))<=
                         sum_of_modules(first(pds, j)) + abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N))") (("1" (case "abs(eval_pd_noise(pds, first_noises(N, j)) +
                             search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N)) <= abs(eval_pd_noise(pds, first_noises(N, j))) +
                             abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N))") (("1" (hide -3) (("1" (case "sum_of_modules(first(pds, j)) +
                                  abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N)) <= sum_of_modules(first(pds, j+1))") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (use "first_error_terms_recursive_def") (("2" (expand "first_ET") (("2" (replaces -1) (("2" (lift-if) (("2" (prop) (("1" (grind) (("1" (use "sum_of_modules_append") (("1" (grind) nil nil)) nil)) nil) ("2" (expand "append_ol") (("2" (use "sum_of_modules_append") (("1" (replaces -1) (("1" (case "abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N)) <= abs(search_error_term_by_idx(pds, j))") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (use "abs_mult") (("2" (replaces -1) (("2" (case "abs(get_noise_by_idx(j, N)) <= 1") (("1" (lemma "both_sides_times_pos_le1") (("1" (inst -1 "abs(search_error_term_by_idx(pds, j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (typepred "get_noise_by_idx(j, N)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (first_noises const-decl "Noise" affine nil) (BaseType type-eq-decl nil affine nil) (sum_of_modules def-decl "BaseType" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (prefixes const-decl "bool" more_list_props structures) (first def-decl "(prefixes(l))" indexed_list structures) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (first_zero_prop formula-decl nil indexed_list structures) (first_noises_zero_prop formula-decl nil affine nil) (eval_pd_noise_incremental formula-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (first_ET const-decl "ErrorTerms" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs_mult formula-decl nil real_props nil) (pds skolem-const-decl "ErrorTerms" affine nil) (j skolem-const-decl "nat" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (append_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (sum_of_modules_append formula-decl nil affine nil) (first_error_terms_recursive_def formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (partial_eval_pd_noise_upper_bound-1 nil 3620991149 ("" (skolem 1 ("N" "_" "pds")) (("" (induct "n") (("1" (use "first_noises_zero_prop") (("1" (replaces -1) (("1" (use "first_zero_prop[nzBaseType]") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (use "eval_pd_noise_incremental") (("2" (replaces -1) (("2" (case "abs(eval_pd_noise(pds, first_noises(N, j))) + abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N))<=
                         sum_of_modules(first(pds, j)) + abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N))") (("1" (case "abs(eval_pd_noise(pds, first_noises(N, j)) +
                             search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N)) <= abs(eval_pd_noise(pds, first_noises(N, j))) +
                             abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N))") (("1" (hide -3) (("1" (case "sum_of_modules(first(pds, j)) +
                                  abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N)) <= sum_of_modules(first(pds, j+1))") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (use "first_error_terms_recursive_def") (("2" (expand "first_ET") (("2" (replaces -1) (("2" (lift-if) (("2" (prop) (("1" (grind) (("1" (use "sum_of_modules_append") (("1" (grind) nil nil) ("2" (use "first_is_ol[nzBaseType]") nil nil)) nil)) nil) ("2" (expand "append_ol") (("2" (use "sum_of_modules_append") (("1" (replaces -1) (("1" (case "abs(search_error_term_by_idx(pds, j) * get_noise_by_idx(j, N)) <= abs(search_error_term_by_idx(pds, j))") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (use "abs_mult") (("2" (replaces -1) (("2" (case "abs(get_noise_by_idx(j, N)) <= 1") (("1" (lemma "both_sides_times_pos_le1") (("1" (inst -1 "abs(search_error_term_by_idx(pds, j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (typepred "get_noise_by_idx(j, N)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (use "first_is_ol[nzBaseType]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (prefixes const-decl "bool" more_list_props structures) (first def-decl "(prefixes(l))" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (first_zero_prop formula-decl nil indexed_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures)) shostak)) (mult_ac_ac_TCC1 0 (mult_ac_ac_TCC1-1 nil 3619884927 ("" (skeep) (("" (expand "appendable_ol?") (("" (flatten) (("" (expand "lt_idx") (("" (expand "add_ET" 3) (("" (lift-if) (("" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (expand "cons_ol") (("2" (expand "first_ol") (("2" (typepred "newidx") (("2" (use "mult_pd_pd_last_bound") (("2" (expand "null_ol?") (("2" (assert) (("2" (case "NOT null?[[nat, nzBaseType]](pd(Xa1)) AND
       NOT null?[[nat, nzBaseType]](pd(Xa2))") (("1" (flatten) (("1" (assert) (("1" (expand ">=") (("1" (hide-all-but (-1 -2 4)) (("1" (name-replace "stopRW" "last_ol(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)))`1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (appendable_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (mult_pd_pd_last_bound formula-decl nil affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (sum_of_modules def-decl "BaseType" affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (last_ol def-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (next_idx_2 const-decl "nat" affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (first_ol const-decl "T" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil)) shostak (mult_ac_ac subtype "affine.add_ET(affine.newidx, number_fields.*(affine.sum_of_modules(pd(affine.Xa1)), affine.sum_of_modules(pd(affine.Xa2))), affine.empty_ErrorTerms)" "{ol2 | ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].appendable_ol?(affine.mult_pd_pd(cv(affine.Xa1), cv(affine.Xa2), pd(affine.Xa1), pd(affine.Xa2)), ol2)}"))) (mul_noise_value_TCC1 0 (mul_noise_value_TCC1-2 "" 3789916496 ("" (tcc) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (nnreal type-eq-decl nil real_types nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (/= const-decl "boolean" notequal nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil)) shostak (mul_noise_value subtype "affine.som_x_som" "nznum")) (mul_noise_value_TCC1-1 nil 3620056359 ("" (tcc)) ((lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil (mul_noise_value subtype "affine.som_x_som" "nznum"))) (som_inc 0 (som_inc-2 "" 3789916497 ("" (skolem 1 ("n" "_")) (("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "first" 1 1) (("2" (case "x`1 < 1 + n") (("1" (assert) (("1" (expand "sum_of_modules" 1 1) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (hide 1) (("2" (expand "first" 1 2) (("2" (lift-if) (("2" (prop) (("1" (expand "cons_ol") (("1" (expand "sum_of_modules" 1 2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "x`1 = n") (("1" (hide -2 1) (("1" (case "first(ol, n) = null") (("1" (case "search_error_term_by_idx(ol, n) = 0") (("1" (grind) nil nil) ("2" (hide-all-but (1 -2)) (("2" (typepred "x::[nat,BaseType]") (("2" (expand "ordered_list?") (("2" (expand "lt_idx") (("2" (grind) (("2" (expand "search_error_term_by_idx") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (typepred "x::[nat,BaseType]") (("2" (grind) (("2" (expand "first") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (pred type-eq-decl nil defined_types nil) (ErrorTerms type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (BaseType type-eq-decl nil affine nil) (sum_of_modules def-decl "BaseType" affine nil) (prefixes const-decl "bool" more_list_props structures) (first def-decl "(prefixes(l))" indexed_list structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ol_ind_sch formula-decl nil ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (< const-decl "bool" reals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil)) shostak) (som_inc-1 nil 3620071050 ("" (skolem 1 ("n" "_")) (("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType], lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "first" 1 1) (("2" (case "x`1 < 1 + n") (("1" (assert) (("1" (expand "sum_of_modules" 1 1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (grind) nil nil) ("2" (expand "cons_ol") (("2" (hide 1) (("2" (expand "first" 1 2) (("2" (lift-if) (("2" (prop) (("1" (expand "cons_ol") (("1" (expand "sum_of_modules" 1 2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case "x`1 = n") (("1" (hide -2 1) (("1" (case "first(ol, n) = null") (("1" (case "search_error_term_by_idx(ol, n) = 0") (("1" (grind) nil nil) ("2" (hide-all-but (1 -2)) (("2" (typepred "x::[nat,BaseType]") (("2" (expand "ordered_list?") (("2" (expand "lt_idx") (("2" (grind) (("2" (expand "search_error_term_by_idx") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (typepred "x::[nat,BaseType]") (("2" (grind) (("2" (expand "first") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (prefixes const-decl "bool" more_list_props structures) (first def-decl "(prefixes(l))" indexed_list structures) (lt_idx const-decl "bool" indexed_list structures) (ol_ind_sch formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures)) shostak)) (eval_pd_noise_inc_TCC1 0 (eval_pd_noise_inc_TCC1-1 nil 3620579570 ("" (skeep) (("" (use "first_is_ol[nzEpsilon]") nil nil)) nil) ((Noise type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (first_is_ol formula-decl nil indexed_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (eval_pd_noise_inc subtype "indexed_list[nzEpsilon].first(affine.N, (number_fields.+)(affine.n, 1))" "Noise"))) (eval_pd_noise_inc 0 (eval_pd_noise_inc-1 nil 3621087380 ("" (skeep) (("" (lemma "eval_pd_noise_incremental") (("" (inst -1 "N" "n" "mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2))") (("" (assert) (("" (expand "first_noises") (("" (replaces -1) (("" (assert) (("" (use "search_ET_in_mult_pd_pd") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_pd_noise_incremental formula-decl nil affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (search_ET_in_mult_pd_pd formula-decl nil affine nil) (first_noises const-decl "Noise" affine nil) (AffineCombination type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_ac_noise_inc 0 (eval_ac_noise_inc-1 nil 3620400423 ("" (skeep) (("" (expand "eval_ac_noise") (("" (use "eval_pd_noise_incremental") nil nil)) nil)) nil) ((eval_ac_noise const-decl "real" affine nil) (eval_pd_noise_incremental formula-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (eval_ac_noise_mult_inc 0 (eval_ac_noise_mult_inc-1 nil 3620400368 ("" (skeep) (("" (use "eval_ac_noise_inc") (("" (replaces -1) (("" (use "eval_ac_noise_inc") (("" (replaces -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((eval_ac_noise_inc formula-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (first_noises const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (sum_of_modules_decomp 0 (sum_of_modules_decomp-1 nil 3620400247 ("" (skeep) (("" (use "som_inc") (("" (replaces -1) (("" (use "som_inc") (("" (replaces -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((som_inc formula-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (mul_ac_ac_noise_incremental_bound 0 (mul_ac_ac_noise_incremental_bound-2 "" 3789916516 ("" (induct "n") (("1" (skolem 1 ("N" "A" "B")) (("1" (rewrites "first_zero_prop[[nzBaseType]]") (("1" (rewrites "first_zero_prop[[nzBaseType]]") (("1" (rewrites "first_noises_zero_prop") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skolem 1 ("N" "A" "B")) (("2" (inst -1 "N" "A" "B") (("2" (rewrites "sum_of_modules_decomp") (("2" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) - cv(A) * cv(B) -
                                                                  eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)))
                                                        + sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                               + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                               + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                       <=
                                                       sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                               sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                               + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                               + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))") (("1" (hide -2) (("1" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) - cv(A) * cv(B) -
                                                                              eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)))
                                                                          + sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          <=
                                                                          sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                           sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                           + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                           + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                   IMPLIES
                                                                   abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) - cv(A) * cv(B) -
                                                                              eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)))
                                                                          + sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) * abs(get_noise_by_idx(j, N))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j)) * abs(get_noise_by_idx(j, N))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) * abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N))
                                                                          <=
                                                                          sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                           sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                           + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                           + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))") (("1" (assert) (("1" (hide -2) (("1" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                                             eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                                             - cv(A) * cv(B))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * sum_of_modules(first(pd(A), j)) *
                                                                          abs(search_error_term_by_idx(pd(B), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * sum_of_modules(first(pd(B), j)) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N)) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                          * abs(search_error_term_by_idx(pd(B), j))
                                                                         <=
                                                                         sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                          sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                  IMPLIES
                                                                  abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                                             eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                                             - cv(A) * cv(B))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(eval_pd_noise(pd(A),first_noises(N, j))) *
                                                                          abs(search_error_term_by_idx(pd(B), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(eval_pd_noise(pd(B),first_noises(N, j))) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N)) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                          * abs(search_error_term_by_idx(pd(B), j))
                                                                         <=
                                                                         sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                          sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))") (("1" (assert) (("1" (hide -2) (("1" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                         eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                         - cv(A) * cv(B))
                                                     +
                                                     abs(eval_pd_noise(pd(A), first_noises(N, j))) * abs(get_noise_by_idx(j, N)) *
                                                      abs(search_error_term_by_idx(pd(B), j))
                                                     +
                                                     abs(eval_pd_noise(pd(B), first_noises(N, j))) * abs(get_noise_by_idx(j, N)) *
                                                      abs(search_error_term_by_idx(pd(A), j))
                                                     +
                                                     abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N)) *
                                                      abs(search_error_term_by_idx(pd(A), j))
                                                      * abs(search_error_term_by_idx(pd(B), j))
                                                     <=
                                                     abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) +
                                                      sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                      + sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j))
                                                      + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                              IMPLIES
                                              abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                         eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                         - cv(A) * cv(B)
                                                     +
                                                     eval_pd_noise(pd(A), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                      search_error_term_by_idx(pd(B), j)
                                                     +
                                                     eval_pd_noise(pd(B), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                      search_error_term_by_idx(pd(A), j)
                                                     +
                                                     get_noise_by_idx(j, N) * get_noise_by_idx(j, N) *
                                                      search_error_term_by_idx(pd(A), j)
                                                      * search_error_term_by_idx(pd(B), j))
                                                     <=
                                                     abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) +
                                                      sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                      + sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j))
                                                      + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))") (("1" (assert) (("1" (hide -2) (("1" (lemma "minus_add") (("1" (inst -1 "eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j))" "           eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))") (("1" (replaces -1) (("1" (lemma "identity_add") (("1" (inst -1 "           -eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))") (("1" (case "0 = - (search_error_term_by_idx(pd(A), j)*cv(B)+search_error_term_by_idx(pd(B), j)*cv(A)) * get_noise_by_idx(j, N) + search_error_term_by_idx(pd(A), j)*get_noise_by_idx(j, N)*cv(B) + search_error_term_by_idx(pd(B), j)*get_noise_by_idx(j, N)*cv(A)") (("1" (replaces -1) (("1" (replaces -1 :dir RL) (("1" (case "(-eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)) +
                                                    (-(search_error_term_by_idx(pd(A), j) * cv(B) +
                                                        search_error_term_by_idx(pd(B), j) * cv(A))
                                                      * get_noise_by_idx(j, N)
                                                      + search_error_term_by_idx(pd(A), j) * get_noise_by_idx(j, N) * cv(B)
                                                      + search_error_term_by_idx(pd(B), j) * get_noise_by_idx(j, N) * cv(A))) =
                                       - eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j+1))
                                       + search_error_term_by_idx(pd(A), j) * get_noise_by_idx(j, N) * cv(B)
                                       + search_error_term_by_idx(pd(B), j) * get_noise_by_idx(j, N) * cv(A)") (("1" (replaces -1) (("1" (assert) (("1" (case "eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j))
                                           + cv(A) * get_noise_by_idx(j, N) * search_error_term_by_idx(pd(B), j)
                                           + cv(B) * get_noise_by_idx(j, N) * search_error_term_by_idx(pd(A), j)
                                                      +
                                                      eval_pd_noise(pd(A), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                       search_error_term_by_idx(pd(B), j)
                                                      +
                                                      eval_pd_noise(pd(B), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                       search_error_term_by_idx(pd(A), j)
                                                      +
                                                      get_noise_by_idx(j, N) * get_noise_by_idx(j, N) *
                                                       search_error_term_by_idx(pd(A), j)
                                                       * search_error_term_by_idx(pd(B), j)
                                           = eval_ac_noise(A, first_noises(N, 1 +j)) * eval_ac_noise(B, first_noises(N, 1+j))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (use "eval_ac_noise_mult_inc") (("2" (replaces -1) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (use "eval_pd_noise_inc") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("2" (case "FORALL(rA,rB,rC,rD,rE,rF:real):
                                                    abs(rA)
                                                           +
                                                           abs(rB) * abs(rC) *
                                                            abs(rD)
                                                           +
                                                           abs(rF) * abs(rC) *
                                                            abs(rE)
                                                           +
                                                           abs(rC) * abs(rC) *
                                                            abs(rE)
                                                            * abs(rD) >= abs( rA + rB * rC * rD + rF * rC * rE + rC * rC * rE * rD)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand ">=") (("2" (use "abs_mult") (("2" (lemma "abs_mult") (("2" (inst -1 "rC*rC" "rD") (("2" (lemma "abs_mult") (("2" (inst -1 "rC" "rC") (("2" (replaces -1) (("2" (replaces -1) (("2" (replaces -1 :dir RL) (("2" (lemma "abs_mult") (("2" (inst -1 "rC*rE" "rF") (("2" (lemma "abs_mult") (("2" (inst -1 "rC" "rE") (("2" (replaces -1 :dir RL) (("2" (replaces -1 :dir RL) (("2" (lemma "abs_mult") (("2" (inst -1 "rB*rC" "rD") (("2" (lemma "abs_mult") (("2" (inst -1 "rB" "rC") (("2" (replaces -1) (("2" (replaces -1 :dir RL) (("2" (use "triangle") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("2" (assert) (("2" (use "partial_eval_pd_noise_upper_bound") (("2" (lemma "both_sides_times_pos_le1_imp") (("2" (inst -1 "abs(get_noise_by_idx(j, N)) * abs(search_error_term_by_idx(pd(B), j))" "abs(eval_pd_noise(pd(A), first_noises(N, j)))" "sum_of_modules(first(pd(A), j))") (("2" (assert) (("2" (hide -2) (("2" (lemma "partial_eval_pd_noise_upper_bound") (("2" (inst? -1 ("pds" "pd(B)")) (("2" (lemma "both_sides_times_pos_le1_imp") (("2" (inst -1 "abs(get_noise_by_idx(j, N)) * abs(search_error_term_by_idx(pd(A), j))" "abs(eval_pd_noise(pd(B), first_noises(N, j)))" "sum_of_modules(first(pd(B), j))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("2" (case "abs(get_noise_by_idx(j, N)) <= 1") (("1" (assert) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "abs(get_noise_by_idx(j, N)) *
                           (abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) (("1" (hide -2) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (use "first_is_ol[nzBaseType]") (("2" (lemma "sum_of_modules_nnreal") (("2" (inst -1 "first(pd(B), j)") (("2" (expand ">=") (("2" (use "pos_times_le") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "sum_of_modules_nnreal") (("2" (inst -1 "first(pd(A), j)") (("1" (expand ">=") (("1" (use "pos_times_le") (("1" (assert) nil nil)) nil)) nil) ("2" (use "first_is_ol[nzBaseType]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "get_noise_by_idx(j, N)") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrites "both_sides_plus_le1") (("2" (rewrites "both_sides_plus_le1") (("2" (rewrites "both_sides_plus_le1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (search_error_term_by_idx def-decl "BaseType" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (partial_eval_pd_noise_upper_bound formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (identity_add formula-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (eval_pd_noise_inc formula-decl nil affine nil) (eval_ac_noise_mult_inc formula-decl nil affine nil) (minus_real_is_real application-judgement "real" reals nil) (minus_add formula-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (triangle formula-decl nil real_props nil) (abs_mult formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (first_is_ol formula-decl nil indexed_list structures) (pos_times_le formula-decl nil real_props nil) (sum_of_modules_nnreal judgement-tcc nil affine nil) (B skolem-const-decl "AffineCombination" affine nil) (j skolem-const-decl "nat" affine nil) (A skolem-const-decl "AffineCombination" affine nil) (both_sides_plus_le1 formula-decl nil real_props nil) (sum_of_modules_decomp formula-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (empty_noise const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (first_noises_zero_prop formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (first_zero_prop formula-decl nil indexed_list structures) (nat_induction formula-decl nil naturalnumbers nil) (first def-decl "(prefixes(l))" indexed_list structures) (prefixes const-decl "bool" more_list_props structures) (ordered_list type-eq-decl nil ordered_list structures) (sum_of_modules def-decl "BaseType" affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (eval_pd_noise def-decl "real" affine nil) (nzBaseType type-eq-decl nil affine nil) (first_noises const-decl "Noise" affine nil) (eval_ac_noise const-decl "real" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak) (mul_ac_ac_noise_incremental_bound-1 nil 3620382968 ("" (induct "n") (("1" (skolem 1 ("N" "A" "B")) (("1" (rewrites "first_zero_prop[[nzBaseType]]") (("1" (rewrites "first_zero_prop[[nzBaseType]]") (("1" (rewrites "first_noises_zero_prop") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skolem 1 ("N" "A" "B")) (("2" (inst -1 "N" "A" "B") (("2" (rewrites "sum_of_modules_decomp") (("2" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) - cv(A) * cv(B) -
                                                                  eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)))
                                                        + sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                               + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                               + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                       <=
                                                       sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                               sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                               + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                               + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))") (("1" (hide -2) (("1" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) - cv(A) * cv(B) -
                                                                              eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)))
                                                                          + sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          <=
                                                                          sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                           sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                           + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                           + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                   IMPLIES
                                                                   abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) - cv(A) * cv(B) -
                                                                              eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)))
                                                                          + sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) * abs(get_noise_by_idx(j, N))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j)) * abs(get_noise_by_idx(j, N))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) * abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N))
                                                                          <=
                                                                          sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                           sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                           + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                           + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))") (("1" (assert) (("1" (hide -2) (("1" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                                             eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                                             - cv(A) * cv(B))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * sum_of_modules(first(pd(A), j)) *
                                                                          abs(search_error_term_by_idx(pd(B), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * sum_of_modules(first(pd(B), j)) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N)) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                          * abs(search_error_term_by_idx(pd(B), j))
                                                                         <=
                                                                         sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                          sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                  IMPLIES
                                                                  abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                                             eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                                             - cv(A) * cv(B))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(eval_pd_noise(pd(A),first_noises(N, j))) *
                                                                          abs(search_error_term_by_idx(pd(B), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(eval_pd_noise(pd(B),first_noises(N, j))) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                         +
                                                                         abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N)) *
                                                                          abs(search_error_term_by_idx(pd(A), j))
                                                                          * abs(search_error_term_by_idx(pd(B), j))
                                                                         <=
                                                                         sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j)) +
                                                                          sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                                          + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                                                          + abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))") (("1" (assert) (("1" (hide -2) (("1" (case "abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                         eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                         - cv(A) * cv(B))
                                                     +
                                                     abs(eval_pd_noise(pd(A), first_noises(N, j))) * abs(get_noise_by_idx(j, N)) *
                                                      abs(search_error_term_by_idx(pd(B), j))
                                                     +
                                                     abs(eval_pd_noise(pd(B), first_noises(N, j))) * abs(get_noise_by_idx(j, N)) *
                                                      abs(search_error_term_by_idx(pd(A), j))
                                                     +
                                                     abs(get_noise_by_idx(j, N)) * abs(get_noise_by_idx(j, N)) *
                                                      abs(search_error_term_by_idx(pd(A), j))
                                                      * abs(search_error_term_by_idx(pd(B), j))
                                                     <=
                                                     abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) +
                                                      sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                      + sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j))
                                                      + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))
                                              IMPLIES
                                              abs(eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j)) -
                                                         eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))
                                                         - cv(A) * cv(B)
                                                     +
                                                     eval_pd_noise(pd(A), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                      search_error_term_by_idx(pd(B), j)
                                                     +
                                                     eval_pd_noise(pd(B), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                      search_error_term_by_idx(pd(A), j)
                                                     +
                                                     get_noise_by_idx(j, N) * get_noise_by_idx(j, N) *
                                                      search_error_term_by_idx(pd(A), j)
                                                      * search_error_term_by_idx(pd(B), j))
                                                     <=
                                                     abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)) +
                                                      sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))
                                                      + sum_of_modules(first(pd(A), j)) * sum_of_modules(first(pd(B), j))
                                                      + sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))") (("1" (assert) (("1" (hide -2) (("1" (lemma "minus_add") (("1" (inst -1 "eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j))" "           eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))") (("1" (replaces -1) (("1" (lemma "identity_add") (("1" (inst -1 "           -eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j))") (("1" (case "0 = - (search_error_term_by_idx(pd(A), j)*cv(B)+search_error_term_by_idx(pd(B), j)*cv(A)) * get_noise_by_idx(j, N) + search_error_term_by_idx(pd(A), j)*get_noise_by_idx(j, N)*cv(B) + search_error_term_by_idx(pd(B), j)*get_noise_by_idx(j, N)*cv(A)") (("1" (replaces -1) (("1" (replaces -1 :dir RL) (("1" (case "(-eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j)) +
                                                    (-(search_error_term_by_idx(pd(A), j) * cv(B) +
                                                        search_error_term_by_idx(pd(B), j) * cv(A))
                                                      * get_noise_by_idx(j, N)
                                                      + search_error_term_by_idx(pd(A), j) * get_noise_by_idx(j, N) * cv(B)
                                                      + search_error_term_by_idx(pd(B), j) * get_noise_by_idx(j, N) * cv(A))) =
                                       - eval_pd_noise(mult_pd_pd(cv(A), cv(B), pd(A), pd(B)), first_noises(N, j+1))
                                       + search_error_term_by_idx(pd(A), j) * get_noise_by_idx(j, N) * cv(B)
                                       + search_error_term_by_idx(pd(B), j) * get_noise_by_idx(j, N) * cv(A)") (("1" (replaces -1) (("1" (assert) (("1" (case "eval_ac_noise(A, first_noises(N, j)) * eval_ac_noise(B, first_noises(N, j))
                                           + cv(A) * get_noise_by_idx(j, N) * search_error_term_by_idx(pd(B), j)
                                           + cv(B) * get_noise_by_idx(j, N) * search_error_term_by_idx(pd(A), j)
                                                      +
                                                      eval_pd_noise(pd(A), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                       search_error_term_by_idx(pd(B), j)
                                                      +
                                                      eval_pd_noise(pd(B), first_noises(N, j)) * get_noise_by_idx(j, N) *
                                                       search_error_term_by_idx(pd(A), j)
                                                      +
                                                      get_noise_by_idx(j, N) * get_noise_by_idx(j, N) *
                                                       search_error_term_by_idx(pd(A), j)
                                                       * search_error_term_by_idx(pd(B), j)
                                           = eval_ac_noise(A, first_noises(N, 1 +j)) * eval_ac_noise(B, first_noises(N, 1+j))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (use "eval_ac_noise_mult_inc") (("2" (replaces -1) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (use "eval_pd_noise_inc") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("2" (case "FORALL(rA,rB,rC,rD,rE,rF:real):
                                                    abs(rA)
                                                           +
                                                           abs(rB) * abs(rC) *
                                                            abs(rD)
                                                           +
                                                           abs(rF) * abs(rC) *
                                                            abs(rE)
                                                           +
                                                           abs(rC) * abs(rC) *
                                                            abs(rE)
                                                            * abs(rD) >= abs( rA + rB * rC * rD + rF * rC * rE + rC * rC * rE * rD)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand ">=") (("2" (use "abs_mult") (("2" (lemma "abs_mult") (("2" (inst -1 "rC*rC" "rD") (("2" (lemma "abs_mult") (("2" (inst -1 "rC" "rC") (("2" (replaces -1) (("2" (replaces -1) (("2" (replaces -1) (("2" (replaces -1 :dir RL) (("2" (lemma "abs_mult") (("2" (inst -1 "rC*rE" "rF") (("2" (lemma "abs_mult") (("2" (inst -1 "rC" "rE") (("2" (replaces -1 :dir RL) (("2" (replaces -1 :dir RL) (("2" (lemma "abs_mult") (("2" (inst -1 "rB*rC" "rD") (("2" (lemma "abs_mult") (("2" (inst -1 "rB" "rC") (("2" (replaces -1) (("2" (replaces -1 :dir RL) (("2" (use "triangle") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("2" (assert) (("2" (use "partial_eval_pd_noise_upper_bound") (("2" (lemma "both_sides_times_pos_le1_imp") (("2" (inst -1 "abs(get_noise_by_idx(j, N)) * abs(search_error_term_by_idx(pd(B), j))" "abs(eval_pd_noise(pd(A), first_noises(N, j)))" "sum_of_modules(first(pd(A), j))") (("2" (assert) (("2" (hide -2) (("2" (lemma "partial_eval_pd_noise_upper_bound") (("2" (inst? -1 ("pds" "pd(B)")) (("2" (lemma "both_sides_times_pos_le1_imp") (("2" (inst -1 "abs(get_noise_by_idx(j, N)) * abs(search_error_term_by_idx(pd(A), j))" "abs(eval_pd_noise(pd(B), first_noises(N, j)))" "sum_of_modules(first(pd(B), j))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("2" (case "abs(get_noise_by_idx(j, N)) <= 1") (("1" (assert) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "abs(get_noise_by_idx(j, N)) *
                           (abs(search_error_term_by_idx(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j)))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) (("1" (hide -2) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "sum_of_modules(first(pd(A), j)) * abs(search_error_term_by_idx(pd(B), j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) (("1" (assert) (("1" (lemma "both_sides_times_pos_le1_imp") (("1" (inst -1 "sum_of_modules(first(pd(B), j)) * abs(search_error_term_by_idx(pd(A), j))" "abs(get_noise_by_idx(j, N))" "1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (use "first_is_ol[nzBaseType]") (("2" (lemma "sum_of_modules_nnreal") (("2" (inst -1 "first(pd(B), j)") (("2" (expand ">=") (("2" (use "pos_times_le") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "sum_of_modules_nnreal") (("2" (inst -1 "first(pd(A), j)") (("1" (expand ">=") (("1" (use "pos_times_le") (("1" (assert) nil nil)) nil)) nil) ("2" (use "first_is_ol[nzBaseType]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "get_noise_by_idx(j, N)") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrites "both_sides_plus_le1") (("2" (rewrites "both_sides_plus_le1") (("2" (rewrites "both_sides_plus_le1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_is_ol formula-decl nil indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (first_zero_prop formula-decl nil indexed_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (prefixes const-decl "bool" more_list_props structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) shostak)) (mul_noise_value_is_Epsilon 0 (mul_noise_value_is_Epsilon-3 "" 3620572796 ("" (skeep) (("" (expand "mul_noise_value") (("" (lemma "mul_ac_ac_noise_incremental_bound") (("" (inst? -1 ("n" "max(last_idx(N),max(last_idx(pd(Xa1)),last_idx(pd(Xa2))))+1")) (("1" (inst -1 "N" "Xa1" "Xa2") (("1" (case "first_noises(N,
                                                              max(last_idx(N),
                                                                  max(last_idx(pd(Xa1)), last_idx(pd(Xa2))))+1)  = N") (("1" (replaces -1) (("1" (case "first(pd(Xa1),
                                                                      max(last_idx(N),
                                                                          max(last_idx(pd(Xa1)), last_idx(pd(Xa2))))+1)  = pd(Xa1)") (("1" (replaces -1) (("1" (case "first(pd(Xa2),
                                                                              max(last_idx(N),
                                                                                  max(last_idx(pd(Xa1)), last_idx(pd(Xa2))))+1)  = pd(Xa2)") (("1" (replaces -1) (("1" (assert) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) (("2" (case "FORALL (x,y:real): abs(x) <= y  IMPLIES x >= -y") (("1" (inst?) (("1" (prop) (("1" (hide -2) (("1" (hide 1) (("1" (expand ">=") (("1" (use "div_mult_pos_neg_le2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (hide 1) (("2" (case "FORALL (x,y:real): abs(x) <= y  IMPLIES x <= y") (("1" (inst?) (("1" (prop) (("1" (hide 1) (("1" (use "div_mult_pos_neg_le1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "first_all_prop[nzBaseType]") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "first_all_prop[nzBaseType]") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "first_noises") (("2" (use "first_all_prop[nzEpsilon]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (mul_noise_value const-decl "real" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (Xa2 skolem-const-decl "AffineCombination" affine nil) (Xa1 skolem-const-decl "AffineCombination" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (N skolem-const-decl "Noise" affine nil) (Noise type-eq-decl nil affine nil) (last_idx const-decl "int" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (first_noises const-decl "Noise" affine nil) (prefixes const-decl "bool" more_list_props structures) (first def-decl "(prefixes(l))" indexed_list structures) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_neg_le1 formula-decl nil extra_real_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sum_of_modules def-decl "BaseType" affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (eval_pd_noise def-decl "real" affine nil) (eval_ac_noise const-decl "real" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_mult_pos_neg_le2 formula-decl nil extra_real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (first_all_prop formula-decl nil indexed_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (mul_ac_ac_noise_incremental_bound formula-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (mul_noise_value_is_Epsilon subtype "affine.mul_noise_value(affine.Xa1, affine.Xa2, affine.N)" "Epsilon")) (mul_noise_value_is_Epsilon-2 nil 3620148486 ("" (skeep) (("" (expand "mul_noise_value") (("" (lemma "mul_ac_ac_noise_incremental_bound") (("" (inst? -1 ("n" "max(last_idx(N),max(last_idx(pd(Xa1)),last_idx(pd(Xa2))))+1")) (("1" (inst -1 "N" "Xa1" "Xa2") (("1" (case "first(N,
                                            max(last_idx(N),
                                                max(last_idx(pd(Xa1)), last_idx(pd(Xa2))))+1)  = N") (("1" (replaces -1) (("1" (case "first(pd(Xa1),
                                                max(last_idx(N),
                                                    max(last_idx(pd(Xa1)), last_idx(pd(Xa2))))+1)  = pd(Xa1)") (("1" (replaces -1) (("1" (case "first(pd(Xa2),
                                                    max(last_idx(N),
                                                        max(last_idx(pd(Xa1)), last_idx(pd(Xa2))))+1)  = pd(Xa2)") (("1" (replaces -1) (("1" (assert) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) (("2" (case "FORALL (x,y:real): abs(x) <= y  IMPLIES x >= -y") (("1" (inst?) (("1" (prop) (("1" (hide -2) (("1" (hide 1) (("1" (expand ">=") (("1" (use "div_mult_pos_neg_le2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (hide 1) (("2" (case "FORALL (x,y:real): abs(x) <= y  IMPLIES x <= y") (("1" (inst?) (("1" (prop) (("1" (hide 1) (("1" (use "div_mult_pos_neg_le1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "first_all_prop[real]") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "first_all_prop[real]") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "first_all_prop[Epsilon]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures)) nil (mul_noise_value_is_Epsilon subtype "affine.mul_noise_value(affine.Xa1, affine.Xa2, affine.N)" "Epsilon")) (mul_noise_value_is_Epsilon-1 nil 3620056359 ("" (skeep) (("" (lemma "mul_noise_value_bounds") (("" (inst -1 "N" "Xa1" "Xa2") (("" (grind) (("1" (hide -2) (("1" (rewrite "div_mult_pos_le1") nil nil)) nil) ("2" (hide -1) (("2" (expand ">=") (("2" (rewrite "div_mult_pos_le2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (mul_noise_value_is_Epsilon subtype "affine.mul_noise_value(affine.Xa1, affine.Xa2, affine.N)" "Epsilon"))) (som_zero 0 (som_zero-1 nil 3621350166 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep) (("2" (skolem 1 "x_") (("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (sum_of_modules def-decl "BaseType" affine nil) (BaseType type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (pred type-eq-decl nil defined_types nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (list type-decl nil list_adt nil)) shostak)) (epn_aET__nnull_pds_TCC1 0 (epn_aET__nnull_pds_TCC1-2 "" 3789916523 ("" (tcc) nil nil) ((/= const-decl "boolean" notequal nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_idx const-decl "bool" indexed_list structures)) shostak (epn_aET__nnull_pds subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.x), list_adt[[nat, nzBaseType]].car(ol)))}")) (epn_aET__nnull_pds_TCC1-1 nil 3621356082 ("" (tcc)) ((null_ol? const-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures)) nil (epn_aET__nnull_pds subtype "affine.empty_ErrorTerms" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.n, affine.x), list_adt[[nat, nzBaseType]].car(ol)))}"))) (epn_aET__nnull_pds 0 (epn_aET__nnull_pds-1 nil 3621360085 ("" (skeep) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "add_ET") (("1" (assert) (("1" (expand "null_ol?") (("1" (case "null?[[nat, nzBaseType]](pds)") (("1" (hide -2) (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (split 3) (("1" (flatten) (("1" (expand "cons_ol") (("1" (lemma "eval_pd_noise_append") (("1" (inst -1 "N" "cons_ol((n,x),null)" "pds") (("1" (split -1) (("1" (expand "cons_ol") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_pd_noise def-decl "real" affine nil) (eval_pd_noise_append formula-decl nil affine nil) (append def-decl "list[T]" list_props nil) (append_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (null adt-constructor-decl "(null?)" list_adt nil) (BaseType type-eq-decl nil affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (epn_mpp_null_pds1 0 (epn_mpp_null_pds1-2 "" 3789916526 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "mult_pd_pd" 1) (("" (expand "null_ol") (("" (expand "null_ol?") (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (case-replace "pds!1=null") (("1" (hide -3) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (lemma "epn_aET__nnull_pds") (("2" (inst -1 "N!1" "car(pds!1)`1" "mult_pd_pd(x1, x2, null, cdr(pds!1))" "car(pds!1)`2 * x1") (("2" (replaces -1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2 * x1), null)") (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car(pds!1)`1, N!1) * (car(pds!1)`2 * x1) +
                              x1 * eval_pd_noise(cdr(pds!1), N!1) = x1 * (get_noise_by_idx(car(pds!1)`1, N!1) * car(pds!1)`2  +
                              eval_pd_noise(cdr(pds!1), N!1))") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (lemma "eval_pd_noise_append") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)" "cdr_ol(pds!1)") (("1" (split -1) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "append_ol") (("1" (expand "append") (("1" (expand "append") (("1" (case "cons((car(pds!1)`1, car(pds!1)`2), cdr(pds!1)) = pds!1") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (use "list_cons_eta[[nat,nzBaseType]]") (("2" (replaces -1 :dir RL) (("2" (assert) (("2" (case "(car(pds!1)`1, car(pds!1)`2) = car(pds!1)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "lt_idx") (("2" (expand "last_ol") (("2" (typepred "pds!1") (("2" (hide-all-but (2 -1 5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (flatten) (("1" (lemma "mult_pd_pd_preserves_order_2") (("1" (inst -1 "x1" "x2" "pds!1") (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "pds!1") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mult_pd_pd_preserves_order_2 formula-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (list_cons_eta formula-decl nil list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (eval_pd_noise_append formula-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pds!1 skolem-const-decl "ErrorTerms" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (epn_aET__nnull_pds formula-decl nil affine nil) (car_ol const-decl "T" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (eval_pd_noise def-decl "real" affine nil) (BaseType type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (epn_mpp_null_pds1-1 nil 3621345925 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("1" (generalize "L" "L") (("1" (induct "L" :name "NAT_induction") (("1" (skeep) (("1" (skeep) (("1" (expand "mult_pd_pd" 1) (("1" (expand "null_ol") (("1" (expand "null_ol?") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (case-replace "pds!1=null") (("1" (hide -3) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (lemma "epn_aET__nnull_pds") (("2" (inst -1 "N!1" "car(pds!1)`1" "mult_pd_pd(x1, x2, null, cdr(pds!1))" "car(pds!1)`2 * x1") (("2" (replaces -1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2 * x1), null)") (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car(pds!1)`1, N!1) * (car(pds!1)`2 * x1) +
                              x1 * eval_pd_noise(cdr(pds!1), N!1) = x1 * (get_noise_by_idx(car(pds!1)`1, N!1) * car(pds!1)`2  +
                              eval_pd_noise(cdr(pds!1), N!1))") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (replaces -1 :dir RL) (("1" (lemma "eval_pd_noise_append") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)" "cdr_ol(pds!1)") (("1" (split -1) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "append_ol") (("1" (expand "append") (("1" (expand "append") (("1" (case "cons((car(pds!1)`1, car(pds!1)`2), cdr(pds!1)) = pds!1") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (use "list_cons_eta[[nat,nzBaseType]]") (("2" (replaces -1 :dir RL) (("2" (assert) (("2" (case "(car(pds!1)`1, car(pds!1)`2) = car(pds!1)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "lt_idx") (("2" (expand "last_ol") (("2" (typepred "pds!1") (("2" (hide-all-but (2 -1 5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (flatten) (("1" (lemma "mult_pd_pd_preserves_order_2") (("1" (inst -1 "x1" "x2" "pds!1") (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "pds!1") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) shostak)) (epn_mpp_null_pds2 0 (epn_mpp_null_pds2-2 "" 3789916528 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (expand "mult_pd_pd" 1) (("" (expand "null_ol") (("" (expand "null_ol?") (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (case-replace "pds!1=null") (("1" (hide -3) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (lemma "epn_aET__nnull_pds") (("2" (inst -1 "N!1" "car(pds!1)`1" "mult_pd_pd(x1, x2,cdr(pds!1),null)" "car(pds!1)`2 * x2") (("2" (replaces -1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2 * x2), null)") (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car(pds!1)`1, N!1) * (car(pds!1)`2 * x2) +
                                                                            x2 * eval_pd_noise(cdr(pds!1), N!1) = x2 * (get_noise_by_idx(car(pds!1)`1, N!1) * car(pds!1)`2  +
                                                                            eval_pd_noise(cdr(pds!1), N!1))") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (lemma "eval_pd_noise_append") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)" "cdr_ol(pds!1)") (("1" (split -1) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "append_ol") (("1" (expand "append") (("1" (expand "append") (("1" (case "cons((car(pds!1)`1, car(pds!1)`2), cdr(pds!1)) = pds!1") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (use "list_cons_eta[[nat,nzBaseType]]") (("2" (replaces -1 :dir RL) (("2" (assert) (("2" (case "(car(pds!1)`1, car(pds!1)`2) = car(pds!1)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "lt_idx") (("2" (expand "last_ol") (("2" (typepred "pds!1") (("2" (hide-all-but (2 -1 5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (flatten) (("1" (lemma "mult_pd_pd_preserves_order_1") (("1" (inst -1 "x1" "x2" "pds!1") (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "pds!1") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mult_pd_pd_preserves_order_1 formula-decl nil affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (list_cons_eta formula-decl nil list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (eval_pd_noise_append formula-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pds!1 skolem-const-decl "ErrorTerms" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (epn_aET__nnull_pds formula-decl nil affine nil) (car_ol const-decl "T" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (eval_pd_noise def-decl "real" affine nil) (BaseType type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (epn_mpp_null_pds2-1 nil 3621359750 ("" (skeep) (("" (name "L" "length(pds)+length(N)") (("" (generalize "N" "N") (("" (generalize "pds" "pds") (("1" (generalize "L" "L") (("1" (induct "L" :name "NAT_induction") (("1" (skeep) (("1" (skeep) (("1" (expand "mult_pd_pd" 1) (("1" (expand "null_ol") (("1" (expand "null_ol?") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (case-replace "pds!1=null") (("1" (hide -3) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (lemma "epn_aET__nnull_pds") (("2" (inst -1 "N!1" "car(pds!1)`1" "mult_pd_pd(x1, x2,cdr(pds!1),null)" "car(pds!1)`2 * x2") (("2" (replaces -1) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "empty_ErrorTerms") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2 * x2), null)") (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (replaces -1) (("1" (case "get_noise_by_idx(car(pds!1)`1, N!1) * (car(pds!1)`2 * x2) +
                                                                            x2 * eval_pd_noise(cdr(pds!1), N!1) = x2 * (get_noise_by_idx(car(pds!1)`1, N!1) * car(pds!1)`2  +
                                                                            eval_pd_noise(cdr(pds!1), N!1))") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)") (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (replaces -1 :dir RL) (("1" (lemma "eval_pd_noise_append") (("1" (inst -1 "N!1" "cons_ol((car(pds!1)`1, car(pds!1)`2), null)" "cdr_ol(pds!1)") (("1" (split -1) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "append_ol") (("1" (expand "append") (("1" (expand "append") (("1" (case "cons((car(pds!1)`1, car(pds!1)`2), cdr(pds!1)) = pds!1") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (use "list_cons_eta[[nat,nzBaseType]]") (("2" (replaces -1 :dir RL) (("2" (assert) (("2" (case "(car(pds!1)`1, car(pds!1)`2) = car(pds!1)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "lt_idx") (("2" (expand "last_ol") (("2" (typepred "pds!1") (("2" (hide-all-but (2 -1 5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -2 4)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (flatten) (("1" (lemma "mult_pd_pd_preserves_order_1") (("1" (inst -1 "x1" "x2" "pds!1") (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds!1)" "N!1") (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N!1" "pds!1") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures)) nil)) (epn_over_last_is_zero_TCC1 0 (epn_over_last_is_zero_TCC1-1 nil 3621707863 ("" (subtype-tcc) nil nil) ((empty_noise const-decl "Noise" affine nil) (lt_idx const-decl "bool" indexed_list structures)) nil (epn_over_last_is_zero subtype "affine.empty_noise" "{ol | booleans.OR(list_adt[[nat, nzEpsilon]].null?(ol), indexed_list[nzEpsilon].lt_idx((affine.n, affine.nze), list_adt[[nat, nzEpsilon]].car(ol)))}"))) (epn_over_last_is_zero 0 (epn_over_last_is_zero-1 nil 3621707863 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (skeep) (("2" (expand "eval_pd_noise" 1) (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (expand "car_ol") (("2" (expand "cdr_ol") (("2" (expand "last_idx") (("2" (expand "last_ol" -2) (("2" (lift-if) (("2" (split -2) (("1" (flatten) (("1" (assert) (("1" (inst?) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "x`1 < n") (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (typepred "x::[nat,nzBaseType]") (("2" (grind) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ((car_ol const-decl "T" ordered_list structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (olidx_car_last formula-decl nil indexed_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_ol def-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise def-decl "real" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (last_idx const-decl "int" indexed_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Noise type-eq-decl nil affine nil) (empty_noise const-decl "Noise" affine nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak)) (epn_up_to_last_idx_pd_is_zero_TCC1 0 (epn_up_to_last_idx_pd_is_zero_TCC1-1 nil 3621710151 ("" (grind) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (last_idx const-decl "int" indexed_list structures)) nil (epn_up_to_last_idx_pd_is_zero subtype "(number_fields.+)(1, indexed_list[nzBaseType].last_idx(affine.pds))" "nat"))) (epn_up_to_last_idx_pd_is_zero 0 (epn_up_to_last_idx_pd_is_zero-1 nil 3621710151 ("" (induct "pds" :name "ol_ind_sch[[nat,nzBaseType],lt_idx[nzBaseType]]") (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil) ("2" (skeep*) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (inst -1 "first_noises(N, 1 + last_idx(cons(x, ol)))" "cons(x, ol)") (("1" (replaces -1) (("1" (assert) (("1" (expand "cdr_ol") (("1" (case "null_ol?(ol)") (("1" (assert) (("1" (expand "eval_pd_noise" 2 1) (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" 2 1) (("1" (hide -2) (("1" (grind) (("1" (lemma "gnbi_lt_first_idem") (("1" (inst -1 "N" "1+x`1" "x`1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "last_idx(ol) = last_idx(cons(x, ol))") (("1" (replaces -1 :dir RL) (("1" (expand "car_ol") (("1" (inst -1 "N") (("1" (replaces -1) (("1" (assert) (("1" (typepred "x::[nat,nzBaseType]") (("1" (use "gnbi_lt_first_idem") (("1" (assert) (("1" (expand "ordered_list?") (("1" (expand "null_ol?") (("1" (assert) (("1" (expand "lt_idx") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last_idx" 1 2) (("2" (hide-all-but (1 2 3)) (("2" (expand "last_idx") (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (expand "last_ol" 2 2) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ((TRUE const-decl "bool" booleans nil) (x skolem-const-decl "{x: [nat, nzBaseType] | ordered_list?(cons(x, ol))}" affine nil) (ol skolem-const-decl "ordered_list[[nat, nzBaseType], lt_idx[nzBaseType]]" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (last_ol def-decl "T" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gnbi_lt_first_idem formula-decl nil affine nil) (car_ol const-decl "T" ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ol_ind_sch formula-decl nil ordered_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (first_noises const-decl "Noise" affine nil) (eval_pd_noise def-decl "real" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (ordered_list type-eq-decl nil ordered_list structures) (last_idx const-decl "int" indexed_list structures) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (epn_trim_noise 0 (epn_trim_noise-1 nil 3621769055 ("" (induct "n") (("1" (skeep) (("1" (expand "last_idx") (("1" (lift-if) (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (typepred "last_ol(pds)`1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (inst? -1 :where 1) (("2" (replaces -1) (("2" (expand_ol) (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (replaces -1) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (case "last_idx(pds) < j") (("1" (inst -2 "N" "pds") (("1" (assert) (("1" (hide -3) (("1" (use "first_noises_recursive_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_noise_append") (("1" (split -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (assert) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_pd_noise") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (flatten) (("2" (use "epn_over_last_is_zero") (("1" (assert) nil nil) ("2" (expand "/=") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (lift-if) (("2" (expand "empty_noise") (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (expand "lt_idx") (("2" (expand "first_ol") (("2" (expand "cons_ol") (("2" (use "last_up_to_idx[nzEpsilon]") (("2" (expand "first_noises") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil) ("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "last_idx(pds) = j") (("1" (hide -2) (("1" (hide-all-but (-1 2)) (("1" (replaces -1 :dir RL) (("1" (use "epn_up_to_last_idx_pd_is_zero") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (first_noises_recursive_def formula-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (eval_pd_noise_noise_append formula-decl nil affine nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (empty_noise const-decl "Noise" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (N skolem-const-decl "Noise" affine nil) (j skolem-const-decl "nat" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (last_up_to_idx formula-decl nil indexed_list structures) (first_ol const-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (epn_over_last_is_zero formula-decl nil affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (epn_up_to_last_idx_pd_is_zero formula-decl nil affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last_ol def-decl "T" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (nat_induction formula-decl nil naturalnumbers nil) (first_noises const-decl "Noise" affine nil) (eval_pd_noise def-decl "real" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (last_idx const-decl "int" indexed_list structures) (ordered_list type-eq-decl nil ordered_list structures) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ErrorTerms type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (epn_mult_first 0 (epn_mult_first-1 nil 3621713355 ("" (skolem 1 ("_" "_" "pds1_" "pds2_" "_" "_")) (("" (name "L" "length(pds1_) + length(pds2_)") (("" (generalize "pds1_" "pds1") (("" (generalize "pds2_" "pds2") (("" (generalize "L" "L") (("" (induct "L" :name "NAT_induction") (("" (skeep) (("" (skeep) (("" (skeep) (("" (expand "mult_pd_pd" 1 1) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 1) (("1" (assert) (("1" (expand "null_ol") (("1" (hide -3) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (hide-all-but (3 2 -5)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 1) (("1" (assert) (("1" (expand "add_ET") (("1" (hide -3) (("1" (use "epn_trim_noise") (("1" (assert) (("1" (expand "last_idx" 1) (("1" (expand "cons_ol") (("1" (expand "last_ol") (("1" (expand "empty_ErrorTerms") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (hide-all-but (1 -6 4 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (replaces -1) (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (lemma "eval_pd_noise_rec_pds_def") (("1" (inst -1 "N" "cons_ol((car(pds2)`1, car(pds2)`2 * x1),
                           mult_pd_pd(x1, x2, pds1, cdr(pds2)))") (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (replaces -1) (("1" (assert) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (expand "cdr_ol") (("1" (split -3) (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (assert) nil nil) ("2" (hide-all-but (1 -5 5)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -5 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "lt_idx") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "/=") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mult_pd_pd" 2 2) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (inst -2 "N" "n" "x1" "x2") (("1" (assert) (("1" (hide-all-but (6 -4 5)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (split -3) (("1" (expand "mult_pd_pd" 1 2) (("1" (expand "add_ET") (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "empty_ErrorTerms") (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_pd_noise") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -5 4)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (split -3) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -4 5)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mult_pd_pd" 2 2) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -2 "N" "n" "x1" "x2") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (split -3) (("1" (replaces -1) (("1" (expand "mult_pd_pd" 1 2) (("1" (expand "add_ET") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1) (("1" (assert) (("1" (expand "add_ET") (("1" (hide -3) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -4 5)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (inst -3 "j-2") (("1" (assert) (("1" (inst -3 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (split -3) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -4 6)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mult_pd_pd" 2 2) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-2") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -2 "N" "n" "x1" "x2") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 1) (("1" (assert) (("1" (expand "add_ET") (("1" (hide -3) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "cons_ol") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -4 6)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -3 "j-1") (("1" (assert) (("1" (inst -3 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -3 "N" "n" "x1" "x2") (("1" (assert) (("1" (split -3) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_lt_first_idem") (("1" (grind) (("1" (hide-all-but (1 -4 7)) (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mult_pd_pd" 2 2) (("2" (assert) (("2" (expand "add_ET") (("2" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "pds2" "cdr_ol(pds1)") (("1" (assert) (("1" (inst -2 "N" "n" "x1" "x2") (("1" (assert) (("1" (hide-all-but (8 7 -3)) (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (inst -2 "N" "n" "x1" "x2") (("1" (assert) (("1" (hide-all-but (6 -4 4)) (("1" (use "olidx_car_last[nzBaseType]") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -2) (("1" (expand "mult_pd_pd" 1) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "empty_ErrorTerms") (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -4 6)) (("2" (grind) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "mult_pd_pd" 1 2) (("1" (assert) (("1" (expand "add_ET") (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (replaces -1) (("1" (expand "null_ol?") (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (inst -2 "j-1") (("1" (assert) (("1" (inst -2 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (inst -2 "N" "n" "x1" "x2") (("1" (assert) (("1" (split -2) (("1" (expand "cdr_ol") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_lt_first_idem") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide-all-but (1 -4 6)) (("2" (use "olidx_car_last[nzBaseType]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -4 7)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "j-1") (("1" (assert) (("1" (inst -1 "cdr_ol(pds2)" "pds1") (("1" (assert) (("1" (inst -1 "N" "n" "x1" "x2") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (expand "mult_pd_pd" 2 2) (("1" (expand "add_ET") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (null_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (add_ET const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_cdr_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (j skolem-const-decl "nat" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (epn_trim_noise formula-decl nil affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons_ol const-decl "ordered_list" ordered_list structures) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (pds2 skolem-const-decl "ErrorTerms" affine nil) (x1 skolem-const-decl "BaseType" affine nil) (x2 skolem-const-decl "BaseType" affine nil) (pds1 skolem-const-decl "ErrorTerms" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_plus_real_is_real application-judgement "real" reals nil) (gnbi_lt_first_idem formula-decl nil affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (last_idx const-decl "int" indexed_list structures) (eval_pd_noise def-decl "real" affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (first_noises const-decl "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (mpp_first_N 0 (mpp_first_N-1 nil 3621704720 ("" (skeep) (("" (expand "mul_noise_value") (("" (lift-if) (("" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand ">=") (("2" (expand "next_idx_2") (("2" (expand "next_idx") (("2" (case "last_idx(pd(Xa1))< n AND last_idx(pd(Xa2)) < n") (("1" (hide -2) (("1" (flatten) (("1" (case "eval_ac_noise(Xa1, first_noises(N, n)) = eval_ac_noise(Xa1, N)") (("1" (replaces -1) (("1" (case "eval_ac_noise(Xa2, first_noises(N, n)) = eval_ac_noise(Xa2, N)") (("1" (replaces -1) (("1" (assert) (("1" (case "eval_pd_noise(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)),
                                                   first_noises(N, n)) = eval_pd_noise(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)),
                                                   N)") (("1" (replaces -1) nil nil) ("2" (hide-all-but (- 1)) (("2" (use "epn_mult_first") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "eval_ac_noise") (("2" (use "epn_trim_noise") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "eval_ac_noise") (("2" (use "epn_trim_noise") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (mul_noise_value const-decl "real" affine nil) (>= const-decl "bool" reals nil) (next_idx const-decl "nat" affine nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (first_noises const-decl "Noise" affine nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (epn_mult_first formula-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (eval_pd_noise def-decl "real" affine nil) (epn_trim_noise formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (last_idx const-decl "int" indexed_list structures) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (next_idx_2 const-decl "nat" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (containment_mul 0 (containment_mul-4 "" 3743881257 ("" (skeep) (("" (expand "mult_ac_ac" 1) (("" (expand "eval_ac_noise" 1) (("" (assert) (("" (rewrites "eval_pd_noise_append") (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (case "sum_of_modules(pd(Xa1)) = 0 OR
                                                        sum_of_modules(pd(Xa2)) = 0") (("1" (hide -2) (("1" (prop) (("1" (use "som_zero") (("1" (assert) (("1" (lemma "epn_mpp_null_pds1") (("1" (inst -1 "N" "pd(Xa2)" "cv(Xa1)" "cv(Xa2)") (("1" (case "pd(Xa1)=null") (("1" (replace -1 + :hide? t) (("1" (replaces -1) (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "eval_pd_noise" 1 1) (("1" (expand "eval_ac_noise") (("1" (replaces -4 :dir RL) (("1" (replaces -4 :dir RL) (("1" (reveal -4) (("1" (replace -1 + :hide? t) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "som_zero") (("2" (assert) (("2" (lemma "epn_mpp_null_pds2") (("2" (inst -1 "N" "pd(Xa1)" "cv(Xa1)" "cv(Xa2)") (("2" (case "pd(Xa2)=null") (("1" (replace -1 + :hide? t) (("1" (replaces -1) (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "eval_pd_noise" 1 1) (("1" (expand "eval_ac_noise") (("1" (replaces -4 :dir RL) (("1" (replaces -4 :dir RL) (("1" (reveal -4) (("1" (replace -1 + :hide? t) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "empty_ErrorTerms") (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (case "eval_pd_noise(cons((n,
                                              sum_of_modules(pd(Xa1)) *
                                               sum_of_modules(pd(Xa2))),
                                             null),
                           N) = mul_noise_value(Xa1, Xa2, N) * sum_of_modules(pd(Xa1)) *
                                        sum_of_modules(pd(Xa2))") (("1" (replaces -1) (("1" (hide -4) (("1" (expand "mul_noise_value") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (assert) (("1" (replaces -1) (("1" (lemma "mpp_first_N") (("1" (inst -1 "N" "Xa1" "Xa2" "n") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "/=") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "first_ol") (("2" (expand "lt_idx") (("2" (use "mult_pd_pd_last_bound") (("2" (assert) (("2" (expand "null_ol?") (("2" (case "NOT null?[[nat, nzBaseType]](pd(Xa1)) AND
                                                   NOT null?[[nat, nzBaseType]](pd(Xa2))") (("1" (flatten) (("1" (assert) (("1" (expand "next_idx_2") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (hide-all-but (-1 -2 5)) (("1" (name-replace "stopRW" "last_ol(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)))`1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mult_ac_ac const-decl "AffineCombination" affine nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (mult_pd_pd_last_bound formula-decl nil affine nil) (last_ol def-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (appendable_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (eval_pd_noise def-decl "real" affine nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (mul_noise_value const-decl "real" affine nil) (first_noises const-decl "Noise" affine nil) (next_idx_2 const-decl "nat" affine nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (epn_mpp_null_pds1 formula-decl nil affine nil) (som_zero formula-decl nil affine nil) (epn_mpp_null_pds2 formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (mpp_first_N formula-decl nil affine nil) (Xa1 skolem-const-decl "AffineCombination" affine nil) (Xa2 skolem-const-decl "AffineCombination" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (TRUE const-decl "bool" booleans nil) (eval_pd_noise_append formula-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (AffineCombination type-eq-decl nil affine nil) (add_ET const-decl "ErrorTerms" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sum_of_modules def-decl "BaseType" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (eval_ac_noise const-decl "real" affine nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak) (containment_mul-3 "" 3621347197 ("" (skeep) (("" (expand "mult_ac_ac" 1) (("" (expand "eval_ac_noise" 1) (("" (assert) (("" (rewrites "eval_pd_noise_append") (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (case "sum_of_modules(pd(Xa1)) = 0 OR
                                             sum_of_modules(pd(Xa2)) = 0") (("1" (hide -2) (("1" (prop) (("1" (use "som_zero") (("1" (assert) (("1" (lemma "epn_mpp_null_pds1") (("1" (inst -1 "N" "pd(Xa2)" "cv(Xa1)" "cv(Xa2)") (("1" (case "pd(Xa1)=null") (("1" (replace -1 + :hide? t) (("1" (replaces -1) (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "eval_pd_noise" 1 1) (("1" (expand "eval_ac_noise") (("1" (replaces -4 :dir RL) (("1" (replaces -4 :dir RL) (("1" (reveal -4) (("1" (replace -1 + :hide? t) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "som_zero") (("2" (assert) (("2" (lemma "epn_mpp_null_pds2") (("2" (inst -1 "N" "pd(Xa1)" "cv(Xa1)" "cv(Xa2)") (("2" (case "pd(Xa2)=null") (("1" (replace -1 + :hide? t) (("1" (replaces -1) (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "eval_pd_noise" 1 1) (("1" (expand "eval_ac_noise") (("1" (replaces -4 :dir RL) (("1" (replaces -4 :dir RL) (("1" (reveal -4) (("1" (replace -1 + :hide? t) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "empty_ErrorTerms") (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (case "eval_pd_noise(cons((n,
                                   sum_of_modules(pd(Xa1)) *
                                    sum_of_modules(pd(Xa2))),
                                  null),
                N) = mul_noise_value(Xa1, Xa2, N) * sum_of_modules(pd(Xa1)) *
                             sum_of_modules(pd(Xa2))") (("1" (replaces -1) (("1" (hide -4) (("1" (expand "mul_noise_value") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (assert) (("1" (assert) (("1" (replaces -1) (("1" (lemma "mpp_first_N") (("1" (inst -1 "N" "Xa1" "Xa2" "n") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "every") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (expand "/=") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "first_ol") (("2" (expand "lt_idx") (("2" (use "mult_pd_pd_last_bound") (("2" (assert) (("2" (expand "null_ol?") (("2" (case "NOT null?[[nat, nzBaseType]](pd(Xa1)) AND
                                        NOT null?[[nat, nzBaseType]](pd(Xa2))") (("1" (flatten) (("1" (assert) (("1" (expand "next_idx_2") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (hide-all-but (-1 -2 5)) (("1" (name-replace "stopRW" "last_ol(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)))`1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_ol def-decl "T" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak) (containment_mul-2 "" 3621267667 ("" (skeep) (("" (expand "mult_ac_ac" 1) (("" (expand "eval_ac_noise" 1) (("" (assert) (("" (rewrites "eval_pd_noise_append") (("1" (expand "add_ET") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (case "sum_of_modules(pd(Xa1)) = 0 OR
 sum_of_modules(pd(Xa2)) = 0") (("1" (hide -2) (("1" (prop) (("1" (use "som_zero") (("1" (assert) (("1" (lemma "epn_mpp_null_pds1") (("1" (inst -1 "N" "pd(Xa2)" "cv(Xa1)" "cv(Xa2)") (("1" (case "pd(Xa1)=null") (("1" (replace -1 + :hide? t) (("1" (replaces -1) (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "eval_pd_noise" 1 1) (("1" (expand "eval_ac_noise") (("1" (replaces -4 :dir RL) (("1" (replaces -4 :dir RL) (("1" (reveal -4) (("1" (replace -1 + :hide? t) (("1" (expand "eval_pd_noise") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "som_zero") (("2" (assert) (("2" (lemma "epn_mpp_null_pds2") (("2" (inst -1 "N" "pd(Xa1)" "cv(Xa1)" "cv(Xa2)") (("2" (case "pd(Xa2)=null") (("1" (replace -1 + :hide? t) (("1" (replaces -1) (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (expand "eval_pd_noise" 1 1) (("1" (expand "eval_ac_noise") (("1" (replaces -4 :dir RL) (("1" (replaces -4 :dir RL) (("1" (reveal -4) (("1" (replace -1 + :hide? t) (("1" (expand "eval_pd_noise") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "empty_ErrorTerms") (("2" (expand "null_ol?") (("2" (expand "cons_ol") (("2" (case "eval_pd_noise(cons((n,
                                  sum_of_modules(pd(Xa1)) *
                                   sum_of_modules(pd(Xa2))),
                                 null),
                            N) = mul_noise_value(Xa1, Xa2, N) * sum_of_modules(pd(Xa1)) *
                                   sum_of_modules(pd(Xa2))") (("1" (replaces -1) (("1" (hide -4) (("1" (expand "mul_noise_value") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand "null_ol?") (("1" (expand "cdr_ol") (("1" (expand "car_ol") (("1" (expand "eval_pd_noise" -1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "add_ET") (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (expand "null_ol?") (("2" (expand "empty_ErrorTerms") (("2" (expand "cons_ol") (("2" (expand "appendable_ol?") (("2" (flatten) (("2" (expand "first_ol") (("2" (expand "lt_idx") (("2" (use "mult_pd_pd_last_bound") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((appendable_ol? const-decl "bool" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures)) shostak) (containment_mul-1 nil 3619979990 ("" (skeep) (("" (expand "mult_ac_ac" 1) (("" (expand "eval_ac_noise" 1) (("" (assert) (("" (rewrites "eval_pd_noise_append") (("" (case "eval_pd_noise(cons((n,
                           sum_of_modules(pd(Xa1)) *
                            sum_of_modules(pd(Xa2))),
                          null),
                     N) = mul_noise_value(x1, x2, Xa1, Xa2, N) * sum_of_modules(pd(Xa1)) *
                            sum_of_modules(pd(Xa2))") (("1" (replaces -1) (("1" (hide -3) (("1" (expand "mul_noise_value") (("1" (lift-if) (("1" (prop) (("1" (comment "usar que si som_som es cero, todos los Xa1_i Xa2_i son cero") (("1" (postpone) nil ";;; usar que si som_som es cero, todos los Xa1_i Xa2_i son cero")) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (next_idx_mult_ac_ac_TCC1 0 (next_idx_mult_ac_ac_TCC1-1 nil 3628272610 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (upfrom nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (next_idx const-decl "nat" affine nil) (next_idx_2 const-decl "nat" affine nil)) nil (next_idx_mult_ac_ac subtype "affine.n" "{newidx: naturalnumbers.nat | reals.>=(newidx, affine.next_idx_2(pd(affine.Xa1), pd(affine.Xa2)))}"))) (next_idx_mult_ac_ac 0 (next_idx_mult_ac_ac-1 nil 3629025760 ("" (skeep) (("" (expand "mult_ac_ac") (("" (assert) (("" (case "next_idx(append_ol(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)),
                         add_ET(n, sum_of_modules(pd(Xa1)) * sum_of_modules(pd(Xa2)),
                                empty_ErrorTerms))) = max(next_idx(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2))), next_idx(add_ET(n, sum_of_modules(pd(Xa1)) * sum_of_modules(pd(Xa2)),
                                empty_ErrorTerms)))") (("1" (replaces -1) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pd(Xa1) = empty_ErrorTerms") (("1" (case "pd(Xa2) = empty_ErrorTerms") (("1" (grind) nil nil) ("2" (replace -1) (("2" (use "mult_pd_pd_last_bound__null_nnull") (("2" (split -1) (("1" (typepred "n") (("1" (expand ">=") (("1" (expand "next_idx_2") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand "empty_ErrorTerms") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "null_ol?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "pd(Xa2) = empty_ErrorTerms") (("1" (replace -1) (("1" (use "mult_pd_pd_last_bound__nnull_null") (("1" (split -1) (("1" (typepred "n") (("1" (expand ">=") (("1" (expand "next_idx_2") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand_ol) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand_ol) (("2" (assert) nil nil)) nil) ("3" (expand_ol) nil nil)) nil)) nil)) nil) ("2" (use "mult_pd_pd_last_bound") (("2" (expand_ol) (("2" (assert) (("2" (typepred "n") (("2" (expand ">=") (("2" (expand "next_idx_2") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (case "max(last_ol(Xa1`pd)`1, last_ol(Xa2`pd)`1) <= n-1") (("1" (hide -2) (("1" (name-replace "A" "last_ol(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)))`1") (("1" (name-replace "B" "max(last_ol(Xa1`pd)`1, last_ol(Xa2`pd)`1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_idx_append") (("2" (expand "next_idx") (("2" (hide 2) (("2" (name-replace "A" "last_idx(append_ol(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)),
                          add_ET(n, sum_of_modules(pd(Xa1)) * sum_of_modules(pd(Xa2)),
                                 empty_ErrorTerms)))") (("2" (name-replace "B" "last_idx(mult_pd_pd(cv(Xa1), cv(Xa2), pd(Xa1), pd(Xa2)))") (("2" (name-replace "C" "last_idx(add_ET(n, sum_of_modules(pd(Xa1)) * sum_of_modules(pd(Xa2)),
                           empty_ErrorTerms))") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mult_ac_ac const-decl "AffineCombination" affine nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (sum_of_modules def-decl "BaseType" affine nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (next_idx_2 const-decl "nat" affine nil) (add_ET const-decl "ErrorTerms" affine nil) (AffineCombination type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (BaseType type-eq-decl nil affine nil) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (next_idx const-decl "nat" affine nil) (ErrorTerms type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (mult_pd_pd_last_bound__null_nnull formula-decl nil affine nil) (null_ol const-decl "ordered_list" ordered_list structures) (mult_pd_pd_last_bound formula-decl nil affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (<= const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (mult_pd_pd_last_bound__nnull_null formula-decl nil affine nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (TRUE const-decl "bool" booleans nil) (last_idx_append formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (idxs_ac_mult_ac_ac 0 (idxs_ac_mult_ac_ac-1 nil 3628937568 ("" (skeep) (("" (expand "mult_ac_ac") (("" (expand "idxs_ac") (("" (assert) (("" (use "idxs_pd_append") (("" (replaces -1) (("" (use "member_append_fi[nat]") (("" (assert) (("" (hide -2) (("" (split -1) (("1" (name "L" "length(pd(Xa1))+length(pd(Xa2))") (("1" (name-replace "pds1_" "pd(Xa1)") (("1" (name-replace "pds2_" "pd(Xa2)") (("1" (generalize "cv(Xa1)" "cv1") (("1" (generalize "cv(Xa2)" "cv2") (("1" (generalize "pds1_" "pds1") (("1" (generalize "pds2_" "pds2") (("1" (generalize "L" "L") (("1" (induct "L" :name "NAT_induction") (("1" (deftactic applyih (num pdsn ih-fnum hyp-fnum len-fnum mbr-fnum nnl-fnum) (spread (inst ih-fnum num) ((then (assert) (inst? ih-fnum :where hyp-fnum) (expand "length" len-fnum pdsn) (assert) (hide-all-but (list nnl-fnum mbr-fnum ih-fnum)) (grind)) (then (let ((new-len (+ len-fnum 1)) (new-nnl (if (listp nnl-fnum) (mapcar (lambda (n) (+ n 1)) nnl-fnum) (+ nnl-fnum 1)))) (then (hide-all-but (list new-len 1 new-nnl)) (grind))))))) (("1" (skeep) (("1" (skeep) (("1" (expand "mult_pd_pd" -3) (("1" (expand_ol) (("1" (lift-if -3) (("1" (split -3) (("1" (flatten) (("1" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "add_ET") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (applyih "j-1" 2 -4 -2 -5 3 1) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand_ol) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (expand_ol) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (applyih "j-1" 2 -4 -1 -5 5 3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (applyih "j-1" 2 -3 -1 -4 6 4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (applyih "j-1" 1 -4 -2 -5 2 1) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (applyih "j-1" 1 -4 -1 -5 4 3) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (applyih "j-1" 1 -3 -1 -4 5 4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET") (("1" (expand_ol) (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (applyih "j-2" (1 2) -4 -2 -5 (3 4) (1 2)) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (applyih "j-2" (1 2) -4 -1 -5 (5 6) (3 4)) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (applyih "j-2" (1 2) -3 -1 -4 (6 7) (4 5)) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "add_ET") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (applyih "j-1" 1 -4 -2 -5 4 3) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (applyih "j-1" 1 -4 -1 -5 6 5) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (applyih "j-1" 1 -3 -1 -4 7 6) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "add_ET") (("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (applyih "j-1" 2 -3 -2 -4 6 3) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (expand "idxs_pd" -2) (("1" (expand_ol) (("1" (expand "member" -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (applyih "j-1" 2 -3 -1 -4 8 5) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (applyih "j-1" 2 -2 -1 -3 9 6) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "add_ET") (("2" (lift-if -1) (("2" (deftactic expand_ols nil (expand* "null_ol?" "car_ol" "cdr_ol" "cons_ol" "empty_ErrorTerms")) (("2" (expand_ols) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mult_ac_ac const-decl "AffineCombination" affine nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (sum_of_modules_nnreal expr-judgement "nonneg_real" affine nil) (ac_proj_pd formula-decl nil affine nil) (TRUE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" affine nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (NAT_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (idxs_pd def-decl "list[nat]" affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (member_append_fi formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (mult_pd_pd def-decl "ErrorTerms" affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (next_idx_2 const-decl "nat" affine nil) (upfrom nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sum_of_modules def-decl "BaseType" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (idxs_pd_append formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil)) shostak)) (null_ol?_empty_noise 0 (null_ol?_empty_noise-1 nil 3621852500 ("" (grind) nil nil) ((empty_noise const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (var_ac_noise_unf3_TCC1 0 (var_ac_noise_unf3_TCC1-2 "" 3789916558 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak (var_ac_noise_unf3 subtype "affine.empty_noise" "{N | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), reals.<(affine.m, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1))}")) (var_ac_noise_unf3_TCC1-1 nil 3621688552 ("" (tcc)) ((null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures)) nil (var_ac_noise_unf3 subtype "affine.empty_noise" "{N | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), reals.<(affine.m, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1))}"))) (var_ac_noise_unf3 0 (var_ac_noise_unf3-1 nil 3621691473 ("" (skeep) (("" (split -2) (("1" (flatten) (("1" (case "null_ol?(N)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (grind) nil nil) ("2" (grind) (("2" (expand "eval_pd_noise") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (eval_pd_noise def-decl "real" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (eval_ac_noise const-decl "real" affine nil) (extend_N const-decl "Noise" affine nil) (add_N const-decl "Noise" affine nil) (empty_noise const-decl "Noise" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_extend_N_unf 0 (gnbi_extend_N_unf-1 nil 3621689436 ("" (skeep) (("" (split -2) (("1" (flatten) (("1" (replaces -1) (("1" (case "null_ol?(N)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (case "e=e2") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (empty_noise const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_N const-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (car_ol const-decl "T" ordered_list structures) (get_noise_by_idx def-decl "Epsilon" affine nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (cdr_Noise_jdg application-judgement "Noise" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (gnbi_extend_N_trivial 0 (gnbi_extend_N_trivial-1 nil 3621790164 ("" (skeep) (("" (grind) nil nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (add_N const-decl "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (car_ol const-decl "T" ordered_list structures)) shostak)) (first__extend_N_TCC1 0 (first__extend_N_TCC1-2 "" 3789916562 ("" (skeep) (("" (split -1) (("1" (hide-all-but (-1 2)) (("1" (expand_ol) (("1" (expand "first_noises") (("1" (expand "first") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "car_up_to_idx[nzEpsilon]") (("2" (inst?) (("2" (inst -1 "n") (("2" (assert) (("2" (expand "null_ol?") (("2" (assert) (("2" (expand "first_noises") (("2" (assert) (("2" (expand "first") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (first_noises const-decl "Noise" affine nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Noise type-eq-decl nil affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (car_up_to_idx formula-decl nil indexed_list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak (first__extend_N subtype "affine.first_noises(affine.N, affine.n)" "{N | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), reals.<(affine.m, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1))}")) (first__extend_N_TCC1-1 nil 3621698687 ("" (skeep) (("" (split -1) (("1" (hide-all-but (-1 2)) (("1" (expand_ol) (("1" (expand "first_noises") (("1" (expand "first") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "car_up_to_idx[nzEpsilon]") (("2" (inst?) (("2" (inst -1 "n") (("2" (assert) (("2" (expand "null_ol?") (("2" (assert) (("2" (expand "first_noises") (("2" (assert) (("2" (expand "first") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (first def-decl "(prefixes(l))" indexed_list structures) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (car_up_to_idx formula-decl nil indexed_list structures)) nil (first__extend_N subtype "affine.first_noises(affine.N, affine.n)" "{N | booleans.OR(ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].null_ol?(affine.N), reals.<(affine.m, ordered_list[[nat, nzEpsilon], indexed_list[nzEpsilon].lt_idx].car_ol(affine.N)`1))}"))) (first__extend_N 0 (first__extend_N-1 nil 3621792407 ("" (skeep) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (expand "extend_N") (("1" (expand "add_N") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (case "null_ol?(N)") (("1" (assert) (("1" (expand "first_noises") (("1" (expand "first") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand_ol) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "first_noises" :assert? none) (("2" (expand "first" :assert? none) (("2" (lift-if 2) (("2" (split 2) (("1" (expand_ol) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but (-1 -4 -3)) (("1" (expand "car_ol") (("1" (abstract-and-then -1 1 (assert)) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "first_noises" :assert? none) (("1" (expand "first" :assert? none) (("1" (expand_ol) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "first_noises" :assert? none) (("2" (expand "first" :assert? none) (("2" (expand_ol) (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "extend_N" 2 1 :assert? none) (("2" (expand "add_N" :assert? none) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (expand "first_noises" :assert? none) (("1" (expand "first" 1 1 :assert? none) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "first" 1 1 :assert? none) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "extend_N" :assert? none) (("1" (expand "add_N" :assert? none) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split -3) (("1" (expand "extend_N" :assert? none) (("1" (expand "add_N" :assert? none) (("1" (assert) (("1" (expand "first" 1 2 :assert? none) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend_N" :assert? none) (("2" (expand "add_N" :assert? none) (("2" (assert) (("2" (expand "first" 1 2 :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (expand_ol) nil nil) ("2" (expand "first" 2 :assert? none) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (expand "extend_N" :assert? none) (("2" (expand "add_N" :assert? none) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (hide -2) (("1" (case "first_noises(N, n) = empty_noise") (("1" (replaces -1) (("1" (expand "first_noises" :assert? none) (("1" (expand "first" :assert? none) (("1" (expand_ol) (("1" (expand "extend_N" :assert? none) (("1" (expand "add_N" :assert? none) (("1" (assert) (("1" (expand "first" :assert? none) (("1" (assert) (("1" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "first_noises" :assert? none) (("2" (expand "first" :assert? none) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand_ol) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) nil nil)) nil) ("2" (flatten) (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (assert) (("2" (expand "extend_N" :assert? none) (("2" (expand "add_N" :assert? none) (("2" (expand "first_noises" 2 1 :assert? none) (("2" (expand "first" 2 1 :assert? none) (("2" (expand_ol) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "first(N, n)=empty_noise") (("1" (replaces -1) (("1" (expand_ol) nil nil)) nil) ("2" (expand "first_noises" :assert? none) (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "first_noises" :assert? none) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "first_noises" :assert? none) (("2" (expand "first" 3 :assert? none) (("2" (lift-if 3) (("2" (assert) (("2" (split 3) (("1" (flatten) (("1" (expand "first" 2 :assert? none) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand_ol) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefixes const-decl "bool" more_list_props structures) (add_N const-decl "Noise" affine nil) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (first_noises const-decl "Noise" affine nil) (car_ol const-decl "T" ordered_list structures) (empty_noise const-decl "Noise" affine nil) (first def-decl "(prefixes(l))" indexed_list structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (extend_N const-decl "Noise" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) shostak)) (Half_pd_TCC1 0 (Half_pd_TCC1-1 nil 3627238844 ("" (skeep) (("" (expand "null_ol?") (("" (expand "empty_ErrorTerms") (("" (propax) nil nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Half_pd subtype "affine.empty_ErrorTerms" "{pd_: affine.ErrorTerms | booleans.OR(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].null_ol?(pd_), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].null_ol?(affine.pds)), ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(pd_)`1 = ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(affine.pds)`1)))}"))) (Half_pd_TCC2 0 (Half_pd_TCC2-1 nil 3628356478 ("" (skeep*) (("" (expand "lt_idx") (("" (replaces -) (("" (expand "cdr_ol") (("" (expand "car_ol") (("" (expand "null_ol?") (("" (typepred "v(cdr(pds))") (("" (expand "null_ol?") (("" (assert) (("" (flatten) (("" (expand "car_ol") (("" (replaces -2) (("" (typepred "pds") (("" (expand "ordered_list?" -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx const-decl "bool" indexed_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (ErrorTerms type-eq-decl nil affine nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car_ol const-decl "T" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Half_pd subtype "affine.Half_pd(affine.tail)" "{ol | booleans.OR(list_adt[[nat, nzBaseType]].null?(ol), indexed_list[nzBaseType].lt_idx((affine.head`1, number_fields./(affine.head`2, 2)), list_adt[[nat, nzBaseType]].car(ol)))}"))) (Half_pd_TCC3 0 (Half_pd_TCC3-1 nil 3628356478 ("" (skeep*) (("" (replaces -) (("" (expand "null_ol?") (("" (expand "car_ol") (("" (expand "cons_ol") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((car_ol const-decl "T" ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Half_pd subtype "ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].cons_ol((affine.head`1, number_fields./(affine.head`2, 2)), affine.Half_pd(affine.tail))" "{pd_: affine.ErrorTerms | booleans.OR(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].null_ol?(pd_), (booleans.AND((booleans.NOT)(ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].null_ol?(affine.pds)), ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(pd_)`1 = ordered_list[[nat, nzBaseType], indexed_list[nzBaseType].lt_idx].car_ol(affine.pds)`1)))}"))))
