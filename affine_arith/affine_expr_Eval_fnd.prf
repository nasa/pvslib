(|affine_expr_Eval_fnd| (|CacheData_TCC1| 0 (|CacheData_TCC1-1| |nil| 3635095591 ("" (ASSUMING-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|strict_order?| CONST-DECL "bool" |orders| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (|irreflexive?| CONST-DECL "bool" |relations| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|strict_total_order_restrict| APPLICATION-JUDGEMENT "(strict_total_order?[S])" |restrict_order_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|CacheData| ASSUMING "structures@ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (|CacheData_correct?_TCC1| 0 (|CacheData_correct?_TCC1-1| |nil| 3631623248 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|CacheData_correct?| SUBTYPE "affine_expr_Eval_fnd.re" "(IntervalExpr_adt.pow?)"))) (|CacheData_correct?_TCC2| 0 (|CacheData_correct?_TCC2-1| |nil| 3631623248 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|CacheData_correct?| SUBTYPE "affine_expr_Eval_fnd.idxs" "(list_adt[nat].cons?)"))) (|CacheData_correct?_TCC3| 0 (|CacheData_correct?_TCC3-1| |nil| 3631623248 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|CacheData_correct?| SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (|CacheData_correct?_inclusion| 0 (|CacheData_correct?_inclusion-1| |nil| 3638271616 ("" (SKEEP) (("" (EXPAND "CacheData_correct?") (("" (FLATTEN) (("" (ASSERT) (("" (FLATTEN) (("" (SPLIT 1) (("1" (USE "length_append[Interval]") (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append[Interval]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (USE "nth_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "nth_ac") (("3" (USE "nth_append[Interval]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL)) SHOSTAK)) (|correct_cache?_TCC1| 0 (|correct_cache?_TCC1-1| |nil| 3631620842 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|correct_cache?| TERMINATION "affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.t)" "NIL"))) (|correct_cache?_alt_def| 0 (|correct_cache?_alt_def-1| |nil| 3638269279 ("" (INDUCT "cache") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ((|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|)) SHOSTAK)) (|cache_powvar_correct| 0 (|cache_powvar_correct-1| |nil| 3632133476 ("" (SKOLEM 1 ("box_" "cache_" "i_")) (("" (NAME "L" "length(cache_)") (("" (TYPEPRED "i_") (("" (GENERALIZE-SKOLEM-CONSTANTS) (("" (INDUCT "L_1") (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKOLEM 1 "j") (("2" (FLATTEN) (("2" (SKEEP) (("2" (EXPAND "nth" 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "cache_1") (("1" (EXPAND "correct_cache?") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST? -1 :WHERE 2) (("1" (ASSERT) (("1" (SPLIT 3) (("1" (EXPAND "length" -1) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length" -2) (("2" (LIFT-IF -2) (("2" (SPLIT -2) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (TYPEPRED "cache_1") (("3" (EXPAND "correct_cache?" -1) (("3" (LIFT-IF -1) (("3" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|length| DEF-DECL "nat" |list_props| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|cache_1| SKOLEM-CONST-DECL "(correct_cache?(box_1))" |affine_expr_Eval_fnd| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|box_1| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|i_1| SKOLEM-CONST-DECL "below(length(cache_1))" |affine_expr_Eval_fnd| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)) SHOSTAK)) (|compatible_pairs_on?_TCC1| 0 (|compatible_pairs_on?_TCC1-1| |nil| 3631905767 ("" (SUBTYPE-TCC) (("" (GRIND) NIL NIL)) NIL) ((|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|represents_var?| CONST-DECL "bool" |affine| NIL)) NIL (|compatible_pairs_on?| SUBTYPE "affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re))" "(affine.represents_var?)"))) (|compatible_pairs_on?_TCC2| 0 (|compatible_pairs_on?_TCC2-1| |nil| 3631905767 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL)) NIL (|compatible_pairs_on?| SUBTYPE "affine_expr_Eval_fnd.re" "(IntervalExpr_adt.pow?)"))) (|compatible_pairs_on?_TCC3| 0 (|compatible_pairs_on?_TCC3-2| |nil| 3638025854 ("" (SKEEP*) (("" (TYPEPRED "l") (("" (USE "cache_powvar_correct") (("" (EXPAND "CacheData_correct?") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL)) NIL (|compatible_pairs_on?| SUBTYPE "list_props[CacheData].nth(affine_expr_Eval_fnd.l, affine_expr_Eval_fnd.i)`3" "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(nwidxs), (number_fields.-)(IntervalExpr_adt.opn(affine_expr_Eval_fnd.re), 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(nwidxs)), reals.>=(list_adt[nat].car(nwidxs), affine.next_idx(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re))))))))), list_props[[nat, nzBaseType]].length(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re)))) = 0)}")) (|compatible_pairs_on?_TCC3-1| |nil| 3631905767 ("" (GRIND) NIL NIL) NIL NIL (|compatible_pairs_on?| SUBTYPE "list_props[CacheData].nth(affine_expr_Eval_fnd.l, affine_expr_Eval_fnd.i)`3" "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(nwidxs), (number_fields.-)(IntervalExpr_adt.opn(affine_expr_Eval_fnd.re), 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(nwidxs)), reals.>=(list_adt[nat].car(nwidxs), affine.next_idx(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re))))))))), list_props[[nat, nzBaseType]].length(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re)))) = 0)}"))) (|cache_eq_TCC1| 0 (|cache_eq_TCC1-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC2| 0 (|cache_eq_TCC2-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC3| 0 (|cache_eq_TCC3-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC4| 0 (|cache_eq_TCC4-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC5| 0 (|cache_eq_TCC5-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC6| 0 (|cache_eq_TCC6-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC7| 0 (|cache_eq_TCC7-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC8| 0 (|cache_eq_TCC8-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC9| 0 (|cache_eq_TCC9-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC10| 0 (|cache_eq_TCC10-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC11| 0 (|cache_eq_TCC11-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC12| 0 (|cache_eq_TCC12-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC13| 0 (|cache_eq_TCC13-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC14| 0 (|cache_eq_TCC14-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (|cache_eq_TCC15| 0 (|cache_eq_TCC15-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_TCC16| 0 (|cache_eq_TCC16-1| |nil| 3766770260 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) NIL (|cache_eq| SUBTYPE "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (|cache_eq_sound| 0 (|cache_eq_sound-1| |nil| 3766770276 ("" (INDUCT "expr1") (("1" (SKEEP) (("1" (EXPAND "cache_eq") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (HIDE -1) (("2" (SKEEP) (("2" (EXPAND "cache_eq") (("2" (FLATTEN) (("2" (DECOMPOSE-EQUALITY 1) (("2" (DECOMPOSE-EQUALITY 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (HIDE -1) (("3" (SKEEP) (("3" (EXPAND "cache_eq") (("3" (FLATTEN) (("3" (DECOMPOSE-EQUALITY 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (HIDE -3) (("4" (TYPEPRED "ADD1_var") (("4" (REPLACES -1) (("4" (TYPEPRED "ADD2_var") (("4" (REPLACES -1) (("4" (SKEEP) (("4" (EXPAND "cache_eq" -3) (("4" (FLATTEN) (("4" (DECOMPOSE-EQUALITY 1) (("1" (INST -1 "op1(expr2)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST -2 "op2(expr2)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (HIDE -2) (("5" (TYPEPRED "ABS1_var") (("5" (REPLACES -1) (("5" (SKEEP) (("5" (EXPAND "cache_eq" -2) (("5" (FLATTEN) (("5" (DECOMPOSE-EQUALITY 1) (("5" (INST -1 "op(expr2)") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (HIDE -2) (("6" (TYPEPRED "NEG1_var") (("6" (REPLACES -1) (("6" (SKEEP) (("6" (EXPAND "cache_eq" -2) (("6" (FLATTEN) (("6" (DECOMPOSE-EQUALITY 1) (("6" (INST -1 "op(expr2)") (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (HIDE -3) (("7" (TYPEPRED "SUB1_var") (("7" (REPLACES -1) (("7" (TYPEPRED "SUB2_var") (("7" (REPLACES -1) (("7" (SKEEP) (("7" (EXPAND "cache_eq" -3) (("7" (FLATTEN) (("7" (DECOMPOSE-EQUALITY 1) (("1" (INST -1 "op1(expr2)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST -2 "op2(expr2)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (HIDE -3) (("8" (TYPEPRED "MULT1_var") (("8" (REPLACES -1) (("8" (TYPEPRED "MULT2_var") (("8" (REPLACES -1) (("8" (SKEEP) (("8" (EXPAND "cache_eq" -3) (("8" (FLATTEN) (("8" (DECOMPOSE-EQUALITY 1) (("1" (INST -1 "op1(expr2)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST -2 "op2(expr2)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (HIDE -2) (("9" (TYPEPRED "SQ1_var") (("9" (REPLACES -1) (("9" (SKEEP) (("9" (EXPAND "cache_eq" -2) (("9" (FLATTEN) (("9" (DECOMPOSE-EQUALITY 1) (("9" (INST -1 "op(expr2)") (("9" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (HIDE -2) (("10" (TYPEPRED "POW1_var") (("10" (REPLACES -1) (("10" (SKEEP) (("10" (EXPAND "cache_eq" -2) (("10" (FLATTEN) (("10" (DECOMPOSE-EQUALITY 1) (("10" (INST -1 "op(expr2)") (("10" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (HIDE -3) (("11" (TYPEPRED "DIV1_var") (("11" (REPLACES -1) (("11" (TYPEPRED "DIV2_var") (("11" (REPLACES -1) (("11" (SKEEP) (("11" (EXPAND "cache_eq" -3) (("11" (FLATTEN) (("11" (DECOMPOSE-EQUALITY 1) (("1" (INST -1 "op1(expr2)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST -2 "op2(expr2)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (HIDE -) (("12" (SKEEP) (("12" (EXPAND "cache_eq") (("12" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (HIDE -) (("13" (SKEEP) (("13" (EXPAND "cache_eq") (("13" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("14" (SKEEP) (("14" (HIDE -) (("14" (SKEEP) (("14" (EXPAND "cache_eq") (("14" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("15" (SKEEP) (("15" (HIDE -) (("15" (SKEEP) (("15" (EXPAND "cache_eq") (("15" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("16" (SKEEP) (("16" (HIDE -) (("16" (SKEEP) (("16" (EXPAND "cache_eq") (("16" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("17" (SKEEP) (("17" (HIDE -) (("17" (SKEEP) (("17" (EXPAND "cache_eq") (("17" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("18" (SKEEP) (("18" (HIDE -) (("18" (SKEEP) (("18" (EXPAND "cache_eq") (("18" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("19" (SKEEP) (("19" (HIDE -) (("19" (SKEEP) (("19" (EXPAND "cache_eq") (("19" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("20" (SKEEP) (("20" (HIDE -) (("20" (SKEEP) (("20" (EXPAND "cache_eq") (("20" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("21" (SKEEP) (("21" (HIDE -) (("21" (SKEEP) (("21" (EXPAND "cache_eq") (("21" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("22" (SKEEP) (("22" (HIDE -) (("22" (SKEEP) (("22" (EXPAND "cache_eq") (("22" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("23" (SKEEP) (("23" (HIDE -) (("23" (SKEEP) (("23" (EXPAND "cache_eq") (("23" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("24" (SKEEP) (("24" (HIDE -) (("24" (SKEEP) (("24" (EXPAND "cache_eq") (("24" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (DIV ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (div?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_DIV_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_POW_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (SQ ADT-CONSTRUCTOR-DECL "[RealExpr -> (sq?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_SQ_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (MULT ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (mult?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_MULT_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (SUB ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (sub?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_SUB_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (NEG ADT-CONSTRUCTOR-DECL "[RealExpr -> (neg?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_NEG_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|bincludes?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|op| SHARED-ADT-ACCESSOR-DECL "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" |IntervalExpr_adt| |interval_arith|) (|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (ABS ADT-CONSTRUCTOR-DECL "[RealExpr -> (abs?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_ABS_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|op2| SHARED-ADT-ACCESSOR-DECL "[{x: IntervalExpr |
         brel?(x) OR fun4?(x) OR fun2?(x) OR div?(x) OR mult?(x) OR sub?(x)
     OR add?(x)} ->
   RealExpr]" |IntervalExpr_adt| |interval_arith|) (|brel?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|op1| SHARED-ADT-ACCESSOR-DECL "[{x: IntervalExpr |
         brel?(x) OR fun4?(x) OR fun2?(x) OR div?(x) OR mult?(x) OR sub?(x)
     OR add?(x)} ->
   RealExpr]" |IntervalExpr_adt| |interval_arith|) (|expr2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (ADD ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (add?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_ADD_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (TRUE CONST-DECL "bool" |booleans| NIL) (|IntervalExpr_VARIDX_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (VARIDX ADT-CONSTRUCTOR-DECL "[nat -> (varidx?)]" |IntervalExpr_adt| |interval_arith|) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|opc| ADT-ACCESSOR-DECL "[(const?) -> [Unit -> real]]" |IntervalExpr_adt| |interval_arith|) (|Unit| TYPE-DECL NIL |Unit_adt| |structures|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Includes?| CONST-DECL "bool" |interval| |interval_arith|) (|unit?| ADT-RECOGNIZER-DECL "[Unit -> boolean]" |Unit_adt| |structures|) (|unit| ADT-CONSTRUCTOR-DECL "(unit?)" |Unit_adt| |structures|) (CONST ADT-CONSTRUCTOR-DECL "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_CONST_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_induction| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cache_eq| INDUCTIVE-DECL "bool" |affine_expr_Eval_fnd| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|)) SHOSTAK)) (|cache_get_TCC1| 0 (|cache_get_TCC1-1| |nil| 3631365124 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|cache_get| SUBTYPE "Maybe[AffineCombination].None" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}"))) (|cache_get_TCC2| 0 (|cache_get_TCC2-2| "" 3803764425 ("" (SKEEP*) (("" (LEMMA "cache_eq_sound") (("" (INST?) (("" (ASSERT) (("" (INST 1 "0") (("1" (EXPAND "nth") (("1" (REPLACE -1 :DIR RL) (("1" (REPLACE -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|cache_eq_sound| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (|cache_get| SUBTYPE "Maybe[AffineCombination].Some(affine_expr_Eval_fnd.h`2)" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}")) (|cache_get_TCC2-1| |nil| 3631366154 ("" (SKEEP*) (("" (LEMMA "cache_eq_sound") (("" (INST?) (("" (ASSERT) (("" (HIDE -2) (("" (INST 1 "0") (("1" (EXPAND "nth") (("1" (REPLACE -1 :DIR RL) (("1" (REPLACE -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|cache_get| SUBTYPE "Maybe[AffineCombination].Some(affine_expr_Eval_fnd.h`2)" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}"))) (|cache_get_TCC3| 0 (|cache_get_TCC3-1| |nil| 3631366154 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL)) NIL (|cache_get| TERMINATION "affine_expr_Eval_fnd.cache_get(affine_expr_Eval_fnd.t)" "NIL"))) (|cache_get_TCC4| 0 (|cache_get_TCC4-1| |nil| 3631366154 ("" (SKEEP*) (("" (TYPEPRED "v(t)(re)") (("" (ASSERT) (("" (SKEEP) (("" (INST 2 "i+1") (("1" (REPLACE -3) (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|strict_well_founded?| CONST-DECL "bool" |orders| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|t| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|cache_get| SUBTYPE "affine_expr_Eval_fnd.cache_get(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}"))) (|cache_get_powvar_TCC1| 0 (|cache_get_powvar_TCC1-1| |nil| 3631466640 ("" (SUBTYPE-TCC) NIL NIL) ((|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL)) NIL (|cache_get_powvar| SUBTYPE "Maybe[CacheData].None" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (|cache_get_powvar_TCC2| 0 (|cache_get_powvar_TCC2-1| |nil| 3631466640 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL)) NIL (|cache_get_powvar| TERMINATION "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "NIL"))) (|cache_get_powvar_TCC3| 0 (|cache_get_powvar_TCC3-1| |nil| 3631466640 ("" (SKEEP*) (("" (TYPEPRED "v(t)(re)") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (SKEEP) (("" (INST 2 "i+1") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|strict_well_founded?| CONST-DECL "bool" |orders| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|t| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (|cache_get_powvar_TCC4| 0 (|cache_get_powvar_TCC4-1| |nil| 3631466640 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL)) NIL (|cache_get_powvar| TERMINATION "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "NIL"))) (|cache_get_powvar_TCC5| 0 (|cache_get_powvar_TCC5-2| |nil| 3637320258 ("" (SKEEP*) (("" (TYPEPRED "v(t)(re)") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (SKEEP) (("" (INST 2 "i+1") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|strict_well_founded?| CONST-DECL "bool" |orders| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|t| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}")) (|cache_get_powvar_TCC5-1| |nil| 3631466640 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (|cache_get_powvar_TCC6| 0 (|cache_get_powvar_TCC6-1| |nil| 3631466640 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL)) SHOSTAK (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.h`1" "(IntervalExpr_adt.pow?)"))) (|cache_get_powvar_TCC7| 0 (|cache_get_powvar_TCC8-1| |nil| 3631466640 ("" (SKEEP*) (("" (ASSERT) (("" (INST 1 "0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|cache_get_powvar| SUBTYPE "Maybe[CacheData].Some(affine_expr_Eval_fnd.h)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (|cache_get_powvar_TCC8| 0 (|cache_get_powvar_TCC8-1| "" 3789917494 ("" (SKEEP*) (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[list])" |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (|cache_get_powvar| TERMINATION "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "NIL")) (|cache_get_powvar_TCC9-1| |nil| 3631466640 ("" (SKEEP*) (("" (ASSERT) (("" (INST 2 "0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|cache_get_powvar| TERMINATION "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "NIL"))) (|cache_get_powvar_TCC9| 0 (|cache_get_powvar_TCC9-1| "" 3789917494 ("" (SKEEP*) (("" (ASSERT) NIL NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.nextresult" "(Maybe[CacheData].some?)")) (|cache_get_powvar_TCC10-1| |nil| 3631466640 ("" (SKEEP*) (("" (ASSERT) (("" (TYPEPRED "nextresult") (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.nextresult" "(Maybe[CacheData].some?)"))) (|cache_get_powvar_TCC10| 0 (|cache_get_powvar_TCC11-2| |nil| 3767012435 ("" (SKEEP*) (("" (ASSERT) (("" (TYPEPRED "nextresult") (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|cache_get_powvar| SUBTYPE "Maybe[CacheData].val(affine_expr_Eval_fnd.nextresult)`1" "(IntervalExpr_adt.pow?)")) (|cache_get_powvar_TCC11-1| |nil| 3631466640 ("" (SKEEP*) (("" (ASSERT) (("" (INST 2 "0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|cache_get_powvar| SUBTYPE "Maybe[CacheData].val(affine_expr_Eval_fnd.nextresult)`1" "(IntervalExpr_adt.pow?)"))) (|cache_get_powvar_TCC11| 0 (|cache_get_powvar_TCC12-2| |nil| 3767012422 ("" (SKEEP*) (("" (ASSERT) (("" (INST 2 "0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|cache_get_powvar| SUBTYPE "Maybe[CacheData].Some(affine_expr_Eval_fnd.h)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}")) (|cache_get_powvar_TCC12-1| |nil| 3631554556 ("" (SKEEP*) (("" (ASSERT) (("" (TYPEPRED "nextresult") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (SKEEP) (("" (INST 4 "i+1") (("1" (GRIND) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|cache_get_powvar| SUBTYPE "Maybe[CacheData].Some(affine_expr_Eval_fnd.h)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (|cache_get_powvar_TCC12| 0 (|cache_get_powvar_TCC13-2| |nil| 3767012408 ("" (SKEEP*) (("" (ASSERT) (("" (TYPEPRED "nextresult") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (SKEEP) (("" (INST 4 "i+1") (("1" (GRIND) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|cache| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|t| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.nextresult" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}")) (|cache_get_powvar_TCC13-1| |nil| 3631554556 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|cache_get_powvar| SUBTYPE "affine_expr_Eval_fnd.nextresult" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (|cache_powvar_correct_result| 0 (|cache_powvar_correct_result-1| |nil| 3632140157 ("" (SKEEP) (("" (ASSERT) (("" (FLATTEN) (("" (TYPEPRED "cache_get_powvar(cache)(re)") (("" (ASSERT) (("" (FLATTEN) (("" (SKEEP) (("" (USE "cache_powvar_correct") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|cache_get_powvar| DEF-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL)) SHOSTAK)) (RE2AC_TCC1 0 (RE2AC_TCC1-1 |nil| 3631293338 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(affine_expr_Eval_fnd.result)`2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC2 0 (RE2AC_TCC2-3 "" 3789917499 ("" (LEMMA "well_founded_restrict[IntervalExpr, RealExpr]") (("" (INST?) (("" (EXPAND "well_founded?") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|strict_well_founded?| CONST-DECL "bool" |orders| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded_restrict| JUDGEMENT-TCC NIL |restrict_order_props| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|)) SHOSTAK (RE2AC WELL-FOUNDED "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], bool].restrict(IntervalExpr_adt.<<)" "NIL")) (RE2AC_TCC2-2 |nil| 3637320866 ("" (THEN (LEMMA "well_founded_restrict[IntervalExpr, RealExpr]") (INST?) (EXPAND "well_founded?") (PROPAX)) NIL NIL) NIL NIL (RE2AC WELL-FOUNDED "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], bool].restrict(IntervalExpr_adt.<<)" "NIL")) (RE2AC_TCC2-1 |nil| 3631293338 ("" (LEMMA "well_founded_restrict[AffineExpr, RealExpr]") (("" (INST?) (("" (EXPAND "well_founded?") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC WELL-FOUNDED "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], bool].restrict(IntervalExpr_adt.<<)" "NIL"))) (RE2AC_TCC3 0 (RE2AC_TCC3-1 "" 3789917499 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -1) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC4-2 |nil| 3632065384 ("" (THEN (SKEEP*) (ASSERT) (REPLACES -1) (REPLACES -1) (HIDE -1) (ASSERT) (SPREAD (SPLIT 1) ((SPREAD (INST 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") ((GRIND) (GRIND) (GRIND))) (THEN (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (HIDE-ALL-BUT (-1 1)) (REPLACES -1) (GRIND) (EXPAND "eval_pd_noise") (GRIND)) (THEN (NAME "j" "i-1") (SPREAD (CASE "j< length(cache)") ((THEN (EXPAND "nth" 2) (ASSERT) (SKEEP) (REPLACE -2) (INST -5 "j") (INST -5 "n")) (THEN (HIDE (3 -4)) (TYPEPRED "i") (EXPAND "length" -1) (ASSERT)))))))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth") (TYPEPRED "nextfreeidx") (TYPEPRED "opC") (REPLACES -1) (EXPAND "next_idx") (EXPAND "const_ac") (HIDE-ALL-BUT (1 -1)) (GRIND)) (THEN (EXPAND "nth" 2) (ASSERT) (INST -3 "i-1")))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC4-1 |nil| 3631293338 ("" (SKEEP) (("" (ASSERT) (("" (EXPAND "compatible_pairs?") (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?") (("" (SKEEP) (("" (INST 1 "N") (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC4 0 (RE2AC_TCC4-1 "" 3789917500 ("" (SKEEP*) (("" (ASSERT) (("" (REPLACES (-1 -2)) (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|const_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC5-1 |nil| 3631294584 ("" (THEN (SKEEP*) (ASSERT) (REPLACES (-1 -2)) (REPLACE -1) (ASSERT) (HIDE -2) (SPREAD (SPLIT 2) ((THEN (INST 1 "(:car(result`2):)") (GRIND)) (THEN (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (SPREAD (SPLIT 1) ((PROPAX) (THEN (EXPAND "compatible_pairs_on?") (SKEEP :PREDS? T) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "vars_in_box_compatible?") (EXPAND "eval_ACExpr_Env" 1) (INST -2 "varidx") (FLATTEN) (REPLACES -2 :DIR RL) (EXPAND "nth_ac" 1) (PROPAX)) (THEN (EXPAND "nth" 2) (ASSERT) (INST -3 "i-1")))))))) (THEN (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth") (EXPAND "nth_ac") (HIDE -1) (EXPAND "var_ac") (TYPEPRED "nextfreeidx") (SPREAD (CASE "null?(box)") ((GRIND) (GRIND)))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SPREAD (INST -2 "i-1") ((THEN (EXPAND "nth" 2) (ASSERT)) (THEN (TYPEPRED "i") (GRIND))))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC5 0 (RE2AC_TCC5-1 "" 3789917502 ("" (SKEEP*) (("" (ASSERT) (("" (REPLACES -1) (("" (REPLACES -1) (("" (HIDE -1) (("" (ASSERT) (("" (SPLIT 1) (("1" (INST 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (REPLACES -1) (("1" (GRIND) (("1" (EXPAND "eval_pd_noise") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (CASE "j< length(cache)") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (SKEEP) (("1" (REPLACE -2) (("1" (INST -5 "j") (("1" (INST -5 "n") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (3 -4)) (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth") (("1" (TYPEPRED "nextfreeidx") (("1" (TYPEPRED "opC") (("1" (EXPAND "next_idx") (("1" (EXPAND "const_ac") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|next_idx| CONST-DECL "nat" |affine| NIL) (|##| CONST-DECL "bool" |interval| |interval_arith|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|eval_pd_noise| DEF-DECL "real" |affine| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|Unit| TYPE-DECL NIL |Unit_adt| |structures|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Includes?| CONST-DECL "bool" |interval| |interval_arith|) (|unit?| ADT-RECOGNIZER-DECL "[Unit -> boolean]" |Unit_adt| |structures|) (|unit| ADT-CONSTRUCTOR-DECL "(unit?)" |Unit_adt| |structures|) (CONST ADT-CONSTRUCTOR-DECL "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" |IntervalExpr_adt| |interval_arith|) (|const_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC6-3 |nil| 3767012201 ("" (SKEEP*) (("" (ASSERT) (("" (REPLACES -1) (("" (REPLACES -1) (("" (HIDE -1) (("" (ASSERT) (("" (SPLIT 1) (("1" (INST 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (REPLACES -1) (("1" (GRIND) (("1" (EXPAND "eval_pd_noise") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (CASE "j< length(cache)") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (SKEEP) (("1" (REPLACE -2) (("1" (INST -5 "j") (("1" (INST -5 "n") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (3 -4)) (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth") (("1" (TYPEPRED "nextfreeidx") (("1" (TYPEPRED "opC") (("1" (REPLACES -1) (("1" (EXPAND "next_idx") (("1" (EXPAND "const_ac") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC6-2 |nil| 3767011439 ("" (SKEEP*) (("" (REPLACES -1) (("" (REPLACES -2) (("" (ASSERT) (("" (SPLIT 2) (("1" (INST 1 "(:(VARIDX(varidx), ac, null):)") (("1" (EXPAND "append") (("1" (GRIND) NIL))) ("2" (GRIND) NIL) ("3" (GRIND) NIL))) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST?) (("1" (FLATTEN) (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (PROPAX) NIL))))))))))))))))))) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL))))))))))))))))))))))))))))) ("3" (HIDE -2) (("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded" 1) (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL))))))))))))) ("2" (EXPAND "idxs_bounded" -2) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL))))))))))))))))) ("4" (EXPAND "correct_cache?") (("4" (TYPEPRED "cache") (("4" (EXPAND "CacheData_correct?") (("4" (PROPAX) NIL)))))))))))))))) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC6-1 |nil| 3631294584 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC6 0 (RE2AC_TCC6-1 "" 3789917503 ("" (SKEEP*) (("" (REPLACES -1) (("" (REPLACES -2) (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC7-1 |nil| 3631294584 ("" (SKEEP*) (("" (REPLACES -1) (("" (REPLACES -2) (("" (ASSERT) (("" (SPLIT 2) (("1" (INST 1 "(:(VARIDX(varidx), ac, null):)") (("1" (EXPAND "append") (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST?) (("1" (FLATTEN) (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2) (("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded" 1) (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "idxs_bounded" -2) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "correct_cache?") (("4" (TYPEPRED "cache") (("4" (EXPAND "CacheData_correct?") (("4" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC7 0 (RE2AC_TCC7-1 "" 3789917504 ("" (SKEEP*) (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL) ((|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC8-1 |nil| 3631295747 ("" (SKEEP*) (("" (ASSERT) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (REPLACE -4 1) (("2" (ASSERT) (("2" (INST 1 "(:car(result`2):)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (REPLACE -8 1) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "nth" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST? :SUBST ("i" "i!1" "n" "n")) (("1" (ASSERT) (("1" (EXPAND "powvar?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (TYPEPRED "i") (("2" (INST? :SUBST ("i" "i - 1" "n" "n")) (("1" (EXPAND "length" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -5) (("4" (REPLACE -4) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE -6) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST? :SUBST ("i" "i!1")) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST? :SUBST ("i" "i-1")) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC8 0 (RE2AC_TCC9-4 |nil| 3767012646 ("" (SKEEP*) (("" (ASSERT) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (REPLACE -4 1) (("2" (ASSERT) (("2" (INST 1 "(:car(result`2):)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (REPLACE -8 1) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "nth" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST? :SUBST ("i" "i!1" "n" "n")) (("1" (ASSERT) (("1" (EXPAND "powvar?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (TYPEPRED "i") (("2" (INST? :SUBST ("i" "i - 1" "n" "n")) (("1" (EXPAND "length" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -5) (("4" (REPLACE -4) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE -6) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST? :SUBST ("i" "i!1")) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST? :SUBST ("i" "i-1")) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|cache_get| DEF-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((re, val(cached), null), cache)))" |affine_expr_Eval_fnd| NIL) (|cached| SKOLEM-CONST-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (> CONST-DECL "bool" |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC9-3 |nil| 3638025920 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC9-2 |nil| 3632065729 ("" (SKEEP*) (("" (REPLACES -1) (("" (REPLACES -2) (("" (ASSERT) (("" (SPLIT 2) (("1" (INST 1 "(:(VARIDX(varidx), ac, null):)") (("1" (EXPAND "append") (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (EXPAND "powvar?") (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "eval") (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST?) (("1" (FLATTEN) (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2) (("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded" 1) (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "idxs_bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC9-1 |nil| 3631295747 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC9 0 (RE2AC_TCC9-1 "" 3789917507 ("" (SKEEP*) (("" (ASSERT) NIL NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC3-1 |nil| 3631293338 ("" (THEN (SKEEP*) (ASSERT) (REPLACES -1) (REPLACES -1) (HIDE -1) (ASSERT) (SPREAD (SPLIT 1) ((SPREAD (INST 1 "(:(CONST(opc, opC), opC, null):)") ((GRIND) (GRIND) (GRIND))) (THEN (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (HIDE-ALL-BUT (-1 1)) (REPLACES -1) (GRIND) (TYPEPRED "opC") (GRIND) (EXPAND "eval_pd_noise") (GRIND)) (THEN (NAME "j" "i-1") (SPREAD (CASE "j< length(cache)") ((THEN (EXPAND "nth" 2) (ASSERT) (REPLACE -2) (GRIND)) (GRIND))))))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth") (TYPEPRED "nextfreeidx") (TYPEPRED "opC") (REPLACES -1) (EXPAND "next_idx") (EXPAND "const_ac") (HIDE-ALL-BUT (1 -1)) (GRIND)) (THEN (EXPAND "nth" 2) (ASSERT) (INST -2 "i-1"))))) (THEN (TYPEPRED "cache") (HIDE -1 -2) (EXPAND "correct_cache?" 1) (HIDE -1) (EXPAND "CacheData_correct?") (PROPAX))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC10 0 (RE2AC_TCC10-1 |nil| 3631295747 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varidx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC11 0 (RE2AC_TCC11-2 "" 3789917508 ("" (SKEEP*) (("" (REPLACES -1) (("" (ASSERT) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC11-1 |nil| 3631295747 ("" (THEN (SKEEP*) (REPLACES -1) (REPLACES -2) (ASSERT) (SPREAD (SPLIT 2) ((SPREAD (INST 1 "(:(VARIDX(varidx), ac, null):)") ((THEN (EXPAND "append") (GRIND)) (GRIND) (GRIND))) (THEN (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?" 1) (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (ASSERT) (EXPAND "nth" 1) (EXPAND "eval_ACExpr_Env") (EXPAND "vars_in_box_compatible?") (INST?) (FLATTEN) (REPLACES -6) (EXPAND "nth_ac") (PROPAX)) (THEN (EXPAND "compatible_pairs_on?") (EXPAND "nth" 2) (ASSERT) (INST?) (TYPEPRED "i") (ASSERT) (GRIND))))) (THEN (HIDE -2) (TYPEPRED "cache") (EXPAND "idxs_bounded" 1) (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "nextfreeidx") (USE "last_idx_box") (REPLACES -6) (EXPAND "nth_ac") (ASSERT)) (THEN (EXPAND "idxs_bounded" -2) (EXPAND "nth" 2) (ASSERT) (INST?))))) (THEN (EXPAND "correct_cache?") (TYPEPRED "cache") (EXPAND "CacheData_correct?") (PROPAX))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC12 0 (RE2AC_TCC12-1 |nil| 3631295747 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC13 0 (RE2AC_TCC13-2 "" 3789917511 ("" (SKEEP*) (("" (REPLACES -1) (("" (REPLACES -3) (("" (ASSERT) (("" (SPLIT 3) (("1" (INST 1 "(:(VARIDX(varidx), ac, null):)") (("1" (EXPAND "append") (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (EXPAND "powvar?") (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "eval") (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST?) (("1" (FLATTEN) (("1" (REPLACES -7) (("1" (EXPAND "nth_ac") (("1" (SKEEP) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE -3) (("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded" 1) (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "idxs_bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|varidx| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|ac| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((VARIDX(varidx), ac, null), cache)))" |affine_expr_Eval_fnd| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (VARIDX ADT-CONSTRUCTOR-DECL "[nat -> (varidx?)]" |IntervalExpr_adt| |interval_arith|) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC13-1 |nil| 3631295747 ("" (SKEEP*) (("" (REPLACES -1) (("" (REPLACES -3) (("" (ASSERT) (("" (SPLIT 3) (("1" (INST 1 "(:(VARIDX(varidx), ac, null):)") (("1" (EXPAND "append") (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (EXPAND "powvar?") (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "eval") (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST?) (("1" (FLATTEN) (("1" (REPLACES -7) (("1" (EXPAND "nth_ac") (("1" (SKEEP) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE -3) (("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded" 1) (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (REPLACES -6) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "idxs_bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC14 0 (RE2AC_TCC14-2 |nil| 3767016208 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|restrict| CONST-DECL "R" |restrict| NIL)) NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL")) (RE2AC_TCC14-1 |nil| 3631295747 ("" (THEN (SKEEP*) (TYPEPRED "res1") (ASSERT) (FLATTEN) (SPREAD (SPLIT 3) ((THEN (EXPAND "compatible_pairs?") (SKEEP -3) (INST 1 "N") (ASSERT)) (THEN (REPLACE -9 :DIR RL) (ASSERT))))) NIL NIL) NIL NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL"))) (RE2AC_TCC15 0 (RE2AC_TCC15-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC16 0 (RE2AC_TCC16-1 "" 3789917514 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC15-2 |nil| 3632066118 ("" (THEN (SKEEP*) (TYPEPRED "res1") (ASSERT) (REPLACES -5 :DIR RL) (FLATTEN) (ASSERT) (EXPAND "compatible_pairs?" 3) (PROPAX)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC15-1 |nil| 3631300447 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC17 0 (RE2AC_TCC17-1 "" 3789917516 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)")) (RE2AC_TCC16-1 |nil| 3631300447 ("" (THEN (SKEEP*) (REPLACES -1) (TYPEPRED "res1") (ASSERT) (REPLACES -5 :DIR RL) (FLATTEN) (ASSERT) (EXPAND "compatible_pairs?") (PROPAX)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC18 0 (RE2AC_TCC17-1 |nil| 3631300447 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC19 0 (RE2AC_TCC19-1 "" 3789917519 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) (("" (REPLACES -5 :DIR RL) (("" (FLATTEN) (("" (ASSERT) (("" (EXPAND "compatible_pairs?") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC18-1 |nil| 3631359170 ("" (THEN (SKEEP*) (REPLACES -1) (TYPEPRED "res1") (ASSERT) (REPLACES -5 :DIR RL) (FLATTEN) (ASSERT) (EXPAND "compatible_pairs?") (PROPAX)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}"))) (RE2AC_TCC20 0 (RE2AC_TCC20-1 "" 3789917521 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re2" -1) (LABEL "cache2-form" -2) (LABEL "N2" -3) (LABEL "newid2-prop" -4) (LABEL "cache2-idxs_bound" -5))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re1" -1) (LABEL "cache1-form" -2) (LABEL "N1" -3) (LABEL "newid1-prop" -4) (LABEL "cache1-idxs_bound" -5))) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|well_founded_restrict| APPLICATION-JUDGEMENT "(well_founded?[S])" |restrict_order_props| NIL) (|strict_order_restrict| APPLICATION-JUDGEMENT "(strict_order?[S])" |restrict_order_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "NIL")) (RE2AC_TCC19-2 |nil| 3631632051 ("" (THEN (SKEEP*) (ASSERT) (HIDE -11) (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re2" -1) (LABEL "cache2-form" -2) (LABEL "N2" -3) (LABEL "newid2-prop" -4) (LABEL "cache2-idxs_bound" -5))) (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re1" -1) (LABEL "cache1-form" -2) (LABEL "N1" -3) (LABEL "newid1-prop" -4) (LABEL "cache1-idxs_bound" -5))) (SPREAD (SPLIT 3) ((GRIND) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES1) (TYPEPRED_RES2) (SKOLEM "cache2-form" "l2") (SKOLEM "cache1-form" "l1") (REPLACE "cache1-form" "cache2-form") (REPLACE "cache2-form" 3) (INST 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (HIDE-ALL-BUT 3) (EXPAND "append" 1 3) (USE "append_assoc[CacheData]") (ASSERT)) (THEN (TYPEPRED_RES2) (SKOLEM "N2" "N2") (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (INST 2 "N2") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 2) (REPLACE "result") (ASSERT) (EXPAND "eval_ACExpr_Env" 2) (REPLACES "re") (ASSERT) (USE "containment_add") (ASSERT) (HIDE 3) (SPREAD (SPLIT 1) ((THEN (TYPEPRED_RES1) (REPLACES "re1" :DIR RL) (SKOLEM "N1" "N1") (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (SPREAD (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                         eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                          eval_ac_noise(nth(cache1, i)`2, N1)") ((THEN (REPLACE "ac1") (SPREAD (INST -1 "0") ((THEN (EXPAND "nth" -1) (REPLACES -1) (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SPREAD (INST "N1 compatible pairs" "0") ((THEN (EXPAND "nth" "N1 compatible pairs") (PROPAX)) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SKEEP) (INST "N1 compatible pairs" "i!1") (REPLACE "N1 compatible pairs" 1) (SKOLEM "cache2-form" "l2") (REPLACE "cache2-form" "N2 compatible pairs") (SPREAD (INST "N2 compatible pairs" "length(l2)+i!1") ((SPREAD (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((ASSERT) (THEN (HIDE-ALL-BUT 1) (USE "nth_append[CacheData]") (ASSERT)))) (THEN (REPLACE "cache2-form" 1) (USE "length_append[CacheData]") (REPLACES -1) (ASSERT)))))))) (SPREAD (INST "N2 compatible pairs" "0") ((THEN (EXPAND "nth" "N2 compatible pairs") (ASSERT)) (THEN (EXPAND "length") (ASSERT))))))) (THEN (NAME "j" "i-1") (TYPEPRED "i") (EXPAND "length") (EXPAND "nth" 3) (ASSERT) (REPLACE -2) (REPLACE "result") (ASSERT) (INST "N2 compatible pairs" "j"))))) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES2) (TYPEPRED_RES1)) (THEN (REPLACES "result") (ASSERT) (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (USE "next_idx_add_ac_ac") (EXPAND ">=") (TYPEPRED_RES2) (TYPEPRED_RES1) (EXPAND "idxs_bounded") (SPREAD (INST "cache1-idxs_bound" "0") ((THEN (EXPAND "nth" "cache1-idxs_bound") (REPLACE "ac1" :DIR RL) (SPREAD (INST "cache2-idxs_bound" "0") ((THEN (EXPAND "nth" "cache2-idxs_bound") (REPLACE "ac2" :DIR RL) (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (EXPAND "max") (LIFT-IF -4) (SPREAD (SPLIT -4) ((THEN (FLATTEN) (EXPAND ">=") (ASSERT)) (THEN (FLATTEN) (ASSERT))))) (GRIND)))) (GRIND)))) (THEN (TYPEPRED_RES2) (EXPAND "idxs_bounded") (SPREAD (INST "cache2-idxs_bound" "i-1") ((THEN (EXPAND "nth" 3) (PROPAX)) (THEN (TYPEPRED "i") (GRIND))))))))))) NIL NIL) NIL NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "NIL")) (RE2AC_TCC19-1 |nil| 3631365124 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "NIL"))) (RE2AC_TCC21 0 (RE2AC_TCC21-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC22 0 (RE2AC_TCC20-1 |nil| 3631365124 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC23 0 (RE2AC_TCC21-2 |nil| 3767016128 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)")) (RE2AC_TCC21-1 |nil| 3631365124 ("" (THEN (SKEEP*) (ASSERT) (HIDE -11) (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re2" -1) (LABEL "cache2-form" -2) (LABEL "N2" -3) (LABEL "newid2-prop" -4) (LABEL "cache2-idxs_bound" -5) (LABEL "cache2 correct" -6))) (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re1" -1) (LABEL "cache1-form" -2) (LABEL "N1" -3) (LABEL "newid1-prop" -4) (LABEL "cache1-idxs_bound" -5) (LABEL "cache1 correct" -6))) (SPREAD (SPLIT 3) ((GRIND) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES1) (TYPEPRED_RES2) (SKOLEM "cache2-form" "l2") (SKOLEM "cache1-form" "l1") (REPLACE "cache1-form" "cache2-form") (REPLACE "cache2-form" 3) (SPREAD (INST 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") ((THEN (HIDE-ALL-BUT 3) (EXPAND "append" 1 3) (USE "append_assoc[CacheData]") (ASSERT)) (GRIND)))) (THEN (TYPEPRED_RES2) (SKOLEM "N2" "N2") (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (INST 2 "N2") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 2) (REPLACE "result") (ASSERT) (EXPAND "eval_ACExpr_Env" 2) (REPLACES "re") (ASSERT) (USE "containment_add") (ASSERT) (HIDE 3) (SPREAD (SPLIT 1) ((THEN (TYPEPRED_RES1) (REPLACES "re1" :DIR RL) (SKOLEM "N1" "N1") (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (SPREAD (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                      eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                       eval_ac_noise(nth(cache1, i)`2, N1)") ((THEN (REPLACE "ac1") (SPREAD (INST -1 "0") ((THEN (EXPAND "nth" -1) (REPLACES -1) (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SPREAD (INST "N1 compatible pairs" "0") ((THEN (EXPAND "nth" "N1 compatible pairs") (PROPAX)) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SKEEP) (INST "N1 compatible pairs" "i!1") (REPLACE "N1 compatible pairs" 1) (SKOLEM "cache2-form" "l2") (REPLACE "cache2-form" "N2 compatible pairs") (SPREAD (INST "N2 compatible pairs" "length(l2)+i!1") ((SPREAD (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((ASSERT) (THEN (HIDE-ALL-BUT 1) (USE "nth_append[CacheData]") (ASSERT)))) (THEN (REPLACE "cache2-form" 1) (USE "length_append[CacheData]") (REPLACES -1) (ASSERT)))))))) (SPREAD (INST "N2 compatible pairs" "0") ((THEN (EXPAND "nth" "N2 compatible pairs") (ASSERT)) (THEN (EXPAND "length") (ASSERT))))))) (THEN (NAME "j" "i-1") (TYPEPRED "i") (EXPAND "length") (EXPAND "nth" 3) (ASSERT) (REPLACE -2) (REPLACE "result") (ASSERT) (INST "N2 compatible pairs" "j"))))) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES2) (TYPEPRED_RES1)) (THEN (REPLACES "result") (ASSERT) (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (USE "next_idx_add_ac_ac") (EXPAND ">=") (TYPEPRED_RES2) (TYPEPRED_RES1) (EXPAND "idxs_bounded") (SPREAD (INST "cache1-idxs_bound" "0") ((THEN (EXPAND "nth" "cache1-idxs_bound") (REPLACE "ac1" :DIR RL) (SPREAD (INST "cache2-idxs_bound" "0") ((THEN (EXPAND "nth" "cache2-idxs_bound") (REPLACE "ac2" :DIR RL) (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -13)) (EXPAND "max") (LIFT-IF -4) (SPREAD (SPLIT -4) ((THEN (FLATTEN) (EXPAND ">=") (ASSERT)) (THEN (FLATTEN) (ASSERT))))) (GRIND)))) (GRIND)))) (THEN (TYPEPRED_RES2) (EXPAND "idxs_bounded") (SPREAD (INST "cache2-idxs_bound" "i-1") ((THEN (EXPAND "nth" 3) (PROPAX)) (THEN (TYPEPRED "i") (GRIND)))))))) (THEN (REPLACES "result") (ASSERT) (EXPAND "correct_cache?" 1) (TYPEPRED_RES2) (ASSERT) (EXPAND "CacheData_correct?") (PROPAX))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC24 0 (RE2AC_TCC22-3 |nil| 3632067579 ("" (TERMINATION-TCC) NIL NIL) ((|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|)) NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC22-2 |nil| 3632066368 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -11) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re2" -1) (LABEL "cache2-form" -2) (LABEL "N2" -3) (LABEL "newid2-prop" -4) (LABEL "cache2-idxs_bound" -5) (LABEL "cache2 correct" -6))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re1" -1) (LABEL "cache1-form" -2) (LABEL "N1" -3) (LABEL "newid1-prop" -4) (LABEL "cache1-idxs_bound" -5) (LABEL "cache1 correct" -6))) (("" (SPLIT 3) (("1" (GRIND) NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL))))))) ("2" (GRIND) NIL))))))))))))))))))) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (INST 2 "N2") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 2) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (REPLACES "re") (("1" (ASSERT) (("1" (USE "containment_add") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                               eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (EXPAND "nth" "N1 compatible pairs") (("1" (FLATTEN) NIL))) ("2" (EXPAND "length") (("2" (ASSERT) NIL))))))))))) ("2" (EXPAND "length") (("2" (ASSERT) NIL))))))) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL))))) ("2" (HIDE-ALL-BUT 1) (("2" (USE "nth_append[CacheData]") (("2" (ASSERT) NIL))))))) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL))))))))))))))))))))))))))))) ("2" (INST "N2 compatible pairs" "0") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) NIL))) ("2" (EXPAND "length") (("2" (ASSERT) NIL))))))))))))))))))))))))))) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length") (("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (INST "N2 compatible pairs" "j") NIL))))))))))))))))))))))))))))))))) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) NIL))))))) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_add_ac_ac") (("1" (EXPAND ">=") (("1" (TYPEPRED_RES2) (("1" (TYPEPRED_RES1) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -13)) (("1" (EXPAND "max") (("1" (LIFT-IF -4) (("1" (SPLIT -4) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (ASSERT) NIL))))) ("2" (FLATTEN) (("2" (ASSERT) NIL))))))))))))))) ("2" (GRIND) NIL))))))) ("2" (GRIND) NIL))))))))))))))))) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (PROPAX) NIL))) ("2" (TYPEPRED "i") (("2" (GRIND) NIL))))))))))))))))))) ("6" (REPLACES "result") (("6" (ASSERT) (("6" (EXPAND "correct_cache?" 1) (("6" (TYPEPRED_RES2) (("6" (ASSERT) (("6" (EXPAND "CacheData_correct?") (("6" (PROPAX) NIL)))))))))))))))))))))))))) NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC22-1 |nil| 3631365124 ("" (SKEEP*) (("" (ASSERT) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (REPLACE -4 1) (("2" (ASSERT) (("2" (INST 1 "(:car(result`2):)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (REPLACE -8 1) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (EXPAND "nth" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -5 "i!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST -2 "i-1") (("2" (ASSERT) (("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -5) (("4" (REPLACE -4) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE -6) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -4 "i!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "i-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACES -4) (("5" (ASSERT) (("5" (HIDE -4) (("5" (EXPAND "correct_cache?") (("5" (EXPAND "CacheData_correct?") (("5" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC25 0 (RE2AC_TCC23-1 |nil| 3631365124 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|add_pd_pd| CONST-DECL "ErrorTerms" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|add_ac_ac| CONST-DECL "AffineCombination" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC26 0 (RE2AC_TCC24-2 |nil| 3767009989 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -11) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (WITH-LABELS (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (SPLIT 3) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (INST 2 "N2") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 2) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "powvar?" 2) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (REPLACES "re") (("1" (EXPAND "eval" 2) (("1" (SKEEP) (("1" (USE "containment_add") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                 eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                  eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (EXPAND "nth" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "n") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (INST "N1 compatible pairs" "n") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (INST "N2 compatible pairs" "n") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (USE "more_list_props[CacheData].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "N2 compatible pairs" "0") (("1" (INST "N2 compatible pairs" "n") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length") (("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (INST "N2 compatible pairs" "j") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) NIL NIL)) NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_add_ac_ac") (("1" (EXPAND ">=") (("1" (TYPEPRED_RES2) (("1" (TYPEPRED_RES1) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (EXPAND "max") (("1" (LIFT-IF -4) (("1" (SPLIT -4) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (PROPAX) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|next_idx_add_ac_ac| FORMULA-DECL NIL |affine| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|ac1| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|ac2| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((re, add_ac_ac(ac1, ac2), null), cache2)))" |affine_expr_Eval_fnd| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|cache2| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|i!1| SKOLEM-CONST-DECL "below(length(cache1))" |affine_expr_Eval_fnd| NIL) (|l2| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|cache1| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|containment_add| FORMULA-DECL NIL |affine| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|append_assoc| FORMULA-DECL NIL |list_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|add_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|add_pd_pd| CONST-DECL "ErrorTerms" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC24-1 |nil| 3631365124 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC27 0 (RE2AC_TCC27-1 "" 3789917536 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (WITH-LABELS (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC25-1 |nil| 3631365124 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -11) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (WITH-LABELS (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (SPLIT 3) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (INST 2 "N2") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 2) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "powvar?" 2) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (REPLACES "re") (("1" (EXPAND "eval" 2) (("1" (SKEEP) (("1" (USE "containment_add") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                    eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                     eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (EXPAND "nth" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "n") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (INST "N1 compatible pairs" "n") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (INST "N2 compatible pairs" "n") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (USE "more_list_props[CacheData].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "N2 compatible pairs" "0") (("1" (INST "N2 compatible pairs" "n") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length") (("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (INST "N2 compatible pairs" "j") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) NIL NIL)) NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_add_ac_ac") (("1" (EXPAND ">=") (("1" (TYPEPRED_RES2) (("1" (TYPEPRED_RES1) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (EXPAND "max") (("1" (LIFT-IF -4) (("1" (SPLIT -4) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (PROPAX) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC28 0 (RE2AC_TCC26-2 |nil| 3632067889 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC26-1 |nil| 3631365124 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC29 0 (RE2AC_TCC27-2 |nil| 3767011072 ("" (SKEEP*) (("" (ASSERT) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (REPLACE -4 1) (("2" (ASSERT) (("2" (INST 1 "(:car(result`2):)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (REPLACE -8 1) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "nth" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST? :SUBST ("i" "i!1" "n" "n")) (("1" (ASSERT) (("1" (EXPAND "powvar?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (TYPEPRED "i") (("2" (INST? :SUBST ("i" "i - 1" "n" "n")) (("1" (EXPAND "length" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -5) (("4" (REPLACE -4) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE -6) (("1" (TYPEPRED "cache_get(cache)(re)") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST? :SUBST ("i" "i!1")) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST? :SUBST ("i" "i-1")) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|cache_get| DEF-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((re, val(cached), null), cache)))" |affine_expr_Eval_fnd| NIL) (|cached| SKOLEM-CONST-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (> CONST-DECL "bool" |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC27-1 |nil| 3631365124 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC30 0 (RE2AC_TCC28-1 |nil| 3631365124 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|restrict| CONST-DECL "R" |restrict| NIL)) NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL"))) (RE2AC_TCC31 0 (RE2AC_TCC31-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC32 0 (RE2AC_TCC32-1 "" 3789917543 ("" (SKEEP*) (("" (ASSERT) NIL NIL)) NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC29-1 |nil| 3631365124 ("" (THEN (SKEEP*) (ASSERT) (SPREAD (SPLIT 1) ((GRIND) (THEN (REPLACE -4 1) (ASSERT) (INST 1 "(:car(result`2):)") (GRIND)) (THEN (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (REPLACE -8 1) (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SKEEP) (EXPAND "nth" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (TYPEPRED "cache_get(cache)(re)") (ASSERT) (SKEEP) (INST? :SUBST ("i" "i!1" "n" "n")) (ASSERT) (EXPAND "powvar?") (GRIND)) (THEN (FLATTEN) (ASSERT) (TYPEPRED "i") (SPREAD (INST? :SUBST ("i" "i - 1" "n" "n")) ((THEN (EXPAND "length" -1) (ASSERT)) (THEN (EXPAND "length" -1) (ASSERT)))))))) (THEN (HIDE -5) (REPLACE -4) (ASSERT) (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACE -6) (TYPEPRED "cache_get(cache)(re)") (ASSERT) (SKEEP) (INST? :SUBST ("i" "i!1")) (ASSERT)) (THEN (EXPAND "nth" 2) (ASSERT) (INST? :SUBST ("i" "i-1"))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC33 0 (RE2AC_TCC30-1 |nil| 3631365124 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC34 0 (RE2AC_TCC34-1 "" 3789917546 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC31-2 "" 3631566874 ("" (THEN (SKEEP*) (TYPEPRED "res1") (ASSERT) (FLATTEN) (SPREAD (SPLIT 4) ((THEN (EXPAND "compatible_pairs?") (SKEEP -3) (INST 1 "N") (ASSERT)) (THEN (REPLACE -11 :DIR RL) (REPLACE -10 :DIR RL) (PROPAX)) (THEN (REPLACE -11 :DIR RL) (PROPAX))))) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC31-1 |nil| 3631365124 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -12) (("" (APPLY (THEN (LABEL "result" -11) (LABEL "ac2" -10) (LABEL "cache2" -9) (LABEL "newid2" -8) (LABEL "res2" -7) (LABEL "ac1" -6) (LABEL "cache1" -5) (LABEL "newid1" -4) (LABEL "res1" -3) (LABEL "cached" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re2" -1) (LABEL "cache2-form" -2) (LABEL "N2" -3) (LABEL "newid2-prop" -4) (LABEL "cache2-idxs_bound" -5))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re1" -1) (LABEL "cache1-form" -2) (LABEL "N1" -3) (LABEL "newid1-prop" -4) (LABEL "cache1-idxs_bound" -5))) (("" (SPLIT 4) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, mult_ac_ac(ac1, ac2, newid2)), append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[[RealExpr, AffineCombination]]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "next_idx_2") (("2" (EXPAND ">=") (("2" (EXPAND "idxs_bounded") (("2" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (NAME "updN2" "upd_noise(N2,
                                        newid2,
                                        mul_noise_value
                                        (ac1,
                                         ac2,
                                         first_noises(N2, newid2)))") (("1" (INST 2 "updN2") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N2 vars in box comp" "i") (("1" (FLATTEN) (("1" (CASE "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (SPLIT 1) (("1" (REPLACE "N2 vars in box comp" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED "nextfreeidx") (("2" (EXPAND "last_idx_in_box") (("2" (REPLACES -7) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "re") (("1" (ASSERT) (("1" (USE "containment_mul") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (EXPAND "next_idx_2") (("1" (EXPAND ">=") (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (REPLACES -1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                        eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                         eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (EXPAND "nth" "N1 compatible pairs") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (REPLACE "N1 compatible pairs" 1) (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT 1) (("2" (USE "nth_append[[RealExpr, AffineCombination]]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[[RealExpr, AffineCombination]]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (REPLACE "ac1" -1) (("2" (TYPEPRED_RES1) (("2" (EXPAND "idxs_bounded" "cache1-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache1-idxs_bound" -6 "newid2-prop")) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (CASE "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (REPLACES -1) (("1" (INST "N2 compatible pairs" "0") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES -1 :DIR RL) (("4" (USE "first_noises_upd") (("4" (REPLACES -1) (("4" (USE "gnbi_upd") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (INST "N2 compatible pairs" "j") (("2" (CASE "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (ASSERT) NIL NIL) ("2" (REPLACES -3 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "j") (("2" (EXPAND "next_idx") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "mul_noise_value_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) (("4" (HIDE-ALL-BUT (3 -9 -4)) (("4" (EXPAND ">=") (("4" (CASE "nextfreeidx <= newid2") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "nextfreeidx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (ASSERT) (("2" (TYPEPRED "reals.<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "partial_order?") (("2" (EXPAND "preorder?") (("2" (EXPAND "reflexive?") (("2" (EXPAND "transitive?") (("2" (FLATTEN) (("2" (INST -1 "nextfreeidx" "newid1" "newid2") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_mult_ac_ac") (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound")) (("1" (EXPAND ">=") (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC35 0 (RE2AC_TCC32-3 |nil| 3767016267 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) (("" (FLATTEN) (("" (SPLIT 4) (("1" (EXPAND "compatible_pairs?") (("1" (SKEEP -3) (("1" (INST 1 "N") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -10 :DIR RL) (("2" (REPLACE -9 :DIR RL) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC32-2 |nil| 3632068503 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC32-1 |nil| 3631365124 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}"))) (RE2AC_TCC36 0 (RE2AC_TCC33-2 |nil| 3767016325 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|restrict| CONST-DECL "R" |restrict| NIL)) NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "NIL")) (RE2AC_TCC33-1 |nil| 3631466640 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "NIL"))) (RE2AC_TCC37 0 (RE2AC_TCC37-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC38 0 (RE2AC_TCC34-1 |nil| 3631466640 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC39 0 (RE2AC_TCC35-2 |nil| 3631472540 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)")) (RE2AC_TCC35-1 |nil| 3631466640 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC40 0 (RE2AC_TCC36-2 |nil| 3767016447 ("" (SKEEP*) (("" (EXPAND "next_idx_2") (("" (TYPEPRED "res2") (("" (ASSERT) (("" (FLATTEN) (("" (REPLACE -14 :DIR RL) (("" (TYPEPRED "res1") (("" (ASSERT) (("" (FLATTEN) (("" (REPLACES -17) (("" (HIDE-ALL-BUT (6 -10 -5 -11)) (("" (EXPAND "idxs_bounded") (("" (INST -1 "0") (("1" (INST? :SUBST ("i" "0")) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (REVEAL 1) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REVEAL 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|next_idx_2| CONST-DECL "nat" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|cache2| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|odd_plus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|res1| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = re1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid2" "{newidx: naturalnumbers.nat | reals.>=(newidx, affine.next_idx_2(pd(affine_expr_Eval_fnd.ac1), pd(affine_expr_Eval_fnd.ac2)))}")) (RE2AC_TCC36-1 |nil| 3631466640 ("" (TERMINATION-TCC) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid2" "{newidx: naturalnumbers.nat | reals.>=(newidx, affine.next_idx_2(pd(affine_expr_Eval_fnd.ac1), pd(affine_expr_Eval_fnd.ac2)))}"))) (RE2AC_TCC41 0 (RE2AC_TCC41-1 "" 3789917559 ("" (SKEEP*) (("" (GRIND) NIL NIL)) NIL) ((|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC37-3 |nil| 3632068879 ("" (THEN (SKEEP*) (GRIND)) NIL NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC37-2 |nil| 3631550185 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC37-1 |nil| 3631466640 ("" (GRIND) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC42 0 (RE2AC_TCC42-1 "" 3789917564 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE 1) (("" (HIDE -6) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|mult_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|append_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|add_ET| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC38-2 |nil| 3631567697 ("" (THEN (SKEEP*) (ASSERT) (EXPAND "null_ol") (HIDE 1) (HIDE -6) (SPREAD (SPLIT 1) ((GRIND) (THEN (REPLACE -5 1) (ASSERT) (INST 1 "(: (re, acRes,null)::CacheData :)") (GRIND)) (THEN (REPLACE -5 1) (ASSERT) (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (SPREAD (CASE "pow=0") ((THEN (REPLACES -1) (REPLACES -4) (REPLACES -6) (EXPAND "pow_var_ac") (EXPAND "eval_ACExpr_Env") (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "expt_x0") (ASSERT)) (SPREAD (CASE "pow=1") ((THEN (REPLACES -1) (REPLACES -4) (REPLACES -6) (EXPAND "eval_ACExpr_Env" 2) (EXPAND "pow_var_ac" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (REPLACES -6) (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (EXPAND "nth_ac" 1) (EXPAND "vars_in_box_compatible?") (INST -2 "idx") (FLATTEN) (REPLACES -2 1 :DIR RL) (EXPAND "eval_ac_noise") (EXPAND "nth_ac") (SPREAD (CASE "pd(var_ac(nth(box, idx), idx)) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT)) (GRIND)))) (THEN (FLATTEN) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (EXPAND "vars_in_box_compatible?") (INST -2 "idx") (FLATTEN) (REPLACES -2 1 :DIR RL) (REPLACES -6) (EXPAND "eval_ac_noise" 1) (ASSERT) (EXPAND "nth_ac") (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (LIFT-IF -1) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACES -1) (SPREAD (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((THEN (REPLACES -1) (ASSERT) (USE "expt_x1") (REPLACES -1) (USE "expt_x1") (ASSERT)) (THEN (HIDE 3) (SPREAD (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL)) (GRIND)))))))))) (THEN (FLATTEN) (EXPAND "vars_in_box_compatible?") (INST -1 "idx") (FLATTEN) (REPLACES -1 2 :DIR RL) (EXPAND "eval_ac_noise") (ASSERT) (REPLACES -5) (EXPAND "nth_ac") (USE "expt_x1") (REPLACES -1) (USE "expt_x1") (REPLACES -1) (ASSERT) (USE "eval_pd_noise_rec_pds_def") (LIFT-IF -1) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACES -1) (EXPAND_OL) (SPREAD (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((THEN (REPLACES -1) (ASSERT) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "expt_x0") (REPLACES -1) (GRIND)) (THEN (USE "expt_x0") (REPLACES -1) (EXPAND "nth" 1) (SPREAD (TYPEPRED "car(pd
                                                                                                      (var_ac(IF idx = 0 THEN car(box)
                                                                                                              ELSE nth(cdr(box), idx - 1)
                                                                                                              ENDIF,
                                                                                                              idx)))`2") ((THEN (EXPAND "/=") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (GRIND)))))))) (SPREAD (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL)) (GRIND))))))))))))))) (SPREAD (SPLIT -5) ((GRIND) (THEN (REPLACES -7 3) (REPLACES -5 3) (EXPAND "pow_var_ac") (ASSERT) (EXPAND "eval_ACExpr_Env" 3) (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (REPLACES -5) (EXPAND "nth_ac") (EXPAND "vars_in_box_compatible?") (INST -2 "idx") (FLATTEN) (REPLACES -2 3 :DIR RL) (EXPAND "eval_ac_noise") (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (LIFT-IF 3) (SPREAD (SPLIT 3) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (GRIND)))))))))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST -2 "i-1"))))) (THEN (REPLACE -5 1) (ASSERT) (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACES -6) (USE "next_idx_pow_var_ac") (ASSERT) (REPLACES -1) (TYPEPRED "nextfreeidx") (REPLACES -6) (EXPAND "last_idx_in_box") (EXPAND "nth_ac") (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT) (EXPAND "next_idx") (EXPAND "last_idx") (EXPAND "last_ol") (REVEAL 1) (GRIND)) (THEN (FLATTEN) (ASSERT) (GRIND))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST -2 "i-1")))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC38-1 |nil| 3631466640 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -7) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 4) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST 1 "(: val(cached) :)") (("2" (GRIND) NIL NIL)) NIL) ("3" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound"))) (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -2 1 :DIR RL) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache comp pairs" "i-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -2 1 :DIR RL) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC43 0 (RE2AC_TCC43-1 "" 3789917586 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -12) (("" (APPLY (THEN (LABEL "result" -11) (LABEL "ac2" -10) (LABEL "cache2" -9) (LABEL "newid2" -8) (LABEL "res2" -7) (LABEL "ac1" -6) (LABEL "cache1" -5) (LABEL "newid1" -4) (LABEL "res1" -3) (LABEL "cached" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (("" (SPLIT 4) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (EXPAND "next_idx_2") (("3" (EXPAND ">=") (("3" (EXPAND "idxs_bounded") (("3" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (NAME "updN2" "upd_noise(N2,
                                                                                                   newid2,
                                                                                                   mul_noise_value
                                                                                                   (ac1,
                                                                                                    ac2,
                                                                                                    first_noises(N2, newid2)))") (("1" (INST 2 "updN2") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N2 vars in box comp" "i") (("1" (FLATTEN) (("1" (CASE "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (SPLIT 1) (("1" (REPLACE "N2 vars in box comp" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED "nextfreeidx") (("2" (EXPAND "last_idx_in_box") (("2" (REPLACES -7) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (SKEEP) (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "powvar?") (("1" (REPLACES "re") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval") (("1" (USE "containment_mul") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (EXPAND "next_idx_2") (("1" (EXPAND ">=") (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (REPLACES -1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                                                             eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                                                              eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (INST "N1 compatible pairs" "n") (("1" (FLATTEN) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (INST "N1 compatible pairs" "n") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (INST "N2 compatible pairs" "n") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (USE "more_list_props[CacheData].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[[RealExpr, AffineCombination]]") (("2" (ASSERT) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (REPLACE "ac1" -1) (("2" (TYPEPRED_RES1) (("2" (EXPAND "idxs_bounded" "cache1-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache1-idxs_bound" -6 "newid2-prop")) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (CASE "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (REPLACES -1) (("1" (INST "N2 compatible pairs" "0") (("1" (INST "N2 compatible pairs" "n") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES -1 :DIR RL) (("4" (USE "first_noises_upd") (("4" (REPLACES -1) (("4" (USE "gnbi_upd") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (SKEEP) (("2" (INST "N2 compatible pairs" "j") (("2" (INST "N2 compatible pairs" "n") (("2" (FLATTEN) (("2" (CASE "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) (("1" (CASE "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            N2)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 3) (("2" (EXPAND "updN2") (("2" (LEMMA "gnbi_upd_2") (("2" (INST? -1 :WHERE 1) (("2" (ASSERT) (("2" (TYPEPRED "res1") (("2" (ASSERT) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (HIDE-ALL-BUT (-1 "newid2-prop" -5 "newid1" "newid2" -7 -13)) (("2" (REPLACES "newid1") (("2" (REPLACES "newid2") (("2" (EXPAND "nth" -3 1) (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (USE "olidx_car_last[nzBaseType]") (("2" (CASE "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))") (("1" (ASSERT) (("1" (EXPAND "last_idx") (("1" (EXPAND ">=") (("1" (EXPAND ">") (("1" (CASE "last_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (HIDE -3 -4) (("1" (CASE "car_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (HIDE -2 -3) (("1" (EXPAND "car_ol") (("1" (REPLACES -3) (("1" (CASE "val(res1)`1 < nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT (1 "newid2-prop" -1)) (("2" (CASE "val(res1)`1 = val(res2)`1") (("1" (REPLACES -1) NIL NIL) ("2" (CASE "val(res1)`1 < val(res2)`1") (("1" (HIDE-ALL-BUT (-1 -2 2)) (("1" (CASE "transitive?[real](<)") (("1" (EXPAND "transitive?") (("1" (INST? -1 :WHERE 1) (("1" (INST? -1 :WHERE -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "updN2" 1) (("2" (HIDE 3) (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED "i!1") (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "j") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (HIDE 1) (("2" (USE "next_idx_pow_var_ac") (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -4 "cache2-idxs_bound") (("2" (REPLACE -1 "cache2-idxs_bound") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -5 -6)) (("2" (CASE "i!1 = opn(nth(cache2, j)`1) - 2") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (EXPAND ">=") (("1" (USE "both_sides_plus_le1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i!1 < opn(nth(cache2, j)`1) - 2") (("1" (HIDE (-2 1)) (("1" (REPLACES -2 :DIR RL) (("1" (EXPAND ">=") (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache2, j)`3" "opn(nth(cache2, j)`1) - 2" "i!1") (("1" (CASE "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < nth(nth(cache2, j)`3, i!1)") (("1" (HIDE "cache2-idxs_bound") (("1" (HIDE -3) (("1" (NAME-REPLACE "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (("1" (NAME-REPLACE "B" "nth(nth(cache2, j)`3, i!1)") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -3 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "j") (("2" (EXPAND "next_idx") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "mul_noise_value_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) (("4" (HIDE-ALL-BUT (3 "newid2-prop" "newid1-prop")) (("4" (EXPAND ">=") (("4" (CASE "nextfreeidx <= newid2") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "nextfreeidx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (ASSERT) (("2" (TYPEPRED "reals.<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "partial_order?") (("2" (EXPAND "preorder?") (("2" (EXPAND "reflexive?") (("2" (EXPAND "transitive?") (("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_mult_ac_ac") (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound")) (("1" (EXPAND ">=") (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|next_idx_mult_ac_ac| FORMULA-DECL NIL |affine| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((re, mult_ac_ac(ac1, ac2, newid2), null), cache2)))" |affine_expr_Eval_fnd| NIL) (|lt_plus_lt2| FORMULA-DECL NIL |real_props| NIL) (|preorder?| CONST-DECL "bool" |orders| NIL) (|dichotomous?| CONST-DECL "bool" |orders| NIL) (|antisymmetric?| CONST-DECL "bool" |relations| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (|partial_order?| CONST-DECL "bool" |orders| NIL) (|realorder?| CONST-DECL "bool" |real_orders| |reals|) (|total_order?| CONST-DECL "bool" |orders| NIL) (|mul_noise_value_is_Epsilon| JUDGEMENT-TCC NIL |affine| NIL) (|containment_mul| FORMULA-DECL NIL |affine| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|gnbi_upd| FORMULA-DECL NIL |affine| NIL) (|first_noises_upd| FORMULA-DECL NIL |affine| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|l2| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i!1| SKOLEM-CONST-DECL "below(length(cache1))" |affine_expr_Eval_fnd| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|beyond_last_idx_notmember| FORMULA-DECL NIL |affine| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|eval_upd_no_idxs_ac| FORMULA-DECL NIL |affine| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|updN2| SKOLEM-CONST-DECL "{N_: Noise |
   (null_ol?(N2) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = newid2)) AND
    (NOT null_ol?(N2) IMPLIES
      null_ol?(N_) OR
       ((newid2 < car_ol(N2)`1 AND car_ol(N_)`1 = newid2) OR
         (newid2 > car_ol(N2)`1 AND car_ol(N_)`1 = car_ol(N2)`1) OR
          car_ol(N_)`1 >= min(car_ol(N2)`1, newid2)))}" |affine_expr_Eval_fnd| NIL) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|olidx_car_last| FORMULA-DECL NIL |indexed_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|strict_order?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|nth_ol| FORMULA-DECL NIL |ordered_list| |structures|) (|j| SKOLEM-CONST-DECL "int" |affine_expr_Eval_fnd| NIL) (|i!1| SKOLEM-CONST-DECL "below(opn(nth[CacheData](cache2, j)`1) - 1)" |affine_expr_Eval_fnd| NIL) (|both_sides_plus_le1| FORMULA-DECL NIL |real_props| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|get_noise_by_idx| DEF-DECL "Epsilon" |affine| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|eval_pd_noise_rec_pds_def| FORMULA-DECL NIL |affine| NIL) (|lt_idx_strict_order| FORMULA-DECL NIL |indexed_list| |structures|) (|gnbi_upd_2| FORMULA-DECL NIL |affine| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|upd_noise| DEF-DECL "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" |affine| NIL) (|mul_noise_value| CONST-DECL "real" |affine| NIL) (|first_noises| CONST-DECL "Noise" |affine| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ac2| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|ac1| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|next_idx_2| CONST-DECL "nat" |affine| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|newid2| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|append_assoc| FORMULA-DECL NIL |list_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|cache1| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|odd_plus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|cache2| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|mult_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|append_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|add_ET| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC39-3 |nil| 3767016536 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -12) (("" (APPLY (THEN (LABEL "result" -11) (LABEL "ac2" -10) (LABEL "cache2" -9) (LABEL "newid2" -8) (LABEL "res2" -7) (LABEL "ac1" -6) (LABEL "cache1" -5) (LABEL "newid1" -4) (LABEL "res1" -3) (LABEL "cached" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (("" (SPLIT 4) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (EXPAND "next_idx_2") (("3" (EXPAND ">=") (("3" (EXPAND "idxs_bounded") (("3" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (NAME "updN2" "upd_noise(N2,
                                                                                                   newid2,
                                                                                                   mul_noise_value
                                                                                                   (ac1,
                                                                                                    ac2,
                                                                                                    first_noises(N2, newid2)))") (("1" (INST 2 "updN2") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N2 vars in box comp" "i") (("1" (FLATTEN) (("1" (CASE "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (SPLIT 1) (("1" (REPLACE "N2 vars in box comp" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED "nextfreeidx") (("2" (EXPAND "last_idx_in_box") (("2" (REPLACES -7) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (SKEEP) (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "powvar?") (("1" (REPLACES "re") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval") (("1" (USE "containment_mul") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (EXPAND "next_idx_2") (("1" (EXPAND ">=") (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (REPLACES -1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                                                             eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                                                              eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (INST "N1 compatible pairs" "n") (("1" (FLATTEN) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (INST "N1 compatible pairs" "n") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (INST "N2 compatible pairs" "n") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (USE "more_list_props[CacheData].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[[RealExpr, AffineCombination]]") (("2" (REPLACES -1) (("2" (ASSERT) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (REPLACE "ac1" -1) (("2" (TYPEPRED_RES1) (("2" (EXPAND "idxs_bounded" "cache1-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache1-idxs_bound" -6 "newid2-prop")) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (CASE "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (REPLACES -1) (("1" (INST "N2 compatible pairs" "0") (("1" (INST "N2 compatible pairs" "n") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES -1 :DIR RL) (("4" (USE "first_noises_upd") (("4" (REPLACES -1) (("4" (USE "gnbi_upd") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (SKEEP) (("2" (INST "N2 compatible pairs" "j") (("2" (INST "N2 compatible pairs" "n") (("2" (FLATTEN) (("2" (CASE "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) (("1" (CASE "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            N2)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 3) (("2" (EXPAND "updN2") (("2" (LEMMA "gnbi_upd_2") (("2" (INST? -1 :WHERE 1) (("2" (ASSERT) (("2" (TYPEPRED "res1") (("2" (ASSERT) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (HIDE-ALL-BUT (-1 "newid2-prop" -5 "newid1" "newid2" -7 -13)) (("2" (REPLACES "newid1") (("2" (REPLACES "newid2") (("2" (EXPAND "nth" -3 1) (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (USE "olidx_car_last[nzBaseType]") (("2" (CASE "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))") (("1" (ASSERT) (("1" (EXPAND "last_idx") (("1" (EXPAND ">=") (("1" (EXPAND ">") (("1" (CASE "last_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (HIDE -3 -4) (("1" (CASE "car_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (HIDE -2 -3) (("1" (EXPAND "car_ol") (("1" (REPLACES -3) (("1" (CASE "val(res1)`1 < nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT (1 "newid2-prop" -1)) (("2" (CASE "val(res1)`1 = val(res2)`1") (("1" (REPLACES -1) NIL NIL) ("2" (CASE "val(res1)`1 < val(res2)`1") (("1" (HIDE-ALL-BUT (-1 -2 2)) (("1" (CASE "transitive?[real](<)") (("1" (EXPAND "transitive?") (("1" (INST? -1 :WHERE 1) (("1" (INST? -1 :WHERE -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "updN2" 1) (("2" (HIDE 3) (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED "i!1") (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "j") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (HIDE 1) (("2" (USE "next_idx_pow_var_ac") (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -4 "cache2-idxs_bound") (("2" (REPLACE -1 "cache2-idxs_bound") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -5 -6)) (("2" (CASE "i!1 = opn(nth(cache2, j)`1) - 2") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (EXPAND ">=") (("1" (USE "both_sides_plus_le1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i!1 < opn(nth(cache2, j)`1) - 2") (("1" (HIDE (-2 1)) (("1" (REPLACES -2 :DIR RL) (("1" (EXPAND ">=") (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache2, j)`3" "opn(nth(cache2, j)`1) - 2" "i!1") (("1" (CASE "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < nth(nth(cache2, j)`3, i!1)") (("1" (HIDE "cache2-idxs_bound") (("1" (HIDE -3) (("1" (NAME-REPLACE "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (("1" (NAME-REPLACE "B" "nth(nth(cache2, j)`3, i!1)") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -3 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "j") (("2" (EXPAND "next_idx") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "mul_noise_value_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) (("4" (HIDE-ALL-BUT (3 "newid2-prop" "newid1-prop")) (("4" (EXPAND ">=") (("4" (CASE "nextfreeidx <= newid2") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "nextfreeidx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (ASSERT) (("2" (TYPEPRED "reals.<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "partial_order?") (("2" (EXPAND "preorder?") (("2" (EXPAND "reflexive?") (("2" (EXPAND "transitive?") (("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_mult_ac_ac") (("1" (EXPAND ">=") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound")) (("1" (EXPAND ">=") (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC39-2 |nil| 3632069106 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC39-1 |nil| 3631466640 ("" (GRIND) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC44 0 (RE2AC_TCC44-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC45 0 (RE2AC_TCC40-3 |nil| 3632069583 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC40-2 |nil| 3632069241 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -12) (("" (APPLY (THEN (LABEL "result" -11) (LABEL "ac2" -10) (LABEL "cache2" -9) (LABEL "newid2" -8) (LABEL "res2" -7) (LABEL "ac1" -6) (LABEL "cache1" -5) (LABEL "newid1" -4) (LABEL "res1" -3) (LABEL "cached" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re2" -1) (LABEL "cache2-form" -2) (LABEL "N2" -3) (LABEL "newid2-prop" -4) (LABEL "cache2-idxs_bound" -5) (LABEL "cache2 correct" -6))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN) (LABEL "re1" -1) (LABEL "cache1-form" -2) (LABEL "N1" -3) (LABEL "newid1-prop" -4) (LABEL "cache1-idxs_bound" -5) (LABEL "cache1 correct" -6))) (("" (SPLIT 4) (("1" (GRIND) NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL))))))) ("2" (GRIND) NIL) ("3" (EXPAND "next_idx_2") (("3" (EXPAND ">=") (("3" (EXPAND "idxs_bounded") (("3" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL))))) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL))))))))))))))))))) ("2" (GRIND) NIL))))))) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL))))))))))))))))))))))))))))) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (NAME "updN2" "upd_noise(N2,
                                                                   newid2,
                                                                   mul_noise_value
                                                                   (ac1,
                                                                    ac2,
                                                                    first_noises(N2, newid2)))") (("1" (INST 2 "updN2") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N2 vars in box comp" "i") (("1" (FLATTEN) (("1" (CASE "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (SPLIT 1) (("1" (REPLACE "N2 vars in box comp" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (ASSERT) NIL))))))))))))))))))))))))))))))) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (ASSERT) NIL))))))))))))))))))))))))) ("2" (FLATTEN) (("2" (ASSERT) NIL))))) ("2" (TYPEPRED "i") (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED "nextfreeidx") (("2" (EXPAND "last_idx_in_box") (("2" (REPLACES -7) (("2" (ASSERT) NIL))))))))))))))))))))))))) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "re") (("1" (ASSERT) (("1" (USE "containment_mul") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (EXPAND "next_idx_2") (("1" (EXPAND ">=") (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (EXPAND "max") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (PROPAX) NIL))))) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (GRIND) NIL))))))))))))))))))) ("2" (GRIND) NIL))))))) ("2" (GRIND) NIL))))))))))) ("2" (CASE "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (REPLACES -1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                 eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                  eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (FLATTEN) (("1" (EXPAND "nth") (("1" (PROPAX) NIL))))) ("2" (EXPAND "length") (("2" (ASSERT) NIL))))))))))) ("2" (EXPAND "length") (("2" (ASSERT) NIL))))))) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL))))))) ("2" (HIDE-ALL-BUT 1) (("2" (USE "nth_append[CacheData]") (("2" (ASSERT) NIL))))))) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[[RealExpr, AffineCombination]]") (("2" (REPLACES -1) (("2" (ASSERT) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL))))))))))))))))))))))))))))))))))))) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (REPLACE "ac1" -1) (("2" (TYPEPRED_RES1) (("2" (EXPAND "idxs_bounded" "cache1-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache1-idxs_bound" -7 "newid2-prop")) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL))))))))) ("2" (GRIND) NIL))))))))))))))))))))))) ("3" (CASE "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (REPLACES -1) (("1" (INST "N2 compatible pairs" "0") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) NIL))) ("2" (EXPAND "length") (("2" (ASSERT) NIL))))))) ("2" (HIDE 2) (("2" (REPLACES -1 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (EXPAND "next_idx") (("1" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) NIL))))))))) ("2" (GRIND) NIL))))))))))))))))))) ("4" (REPLACES -1 :DIR RL) (("4" (USE "first_noises_upd") (("4" (REPLACES -1) (("4" (USE "gnbi_upd") NIL))))))))))))))))))))))))))))) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (INST "N2 compatible pairs" "j") (("2" (FLATTEN) (("2" (CASE "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) (("1" (CASE "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache2, j)`1))),
                                                                  0)`1,
                                                              updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache2, j)`1))),
                                                                  0)`1,
                                                              N2)") (("1" (REPLACES -1) NIL) ("2" (HIDE 3) (("2" (EXPAND "updN2") (("2" (LEMMA "gnbi_upd_2") (("2" (INST? -1 :WHERE 1) (("2" (ASSERT) (("2" (TYPEPRED "res1") (("2" (ASSERT) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (HIDE-ALL-BUT (-1 "newid2-prop" -5 "newid1" "newid2" -8 -13)) (("2" (REPLACES "newid1") (("2" (REPLACES "newid2") (("2" (EXPAND "nth" -3 1) (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (USE "olidx_car_last[nzBaseType]") (("2" (CASE "NOT null?(pd(nth_ac(box, varidx(nth(cache2, j)`1))))") (("1" (ASSERT) (("1" (EXPAND "last_idx") (("1" (EXPAND ">=") (("1" (EXPAND ">") (("1" (CASE "last_ol(pd(nth_ac(box, varidx(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (HIDE -3 -4) (("1" (CASE "car_ol(pd(nth_ac(box, varidx(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (HIDE -2 -3) (("1" (EXPAND "car_ol") (("1" (REPLACES -3) (("1" (CASE "val(res1)`1 < nextfreeidx") (("1" (ASSERT) NIL) ("2" (HIDE-ALL-BUT (1 -4 -1)) (("2" (CASE "val(res1)`1 = val(res2)`1") (("1" (REPLACES -1) NIL) ("2" (CASE "val(res1)`1 < val(res2)`1") (("1" (HIDE-ALL-BUT (-1 -2 2)) (("1" (CASE "transitive?[real](<)") (("1" (EXPAND "transitive?") (("1" (INST? -1 :WHERE 1) (("1" (INST? -1 :WHERE -2) (("1" (ASSERT) NIL))))))) ("2" (GRIND) NIL))))) ("2" (ASSERT) NIL))))))))))))))) ("2" (ASSERT) NIL))))) ("2" (ASSERT) NIL))))))))))) ("2" (REVEAL -14) (("2" (HIDE-ALL-BUT (-1 -2)) (("2" (EXPAND "length") (("2" (ASSERT) NIL))))))))))))))))))))))))))))))))))))))))))))) ("2" (EXPAND "updN2" 1) (("2" (HIDE 3) (("2" (USE "gnbi_upd_2") (("2" (ASSERT) (("2" (TYPEPRED "i!1") (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "j") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (HIDE 1) (("2" (USE "next_idx_pow_var_ac") (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL))) ("2" (FLATTEN) (("2" (REPLACE -4 "cache2-idxs_bound") (("2" (REPLACE -1 "cache2-idxs_bound") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -5 -6)) (("2" (USE "nth_ol[nat,<]") (("2" (REPLACES -3) (("2" (EXPAND ">=") (("2" (HIDE -2) (("2" (CASE "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < newid2") (("1" (HIDE -3) (("1" (NAME-REPLACE "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (("1" (USE "tri_unique_lt1") (("1" (ASSERT) NIL))))))) ("2" (ASSERT) NIL))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (REPLACES -3 1 :DIR RL) (("2" (USE "eval_upd_no_idxs_ac") (("2" (ASSERT) (("2" (HIDE 1) (("2" (EXPAND "idxs_bounded" "cache2-idxs_bound") (("2" (EXPAND "idxs_ac") (("2" (INST "cache2-idxs_bound" "j") (("2" (EXPAND "next_idx") (("2" (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) NIL))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (USE "mul_noise_value_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL))))))))))))) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) (("4" (HIDE-ALL-BUT (3 "newid2-prop" "newid1-prop")) (("4" (EXPAND ">=") (("4" (CASE "nextfreeidx <= newid2") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "nextfreeidx") (("1" (ASSERT) NIL))))))) ("2" (HIDE 2) (("2" (ASSERT) (("2" (TYPEPRED "reals.<=") (("2" (EXPAND "total_order?") (("2" (EXPAND "partial_order?") (("2" (EXPAND "preorder?") (("2" (EXPAND "reflexive?") (("2" (EXPAND "transitive?") (("2" (FLATTEN) (("2" (INST -1 "nextfreeidx" "newid1" "newid2") (("2" (SPLIT -1) (("1" (PROPAX) NIL) ("2" (PROPAX) NIL) ("3" (PROPAX) NIL))))))))))))))))))))))))))))))))))))) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_mult_ac_ac") (("1" (EXPAND ">=") (("1" (PROPAX) NIL))))))))) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound")) (("1" (EXPAND ">=") (("1" (LEMMA "lt_plus_lt2") (("1" (INST -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (ASSERT) NIL))))))))))) ("2" (TYPEPRED "i") (("2" (GRIND) NIL))))))))))))))))))) ("6" (REPLACES "result") (("6" (ASSERT) (("6" (EXPAND "correct_cache?" 1) (("6" (TYPEPRED_RES2) (("6" (ASSERT) (("6" (EXPAND "CacheData_correct?") (("6" (PROPAX) NIL)))))))))))))))))))))))))) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC40-1 |nil| 3631466640 ("" (GRIND)) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC46 0 (RE2AC_TCC46-1 "" 3789917590 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC41-1 |nil| 3631466640 ("" (THEN (SKEEP*) (ASSERT) (HIDE -7) (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (REPLACES "re") (REPLACES "result") (ASSERT) (SPREAD (SPLIT 4) ((THEN (INST 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (GRIND)) (THEN (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound"))) (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (SKEEP) (REPLACES -3 1 :DIR RL) (INST?) (REPLACES "cache comp pairs") (SPREAD (CASE "nth(cache, i!1)`1 = POWVAR(idx, pow)") ((ASSERT) (THEN (HIDE 2) (REVEAL -3 "re") (REPLACES "re") (ASSERT) (REPLACES -1) (HIDE-ALL-BUT (1 "pow is cached" -1)) (TYPEPRED "val(cached)`1") (APPLY-EXTENSIONALITY 1))))) (SPREAD (INST "cache comp pairs" "i-1") ((THEN (EXPAND "nth" 2) (ASSERT)) (THEN (TYPEPRED "i") (GRIND))))))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (SKEEP) (REPLACES -3 1 :DIR RL) (INST?)) (THEN (EXPAND "nth" 2) (ASSERT) (INST?)))))))) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC47 0 (RE2AC_TCC47-1 "" 3789917591 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE 1) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC42-2 |nil| 3631569740 ("" (THEN (SKEEP*) (ASSERT) (HIDE 1) (HIDE -6) (GRIND)) NIL NIL) NIL NIL (RE2AC SUBTYPE "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC42-1 |nil| 3631466640 ("" (SUBTYPE-TCC) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC48 0 (RE2AC_TCC48-1 "" 3789917592 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "result" -11) (LABEL "ac2" -10) (LABEL "cache2" -9) (LABEL "newid2" -8) (LABEL "res2" -7) (LABEL "ac1" -6) (LABEL "cache1" -5) (LABEL "newid1" -4) (LABEL "res1" -3) (LABEL "cached" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC43-1 |nil| 3631466640 ("" (THEN (SKEEP*) (ASSERT) (HIDE -12) (APPLY (THEN (LABEL "result" -11) (LABEL "ac2" -10) (LABEL "cache2" -9) (LABEL "newid2" -8) (LABEL "res2" -7) (LABEL "ac1" -6) (LABEL "cache1" -5) (LABEL "newid1" -4) (LABEL "res1" -3) (LABEL "cached" -2) (LABEL "re" -1))) (DEFTACTIC TYPEPRED_RES2 NIL (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (DEFTACTIC TYPEPRED_RES1 NIL (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (WITH-LABELS (FLATTEN) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (SPREAD (SPLIT 4) ((GRIND) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES1) (TYPEPRED_RES2) (SKOLEM "cache2-form" "l2") (SKOLEM "cache1-form" "l1") (REPLACE "cache1-form" "cache2-form") (REPLACE "cache2-form" 3) (SPREAD (INST 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") ((THEN (HIDE-ALL-BUT 3) (EXPAND "append" 1 3) (USE "append_assoc[CacheData]") (ASSERT)) (GRIND) (THEN (EXPAND "next_idx_2") (EXPAND ">=") (EXPAND "idxs_bounded") (SPREAD (INST "cache1-idxs_bound" "0") ((THEN (EXPAND "nth" "cache1-idxs_bound") (REPLACE "ac1" :DIR RL) (SPREAD (INST "cache2-idxs_bound" "0") ((THEN (EXPAND "nth" "cache2-idxs_bound") (REPLACE "ac2" :DIR RL) (HIDE-ALL-BUT (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (EXPAND "max") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND ">=") (PROPAX)) (THEN (FLATTEN) (ASSERT) (EXPAND ">=") (GRIND))))) (GRIND)))) (THEN (HIDE-ALL-BUT (1 4)) (GRIND)))))))) (THEN (TYPEPRED_RES2) (SKOLEM "N2" "N2") (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (SPREAD (NAME "updN2" "upd_noise(N2,
                                                                                       newid2,
                                                                                       mul_noise_value
                                                                                       (ac1,
                                                                                        ac2,
                                                                                        first_noises(N2, newid2)))") ((THEN (INST 2 "updN2") (SPREAD (SPLIT 2) ((THEN (EXPAND "vars_in_box_compatible?") (SKEEP) (INST "N2 vars in box comp" "i") (FLATTEN) (SPREAD (CASE "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") ((SPREAD (SPLIT 1) ((THEN (REPLACE "N2 vars in box comp" 1 :DIR RL) (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (ASSERT)) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (ASSERT) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (ASSERT))))) (THEN (FLATTEN) (ASSERT)))) (THEN (TYPEPRED "i") (USE "gnbi_upd_2") (ASSERT) (TYPEPRED_RES1) (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (REPLACES -7) (ASSERT))))) (THEN (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (SKEEP) (REPLACES -1) (EXPAND "nth" 1) (REPLACE "result") (ASSERT) (EXPAND "powvar?") (REPLACES "re") (EXPAND "eval_ACExpr_Env" 1) (EXPAND "eval") (USE "containment_mul") (ASSERT) (HIDE 2) (SPREAD (SPLIT 1) ((THEN (TYPEPRED_RES1) (EXPAND "next_idx_2") (EXPAND ">=") (EXPAND "idxs_bounded") (SPREAD (INST "cache1-idxs_bound" "0") ((THEN (EXPAND "nth" "cache1-idxs_bound") (REPLACE "ac1" :DIR RL) (SPREAD (INST "cache2-idxs_bound" "0") ((THEN (EXPAND "nth" "cache2-idxs_bound") (REPLACE "ac2" :DIR RL) (HIDE-ALL-BUT (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (EXPAND "max") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND ">=") (PROPAX)) (THEN (FLATTEN) (ASSERT) (EXPAND ">=") (GRIND))))) (GRIND)))) (GRIND)))) (SPREAD (CASE "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") ((THEN (REPLACES -1) (TYPEPRED_RES1) (REPLACES "re1" :DIR RL) (SKOLEM "N1" "N1") (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (SPREAD (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                                   eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                                    eval_ac_noise(nth(cache1, i)`2, N1)") ((THEN (REPLACE "ac1") (SPREAD (INST -1 "0") ((THEN (EXPAND "nth" -1) (REPLACES -1) (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SPREAD (INST "N1 compatible pairs" "0") ((THEN (INST "N1 compatible pairs" "n") (FLATTEN) (EXPAND "nth") (GRIND)) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SKEEP) (INST "N1 compatible pairs" "i!1") (INST "N1 compatible pairs" "n") (SKOLEM "cache2-form" "l2") (REPLACE "cache2-form" "N2 compatible pairs") (SPREAD (INST "N2 compatible pairs" "length(l2)+i!1") ((THEN (INST "N2 compatible pairs" "n") (SPREAD (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((THEN (ASSERT) (FLATTEN) (REPLACES -1) (ASSERT)) (THEN (HIDE-ALL-BUT 1) (USE "more_list_props[CacheData].nth_append") (ASSERT))))) (THEN (REPLACE "cache2-form" 1) (USE "length_append[[RealExpr, AffineCombination]]") (REPLACES -1) (ASSERT) (USE "length_append[CacheData]") (REPLACES -1) (ASSERT)))))))) (THEN (HIDE 2) (REPLACES -1 1 :DIR RL) (USE "eval_upd_no_idxs_ac") (ASSERT) (HIDE 1) (REPLACE "ac1" -1) (TYPEPRED_RES1) (EXPAND "idxs_bounded" "cache1-idxs_bound") (EXPAND "idxs_ac") (SPREAD (INST "cache1-idxs_bound" "0") ((THEN (EXPAND "nth" "cache1-idxs_bound") (EXPAND "next_idx") (HIDE-ALL-BUT ("cache1-idxs_bound" -6 "newid2-prop")) (USE "beyond_last_idx_notmember") (ASSERT)) (GRIND)))))) (SPREAD (CASE "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") ((THEN (REPLACES -1) (SPREAD (INST "N2 compatible pairs" "0") ((THEN (INST "N2 compatible pairs" "n") (EXPAND "nth" "N2 compatible pairs") (ASSERT) (EXPAND "length") (GRIND)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE 2) (REPLACES -1 1 :DIR RL) (USE "eval_upd_no_idxs_ac") (ASSERT) (HIDE 1) (EXPAND "idxs_bounded" "cache2-idxs_bound") (EXPAND "idxs_ac") (SPREAD (INST "cache2-idxs_bound" "0") ((THEN (EXPAND "nth" "cache2-idxs_bound") (EXPAND "next_idx") (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (USE "beyond_last_idx_notmember") (ASSERT)) (GRIND)))))) (THEN (REPLACES -1 :DIR RL) (USE "first_noises_upd") (REPLACES -1) (USE "gnbi_upd"))))) (THEN (NAME "j" "i-1") (TYPEPRED "i") (EXPAND "length" -1) (EXPAND "nth" 2) (ASSERT) (REPLACE -2) (REPLACE "result") (ASSERT) (SKEEP) (INST "N2 compatible pairs" "j") (INST "N2 compatible pairs" "n") (FLATTEN) (SPREAD (CASE "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") ((THEN (ASSERT) (FLATTEN) (ASSERT) (EXPAND "pow_var_compatible?") (FLATTEN) (ASSERT) (SKEEP) (INST?) (SPREAD (CASE "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") ((THEN (REPLACES -1) (SPREAD (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                     0)`1,
                                                                                                                                                 updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                     0)`1,
                                                                                                                                                 N2)") ((REPLACES -1) (THEN (HIDE 3) (EXPAND "updN2") (LEMMA "gnbi_upd_2") (INST? -1 :WHERE 1) (ASSERT) (TYPEPRED "res1") (ASSERT) (FLATTEN) (TYPEPRED "nextfreeidx") (HIDE-ALL-BUT (-1 "newid2-prop" -5 "newid1" "newid2" -7 -13)) (REPLACES "newid1") (REPLACES "newid2") (EXPAND "nth" -3 1) (USE "last_idx_box") (EXPAND "next_idx") (USE "olidx_car_last[nzBaseType]") (SPREAD (CASE "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))") ((THEN (ASSERT) (EXPAND "last_idx") (EXPAND ">=") (EXPAND ">") (SPREAD (CASE "last_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") ((THEN (HIDE -3 -4) (SPREAD (CASE "car_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") ((THEN (HIDE -2 -3) (EXPAND "car_ol") (REPLACES -3) (SPREAD (CASE "val(res1)`1 < nextfreeidx") ((ASSERT) (THEN (HIDE-ALL-BUT (1 "newid2-prop" -1)) (SPREAD (CASE "val(res1)`1 = val(res2)`1") ((REPLACES -1) (SPREAD (CASE "val(res1)`1 < val(res2)`1") ((THEN (HIDE-ALL-BUT (-1 -2 2)) (SPREAD (CASE "transitive?[real](<)") ((THEN (EXPAND "transitive?") (INST? -1 :WHERE 1) (INST? -1 :WHERE -2) (ASSERT)) (GRIND)))) (ASSERT))))))))) (ASSERT)))) (ASSERT)))) (THEN (EXPAND "length") (ASSERT)))))))) (THEN (EXPAND "updN2" 1) (HIDE 3) (USE "gnbi_upd_2") (ASSERT) (TYPEPRED "i!1") (EXPAND "idxs_bounded") (INST "cache2-idxs_bound" "j") (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (FLATTEN) (HIDE 1) (USE "next_idx_pow_var_ac") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACE -4 "cache2-idxs_bound") (REPLACE -1 "cache2-idxs_bound") (HIDE-ALL-BUT ("cache2-idxs_bound" -5 -6)) (SPREAD (CASE "i!1 = opn(nth(cache2, j)`1) - 2") ((THEN (HIDE -2) (REPLACES -1) (REPLACES -1) (EXPAND ">=") (USE "both_sides_plus_le1") (ASSERT)) (SPREAD (CASE "i!1 < opn(nth(cache2, j)`1) - 2") ((THEN (HIDE (-2 1)) (REPLACES -2 :DIR RL) (EXPAND ">=") (LEMMA "nth_ol[nat,<]") (INST -1 "nth(cache2, j)`3" "opn(nth(cache2, j)`1) - 2" "i!1") (SPREAD (CASE "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < nth(nth(cache2, j)`3, i!1)") ((THEN (HIDE "cache2-idxs_bound") (HIDE -3) (NAME-REPLACE "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (NAME-REPLACE "B" "nth(nth(cache2, j)`3, i!1)") (GRIND)) (GRIND)))) (ASSERT))))))))))))))) (THEN (REPLACES -3 1 :DIR RL) (USE "eval_upd_no_idxs_ac") (ASSERT) (HIDE 1) (EXPAND "idxs_bounded" "cache2-idxs_bound") (EXPAND "idxs_ac") (INST "cache2-idxs_bound" "j") (EXPAND "next_idx") (HIDE-ALL-BUT ("cache2-idxs_bound" -1)) (USE "beyond_last_idx_notmember") (ASSERT))))))))))) (THEN (USE "mul_noise_value_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES2) (TYPEPRED_RES1) (HIDE-ALL-BUT (3 "newid2-prop" "newid1-prop")) (EXPAND ">=") (SPREAD (CASE "nextfreeidx <= newid2") ((THEN (HIDE-ALL-BUT (-1 1)) (LEMMA "lt_plus_lt2") (INST -1 "newid2" "0" "1" "nextfreeidx") (ASSERT)) (THEN (HIDE 2) (ASSERT) (TYPEPRED "reals.<=") (EXPAND "total_order?") (EXPAND "partial_order?") (EXPAND "preorder?") (EXPAND "reflexive?") (EXPAND "transitive?") (FLATTEN) (GRIND))))) (THEN (REPLACES "result") (ASSERT) (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (USE "next_idx_mult_ac_ac") (EXPAND ">=") (PROPAX)) (THEN (TYPEPRED_RES2) (EXPAND "idxs_bounded") (SPREAD (INST "cache2-idxs_bound" "i-1") ((THEN (EXPAND "nth" 3) (HIDE-ALL-BUT (3 "cache2-idxs_bound")) (EXPAND ">=") (LEMMA "lt_plus_lt2") (INST -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (ASSERT)) (THEN (TYPEPRED "i") (GRIND))))))))))) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC49 0 (RE2AC_TCC44-2 |nil| 3767017620 ("" (SKEEP*) (("" (REPLACES -7) (("" (ASSERT) (("" (EXPAND "correct_cache?") (("" (EXPAND "CacheData_correct?") (("" (FLATTEN) (("" (SPLIT 2) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC44-1 |nil| 3631466640 ("" (THEN (SKEEP*) (ASSERT) (EXPAND "null_ol") (HIDE 1) (HIDE -6) (SPREAD (SPLIT 1) ((GRIND) (THEN (REPLACE -5 1) (ASSERT) (INST 1 "(: (re, acRes,null)::CacheData :)") (GRIND)) (THEN (REPLACE -5 1) (ASSERT) (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (SPREAD (CASE "pow=0") ((THEN (REPLACES -1) (REPLACES -5) (REPLACES -7) (EXPAND "pow_var_ac") (EXPAND "eval_ACExpr_Env" 1) (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "expt_x0") (ASSERT) (EXPAND "pow_var_compatible?" 1) (GRIND)) (SPREAD (CASE "pow=1") ((THEN (REPLACES -1) (REPLACES -5) (REPLACES -7) (EXPAND "eval_ACExpr_Env" 2) (EXPAND "pow_var_ac" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (REPLACES -7) (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (EXPAND "nth_ac" 1) (EXPAND "vars_in_box_compatible?") (INST -2 "idx") (FLATTEN) (REPLACES -2 1 :DIR RL) (EXPAND "eval_ac_noise") (EXPAND "nth_ac") (SPREAD (CASE "pd(var_ac(nth(box, idx), idx)) = null") ((THEN (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (ASSERT) (EXPAND "pow_var_compatible?") (GRIND)) (THEN (EXPAND "ordered_list?") (PROPAX))))) (THEN (HIDE-ALL-BUT (-1 1)) (EXPAND "length") (ASSERT))))) (THEN (FLATTEN) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (EXPAND "vars_in_box_compatible?") (INST -2 "idx") (FLATTEN) (REPLACES -2 1 :DIR RL) (REPLACES -7) (EXPAND "eval_ac_noise" 1) (ASSERT) (EXPAND "nth_ac") (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (LIFT-IF -1) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACES -1) (SPREAD (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((THEN (REPLACES -1) (ASSERT) (USE "expt_x1") (REPLACES -1) (LEMMA "expt_x1") (INST? -1 :WHERE 2) (ASSERT) (EXPAND "pow_var_compatible?") (GRIND)) (THEN (HIDE 3) (SPREAD (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL)) (GRIND)))) (THEN (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (EXPAND "ordered_list?" -1) (ASSERT) (EXPAND "ordered_list?") (PROPAX)) (THEN (EXPAND "length") (ASSERT)))))))) (THEN (FLATTEN) (EXPAND "vars_in_box_compatible?") (INST -1 "idx") (FLATTEN) (REPLACES -1 2 :DIR RL) (EXPAND "eval_ac_noise") (ASSERT) (REPLACES -6) (EXPAND "nth_ac") (USE "expt_x1") (REPLACES -1) (USE "expt_x1") (REPLACES -1) (ASSERT) (USE "eval_pd_noise_rec_pds_def") (LIFT-IF -1) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACES -1) (EXPAND_OL) (SPREAD (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((THEN (REPLACES -1) (ASSERT) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "expt_x0") (REPLACES -1) (GRIND)) (THEN (EXPAND "ordered_list?") (PROPAX))))) (THEN (USE "expt_x0") (REPLACES -1) (EXPAND "nth" 1) (SPREAD (TYPEPRED "car(pd
                                                                                                                          (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                  ELSE nth(cdr(box), idx - 1)
                                                                                                                                  ENDIF,
                                                                                                                                  idx)))`2") ((THEN (EXPAND "/=") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (GRIND))))) (THEN (USE "expt_x0") (REPLACES -1) (EXPAND "nth" 1) (SPREAD (TYPEPRED "car(pd
                                                                                                                                              (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                      ELSE nth(cdr(box), idx - 1)
                                                                                                                                                      ENDIF,
                                                                                                                                                      idx)))`2") ((THEN (EXPAND "/=") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (GRIND)))))))) (SPREAD (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL)) (GRIND))) (THEN (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (EXPAND "ordered_list?" -1) (ASSERT) (EXPAND "ordered_list?") (PROPAX)) (THEN (EXPAND "length") (ASSERT)))))))))))))) (SPREAD (SPLIT -6) ((GRIND) (THEN (REPLACES -8 3) (REPLACES -6 3) (EXPAND "pow_var_ac") (ASSERT) (EXPAND "eval_ACExpr_Env" 3) (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (REPLACES -6) (EXPAND "nth_ac") (EXPAND "vars_in_box_compatible?") (INST -2 "idx") (FLATTEN) (REPLACES -2 3 :DIR RL) (EXPAND "eval_ac_noise") (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (LIFT-IF 3) (SPREAD (SPLIT 3) ((THEN (FLATTEN) (ASSERT) (EXPAND "pow_var_compatible?") (PROPAX)) (THEN (FLATTEN) (GRIND)))))))))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST -2 "i-1") (TYPEPRED "i") (GRIND))))) (THEN (REPLACE -5 1) (ASSERT) (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACES -7) (USE "next_idx_pow_var_ac") (ASSERT) (REPLACES -1) (TYPEPRED "nextfreeidx") (REPLACES -7) (EXPAND "last_idx_in_box") (EXPAND "nth_ac") (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT) (EXPAND "next_idx") (EXPAND "last_idx") (EXPAND "last_ol") (REVEAL 1) (GRIND)) (THEN (FLATTEN) (ASSERT) (GRIND))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST -2 "i-1"))))) (THEN (REPLACES -5) (ASSERT) (EXPAND "correct_cache?") (EXPAND "CacheData_correct?") (REPLACES -1) (REVEAL 1) (ASSERT) (SPREAD (SPLIT -1) ((THEN (EXPAND "length" 2 1) (FLATTEN) (ASSERT)) (THEN (FLATTEN) (ASSERT)))))))) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC50 0 (RE2AC_TCC50-2 "" 3803766472 ("" (SKEEP*) (("" (ASSERT) (("" (EXPAND "null_ol") (("" (HIDE 1) (("" (HIDE -6) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (ASSERT) (("2" (INST 1 "(: (re, acRes,null)::CacheData :)") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (ASSERT) (("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP* 1) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (CASE "pow=0") (("1" (REPLACE -11) (("1" (ASSERT) (("1" (REPLACE -6) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (REVEAL -2) (("1" (REPLACES -2) (("1" (REPLACES -1) (("1" (EXPAND "pow_var_ac") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval") (("1" (EXPAND "eval_ac_noise") (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x0") (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "pow=1") (("1" (REPLACE -11) (("1" (ASSERT) (("1" (REVEAL -2) (("1" (REPLACES -2) (("1" (REPLACES -6) (("1" (REPLACES -1) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (EXPAND "eval") (("1" (EXPAND "pow_var_ac" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (EXPAND "eval" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (FLATTEN) (("1" (REPLACES -8) (("1" (EXPAND "eval_ac_noise" 1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("1" (INST "vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (REPLACES "eval varac is vs" 1 :DIR RL) (("1" (EXPAND "eval_ac_noise" 1) (("1" (EXPAND "nth_ac" -1) (("1" (CASE "pd(var_ac(nth(box, idx), idx)) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "powvar?" 1) (("2" (EXPAND "varidx_powvar" 1) (("2" (EXPAND "eval") (("2" (REPLACE -6 1 :DIR RL) (("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("1" (INST "vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (REPLACES "eval varac is vs" 1 :DIR RL) (("1" (REPLACES -8) (("1" (EXPAND "eval_ac_noise" 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac" -1) (("1" (EXPAND "nth_ac" (1 -1)) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x1") (("1" (REPLACES -1) (("1" (LEMMA "expt_x1") (("1" (INST? -1 :WHERE 2) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (EXPAND "ordered_list?" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("2" (INST "vars in box" "idx") (("2" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (REPLACES "eval varac is vs" 2 :DIR RL) (("2" (EXPAND "eval_ac_noise" 2) (("2" (ASSERT) (("2" (REPLACES -7) (("2" (EXPAND "nth_ac" 1) (("2" (USE "expt_x1") (("2" (REPLACES -1) (("2" (USE "expt_x1") (("2" (REPLACES -1) (("2" (ASSERT) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (EXPAND_OL) (("2" (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x0") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "ordered_list?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (USE "expt_x0") (("3" (REPLACES -1) (("3" (EXPAND "nth" 1) (("3" (TYPEPRED "car(pd
                                                                                                                                                                                                                                        (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                                                                                ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                                                                                ENDIF,
                                                                                                                                                                                                                                                idx)))`2") (("1" (EXPAND "/=") (("1" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "idx") (("2" (GRIND) NIL NIL)) NIL) ("3" (FLATTEN) (("3" (TYPEPRED "idx") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (FLATTEN) (("4" (GRIND) NIL NIL)) NIL) ("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (EXPAND "ordered_list?" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SPLIT -9) (("1" (GRIND) NIL NIL) ("2" (REVEAL -2) (("2" (REPLACE -11) (("2" (ASSERT) (("2" (REPLACE -1) (("2" (REPLACE -7) (("2" (EXPAND "powvar?" 3) (("2" (EXPAND "varidx_powvar" 3) (("2" (EXPAND "pow_var_ac") (("2" (ASSERT) (("2" (EXPAND "eval_ACExpr_Env" 3) (("2" (EXPAND "eval" 3) (("2" (EXPAND "eval" 3) (("2" (REPLACE -9 3 :DIR RL) (("2" (EXPAND "eval_ac_noise") (("2" (ASSERT) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (ASSERT) (("2" (REPLACES -10) (("2" (EXPAND "nth_ac") (("2" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("2" (INST "vars in box" "idx") (("2" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (REPLACES "eval varac is vs" 3 :DIR RL) (("2" (EXPAND "eval_ac_noise" 3) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -10 :HIDE? T) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST -3 "i-1") (("1" (INST -3 "n") NIL NIL) ("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (REVEAL -11) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACE -6 1) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REVEAL -2) (("1" (REPLACES -1) (("1" (USE "next_idx_pow_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (TYPEPRED "nextfreeidx") (("1" (REPLACES -8) (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (EXPAND "last_ol") (("2" (REVEAL 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST? :SUBST ("i" "i-1")) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|result| SKOLEM-CONST-DECL "[{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}, (cons?)]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(result`2))" |affine_expr_Eval_fnd| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|eval_pd_noise_rec_pds_def| FORMULA-DECL NIL |affine| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|expt_x0| FORMULA-DECL NIL |exponentiation| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|ac_proj_cv| FORMULA-DECL NIL |affine| NIL) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|expt_x1| FORMULA-DECL NIL |exponentiation| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|get_noise_by_idx| DEF-DECL "Epsilon" |affine| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|eval_pd_noise| DEF-DECL "real" |affine| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|idx| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC50-1 "" 3789917649 ("" (SKEEP*) (("" (ASSERT) (("" (EXPAND "null_ol") (("" (HIDE 1) (("" (HIDE -6) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (ASSERT) (("2" (INST 1 "(: (re, acRes,null)::CacheData :)") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (ASSERT) (("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP* 1) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (CASE "pow=0") (("1" (REPLACE -11) (("1" (ASSERT) (("1" (REPLACE -7) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (REVEAL -2) (("1" (REPLACES -2) (("1" (REPLACES -1) (("1" (EXPAND "pow_var_ac") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval") (("1" (EXPAND "eval_ac_noise") (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x0") (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "pow=1") (("1" (REPLACE -11) (("1" (ASSERT) (("1" (REVEAL -2) (("1" (REPLACES -2) (("1" (REPLACES -7) (("1" (REPLACES -1) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (EXPAND "eval") (("1" (EXPAND "pow_var_ac" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (EXPAND "eval" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (FLATTEN) (("1" (REPLACES -8) (("1" (EXPAND "eval_ac_noise" 1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("1" (INST "vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (REPLACES "eval varac is vs" 1 :DIR RL) (("1" (EXPAND "eval_ac_noise" 1) (("1" (EXPAND "nth_ac" -1) (("1" (CASE "pd(var_ac(nth(box, idx), idx)) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "powvar?" 1) (("2" (EXPAND "varidx_powvar" 1) (("2" (EXPAND "eval") (("2" (REPLACE -6 1 :DIR RL) (("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("1" (INST "vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (REPLACES "eval varac is vs" 1 :DIR RL) (("1" (REPLACES -8) (("1" (EXPAND "eval_ac_noise" 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac" -1) (("1" (EXPAND "nth_ac" (1 -1)) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x1") (("1" (REPLACES -1) (("1" (LEMMA "expt_x1") (("1" (INST? -1 :WHERE 2) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (EXPAND "ordered_list?" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("2" (INST "vars in box" "idx") (("2" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (REPLACES "eval varac is vs" 2 :DIR RL) (("2" (EXPAND "eval_ac_noise" 2) (("2" (ASSERT) (("2" (REPLACES -7) (("2" (EXPAND "nth_ac" 1) (("2" (USE "expt_x1") (("2" (REPLACES -1) (("2" (USE "expt_x1") (("2" (REPLACES -1) (("2" (ASSERT) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (EXPAND_OL) (("2" (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x0") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "ordered_list?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (USE "expt_x0") (("3" (REPLACES -1) (("3" (EXPAND "nth" 1) (("3" (TYPEPRED "car(pd
                                                                                                                                                                                                                    (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                                                            ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                                                            ENDIF,
                                                                                                                                                                                                                            idx)))`2") (("1" (EXPAND "/=") (("1" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "idx") (("2" (GRIND) NIL NIL)) NIL) ("3" (FLATTEN) (("3" (TYPEPRED "idx") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (FLATTEN) (("4" (GRIND) NIL NIL)) NIL) ("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (EXPAND "ordered_list?" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SPLIT -8) (("1" (GRIND) NIL NIL) ("2" (REVEAL -2) (("2" (REPLACE -11) (("2" (ASSERT) (("2" (REPLACE -1) (("2" (REPLACE -8) (("2" (EXPAND "powvar?" 3) (("2" (EXPAND "varidx_powvar" 3) (("2" (EXPAND "pow_var_ac") (("2" (ASSERT) (("2" (EXPAND "eval_ACExpr_Env" 3) (("2" (EXPAND "eval" 3) (("2" (EXPAND "eval" 3) (("2" (REPLACE -9 3 :DIR RL) (("2" (EXPAND "eval_ac_noise") (("2" (ASSERT) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (ASSERT) (("2" (REPLACES -10) (("2" (EXPAND "nth_ac") (("2" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("2" (INST "vars in box" "idx") (("2" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (REPLACES "eval varac is vs" 3 :DIR RL) (("2" (EXPAND "eval_ac_noise" 3) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -10 :HIDE? T) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST -3 "i-1") (("1" (INST -3 "n") NIL NIL) ("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (REVEAL -11) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACE -6 1) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REVEAL -2) (("1" (REPLACES -1) (("1" (USE "next_idx_pow_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (TYPEPRED "nextfreeidx") (("1" (REPLACES -9) (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (EXPAND "last_ol") (("2" (REVEAL 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST? :SUBST ("i" "i-1")) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC45-2 |nil| 3767017293 ("" (SKEEP*) (("" (ASSERT) (("" (EXPAND "null_ol") (("" (HIDE 1) (("" (HIDE -6) (("" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (ASSERT) (("2" (INST 1 "(: (re, acRes,null)::CacheData :)") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (ASSERT) (("3" (TYPEPRED "cache") (("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST 1 "N") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP* 1) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (CASE "pow=0") (("1" (REPLACE -11) (("1" (ASSERT) (("1" (REPLACE -7) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (REVEAL -2) (("1" (REPLACES -2) (("1" (REPLACES -7) (("1" (REPLACES -1) (("1" (EXPAND "pow_var_ac") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval") (("1" (EXPAND "eval_ac_noise") (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x0") (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "pow=1") (("1" (REPLACE -11) (("1" (ASSERT) (("1" (REVEAL -2) (("1" (REPLACES -2) (("1" (REPLACES -7) (("1" (REPLACES -1) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (EXPAND "eval") (("1" (EXPAND "pow_var_ac" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (EXPAND "eval" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (FLATTEN) (("1" (REPLACES -8) (("1" (EXPAND "eval_ac_noise" 1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("1" (INST "vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (REPLACES "eval varac is vs" 1 :DIR RL) (("1" (EXPAND "eval_ac_noise" 1) (("1" (EXPAND "nth_ac" -1) (("1" (CASE "pd(var_ac(nth(box, idx), idx)) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "powvar?" 1) (("2" (EXPAND "varidx_powvar" 1) (("2" (EXPAND "eval") (("2" (REPLACE -6 1 :DIR RL) (("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("1" (INST "vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (REPLACES "eval varac is vs" 1 :DIR RL) (("1" (REPLACES -8) (("1" (EXPAND "eval_ac_noise" 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac" -1) (("1" (EXPAND "nth_ac" (1 -1)) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x1") (("1" (REPLACES -1) (("1" (LEMMA "expt_x1") (("1" (INST? -1 :WHERE 2) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (EXPAND "ordered_list?" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("2" (INST "vars in box" "idx") (("2" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (REPLACES "eval varac is vs" 2 :DIR RL) (("2" (EXPAND "eval_ac_noise" 2) (("2" (ASSERT) (("2" (REPLACES -7) (("2" (EXPAND "nth_ac" 1) (("2" (USE "expt_x1") (("2" (REPLACES -1) (("2" (USE "expt_x1") (("2" (REPLACES -1) (("2" (ASSERT) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (EXPAND_OL) (("2" (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "expt_x0") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "ordered_list?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (USE "expt_x0") (("3" (REPLACES -1) (("3" (EXPAND "nth" 1) (("3" (TYPEPRED "car(pd
                                                                                                                                                                                                                    (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                                                            ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                                                            ENDIF,
                                                                                                                                                                                                                            idx)))`2") (("1" (EXPAND "/=") (("1" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED "idx") (("2" (GRIND) NIL NIL)) NIL) ("3" (FLATTEN) (("3" (TYPEPRED "idx") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (FLATTEN) (("4" (GRIND) NIL NIL)) NIL) ("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (EXPAND "ordered_list?" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SPLIT -8) (("1" (GRIND) NIL NIL) ("2" (REVEAL -2) (("2" (REPLACES -1 3) (("2" (REPLACES -8 3) (("2" (REPLACE -11) (("2" (ASSERT) (("2" (REPLACE -1) (("2" (REPLACE -8) (("2" (EXPAND "powvar?" 3) (("2" (EXPAND "varidx_powvar" 3) (("2" (EXPAND "pow_var_ac") (("2" (ASSERT) (("2" (EXPAND "eval_ACExpr_Env" 3) (("2" (EXPAND "eval" 3) (("2" (EXPAND "eval" 3) (("2" (REPLACE -9 3 :DIR RL) (("2" (EXPAND "eval_ac_noise") (("2" (ASSERT) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (ASSERT) (("2" (REPLACES -10) (("2" (EXPAND "nth_ac") (("2" (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (("2" (INST "vars in box" "idx") (("2" (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (REPLACES "eval varac is vs" 3 :DIR RL) (("2" (EXPAND "eval_ac_noise" 3) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -10 :HIDE? T) (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST -3 "i-1") (("1" (INST -3 "n") NIL NIL) ("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (REVEAL -11) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACE -6 1) (("4" (ASSERT) (("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REVEAL -2) (("1" (REPLACES -1) (("1" (USE "next_idx_pow_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (TYPEPRED "nextfreeidx") (("1" (REPLACES -9) (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (EXPAND "last_ol") (("2" (REVEAL 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST? :SUBST ("i" "i-1")) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC45-1 |nil| 3631466640 ("" (THEN (SKEEP*) (GRIND)) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC51 0 (RE2AC_TCC46-2 |nil| 3632070867 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.re" "(affine_expr.powvar?)")) (RE2AC_TCC46-1 |nil| 3631466640 ("" (SKEEP*) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (REPLACE -6 -1 :DIR RL) (("" (EXPAND "CacheData_correct?") (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (FLATTEN) (("" (SPLIT -5) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACES -8) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.re" "(affine_expr.powvar?)"))) (RE2AC_TCC52 0 (RE2AC_TCC52-1 "" 3789917654 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "result") (("" (TYPEPRED "cache") (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (EXPAND "CacheData_correct?") (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)")) (RE2AC_TCC47-3 |nil| 3767017240 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (TYPEPRED "cache") (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (EXPAND "CacheData_correct?") (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)")) (RE2AC_TCC47-2 |nil| 3637339644 ("" (THEN (SKEEP*) (ASSERT) (HIDE -7) (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (REPLACES "re") (REPLACES "result") (ASSERT) (SPREAD (SPLIT 4) ((THEN (INST 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (GRIND)) (THEN (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (SKEEP) (REPLACES -3 1 :DIR RL) (INST?) (REPLACES "cache comp pairs") (SPREAD (CASE "nth(cache, i!1)`1 = POWVAR(idx, pow)") ((THEN (ASSERT) (FLATTEN) (ASSERT) (REPLACES "pow is cached") (REPLACES -1) (ASSERT)) (THEN (HIDE 2) (REVEAL -3 "re") (REPLACES "re") (ASSERT) (REPLACES -1) (REVEAL -2) (REPLACES -1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (REVEAL "re") (REPLACE "re" -2) (ASSERT) (REPLACES -2 1 :DIR RL) (REPLACES "pow is cached" 1 :DIR RL) (APPLY-EXTENSIONALITY))))) (SPREAD (INST "cache comp pairs" "i-1") ((THEN (EXPAND "nth" 2) (ASSERT)) (THEN (TYPEPRED "i") (GRIND))))))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (SKEEP) (REPLACES -3 1 :DIR RL) (INST?)) (THEN (EXPAND "nth" 2) (ASSERT) (INST?))))) (THEN (TYPEPRED "cache") (EXPAND "correct_cache?" 1) (EXPAND "CacheData_correct?") (TYPEPRED "cached") (ASSERT) (FLATTEN) (USE "cache_powvar_correct_result") (ASSERT) (REPLACE "cached" -1 :DIR RL) (EXPAND "CacheData_correct?") (FLATTEN) (SPREAD (SPLIT -2) ((THEN (FLATTEN) (ASSERT) (REVEAL "re") (GRIND)) (THEN (REVEAL "re") (GRIND)))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)")) (RE2AC_TCC47-1 |nil| 3631466640 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -10) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow < cached pow" -4) (LABEL "cached" -5) (LABEL "idxs" -6) (LABEL "pownoises" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "no single value" 3) (LABEL "no cv 0" 4))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 5) (("1" (INST 1 "(: (POWVAR(idx, pow), acRes, pownoises) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?" "cache compatible pairs") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "compatible_pairs_on?") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (INST "cache compatible pairs" "i!1") (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) ("cached is correct" "UNKNOWN")) (("1" (REPLACE "cached" "cached is correct" :DIR RL) (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (FLATTEN -8) (("1" (REPLACE "cached`2 is powvarac" -8) (("1" (REPLACE "acRes" 1) (("1" (REPLACE "varac" 1) (("1" (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (("1" (REPLACE "cached`1 varidx" "cached is correct") (("1" (REVEAL "re") (("1" (REPLACE "re" "cached is correct") (("1" (ASSERT) (("1" (REPLACE "cached cache idx" "pownoises" :DIR RL) (("1" (REPLACE "pownoises" "cached is correct" :DIR RL) (("1" (CASE "nth(cache, i!1)`1 = POWVAR(idx, opn(nth(cache, i!1)`1))") (("1" (REPLACES -1) (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "powvarac_ind_on_pow") (("1" (ASSERT) (("1" (INST -1 "pow") (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (SKEEP) (("1" (INST "cached is correct" "i!2") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx")) (("2" (REPLACES "cached cache idx" :DIR RL) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (APPLY-EXTENSIONALITY) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "cache compatible pairs") (("2" (INST "cache compatible pairs" "i-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (INST "cache idxs bound" "i!1") (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) ("cached is correct" "UNKNOWN")) (("1" (REPLACE "cached" "cached is correct" :DIR RL) (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (REPLACE "cached cache idx" "pownoises" :DIR RL) (("1" (REPLACE "pownoises" "cache idxs bound" :DIR RL) (("1" (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REVEAL "re") (("1" (REPLACE "re" "cache idxs bound") (("1" (ASSERT) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (LIFT-IF "cache idxs bound") (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (HIDE-ALL-BUT (3 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (REPLACES "cached cache idx" :DIR RL) (("2" (EXPAND ">") (("2" (EXPAND ">=") (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "correct_cache?" 1) (("4" (EXPAND "CacheData_correct?") (("4" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("4" (TYPEPRED "cached") (("4" (ASSERT) (("4" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("4" (SKEEP "cached cache idx") (("4" (USE "cache_powvar_correct_result") (("4" (WITH-LABELS (ASSERT) ("cached is correct" "UNKNOWN")) (("4" (REPLACE "cached" "cached is correct" :DIR RL) (("4" (EXPAND "CacheData_correct?") (("4" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("4" (SPLIT "cached cond ok") (("1" (REPLACE "pownoises" "cached cond ok" :DIR RL) (("1" (REPLACE "cached`1 varidx" "cached cond ok") (("1" (REVEAL "re") (("1" (REPLACE "re" "cached cond ok") (("1" (ASSERT) (("1" (FLATTEN "cached cond ok") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)"))) (RE2AC_TCC53 0 (RE2AC_TCC48-2 |nil| 3767017154 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow is cached" -6) (LABEL "cached" -7) (LABEL "result" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (TYPEPRED "cache") (("" (EXPAND "correct_cache?" 4) (("" (EXPAND "CacheData_correct?") (("" (EXPAND "powvar?" 4) (("" (EXPAND "varidx_powvar" 4) (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (REPLACE "cached" -1 :DIR RL) (("" (EXPAND "CacheData_correct?") (("" (EXPAND "varidx_powvar" -1) (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REVEAL "re") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "re") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|pow| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC48-1 |nil| 3631466640 ("" (THEN (SKEEP*) (GRIND)) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC54 0 (RE2AC_TCC54-2 "" 3803766707 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -9) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached some" -6) (LABEL "pow is cached" -7) (LABEL "cached" -5) (LABEL "result" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 4) (("1" (INST 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP*) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) (("1" (INST "cache idx bound" "n") (("1" (CASE "nth(cache, i!1)`1 = POW(re1, pow)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REVEAL -3 "re") (("2" (REPLACES "re") (("2" (EXPAND "varidx_powvar" -3) (("2" (REVEAL -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REVEAL "re") (("2" (REPLACE "re" -2) (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-2 1 -12 -5)) (("2" (EXPAND "varidx_powvar") (("2" (APPLY-EXTENSIONALITY) (("1" (USE "IntervalExpr_VARIDX_extensionality") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL -3) (("2" (EXPAND "powvar?") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache idx bound" "i-1") (("1" (INST "cache idx bound" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|length| DEF-DECL "nat" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|IntervalExpr_POW_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i!1| SKOLEM-CONST-DECL "below(length(cache))" |affine_expr_Eval_fnd| NIL) (|bincludes?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|op| SHARED-ADT-ACCESSOR-DECL "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_VARIDX_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|pow| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|cached| SKOLEM-CONST-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(re1, pow), val(cached)`2, val(cached)`3), cache)))" |affine_expr_Eval_fnd| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC54-1 "" 3789917666 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -9) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow is cached" -6) (LABEL "cached" -7) (LABEL "result" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 4) (("1" (INST 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP*) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) (("1" (INST "cache idx bound" "n") (("1" (CASE "nth(cache, i!1)`1 = POW(re1, pow)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REVEAL -3 "re") (("2" (REPLACES "re") (("2" (EXPAND "varidx_powvar" -3) (("2" (REVEAL -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REVEAL "re") (("2" (REPLACE "re" -2) (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-2 1 -12 -5)) (("2" (EXPAND "varidx_powvar") (("2" (APPLY-EXTENSIONALITY) (("1" (USE "IntervalExpr_VARIDX_extensionality") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL -3) (("2" (EXPAND "powvar?") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache idx bound" "i-1") (("1" (INST "cache idx bound" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC49-2 |nil| 3767017107 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -9) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow is cached" -6) (LABEL "cached" -7) (LABEL "result" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 4) (("1" (INST 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP*) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) (("1" (INST "cache idx bound" "n") (("1" (REPLACES "cache comp pairs") (("1" (CASE "nth(cache, i!1)`1 = POW(re1, pow)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACES "pow is cached") (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REVEAL -3 "re") (("2" (REPLACES "re") (("2" (EXPAND "varidx_powvar" -3) (("2" (REVEAL -2) (("2" (REPLACES -1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REVEAL "re") (("2" (REPLACE "re" -2) (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-2 1 -12 -5)) (("2" (EXPAND "varidx_powvar") (("2" (APPLY-EXTENSIONALITY) (("1" (USE "IntervalExpr_VARIDX_extensionality") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL -3) (("2" (EXPAND "powvar?") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache idx bound" "i-1") (("1" (INST "cache idx bound" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC49-1 |nil| 3631466640 ("" (THEN (SKEEP*) (REPLACES -7) (ASSERT) (EXPAND "correct_cache?") (EXPAND "CacheData_correct?") (FLATTEN) (SPREAD (SPLIT 2) ((GRIND) (GRIND) (GRIND)))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC55 0 (RE2AC_TCC55-1 "" 3789917667 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE 1) (("" (HIDE -6) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC50-3 |nil| 3637342891 ("" (THEN (SKEEP*) (ASSERT) (EXPAND "null_ol") (HIDE 1) (HIDE -6) (SPREAD (SPLIT 1) ((GRIND) (THEN (ASSERT) (SPREAD (INST 1 "(: (re, acRes,null)::CacheData :)") ((GRIND) (GRIND)))) (THEN (ASSERT) (TYPEPRED "cache") (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP* 1) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (SPREAD (CASE "pow=0") ((THEN (REPLACE -11) (ASSERT) (REPLACE -7) (EXPAND "powvar?" 1) (EXPAND "varidx_powvar" 1) (REVEAL -2) (REPLACES -2) (REPLACES -7) (REPLACES -1) (EXPAND "pow_var_ac") (EXPAND "eval_ACExpr_Env" 1) (EXPAND "eval") (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "expt_x0") (ASSERT) (EXPAND "pow_var_compatible?" 1) (GRIND)) (SPREAD (CASE "pow=1") ((THEN (REPLACE -11) (ASSERT) (REVEAL -2) (REPLACES -2) (REPLACES -7) (REPLACES -1) (EXPAND "eval_ACExpr_Env" 2) (EXPAND "eval") (EXPAND "pow_var_ac" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (EXPAND "eval" 1) (REPLACE -6 1 :DIR RL) (EXPAND "powvar?" 1) (EXPAND "varidx_powvar" 1) (REPLACE -6 1 :DIR RL) (FLATTEN) (REPLACES -8) (EXPAND "eval_ac_noise" 1) (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (EXPAND "nth_ac" 1) (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (INST "vars in box" "idx") (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (REPLACES "eval varac is vs" 1 :DIR RL) (EXPAND "eval_ac_noise" 1) (EXPAND "nth_ac" -1) (SPREAD (CASE "pd(var_ac(nth(box, idx), idx)) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (EXPAND "pow_var_compatible?") (GRIND)) (THEN (HIDE-ALL-BUT (-1 1)) (EXPAND "length") (ASSERT))))) (THEN (EXPAND "powvar?" 1) (EXPAND "varidx_powvar" 1) (EXPAND "eval") (REPLACE -6 1 :DIR RL) (FLATTEN) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (INST "vars in box" "idx") (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (REPLACES "eval varac is vs" 1 :DIR RL) (REPLACES -8) (EXPAND "eval_ac_noise" 1) (ASSERT) (EXPAND "nth_ac" -1) (EXPAND "nth_ac" (1 -1)) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (LIFT-IF -1) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACES -1) (SPREAD (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((THEN (REPLACES -1) (ASSERT) (USE "expt_x1") (REPLACES -1) (LEMMA "expt_x1") (INST? -1 :WHERE 2) (ASSERT) (EXPAND "pow_var_compatible?") (GRIND)) (THEN (HIDE 3) (SPREAD (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL)) (GRIND)))) (THEN (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (EXPAND "ordered_list?" -1) (ASSERT)) (ASSERT))))))) (THEN (FLATTEN) (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (INST "vars in box" "idx") (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (REPLACES "eval varac is vs" 2 :DIR RL) (EXPAND "eval_ac_noise" 2) (ASSERT) (REPLACES -7) (EXPAND "nth_ac" 1) (USE "expt_x1") (REPLACES -1) (USE "expt_x1") (REPLACES -1) (ASSERT) (USE "eval_pd_noise_rec_pds_def") (LIFT-IF -1) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACES -1) (EXPAND_OL) (SPREAD (CASE "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((THEN (REPLACES -1) (ASSERT) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (USE "expt_x0") (REPLACES -1) (GRIND)) (THEN (EXPAND "ordered_list?") (PROPAX)) (THEN (USE "expt_x0") (REPLACES -1) (EXPAND "nth" 1) (SPREAD (TYPEPRED "car(pd
                                                                                                                                                                                      (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                              ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                              ENDIF,
                                                                                                                                                                                              idx)))`2") ((THEN (EXPAND "/=") (GRIND)) (THEN (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (TYPEPRED "idx") (GRIND)) (THEN (FLATTEN) (GRIND)) (GRIND))))))) (SPREAD (CASE "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((THEN (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL)) (GRIND))) (THEN (TYPEPRED "pd(var_ac(nth[Interval](box, idx), idx))") (EXPAND "ordered_list?" -1) (ASSERT)) (THEN (EXPAND "length") (ASSERT)))))))))))))) (SPREAD (SPLIT -8) ((GRIND) (THEN (REVEAL -2) (REPLACES -1 3) (REPLACES -8 3) (REPLACE -11) (ASSERT) (REPLACE -1) (REPLACE -8) (EXPAND "powvar?" 3) (EXPAND "varidx_powvar" 3) (EXPAND "pow_var_ac") (ASSERT) (EXPAND "eval_ACExpr_Env" 3) (EXPAND "eval" 3) (EXPAND "eval" 3) (REPLACE -9 3 :DIR RL) (EXPAND "eval_ac_noise") (ASSERT) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (ASSERT) (REPLACES -10) (EXPAND "nth_ac") (WITH-LABELS (EXPAND "vars_in_box_compatible?") (("vars in box"))) (INST "vars in box" "idx") (WITH-LABELS (FLATTEN "vars in box") (("eval varac is vs" "when sing interval"))) (REPLACES "eval varac is vs" 3 :DIR RL) (EXPAND "eval_ac_noise" 3) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (LIFT-IF 3) (SPREAD (SPLIT 3) ((THEN (FLATTEN) (ASSERT) (EXPAND "pow_var_compatible?") (PROPAX)) (THEN (FLATTEN) (GRIND)))))))))))) (THEN (REPLACE -10 :HIDE? T) (EXPAND "nth" 2) (ASSERT) (SPREAD (INST -3 "i-1") ((INST -3 "n") (THEN (TYPEPRED "i") (HIDE-ALL-BUT (-1 1 2)) (REVEAL -11) (GRIND)))))))) (THEN (REPLACE -6 1) (ASSERT) (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REVEAL -2) (REPLACES -1) (USE "next_idx_pow_var_ac") (ASSERT) (REPLACES -1) (TYPEPRED "nextfreeidx") (REPLACES -9) (EXPAND "last_idx_in_box") (EXPAND "nth_ac") (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "next_idx") (EXPAND "last_idx") (EXPAND "last_ol") (REVEAL 1) (GRIND))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST? :SUBST ("i" "i-1"))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC50-2 |nil| 3632073429 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -7) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 4) (("1" (INST 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (SKEEP) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) (("1" (REPLACES "cache comp pairs") (("1" (CASE "nth(cache, i!1)`1 = POWVAR(idx, pow)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACES "pow is cached") (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REVEAL -3 "re") (("2" (REPLACES "re") (("2" (ASSERT) (("2" (REPLACES -1) (("2" (REVEAL -2) (("2" (REPLACES -1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REVEAL "re") (("2" (REPLACE "re" -2) (("2" (ASSERT) (("2" (REPLACES -2 1 :DIR RL) (("2" (REPLACES "pow is cached" 1 :DIR RL) (("2" (APPLY-EXTENSIONALITY) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST? :SUBST ("i" "i-1")) (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "i") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "cache") (("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKEEP) (("1" (REPLACES -3 1 :DIR RL) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC50-1 |nil| 3631466640 ("" (SKEEP*) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "cached" -4) (LABEL "idxs" -5) (LABEL "pownoises" -6) (LABEL "newoff" -7) (LABEL "nwidxs" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (WITH-LABELS (SPLIT "not in cache 1") (("pow gt opn cached`1"))) (("" (WITH-LABELS (SPLIT "not in cache 2") (("pow gt opn cached`1"))) (("1" (EXPAND "/=") (("1" (PROPAX) NIL NIL)) NIL) ("2" (REPLACES "nwidxs" 7) (("2" (SPLIT 7) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (NAME "nwidxs2" "append_ol[nat,<](pownoises, nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (POSTPONE) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC56 0 (RE2AC_TCC51-3 |nil| 3767017036 ("" (SKEEP*) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (REPLACE -8 -1 :DIR RL) (("" (EXPAND "CacheData_correct?") (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (ASSERT) (("" (FLATTEN) (("" (SPLIT -5) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACES -9) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (C CONST-DECL "posnat" |binomial| |reals|) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|idxs_pd| DEF-DECL "list[nat]" |affine| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC51-2 |nil| 3637343285 ("" (THEN (SKEEP*) (EXPAND "powvar?") (TYPEPRED "re") (GRIND)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC51-1 |nil| 3631466640 ("" (SKEEP*) (("" (GRIND) NIL NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC57 0 (RE2AC_TCC57-1 "" 3789917754 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (TYPEPRED "cache") (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (EXPAND "CacheData_correct?") (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REVEAL "re") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "re") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|idxs_pd| DEF-DECL "list[nat]" |affine| NIL) (|rat_minus_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|pow| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (C CONST-DECL "posnat" |binomial| |reals|) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC52-3 |nil| 3632073759 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "pow is cached" -4) (LABEL "cached" -5) (LABEL "result" -6) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (TYPEPRED "cache") (("" (TYPEPRED "cached") (("" (ASSERT) (("" (FLATTEN) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) (("" (EXPAND "CacheData_correct?") (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REVEAL "re") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "re") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC52-2 |nil| 3631553433 ("" (SKEEP*) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "cached" -4) (LABEL "idxs" -5) (LABEL "pownoises" -6) (LABEL "newoff" -7) (LABEL "nwidxs" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (WITH-LABELS (SPLIT "not in cache 1") (("pow gt opn cached`1"))) (("" (WITH-LABELS (SPLIT "not in cache 2") (("pow gt opn cached`1"))) (("1" (EXPAND "/=") (("1" (PROPAX) NIL NIL)) NIL) ("2" (REPLACES "nwidxs" 7) (("2" (SPLIT 7) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACES -1 3) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (EXPAND "idxs_bounded" "cache idxs bounded") (("1" (SKEEP "cached cache idx") (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (INST "cache idxs bounded" "i") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bounded") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF "cache idxs bounded") (("1" (SPLIT "cache idxs bounded") (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND ">=") (("2" (REPLACE "pownoises" 4) (("2" (REPLACE "cached cache idx" 4 :DIR RL) (("2" (HIDE-ALL-BUT ("cache idxs bounded" 4)) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 "cached correct" "pow gt opn cached`1")) (("2" (REPLACES -2 1) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "take_ol[nat,<]") (("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACES -4 2) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 2) (("1" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (EXPAND "min" 2) (("1" (LIFT-IF 2) (("1" (CASE "length(pownoises) = opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 2) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (SPLIT "cached cond ok") (("1" (FLATTEN) (("1" (REPLACES "varac" 2) (("1" (REPLACE "re" "cached cond ok") (("1" (ASSERT) (("1" (CASE "car[nat]
                         (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                 nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "take" 1) (("2" (EXPAND "append" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACE -4 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "nats" 2) (("2" (REPLACE "newoff" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACE "varac" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (REPLACE "varac" 2) (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC52-1 |nil| 3631466640 ("" (SKEEP*) (("" (REPLACES -7) (("" (REPLACES -4) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC58 0 (RE2AC_TCC58-1 "" 3803766872 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -12) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached some" -6) (LABEL "pow < cached pow" -7) (LABEL "cached" -5) (LABEL "idxs" -8) (LABEL "pownoises" -9) (LABEL "acRes" -10) (LABEL "result" -11) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "no single value" 3) (LABEL "no cv 0" 5))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 5) (("1" (INST 1 "(: (POW(re1, pow), acRes, pownoises) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?" "cache compatible pairs") (("2" (WITH-LABELS (SKEEP "cache compatible pairs") (("vars in box" "compatible on"))) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (EXPAND "compatible_pairs_on?") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (INST "compatible on" "i!1") (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT -1) ("cached is correct" "UNKNOWN")) (("1" (REPLACE "cached" "cached is correct" :DIR RL) (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (ASSERT (-1 "cached`1 is powvar")) ("cached is correct" "UNKNOWN")) (("1" (WITH-LABELS (FLATTEN "cached is correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (SKEEP) (("1" (INST "compatible on" "n") (("1" (WITH-LABELS (FLATTEN "compatible on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached`2 is powvarac" "eval cache") (("1" (REPLACE "acRes" 1) (("1" (REPLACE "varac" 1) (("1" (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (("1" (REVEAL "re") (("1" (ASSERT) (("1" (REPLACE "cached cache idx" "pownoises" :DIR RL) (("1" (REPLACE "pownoises" "eval cache" :DIR RL) (("1" (CASE "nth(cache, i!1)`1 = POW(re1, opn(nth(cache, i!1)`1))") (("1" (REPLACES -1) (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (EXPAND "eval") (("1" (REPLACE -16 :DIR RL) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST? "vars in box") (("1" (FLATTEN) (("1" (EXPAND "nth_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (HIDE -2) (("2" (SPLIT "cached cond ok") (("1" (TYPEPRED "cached") (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (REPLACE -2 :HIDE? T) (("1" (REPLACE "re" "cached cond ok") (("1" (ASSERT) (("1" (HIDE-ALL-BUT ("cached cond ok" -4 "cached cache idx")) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND ">=") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (LIFT-IF "cached cond ok") (("2" (SPLIT "cached cond ok") (("1" (FLATTEN) (("1" (EXPAND "varidx_powvar") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "pow_var_compatible?") (("3" (SKEEP) (("3" (EXPAND "varidx_powvar") (("3" (INST "cache if powvar" "i!2") (("3" (REPLACE "pownoises" "cache if powvar" :DIR RL) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "pow_var_compatible?") (("2" (SKEEP) (("2" (EXPAND "varidx_powvar") (("2" (INST "cache if powvar" "i!2") (("2" (REPLACE "pownoises" "cache if powvar" :DIR RL) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx" -13 -14)) (("2" (REPLACES "cached cache idx" :DIR RL) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (APPLY-EXTENSIONALITY) (("2" (EXPAND "varidx_powvar") (("2" (USE "IntervalExpr_VARIDX_extensionality") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "compatible on") (("2" (INST "compatible on" "i-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (INST "cache idxs bound" "i!1") (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (REPLACE "cached" "cached is correct" :DIR RL) (("1" (EXPAND "CacheData_correct?") (("1" (ASSERT ("cached is correct" "cached`1 is powvar")) (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (REPLACE "cached cache idx" "pownoises" :DIR RL) (("1" (REPLACE "pownoises" "cache idxs bound" :DIR RL) (("1" (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REVEAL "re") (("1" (REPLACE "re" "cache idxs bound") (("1" (ASSERT) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (LIFT-IF "cache idxs bound") (("2" (SPLIT "cache idxs bound") (("1" (GRIND) NIL NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("already knonwn" "already knonwn" "cache idxs bound" "UNKNOWN"))) (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (ASSERT) (("2" (HIDE-ALL-BUT (4 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (REPLACES "cached cache idx" :DIR RL) (("2" (EXPAND ">") (("2" (EXPAND ">=") (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|containment_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|olidx_car_last| FORMULA-DECL NIL |indexed_list| |structures|) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|notmember_ol_nat| FORMULA-DECL NIL |affine_pow| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|bincludes?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|op| SHARED-ADT-ACCESSOR-DECL "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_VARIDX_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|IntervalExpr_POW_extensionality| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(re1, pow), acRes, pownoises), cache)))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|pownoises| SKOLEM-CONST-DECL "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" |affine_expr_Eval_fnd| NIL) (|acRes| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|pow| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nth_ol| FORMULA-DECL NIL |ordered_list| |structures|) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (C CONST-DECL "posnat" |binomial| |reals|) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC53-3 |nil| 3767017678 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -12) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow < cached pow" -6) (LABEL "cached" -7) (LABEL "idxs" -8) (LABEL "pownoises" -9) (LABEL "acRes" -10) (LABEL "result" -11) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "no single value" 3) (LABEL "no cv 0" 4))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 5) (("1" (INST 1 "(: (POW(re1, pow), acRes, pownoises) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?" "cache compatible pairs") (("2" (WITH-LABELS (SKEEP "cache compatible pairs") (("vars in box" "compatible on"))) (("2" (INST 1 "N") (("2" (ASSERT) (("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "powvar?" 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (EXPAND "compatible_pairs_on?") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (INST "compatible on" "i!1") (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT -1) ("cached is correct" "UNKNOWN")) (("1" (REPLACE "cached" "cached is correct" :DIR RL) (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (ASSERT (-1 "cached`1 is powvar")) ("cached is correct" "UNKNOWN")) (("1" (WITH-LABELS (FLATTEN "cached is correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (SKEEP) (("1" (INST "compatible on" "n") (("1" (WITH-LABELS (FLATTEN "compatible on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached`2 is powvarac" "eval cache") (("1" (REPLACE "acRes" 1) (("1" (REPLACE "varac" 1) (("1" (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (("1" (REVEAL "re") (("1" (ASSERT) (("1" (REPLACE "cached cache idx" "pownoises" :DIR RL) (("1" (REPLACE "pownoises" "eval cache" :DIR RL) (("1" (CASE "nth(cache, i!1)`1 = POW(re1, opn(nth(cache, i!1)`1))") (("1" (REPLACES -1) (("1" (EXPAND "eval_ACExpr_Env") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (EXPAND "eval") (("1" (REPLACE -16 :DIR RL) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST? "vars in box") (("1" (FLATTEN) (("1" (EXPAND "nth_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (HIDE -2) (("2" (SPLIT "cached cond ok") (("1" (TYPEPRED "cached") (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (REPLACE -2 :HIDE? T) (("1" (REPLACE "re" "cached cond ok") (("1" (ASSERT) (("1" (HIDE-ALL-BUT ("cached cond ok" -4 "cached cache idx")) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND ">=") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (LIFT-IF "cached cond ok") (("2" (SPLIT "cached cond ok") (("1" (FLATTEN) (("1" (EXPAND "varidx_powvar") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "pow_var_compatible?") (("3" (SKEEP) (("3" (EXPAND "varidx_powvar") (("3" (INST "cache if powvar" "i!2") (("3" (REPLACE "pownoises" "cache if powvar" :DIR RL) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "pow_var_compatible?") (("2" (SKEEP) (("2" (EXPAND "varidx_powvar") (("2" (INST "cache if powvar" "i!2") (("2" (REPLACE "pownoises" "cache if powvar" :DIR RL) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx" -13 -14)) (("2" (REPLACES "cached cache idx" :DIR RL) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (APPLY-EXTENSIONALITY) (("2" (EXPAND "varidx_powvar") (("2" (USE "IntervalExpr_VARIDX_extensionality") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "compatible on") (("2" (INST "compatible on" "i-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "idxs_bounded") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (INST "cache idxs bound" "i!1") (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (REPLACE "cached" "cached is correct" :DIR RL) (("1" (EXPAND "CacheData_correct?") (("1" (ASSERT ("cached is correct" "cached`1 is powvar")) (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (REPLACE "cached cache idx" "pownoises" :DIR RL) (("1" (REPLACE "pownoises" "cache idxs bound" :DIR RL) (("1" (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REVEAL "re") (("1" (REPLACE "re" "cache idxs bound") (("1" (ASSERT) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (LIFT-IF "cache idxs bound") (("2" (SPLIT "cache idxs bound") (("1" (GRIND) NIL NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("already knonwn" "already knonwn" "cache idxs bound" "UNKNOWN"))) (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (ASSERT) (("2" (HIDE-ALL-BUT (4 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (REPLACES "cached cache idx" :DIR RL) (("2" (EXPAND ">") (("2" (EXPAND ">=") (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (REPLACE "varac" "no single value") (("2" (REVEAL "re") (("2" (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (("2" (REPLACES "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC53-2 |nil| 3631546337 ("" (THEN (SKEEP*) (ASSERT) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow is cached" -6) (LABEL "cached" -7) (LABEL "result" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (REPLACES "re") (REPLACES "result") (ASSERT) (TYPEPRED "cache") (EXPAND "correct_cache?" 4) (EXPAND "CacheData_correct?") (EXPAND "powvar?" 4) (EXPAND "varidx_powvar" 4) (TYPEPRED "cached") (ASSERT) (FLATTEN) (USE "cache_powvar_correct_result") (ASSERT) (REPLACE "cached" -1 :DIR RL) (EXPAND "CacheData_correct?") (EXPAND "varidx_powvar" -1) (FLATTEN) (SPREAD (SPLIT -2) ((THEN (FLATTEN) (ASSERT) (REVEAL "re") (GRIND)) (THEN (REVEAL "re") (GRIND))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC53-1 |nil| 3631466640 ("" (SKEEP*) (("" (GRIND) NIL NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC59 0 (RE2AC_TCC59-1 "" 3789917764 ("" (SKEEP*) (("" (ASSERT) NIL NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-4 |nil| 3632074082 ("" (THEN (SKEEP*) (ASSERT) (HIDE -9) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow is cached" -6) (LABEL "cached" -7) (LABEL "result" -8) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single" 3))) (REPLACES "re") (REPLACES "result") (ASSERT) (SPREAD (SPLIT 4) ((THEN (INST 1 "(: (re, val(cached)`2, val(cached)`3) :)") (GRIND)) (THEN (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (EXPAND "compatible_pairs?") (SKEEP) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP*) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (SKEEP) (REPLACES -3 1 :DIR RL) (INST?) (INST "cache idx bound" "n") (REPLACES "cache comp pairs") (SPREAD (CASE "nth(cache, i!1)`1 = POW(re1, pow)") ((THEN (ASSERT) (FLATTEN) (ASSERT) (REPLACES "pow is cached") (REPLACES -1) (ASSERT)) (THEN (HIDE 2) (REVEAL -3 "re") (REPLACES "re") (EXPAND "varidx_powvar" -3) (REVEAL -2) (REPLACES -1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (REVEAL "re") (REPLACE "re" -2) (ASSERT) (HIDE-ALL-BUT (-2 1 -12 -5)) (EXPAND "varidx_powvar") (SPREAD (APPLY-EXTENSIONALITY) ((THEN (USE "IntervalExpr_VARIDX_extensionality") (ASSERT)) (THEN (REVEAL -3) (EXPAND "powvar?") (PROPAX)))))))) (SPREAD (INST "cache idx bound" "i-1") ((THEN (INST "cache idx bound" "n") (EXPAND "nth" 2) (ASSERT)) (THEN (TYPEPRED "i") (GRIND))))))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (FLATTEN) (SKEEP) (REPLACES -3 1 :DIR RL) (INST?)) (THEN (EXPAND "nth" 2) (ASSERT) (INST?)))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-3 |nil| 3632063087 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "cached" -4) (LABEL "idxs" -5) (LABEL "pownoises" -6) (LABEL "newoff" -7) (LABEL "nwidxs" -8) (LABEL "acRes" -9) (LABEL "result" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (HIDE -11) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "powvarac_ext_on_pow") (("1" (INST -1 "N" "opn(val(cached)`1)" "nth_ac(box, idx)" "vs(idx)" "val(cached)`3" "nextfreeidx") (("1" (ASSERT) (("1" (INST -1 "pow") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "nextfreeidx" "pownoises") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (ASSERT) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (REPLACE "re" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" 1) (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "re" 1) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, i),
                                                                 upd_noise_burst(N,
                                                                                 nats(nextfreeidx, newoff - 1),
                                                                                 LAMBDA
                                                                                 (i: nat):
                                                                                 (get_noise_by_idx
                                                                                  (car(pd(varac))`1, N)
                                                                                  ^
                                                                                  (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                          0)`1,
                                                                      upd_noise_burst(N,
                                                                                      nats(nextfreeidx, newoff - 1),
                                                                                      LAMBDA
                                                                                      (i: nat):
                                                                                      (get_noise_by_idx
                                                                                       (car(pd(varac))`1, N)
                                                                                       ^
                                                                                       (2 + i))))
                                                      ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                          0)`1,
                                                                      N)
                                                      ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (TYPEPRED "i") (("1" (HIDE-ALL-BUT (-1 -2 "cache_k-1`3 length")) (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound") (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -6 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idxs bound" "correct cache" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (LEMMA "containment_pow_var_ac") (("1" (INST -1 "upd_noise_burst(N,
                                                                nats(nextfreeidx, newoff - 1),
                                                                LAMBDA
                                                                (i: nat):
                                                                (get_noise_by_idx(car(pd(varac))`1, N)
                                                                 ^
                                                                 (2 + i)))" "vs(varidx(re))" "varac" "pow" "nwidxs") (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (REPLACE "re" -1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (REPLACE "box eval" 1 :DIR RL) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "nth_ac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                  0)`1,
                                                              upd_noise_burst(N,
                                                                              nats(nextfreeidx, newoff - 1),
                                                                              LAMBDA
                                                                              (i: nat):
                                                                              (get_noise_by_idx
                                                                               (car(pd(varac))`1, N)
                                                                               ^
                                                                               (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                  0)`1,
                                                              N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                 upd_noise_burst(N,
                                                                                 nats(nextfreeidx, newoff - 1),
                                                                                 LAMBDA
                                                                                 (i: nat):
                                                                                 (get_noise_by_idx
                                                                                  (car(pd(varac))`1, N)
                                                                                  ^
                                                                                  (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                 N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1 "cache idxs bound") (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -8)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE "varac" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 -2 -3 1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                     nats(nextfreeidx, newoff - 1)),
                                              pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (USE "nth_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("2" (REPLACES -1 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "nth_append[nat]") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?") (("5" (EXPAND "CacheData_correct?") (("5" (REPLACE "re" 1) (("5" (ASSERT) (("5" (LIFT-IF "nwidxs") (("5" (SPLIT "nwidxs") (("1" (FLATTEN) (("1" (REPLACE -2 1) (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACES -4 2) (("1" (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                           nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (REPLACES -1 2) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (REPLACE -4 "cached correct") (("1" (REPLACE "re" "cached correct") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "append" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "take" -1) (("1" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1) (("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "take" 2) (("2" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "pownoises" 1) (("3" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("3" (USE "cache_powvar_correct_result") (("3" (WITH-LABELS (ASSERT) (("cached correct"))) (("3" (REPLACE "cached" "cached correct" :DIR RL) (("3" (EXPAND "CacheData_correct?" "cached correct") (("3" (TYPEPRED "cached") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (SPLIT "cached correct") (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 2) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACE -4 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (INST -5 "0") (("1" (EXPAND "nth") (("1" (REPLACE -5 3) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REPLACE "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-2 |nil| 3631477806 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "cached" -4) (LABEL "idxs" -5) (LABEL "pownoises" -6) (LABEL "newoff" -7) (LABEL "nwidxs" -8) (LABEL "acRes" -9) (LABEL "result" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (HIDE -11) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "powvarac_ext_on_pow") (("1" (INST -1 "N" "opn(val(cached)`1)" "nth_ac(box, idx)" "vs(idx)" "val(cached)`3" "nextfreeidx") (("1" (ASSERT) (("1" (INST -1 "pow") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" -1) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "nextfreeidx" "pownoises") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (ASSERT) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (REPLACE "re" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" 1) (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "re" 1) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" -1) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, i),
                       upd_noise_burst(N,
                                       nats(nextfreeidx, newoff - 1),
                                       LAMBDA
                                       (i: nat):
                                       (get_noise_by_idx
                                        (car(pd(varac))`1, N)
                                        ^
                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        upd_noise_burst(N,
                                        nats(nextfreeidx, newoff - 1),
                                        LAMBDA
                                        (i: nat):
                                        (get_noise_by_idx
                                         (car(pd(varac))`1, N)
                                         ^
                                         (2 + i))))
        ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        N)
        ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -6)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (FLATTEN) (("1" (REPLACE -4 "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (TYPEPRED "i") (("1" (HIDE-ALL-BUT (-1 -2 -5)) (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound") (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -7 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idxs bound" "correct cache" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (LEMMA "containment_pow_var_ac") (("1" (INST -1 "upd_noise_burst(N,
                                    nats(nextfreeidx, newoff - 1),
                                    LAMBDA
                                    (i: nat):
                                    (get_noise_by_idx(car(pd(varac))`1, N)
                                     ^
                                     (2 + i)))" "vs(varidx(re))" "varac" "pow" "nwidxs") (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (REPLACE "re" -1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (REPLACE "box eval" 1 :DIR RL) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "nth_ac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        upd_noise_burst(N,
                                        nats(nextfreeidx, newoff - 1),
                                        LAMBDA
                                        (i: nat):
                                        (get_noise_by_idx
                                         (car(pd(varac))`1, N)
                                         ^
                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                       upd_noise_burst(N,
                                       nats(nextfreeidx, newoff - 1),
                                       LAMBDA
                                       (i: nat):
                                       (get_noise_by_idx
                                        (car(pd(varac))`1, N)
                                        ^
                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                       N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (FLATTEN) (("1" (REPLACE -4 "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1 "cache idxs bound") (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -6 "cache idxs bound")) (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE "varac" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 -2 -3 1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                   nats(nextfreeidx, newoff - 1)),
            pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (USE "nth_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("2" (REPLACES -1 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "nth_append[nat]") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
           pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?") (("5" (EXPAND "CacheData_correct?") (("5" (REPLACE "re" 1) (("5" (ASSERT) (("5" (LIFT-IF "nwidxs") (("5" (SPLIT "nwidxs") (("1" (FLATTEN) (("1" (REPLACE -2 1) (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACES -4 2) (("1" (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                 nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (REPLACES -1 2) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (REPLACE -4 "cached correct") (("1" (REPLACE "re" "cached correct") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "append" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "take" -1) (("1" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1) (("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "take" 2) (("2" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "pownoises" 1) (("3" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("3" (USE "cache_powvar_correct_result") (("3" (WITH-LABELS (ASSERT) (("cached correct"))) (("3" (REPLACE "cached" "cached correct" :DIR RL) (("3" (EXPAND "CacheData_correct?" "cached correct") (("3" (TYPEPRED "cached") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (SPLIT "cached correct") (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 2) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACE -4 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (INST -5 "0") (("1" (EXPAND "nth") (("1" (REPLACE -5 3) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REPLACE "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-1 |nil| 3631466640 ("" (CASES-TCC) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat"))) (RE2AC_TCC60 0 (RE2AC_TCC60-1 "" 3789917765 ("" (SKEEP*) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC55-2 |nil| 3637345872 ("" (THEN (SKEEP*) (USE "cache_powvar_correct_result") (ASSERT) (REPLACE -6 -1 :DIR RL) (EXPAND "CacheData_correct?") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (SPREAD (SPLIT -5) ((THEN (FLATTEN) (ASSERT) (FLATTEN) (ASSERT) (REPLACES -8) (GRIND)) (GRIND)))) NIL NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC55-1 |nil| 3631554556 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}"))) (RE2AC_TCC61 0 (RE2AC_TCC61-1 "" 3789917766 ("" (SKEEP*) (("" (USE "cache_powvar_correct_result") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC56-1 |nil| 3631622080 ("" (THEN (SKEEP*) (USE "cache_powvar_correct_result") (ASSERT) (REPLACE -8 -1 :DIR RL) (EXPAND "CacheData_correct?") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (SPREAD (SPLIT -5) ((THEN (FLATTEN) (ASSERT) (FLATTEN) (ASSERT) (REPLACES -9) (GRIND)) (GRIND)))) NIL NIL) NIL SHOSTAK (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}"))) (RE2AC_TCC62 0 (RE2AC_TCC57-3 |nil| 3767017849 ("" (SKEEP*) (("" (EXPAND "nth_ac") (("" (REPLACES -4) (("" (HIDE-ALL-BUT 7) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC57-2 |nil| 3631793678 ("" (THEN (SKEEP*) (ASSERT) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow < cached pow" -6) (LABEL "cached" -7) (LABEL "idxs" -8) (LABEL "pownoises" -9) (LABEL "acRes" -10) (LABEL "result" -11) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "no single value" 3) (LABEL "no cv 0" 4))) (HIDE 5) (REPLACES "re") (REPLACES "result") (ASSERT) (EXPAND "correct_cache?" 5) (EXPAND "CacheData_correct?") (EXPAND "powvar?" 5) (EXPAND "varidx_powvar" 5) (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (SKEEP "cached cache idx") (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) ("cached is correct" "UNKNOWN")) (REPLACE "cached" "cached is correct" :DIR RL) (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (SPREAD (SPLIT "cached cond ok") ((THEN (REPLACE "pownoises" "cached cond ok" :DIR RL) (REPLACE "cached`1 varidx" "cached cond ok") (REVEAL "re") (REPLACE "re" "cached cond ok") (ASSERT) (FLATTEN "cached cond ok") (ASSERT) (GRIND)) (THEN (REPLACE "cached`1 varidx" "cached cond ok") (REPLACE "varac" "no single value") (REVEAL "re") (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (REPLACES "re") (ASSERT) (GRIND))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC57-1 |nil| 3631622080 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC63 0 (RE2AC_TCC63-1 "" 3803767122 ("" (SKEEP*) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached some" -6) (LABEL "cached" -5) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 6) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 4))) (("" (WITH-LABELS (SPLIT "not in cache 1") (("pow gt opn cached`1"))) (("" (WITH-LABELS (SPLIT "not in cache 2") (("pow gt opn cached`1"))) (("1" (EXPAND "/=") (("1" (PROPAX) NIL NIL)) NIL) ("2" (REPLACES "nwidxs" 7) (("2" (SPLIT 7) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACE -1 3 :HIDE? T) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (HIDE 4) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (EXPAND "idxs_bounded") (("1" (EXPAND "nth_ac") (("1" (REPLACE "pownoises") (("1" (INST "cache correct" "i") (("1" (REPLACE "cached`2 is powvarac") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 "cached correct" "pow gt opn cached`1")) (("2" (REPLACES -2 1) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "take_ol[nat,<]") (("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACES -4 2) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 2) (("1" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (EXPAND "min" 2) (("1" (LIFT-IF 2) (("1" (CASE "length(pownoises) = opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 2) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (SPLIT "cached cond ok") (("1" (FLATTEN) (("1" (REPLACES "varac" 2) (("1" (REPLACE "re" "cached cond ok") (("1" (ASSERT) (("1" (CASE "car[nat]
                                                                                                                                            (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                                                    nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "take" 1) (("2" (EXPAND "append" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACE -4 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "nats" 2) (("2" (REPLACE "newoff" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACE "varac" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (REPLACE "varac" 2) (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((/= CONST-DECL "boolean" |notequal| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|take_ol| FORMULA-DECL NIL |ordered_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|first_ol| CONST-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|idxs_pd| DEF-DECL "list[nat]" |affine| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|pownoises| SKOLEM-CONST-DECL "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" |affine_expr_Eval_fnd| NIL) (|cached| SKOLEM-CONST-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|last_take_nth| FORMULA-DECL NIL |ordered_list| |structures|) (|appendable_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|append_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|take| DEF-DECL "list[T]" |more_list_props| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (<= CONST-DECL "bool" |reals| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|length_take| FORMULA-DECL NIL |more_list_props| |structures|) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|newoff| SKOLEM-CONST-DECL "int" |affine_expr_Eval_fnd| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC58-2 |nil| 3767017892 ("" (SKEEP*) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (WITH-LABELS (SPLIT "not in cache 1") (("pow gt opn cached`1"))) (("" (WITH-LABELS (SPLIT "not in cache 2") (("pow gt opn cached`1"))) (("1" (EXPAND "/=") (("1" (PROPAX) NIL NIL)) NIL) ("2" (REPLACES "nwidxs" 7) (("2" (SPLIT 7) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACE -1 3 :HIDE? T) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (SKEEP "cached cache idx") (("1" (HIDE 4) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (EXPAND "idxs_bounded") (("1" (EXPAND "nth_ac") (("1" (REPLACE "pownoises") (("1" (INST "cache correct" "i") (("1" (REPLACE "cached`2 is powvarac") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 "cached correct" "pow gt opn cached`1")) (("2" (REPLACES -2 1) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "take_ol[nat,<]") (("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACES -4 2) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 2) (("1" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (EXPAND "min" 2) (("1" (LIFT-IF 2) (("1" (CASE "length(pownoises) = opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 2) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (SPLIT "cached cond ok") (("1" (FLATTEN) (("1" (REPLACES "varac" 2) (("1" (REPLACE "re" "cached cond ok") (("1" (ASSERT) (("1" (CASE "car[nat]
                                                                                                                           (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                                   nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "take" 1) (("2" (EXPAND "append" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACE -4 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "nats" 2) (("2" (REPLACE "newoff" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (REPLACE "varac" 1) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (REPLACE "varac" 2) (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC58-1 |nil| 3631622080 ("" (THEN (SKEEP*) (ASSERT) (HIDE -12) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "pow < cached pow" -6) (LABEL "cached" -7) (LABEL "idxs" -8) (LABEL "pownoises" -9) (LABEL "acRes" -10) (LABEL "result" -11) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "no single value" 3) (LABEL "no cv 0" 4))) (REPLACES "re") (REPLACES "result") (ASSERT) (SPREAD (SPLIT 5) ((THEN (INST 1 "(: (POW(re1, pow), acRes, pownoises) :)") (GRIND)) (THEN (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "compatible_pairs?" "cache compatible pairs") (WITH-LABELS (SKEEP "cache compatible pairs") (("vars in box" "compatible on"))) (INST 1 "N") (ASSERT) (EXPAND "compatible_pairs_on?" 1) (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "powvar?" 1) (EXPAND "varidx_powvar" 1) (EXPAND "compatible_pairs_on?") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (SKEEP "cached cache idx") (INST "compatible on" "i!1") (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT -1) ("cached is correct" "UNKNOWN")) (REPLACE "cached" "cached is correct" :DIR RL) (EXPAND "CacheData_correct?") (WITH-LABELS (ASSERT (-1 "cached`1 is powvar")) ("cached is correct" "UNKNOWN")) (WITH-LABELS (FLATTEN "cached is correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (SPREAD (SPLIT "cached cond ok") ((THEN (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (SKEEP) (INST "compatible on" "n") (WITH-LABELS (FLATTEN "compatible on") (("eval cache" "cache if powvar" "UNKNOWN"))) (REPLACE "cached`2 is powvarac" "eval cache") (REPLACE "acRes" 1) (REPLACE "varac" 1) (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (REVEAL "re") (ASSERT) (REPLACE "cached cache idx" "pownoises" :DIR RL) (REPLACE "pownoises" "eval cache" :DIR RL) (SPREAD (CASE "nth(cache, i!1)`1 = POW(re1, opn(nth(cache, i!1)`1))") ((THEN (REPLACES -1) (EXPAND "eval_ACExpr_Env") (EXPAND "eval") (LEMMA "containment_pow_var_ac") (SPREAD (SPLIT 1) ((THEN (USE "containment_pow_var_ac") (ASSERT) (SPREAD (SPLIT 1) ((THEN (EXPAND "eval") (REPLACE -16 :DIR RL) (EXPAND "vars_in_box_compatible?") (INST? "vars in box") (FLATTEN) (EXPAND "nth_ac") (PROPAX)) (THEN (FLATTEN) (REPLACE "pownoises") (HIDE -2) (SPREAD (SPLIT "cached cond ok") ((THEN (TYPEPRED "cached") (SPREAD (SPLIT -1) ((THEN (FLATTEN) (REPLACE -2 :HIDE? T) (REPLACE "re" "cached cond ok") (ASSERT) (HIDE-ALL-BUT ("cached cond ok" -4 "cached cache idx")) (EXPAND "next_idx") (EXPAND "last_idx") (EXPAND ">=") (USE "notmember_ol_nat") (ASSERT) (SPREAD (SPLIT 1) ((GRIND) (THEN (LIFT-IF "cached cond ok") (SPREAD (SPLIT "cached cond ok") ((THEN (FLATTEN) (EXPAND "varidx_powvar") (USE "olidx_car_last[nzBaseType]") (ASSERT) (EXPAND "car_ol") (ASSERT)) (THEN (FLATTEN) (EXPAND "varidx_powvar") (ASSERT)))))))) (PROPAX)))) (GRIND)))) (THEN (EXPAND "pow_var_compatible?") (SKEEP) (EXPAND "varidx_powvar") (INST "cache if powvar" "i!2") (REPLACE "pownoises" "cache if powvar" :DIR RL) (ASSERT))))) (THEN (EXPAND "pow_var_compatible?") (SKEEP) (EXPAND "varidx_powvar") (INST "cache if powvar" "i!2") (REPLACE "pownoises" "cache if powvar" :DIR RL) (PROPAX))))) (THEN (HIDE-ALL-BUT (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx" -13 -14)) (REPLACES "cached cache idx" :DIR RL) (REPLACES "re") (ASSERT) (APPLY-EXTENSIONALITY) (EXPAND "varidx_powvar") (USE "IntervalExpr_VARIDX_extensionality") (ASSERT))))) (THEN (REPLACE "cached`1 varidx" "cached cond ok") (REPLACE "varac" "no single value") (REVEAL "re") (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (REPLACES "re") (ASSERT) (EXPAND "varidx_powvar") (GRIND))))) (THEN (EXPAND "compatible_pairs_on?" "compatible on") (SPREAD (INST "compatible on" "i-1") ((THEN (EXPAND "nth" 2) (ASSERT)) (THEN (TYPEPRED "i") (GRIND)))))))) (THEN (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACES "acRes") (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "idxs_bounded" "cache idxs bound") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (SKEEP "cached cache idx") (INST "cache idxs bound" "i!1") (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (REPLACE "cached" "cached is correct" :DIR RL) (EXPAND "CacheData_correct?") (ASSERT ("cached is correct" "cached`1 is powvar")) (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (SPREAD (SPLIT "cached cond ok") ((THEN (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (REPLACE "cached`2 is powvarac" "cache idxs bound") (REPLACE "cached cache idx" "pownoises" :DIR RL) (REPLACE "pownoises" "cache idxs bound" :DIR RL) (REPLACE "cached cache idx" "cached`1 varidx" :DIR RL) (REPLACE "cached`1 varidx" "cache idxs bound") (REVEAL "re") (REPLACE "re" "cache idxs bound") (ASSERT) (USE "next_idx_pow_var_ac") (REPLACES -1) (USE "next_idx_pow_var_ac") (REPLACES -1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT)) (THEN (LIFT-IF "cache idxs bound") (SPREAD (SPLIT "cache idxs bound") ((GRIND) (THEN (WITH-LABELS (FLATTEN "cache idxs bound") (("already knonwn" "already knonwn" "cache idxs bound" "UNKNOWN"))) (SPREAD (SPLIT "cache idxs bound") ((THEN (FLATTEN) (GRIND)) (THEN (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (ASSERT) (HIDE-ALL-BUT (4 "cache idxs bound" "pow < cached pow" "cached cache idx")) (REPLACES "cached cache idx" :DIR RL) (EXPAND ">") (EXPAND ">=") (USE "nth_ol[nat,<]") (ASSERT))))))))))) (THEN (REPLACE "cached`1 varidx" "cached cond ok") (REPLACE "varac" "no single value") (REVEAL "re") (HIDE-ALL-BUT ("no single value" "cached cond ok" "re")) (REPLACES "re") (ASSERT) (EXPAND "varidx_powvar") (GRIND))))) (THEN (EXPAND "nth" 2) (ASSERT) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "idxs_bounded" "cache idxs bound") (INST "cache idxs bound" "i-1")))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC64 0 (RE2AC_TCC64-2 "" 3803767336 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached some" -6) (LABEL "cached" -5) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 6) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 4))) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "every") (("1" (SPLIT 1) (("1" (REPLACE "nwidxs" 1) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT (-1 "cache correct")) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACES -1 3) (("1" (SKEEP "cached cache idx") (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST "cache idxs bound" "i") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF "cache idxs bound") (("1" (SPLIT "cache idxs bound") (("1" (ASSERT) (("1" (REPLACE "varac" "varac not single value") (("1" (REPLACE "cached cache idx" "cache idxs bound") (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND ">=") (("2" (REPLACE "pownoises" 6) (("2" (REPLACE "cached cache idx" 6 :DIR RL) (("2" (HIDE-ALL-BUT ("cache idxs bound" 6)) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (USE "take_ol[nat,<]") (("4" (ASSERT) NIL NIL)) NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (TYPEPRED "cache") (("2" (GENERALIZE "cache" "cache") (("2" (INDUCT "cache") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("h" "t")) (("2" (FLATTEN) (("2" (EXPAND "every" 1) (("2" (SPLIT 1) (("1" (TYPEPRED "h`3") (("1" (ASSERT) NIL NIL)) NIL) ("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "correct_cache?" -1) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST?) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (EXPAND "nth" -3) (("3" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (EXPAND "nth" -3) (("4" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?" -1) (("5" (FLATTEN) NIL NIL)) NIL) ("6" (EXPAND "compatible_pairs?") (("6" (SKEEP) (("6" (INST?) (("6" (ASSERT) (("6" (EXPAND "compatible_pairs_on?") (("6" (SKEEP) (("6" (EXPAND "nth" -3) (("6" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (EXPAND "idxs_bounded") (("7" (SKEEP) (("7" (EXPAND "nth" -3) (("7" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "correct_cache?") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "re" 1) (("2" (ASSERT) (("2" (LIFT-IF "nwidxs") (("2" (SPLIT "nwidxs") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (REPLACE "nwidxs" 1) (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (WITH-LABELS (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (REPLACES "nats length" 2) (("1" (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (HIDE -3 "nats i") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                                     nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (REPLACES -1 2) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (REPLACE -4 "cached correct") (("1" (REPLACE "re" "cached correct") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "append" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "take" -1) (("1" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1) (("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "take" 2) (("2" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "pownoises" 1) (("3" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (USE "cache_powvar_correct_result") (("3" (WITH-LABELS (ASSERT) (("cached correct"))) (("3" (REPLACE "cached" "cached correct" :DIR RL) (("3" (EXPAND "CacheData_correct?" "cached correct") (("3" (TYPEPRED "cached") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (SPLIT "cached correct") (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 2) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (INST -5 "0") (("1" (EXPAND "nth") (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REPLACE "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "varidx_powvar") (("3" (REPLACES -5) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (HIDE-ALL-BUT (1 "pow gt opn" "opw gt opn")) (("3" (CASE "opn(val(cached)`1) < pow") (("1" (HIDE "pow gt opn" "opw gt opn") (("1" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 <= pow - opn(val(cached)`1)") (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|take_ol| FORMULA-DECL NIL |ordered_list| |structures|) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|first_ol| CONST-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|nzreal_expt| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|nzreal_exp| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (C CONST-DECL "posnat" |binomial| |reals|) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|pownoises| SKOLEM-CONST-DECL "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" |affine_expr_Eval_fnd| NIL) (|cached| SKOLEM-CONST-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|last_take_nth| FORMULA-DECL NIL |ordered_list| |structures|) (|appendable_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|append_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|take| DEF-DECL "list[T]" |more_list_props| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (<= CONST-DECL "bool" |reals| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|list_induction| FORMULA-DECL NIL |list_adt| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|t| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(t))" |affine_expr_Eval_fnd| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|h| SKOLEM-CONST-DECL "CacheData" |affine_expr_Eval_fnd| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|newoff| SKOLEM-CONST-DECL "int" |affine_expr_Eval_fnd| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|length_take| FORMULA-DECL NIL |more_list_props| |structures|) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-1 "" 3789917822 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "every") (("1" (SPLIT 1) (("1" (REPLACE "nwidxs" 1) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT (-1 "cache correct")) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACES -1 3) (("1" (SKEEP "cached cache idx") (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST "cache idxs bound" "i") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF "cache idxs bound") (("1" (SPLIT "cache idxs bound") (("1" (ASSERT) (("1" (REPLACE "varac" "varac not single value") (("1" (REPLACE "cached cache idx" "cache idxs bound") (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND ">=") (("2" (REPLACE "pownoises" 6) (("2" (REPLACE "cached cache idx" 6 :DIR RL) (("2" (HIDE-ALL-BUT ("cache idxs bound" 6)) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (USE "take_ol[nat,<]") (("4" (ASSERT) NIL NIL)) NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (TYPEPRED "cache") (("2" (GENERALIZE "cache" "cache") (("2" (INDUCT "cache") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("h" "t")) (("2" (FLATTEN) (("2" (EXPAND "every" 1) (("2" (SPLIT 1) (("1" (TYPEPRED "h`3") (("1" (ASSERT) NIL NIL)) NIL) ("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "correct_cache?" -1) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST?) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (EXPAND "nth" -3) (("3" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (EXPAND "nth" -3) (("4" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?" -1) (("5" (FLATTEN) NIL NIL)) NIL) ("6" (EXPAND "compatible_pairs?") (("6" (SKEEP) (("6" (INST?) (("6" (ASSERT) (("6" (EXPAND "compatible_pairs_on?") (("6" (SKEEP) (("6" (EXPAND "nth" -3) (("6" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (EXPAND "idxs_bounded") (("7" (SKEEP) (("7" (EXPAND "nth" -3) (("7" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "correct_cache?") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "re" 1) (("2" (ASSERT) (("2" (LIFT-IF "nwidxs") (("2" (SPLIT "nwidxs") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (REPLACE "nwidxs" 1) (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (WITH-LABELS (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (REPLACES "nats length" 2) (("1" (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (HIDE -3 "nats i") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                        nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (REPLACES -1 2) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (REPLACE -4 "cached correct") (("1" (REPLACE "re" "cached correct") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "append" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "take" -1) (("1" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1) (("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "take" 2) (("2" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "pownoises" 1) (("3" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (USE "cache_powvar_correct_result") (("3" (WITH-LABELS (ASSERT) (("cached correct"))) (("3" (REPLACE "cached" "cached correct" :DIR RL) (("3" (EXPAND "CacheData_correct?" "cached correct") (("3" (TYPEPRED "cached") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (SPLIT "cached correct") (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 2) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (INST -5 "0") (("1" (EXPAND "nth") (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REPLACE "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "varidx_powvar") (("3" (REPLACES -5) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (HIDE-ALL-BUT (1 "pow gt opn" "opw gt opn")) (("3" (CASE "opn(val(cached)`1) < pow") (("1" (HIDE "pow gt opn" "opw gt opn") (("1" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 <= pow - opn(val(cached)`1)") (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-5 |nil| 3767018113 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "every") (("1" (SPLIT 1) (("1" (REPLACE "nwidxs" 1) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT (-1 "cache correct")) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACES -1 3) (("1" (SKEEP "cached cache idx") (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST "cache idxs bound" "i") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF "cache idxs bound") (("1" (SPLIT "cache idxs bound") (("1" (ASSERT) (("1" (REPLACE "varac" "varac not single value") (("1" (REPLACE "cached cache idx" "cache idxs bound") (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND ">=") (("2" (REPLACE "pownoises" 6) (("2" (REPLACE "cached cache idx" 6 :DIR RL) (("2" (HIDE-ALL-BUT ("cache idxs bound" 6)) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (USE "take_ol[nat,<]") (("4" (ASSERT) NIL NIL)) NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (TYPEPRED "cache") (("2" (GENERALIZE "cache" "cache") (("2" (INDUCT "cache") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("h" "t")) (("2" (FLATTEN) (("2" (EXPAND "every" 1) (("2" (SPLIT 1) (("1" (TYPEPRED "h`3") (("1" (ASSERT) NIL NIL)) NIL) ("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "correct_cache?" -1) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST?) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (EXPAND "nth" -3) (("3" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (EXPAND "nth" -3) (("4" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?" -1) (("5" (FLATTEN) NIL NIL)) NIL) ("6" (EXPAND "compatible_pairs?") (("6" (SKEEP) (("6" (INST?) (("6" (ASSERT) (("6" (EXPAND "compatible_pairs_on?") (("6" (SKEEP) (("6" (EXPAND "nth" -3) (("6" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (EXPAND "idxs_bounded") (("7" (SKEEP) (("7" (EXPAND "nth" -3) (("7" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "correct_cache?") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "re" 1) (("2" (ASSERT) (("2" (LIFT-IF "nwidxs") (("2" (SPLIT "nwidxs") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (REPLACE "nwidxs" 1) (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (WITH-LABELS (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (REPLACES "nats length" 2) (("1" (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (HIDE -3 "nats i") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                        nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (REPLACES -1 2) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (REPLACE -4 "cached correct") (("1" (REPLACE "re" "cached correct") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "append" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "take" -1) (("1" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1) (("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "take" 2) (("2" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "pownoises" 1) (("3" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (USE "cache_powvar_correct_result") (("3" (WITH-LABELS (ASSERT) (("cached correct"))) (("3" (REPLACE "cached" "cached correct" :DIR RL) (("3" (EXPAND "CacheData_correct?" "cached correct") (("3" (TYPEPRED "cached") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (SPLIT "cached correct") (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (REPLACES "idx") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 2) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (INST -5 "0") (("1" (EXPAND "nth") (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REPLACE "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "varidx_powvar") (("3" (REPLACES -5) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (HIDE-ALL-BUT (1 "pow gt opn" "opw gt opn")) (("3" (CASE "opn(val(cached)`1) < pow") (("1" (HIDE "pow gt opn" "opw gt opn") (("1" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 <= pow - opn(val(cached)`1)") (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-4 |nil| 3632075985 ("" (GRIND) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-3 |nil| 3632063218 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -8) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached" -3) (LABEL "newoff" -4) (LABEL "nwidxs" -5) (LABEL "acRes" -6) (LABEL "result" -7) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N vars in box" "i_1") (("1" (WITH-LABELS (FLATTEN) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP 1) (("2" (CASE "i_1=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (FLATTEN) (("1" (REPLACE "N vars in box" 1 :DIR RL) (("1" (REPLACE "acRes" 1) (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (HIDE 2) (("1" (REPLACES "varac") (("1" (EXPAND "nth_ac") (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "k") (("1" (FLATTEN) (("1" (USE "idxs_ac_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND ">") (("1" (REPLACES "varac") (("1" (USE "last_idx_box") (("1" (EXPAND ">=") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND "last_ol") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (USE "pow_var_compatible_noise") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "pow_var_compatible_noise") (("1" (REPLACE "varac" 1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache comp pairs on" "i_1 -1 ") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES "cache comp pairs on" 2 :DIR RL) (("1" (SPLIT 2) (("1" (USE "eval_updb_no_idxs") (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache idxs bound" "i_1 - 1") (("2" (EXPAND "idxs_ac") (("2" (EXPAND "next_idx") (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (INST?) (("2" (CASE "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                             upd_noise_burst(N,
                                                                             nwidxs,
                                                                             LAMBDA
                                                                             (i: nat):
                                                                             (get_noise_by_idx
                                                                              (car(pd(varac))`1, N)
                                                                              ^
                                                                              (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                             N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                      0)`1,
                                                                  upd_noise_burst(N,
                                                                                  nwidxs,
                                                                                  LAMBDA
                                                                                  (i: nat):
                                                                                  (get_noise_by_idx
                                                                                   (car(pd(varac))`1, N)
                                                                                   ^
                                                                                   (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                      0)`1,
                                                                  N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACE "nwidxs" -1) (("1" (EXPAND "nth" -1 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (LEMMA "last_idx_box") (("1" (INST? -1 :WHERE -2) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (CASE "NOT null?(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))))") (("1" (ASSERT) (("1" (LEMMA "olidx_car_last[nzBaseType]") (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE "cache comp pairs on") (("1" (REPLACE "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST? "cache idxs bound") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound") (("2" (EXPAND ">=") (("2" (HIDE-ALL-BUT (-5 1 "cache idxs bound")) (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (EXPAND ">=") (("3" (HIDE-ALL-BUT (1 "pow <= 1")) (("3" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "nwidxs") (("1" (CASE "length(nwidxs)=0") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "newoff") (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (REPLACES "nwidxs") (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (INST -5 "pow-2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (2 -2 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?") (("5" (EXPAND "CacheData_correct?") (("5" (FLATTEN) (("5" (TYPEPRED "nextfreeidx") (("5" (REPLACES "nwidxs" 2) (("5" (EXPAND "nats" 2) (("5" (LIFT-IF 2) (("5" (SPLIT 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1 1 :DIR RL) (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-2 |nil| 3631872861 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -8) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached" -3) (LABEL "newoff" -4) (LABEL "nwidxs" -5) (LABEL "acRes" -6) (LABEL "result" -7) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N vars in box" "i_1") (("1" (WITH-LABELS (FLATTEN) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP 1) (("2" (CASE "i_1=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (FLATTEN) (("1" (REPLACE "N vars in box" 1 :DIR RL) (("1" (REPLACE "acRes" 1) (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (HIDE 2) (("1" (REPLACES "varac") (("1" (EXPAND "nth_ac") (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "k") (("1" (FLATTEN) (("1" (USE "idxs_ac_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND ">") (("1" (REPLACES "varac") (("1" (USE "last_idx_box") (("1" (EXPAND ">=") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND "last_ol") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (USE "pow_var_compatible_noise") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "pow_var_compatible_noise") (("1" (REPLACE "varac" 1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache comp pairs on" "i_1 -1 ") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES "cache comp pairs on" 2 :DIR RL) (("1" (SPLIT 2) (("1" (USE "eval_updb_no_idxs") (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache idxs bound" "i_1 - 1") (("2" (EXPAND "idxs_ac") (("2" (EXPAND "next_idx") (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (INST?) (("2" (CASE "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                       upd_noise_burst(N,
                                       nwidxs,
                                       LAMBDA
                                       (i: nat):
                                       (get_noise_by_idx
                                        (car(pd(varac))`1, N)
                                        ^
                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                       N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                            0)`1,
                        upd_noise_burst(N,
                                        nwidxs,
                                        LAMBDA
                                        (i: nat):
                                        (get_noise_by_idx
                                         (car(pd(varac))`1, N)
                                         ^
                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                            0)`1,
                        N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACE "nwidxs" -1) (("1" (EXPAND "nth" -1 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (LEMMA "last_idx_box") (("1" (INST? -1 :WHERE -2) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (CASE "NOT null?(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))))") (("1" (ASSERT) (("1" (LEMMA "olidx_car_last[nzBaseType]") (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE "cache comp pairs on") (("1" (REPLACE "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST? "cache idxs bound") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (FLATTEN) (("1" (REPLACE -4 "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound") (("2" (EXPAND ">=") (("2" (HIDE-ALL-BUT (-6 1 "cache idxs bound")) (("2" (USE "nth_ol[nat,<]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (EXPAND ">=") (("3" (HIDE-ALL-BUT (1 "pow <= 1")) (("3" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "nwidxs") (("1" (CASE "length(nwidxs)=0") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "newoff") (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (REPLACES "nwidxs") (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (INST -5 "pow-2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (2 -2 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?") (("5" (EXPAND "CacheData_correct?") (("5" (FLATTEN) (("5" (TYPEPRED "nextfreeidx") (("5" (REPLACES "nwidxs" 2) (("5" (EXPAND "nats" 2) (("5" (LIFT-IF 2) (("5" (SPLIT 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1 1 :DIR RL) (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-1 |nil| 3631622080 ("" (SKEEP*) (("" (POSTPONE) NIL NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC65 0 (RE2AC_TCC65-3 "" 3883673832 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached some" -6) (LABEL "cached" -5) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 6) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 4))) (("" (HIDE -13) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT "nwidxs") (("1" (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (HIDE "opn name") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (EXPAND "eval" 1) (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (REPLACE -17) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LEMMA "eval_pd_noise_rec_pds_def") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACE "varac" :DIR RL) (("2" (FLATTEN) (("2" (REPLACE "nwidxs" -1 :HIDE? T) (("2" (USE "member_append_fi[nat]") (("2" (ASSERT) (("2" (HIDE -2) (("2" (SPLIT -1) (("1" (SPLIT "cached cond ok") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (REPLACE "pownoises") (("1" (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (("1" (REPLACES "varac") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (USE "take_ol[nat,<]") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) (("2" (HIDE -2) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (REPLACE "varac") (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (("2" (USE "olidx_car_last[nzBaseType]") (("2" (SPLIT -1) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REVEAL "cache comp pairs on") (("3" (HIDE -1) (("3" (INST "cache comp pairs on" "i") (("3" (ASSERT) (("3" (LEMMA "powvar_comp_noise_extension") (("3" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached cache idx" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i") (("2" (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached cache idx") (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "varidx_powvar") (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (REPLACE "varac") (("4" (SPLIT 1) (("1" (EXPAND "nth_ac") (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 "varac not single value")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACE "varac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac" "varac not single value")) (("4" (EXPAND "length") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "j") (("2" (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "cached in cache") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached in cache") (("2" (USE "cache_powvar_correct") (("2" (REPLACE "cached in cache") (("2" (EXPAND "CacheData_correct?") (("2" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (REPLACE "cached idx re" -1) (("2" (REPLACE "re" -1) (("2" (REPLACE "varac" "varac not single value") (("2" (ASSERT) (("2" (REPLACE "cached idx re" 1) (("2" (REPLACE "re" 1) (("2" (EXPAND "varidx_powvar") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "cached idx re" -1) (("3" (REPLACE "re" -1) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (REPLACE "cached idx re" "cached cond ok") (("3" (REPLACE "re" "cached cond ok") (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (ASSERT) NIL NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (INST "cache comp pairs on" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                                          	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                                0)`1,
                                                                                                                                                                                                                                                                                            upd_noise_burst(N,
                                                                                                                                                                                                                                                                                                            nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                                            LAMBDA
                                                                                                                                                                                                                                                                                                            (i: nat):
                                                                                                                                                                                                                                                                                                            (get_noise_by_idx
                                                                                                                                                                                                                                                                                                             (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                                             ^
                                                                                                                                                                                                                                                                                                             (1 + i +opn))))
                                                                                                                                                                                                                                                                            ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                                0)`1,
                                                                                                                                                                                                                                                                                            N)
                                                                                                                                                                                                                                                                            ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "i = opn(nth(cache, k - 1)`1) - 2") (("1" (REPLACES -1) (("1" (HIDE -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE -2) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "opn >= 2")) (("4" (SKEEP) (("4" (REVEAL "opn name") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (1 "varac not single value")) (("5" (EXPAND "length") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (INST -1 "upd_noise_burst(N,
                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                   LAMBDA
                                                                                                                                                                                                   (i: nat):
                                                                                                                                                                                                   (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                                    ^
                                                                                                                                                                                                    (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (EXPAND "nth_ac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                                                                                                                              nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                              LAMBDA
                                                                                                                                                                                                                                                              (i: nat):
                                                                                                                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                               ^
                                                                                                                                                                                                                                                               (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              N)") (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                                    upd_noise_burst(N,
                                                                                                                                                                                                                                                                                    nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                    LAMBDA
                                                                                                                                                                                                                                                                                    (i: nat):
                                                                                                                                                                                                                                                                                    (get_noise_by_idx
                                                                                                                                                                                                                                                                                     (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                     ^
                                                                                                                                                                                                                                                                                     (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                                    N)") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "j < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE (-2 1)) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) (("2" (EXPAND "somevidx") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (EXPAND "varidx_powvar") (("5" (ASSERT) NIL NIL)) NIL) ("6" (EXPAND "varidx_powvar") (("6" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                                      nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                                               pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (CASE "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                                              nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("2" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SPLIT 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                                      =
                                                                      nth(nats(nextfreeidx, newoff - 1),
                                                                          pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                      pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (SPLIT 1) (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_append[nat]") (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-2 "" 3803769554 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached some" -6) (LABEL "cached" -5) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 6) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 4))) (("" (HIDE -13) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (HIDE "opn name") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (EXPAND "eval" 1) (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (REPLACE -17) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LEMMA "eval_pd_noise_rec_pds_def") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACE "varac" :DIR RL) (("2" (FLATTEN) (("2" (REPLACE "nwidxs" -1 :HIDE? T) (("2" (USE "member_append_fi[nat]") (("2" (ASSERT) (("2" (HIDE -2) (("2" (SPLIT -1) (("1" (SPLIT "cached cond ok") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (REPLACE "pownoises") (("1" (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (("1" (REPLACES "varac") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (USE "take_ol[nat,<]") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) (("2" (HIDE -2) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (REPLACE "varac") (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (("2" (USE "olidx_car_last[nzBaseType]") (("2" (SPLIT -1) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REVEAL "cache comp pairs on") (("3" (HIDE -1) (("3" (INST "cache comp pairs on" "i") (("3" (ASSERT) (("3" (LEMMA "powvar_comp_noise_extension") (("3" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached cache idx" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i") (("2" (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached cache idx") (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "varidx_powvar") (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (REPLACE "varac") (("4" (SPLIT 1) (("1" (EXPAND "nth_ac") (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 "varac not single value")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACE "varac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac" "varac not single value")) (("4" (EXPAND "length") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "j") (("2" (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "cached in cache") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached in cache") (("2" (USE "cache_powvar_correct") (("2" (REPLACE "cached in cache") (("2" (EXPAND "CacheData_correct?") (("2" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (REPLACE "cached idx re" -1) (("2" (REPLACE "re" -1) (("2" (REPLACE "varac" "varac not single value") (("2" (ASSERT) (("2" (REPLACE "cached idx re" 1) (("2" (REPLACE "re" 1) (("2" (EXPAND "varidx_powvar") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "cached idx re" -1) (("3" (REPLACE "re" -1) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (REPLACE "cached idx re" "cached cond ok") (("3" (REPLACE "re" "cached cond ok") (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (ASSERT) NIL NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (INST "cache comp pairs on" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                                          	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                                0)`1,
                                                                                                                                                                                                                                                                                            upd_noise_burst(N,
                                                                                                                                                                                                                                                                                                            nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                                            LAMBDA
                                                                                                                                                                                                                                                                                                            (i: nat):
                                                                                                                                                                                                                                                                                                            (get_noise_by_idx
                                                                                                                                                                                                                                                                                                             (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                                             ^
                                                                                                                                                                                                                                                                                                             (1 + i +opn))))
                                                                                                                                                                                                                                                                            ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                                0)`1,
                                                                                                                                                                                                                                                                                            N)
                                                                                                                                                                                                                                                                            ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "i = opn(nth(cache, k - 1)`1) - 2") (("1" (REPLACES -1) (("1" (HIDE -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE -2) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "opn >= 2")) (("4" (SKEEP) (("4" (REVEAL "opn name") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (1 "varac not single value")) (("5" (EXPAND "length") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (INST -1 "upd_noise_burst(N,
                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                   LAMBDA
                                                                                                                                                                                                   (i: nat):
                                                                                                                                                                                                   (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                                    ^
                                                                                                                                                                                                    (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (EXPAND "nth_ac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                                                                                                                              nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                              LAMBDA
                                                                                                                                                                                                                                                              (i: nat):
                                                                                                                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                               ^
                                                                                                                                                                                                                                                               (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              N)") (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                                    upd_noise_burst(N,
                                                                                                                                                                                                                                                                                    nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                    LAMBDA
                                                                                                                                                                                                                                                                                    (i: nat):
                                                                                                                                                                                                                                                                                    (get_noise_by_idx
                                                                                                                                                                                                                                                                                     (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                     ^
                                                                                                                                                                                                                                                                                     (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                                    N)") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "j < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE (-2 1)) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) (("2" (EXPAND "somevidx") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (EXPAND "varidx_powvar") (("5" (ASSERT) NIL NIL)) NIL) ("6" (EXPAND "varidx_powvar") (("6" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                                      nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                                               pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (CASE "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                                              nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("2" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SPLIT 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                                      =
                                                                      nth(nats(nextfreeidx, newoff - 1),
                                                                          pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                      pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (SPLIT 1) (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_append[nat]") (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|nzreal_expt| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|nzreal_exp| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (C CONST-DECL "posnat" |binomial| |reals|) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|cache_powvar_correct_result| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|length_take| FORMULA-DECL NIL |more_list_props| |structures|) (N SKOLEM-CONST-DECL "Noise" |affine_expr_Eval_fnd| NIL) (|pow| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|j| SKOLEM-CONST-DECL "below(opn(nth[CacheData](cache, k - 1)`1) - 1)" |affine_expr_Eval_fnd| NIL) (|k| SKOLEM-CONST-DECL "below(length(cons((re, acRes, nwidxs), cache)))" |affine_expr_Eval_fnd| NIL) (|somevidx| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible_noise| FORMULA-DECL NIL |affine_pow| NIL) (|k| SKOLEM-CONST-DECL "below(length(box))" |affine_expr_Eval_fnd| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|newoff| SKOLEM-CONST-DECL "int" |affine_expr_Eval_fnd| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|opn| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (N SKOLEM-CONST-DECL "Noise" |affine_expr_Eval_fnd| NIL) (|varac| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|get_noise_by_idx| DEF-DECL "Epsilon" |affine| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|upd_noise_burst| CONST-DECL "Noise" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|k| SKOLEM-CONST-DECL "below(length(cons((re, acRes, nwidxs), cache)))" |affine_expr_Eval_fnd| NIL) (|nwidxs| SKOLEM-CONST-DECL "list[nat]" |affine_expr_Eval_fnd| NIL) (|acRes| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(opn(nth[CacheData](cache, k - 1)`1) - 1)" |affine_expr_Eval_fnd| NIL) (|nth_ol| FORMULA-DECL NIL |ordered_list| |structures|) (|containment_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|take| DEF-DECL "list[T]" |more_list_props| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|idxs_pd| DEF-DECL "list[nat]" |affine| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|notmember_ol_nat| FORMULA-DECL NIL |affine_pow| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|cached| SKOLEM-CONST-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|member| DEF-DECL "bool" |list_props| NIL) (|take_ol| FORMULA-DECL NIL |ordered_list| |structures|) (|olidx_car_last| FORMULA-DECL NIL |indexed_list| |structures|) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|member_append_fi| FORMULA-DECL NIL |more_list_props| |structures|) (|pownoises| SKOLEM-CONST-DECL "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" |affine_expr_Eval_fnd| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|last_take_nth| FORMULA-DECL NIL |ordered_list| |structures|) (|powvar_comp_noise_extension| FORMULA-DECL NIL |affine_pow| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|idx| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|beyond_last_idx_notmember| FORMULA-DECL NIL |affine| NIL) (|eval_updb_no_idxs| FORMULA-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|gnbi_updb_2| FORMULA-DECL NIL |affine| NIL) (|member_nats| FORMULA-DECL NIL |affine_pow| NIL) (|power_Epsilon_is_Epsilon| FORMULA-DECL NIL |affine_pow| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|k| SKOLEM-CONST-DECL "below(length(box))" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|eval_pd_noise_rec_pds_def| FORMULA-DECL NIL |affine| NIL) (|lt_idx_strict_order| FORMULA-DECL NIL |indexed_list| |structures|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-1 "" 3789917913 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (HIDE -13) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (HIDE "opn name") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (EXPAND "eval" 1) (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (REPLACE -17) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LEMMA "eval_pd_noise_rec_pds_def") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACE "varac" :DIR RL) (("2" (FLATTEN) (("2" (REPLACE "nwidxs" -1 :HIDE? T) (("2" (USE "member_append_fi[nat]") (("2" (ASSERT) (("2" (HIDE -2) (("2" (SPLIT -1) (("1" (SPLIT "cached cond ok") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (REPLACE "pownoises") (("1" (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (("1" (REPLACES "varac") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (USE "take_ol[nat,<]") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) (("2" (HIDE -2) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (REPLACE "varac") (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (("2" (USE "olidx_car_last[nzBaseType]") (("2" (SPLIT -1) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REVEAL "cache comp pairs on") (("3" (HIDE -1) (("3" (INST "cache comp pairs on" "i") (("3" (ASSERT) (("3" (LEMMA "powvar_comp_noise_extension") (("3" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached cache idx" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i") (("2" (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached cache idx") (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "varidx_powvar") (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (REPLACE "varac") (("4" (SPLIT 1) (("1" (EXPAND "nth_ac") (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 "varac not single value")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACE "varac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac" "varac not single value")) (("4" (EXPAND "length") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "j") (("2" (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "cached in cache") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached in cache") (("2" (USE "cache_powvar_correct") (("2" (REPLACE "cached in cache") (("2" (EXPAND "CacheData_correct?") (("2" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (REPLACE "cached idx re" -1) (("2" (REPLACE "re" -1) (("2" (REPLACE "varac" "varac not single value") (("2" (ASSERT) (("2" (REPLACE "cached idx re" 1) (("2" (REPLACE "re" 1) (("2" (EXPAND "varidx_powvar") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "cached idx re" -1) (("3" (REPLACE "re" -1) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (REPLACE "cached idx re" "cached cond ok") (("3" (REPLACE "re" "cached cond ok") (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (ASSERT) NIL NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (INST "cache comp pairs on" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                     	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     upd_noise_burst(N,
                                                                                                                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                                                                                                                     (get_noise_by_idx
                                                                                                                                                                                                                                                                                      (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                      ^
                                                                                                                                                                                                                                                                                      (1 + i +opn))))
                                                                                                                                                                                                                                                     ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     N)
                                                                                                                                                                                                                                                     ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "i = opn(nth(cache, k - 1)`1) - 2") (("1" (REPLACES -1) (("1" (HIDE -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE -2) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "opn >= 2")) (("4" (SKEEP) (("4" (REVEAL "opn name") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (1 "varac not single value")) (("5" (EXPAND "length") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (INST -1 "upd_noise_burst(N,
                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                     (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                      ^
                                                                                                                                                                                      (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (EXPAND "nth_ac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           upd_noise_burst(N,
                                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                           LAMBDA
                                                                                                                                                                                                                                           (i: nat):
                                                                                                                                                                                                                                           (get_noise_by_idx
                                                                                                                                                                                                                                            (car(pd(varac))`1, N)
                                                                                                                                                                                                                                            ^
                                                                                                                                                                                                                                            (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           N)") (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               upd_noise_burst(N,
                                                                                                                                                                                                                                                               nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                               LAMBDA
                                                                                                                                                                                                                                                               (i: nat):
                                                                                                                                                                                                                                                               (get_noise_by_idx
                                                                                                                                                                                                                                                                (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                ^
                                                                                                                                                                                                                                                                (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               N)") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "j < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE (-2 1)) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) (("2" (EXPAND "somevidx") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (EXPAND "varidx_powvar") (("5" (ASSERT) NIL NIL)) NIL) ("6" (EXPAND "varidx_powvar") (("6" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                            pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (CASE "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                         nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("2" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SPLIT 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                   =
                                                   nth(nats(nextfreeidx, newoff - 1),
                                                       pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (SPLIT 1) (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_append[nat]") (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-4 |nil| 3767019773 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (HIDE -13) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (HIDE "opn name") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (EXPAND "eval" 1) (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (REPLACE -17) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LEMMA "eval_pd_noise_rec_pds_def") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACE "varac" :DIR RL) (("2" (FLATTEN) (("2" (REPLACE "nwidxs" -1 :HIDE? T) (("2" (USE "member_append_fi[nat]") (("2" (ASSERT) (("2" (HIDE -2) (("2" (SPLIT -1) (("1" (SPLIT "cached cond ok") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (REPLACE "pownoises") (("1" (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (("1" (REPLACES "varac") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (USE "take_ol[nat,<]") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) (("2" (HIDE -2) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (REPLACE "varac") (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (("2" (USE "olidx_car_last[nzBaseType]") (("2" (SPLIT -1) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REVEAL "cache comp pairs on") (("3" (HIDE -1) (("3" (INST "cache comp pairs on" "i") (("3" (ASSERT) (("3" (LEMMA "powvar_comp_noise_extension") (("3" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached cache idx" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i") (("2" (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached cache idx") (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "varidx_powvar") (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (REPLACE "varac") (("4" (SPLIT 1) (("1" (EXPAND "nth_ac") (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 "varac not single value")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACE "varac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac" "varac not single value")) (("4" (EXPAND "length") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (INST "cache comp pairs on" "n") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "j") (("2" (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "cached in cache") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached in cache") (("2" (USE "cache_powvar_correct") (("2" (REPLACE "cached in cache") (("2" (EXPAND "CacheData_correct?") (("2" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (REPLACE "cached idx re" -1) (("2" (REPLACE "re" -1) (("2" (REPLACE "varac" "varac not single value") (("2" (ASSERT) (("2" (REPLACE "cached idx re" 1) (("2" (REPLACE "re" 1) (("2" (EXPAND "varidx_powvar") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "cached idx re" -1) (("3" (REPLACE "re" -1) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (REPLACE "cached idx re" "cached cond ok") (("3" (REPLACE "re" "cached cond ok") (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (ASSERT) NIL NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (INST "cache comp pairs on" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                     	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     upd_noise_burst(N,
                                                                                                                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                                                                                                                     (get_noise_by_idx
                                                                                                                                                                                                                                                                                      (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                      ^
                                                                                                                                                                                                                                                                                      (1 + i +opn))))
                                                                                                                                                                                                                                                     ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     N)
                                                                                                                                                                                                                                                     ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "i = opn(nth(cache, k - 1)`1) - 2") (("1" (REPLACES -1) (("1" (HIDE -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE -2) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "opn >= 2")) (("4" (SKEEP) (("4" (REVEAL "opn name") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (1 "varac not single value")) (("5" (EXPAND "length") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SKEEP) (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (INST -1 "upd_noise_burst(N,
                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                     (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                      ^
                                                                                                                                                                                      (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (EXPAND "nth_ac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (INST "cache comp pairs on" "n") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           upd_noise_burst(N,
                                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                           LAMBDA
                                                                                                                                                                                                                                           (i: nat):
                                                                                                                                                                                                                                           (get_noise_by_idx
                                                                                                                                                                                                                                            (car(pd(varac))`1, N)
                                                                                                                                                                                                                                            ^
                                                                                                                                                                                                                                            (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               upd_noise_burst(N,
                                                                                                                                                                                                                                                               nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                               LAMBDA
                                                                                                                                                                                                                                                               (i: nat):
                                                                                                                                                                                                                                                               (get_noise_by_idx
                                                                                                                                                                                                                                                                (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                ^
                                                                                                                                                                                                                                                                (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               N)") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "j < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE (-2 1)) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) (("2" (EXPAND "somevidx") (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (EXPAND "varidx_powvar") (("5" (ASSERT) NIL NIL)) NIL) ("6" (EXPAND "varidx_powvar") (("6" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                            pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (CASE "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                         nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("2" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SPLIT 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                   =
                                                   nth(nats(nextfreeidx, newoff - 1),
                                                       pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (SPLIT -1) (("1" (REPLACES -1 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (USE "length_take[nat]") (("1" (REPLACE -1 -2) (("1" (EXPAND "min") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (SPLIT 1) (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-3 |nil| 3767018486 ("" (THEN (SKEEP*) (ASSERT) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (HIDE -13) (REPLACES "result") (ASSERT) (SPREAD (SPLIT 7) ((SPREAD (INST 1 "(:(re, acRes, nwidxs):)") ((THEN (EXPAND "append" 1) (GRIND)) (GRIND))) (THEN (LIFT-IF "nwidxs") (SPREAD (SPLIT NWIDXS) ((THEN (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (HIDE "opn name") (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "compatible_pairs?") (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (SPREAD (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") ((SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (SKOLEM 1 "k") (INST "N vars in box" "k") (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (SPREAD (SPLIT 1) ((THEN (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1 2) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (ASSERT)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((EXPAND_OL) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)))))))) (THEN (FLATTEN) (ASSERT) (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (REPLACES "nwidxs" -1) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (GRIND)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)))))))) (THEN (EXPAND "compatible_pairs_on?") (SKOLEM 1 "k") (SKEEP) (SPREAD (SPLIT 1) ((SPREAD (CASE "k=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "eval_ACExpr_Env" 1) (REPLACES "acRes") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "i") (INST "cache comp pairs on" "i") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (REPLACE "cached cache idx") (EXPAND "eval_ACExpr_Env" "cache eval") (ASSERT) (USE "cache_powvar_correct") (REPLACE "cached cache idx") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached as AC" "cache eval") (REPLACE "re") (ASSERT) (REPLACE "cached idx re") (REPLACE "varac" 1) (LEMMA "containment_pow_var_ac") (EXPAND "eval" 1) (EXPAND "eval" 1) (SPREAD (INST? -1 :WHERE 1) ((THEN (ASSERT) (HIDE 2) (SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (INST "N vars in box" "idx") (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (REPLACE -17) (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "nth_ac") (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1 2) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "last_idx_in_box") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (FLATTEN)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1) (LEMMA "eval_pd_noise_rec_pds_def") (GRIND))))) (THEN (EXPAND "nth_ac") (REPLACE "varac" :DIR RL) (FLATTEN) (REPLACE "nwidxs" -1 :HIDE? T) (USE "member_append_fi[nat]") (ASSERT) (HIDE -2) (SPREAD (SPLIT -1) ((SPREAD (SPLIT "cached cond ok") ((THEN (EXPAND "next_idx") (EXPAND "last_idx") (REPLACE "pownoises") (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (REPLACES "varac") (USE "olidx_car_last[nzBaseType]") (ASSERT) (EXPAND "car_ol") (SPREAD (USE "notmember_ol_nat") ((THEN (ASSERT) (GRIND)) (USE "take_ol[nat,<]")))) (GRIND))) (THEN (USE "member_nats") (ASSERT) (HIDE -2) (FLATTEN) (TYPEPRED "nextfreeidx") (REPLACE "varac") (USE "last_idx_box") (EXPAND "next_idx") (EXPAND "last_idx") (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (USE "olidx_car_last[nzBaseType]") (SPREAD (SPLIT -1) ((THEN (EXPAND "car_ol") (ASSERT)) (THEN (EXPAND "length") (ASSERT)))))))) (THEN (REVEAL "cache comp pairs on") (HIDE -1) (INST "cache comp pairs on" "i") (ASSERT) (LEMMA "powvar_comp_noise_extension") (SPREAD (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((THEN (ASSERT) (REPLACE "varac" -1) (REPLACES "cached cache idx" :DIR RL) (REPLACE "pownoises" -1) (REPLACE "nwidxs" 1) (REPLACE "pownoises" 1) (REPLACE "re" (-1 1)) (REPLACE "newoff" 1) (REVEAL "opn name") (ASSERT) (GRIND)) (THEN (HIDE 2) (REPLACE "pownoises" 1) (EXPAND "idxs_bounded" "cache idxs bound") (INST "cache idxs bound" "i") (SPREAD (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") ((THEN (REPLACE -1 "cache idxs bound" :HIDE? T) (SPREAD (USE "last_take_nth[nat,<]") ((THEN (REPLACE -1 1 :HIDE? T) (ASSERT)) (GRIND)))) (THEN (REPLACE "cached cache idx") (REPLACE "cached as AC" 1) (USE "next_idx_pow_var_ac") (ASSERT) (GRIND)) (THEN (REPLACE "varac" "varac not single value") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (THEN (EXPAND "varidx_powvar") (REPLACE "varac" "varac not single value") (REPLACE "pownoises" 1) (REPLACE "varac" 1) (FLATTEN) (ASSERT) (FLATTEN) (ASSERT)) (THEN (EXPAND "length" "varac not single value") (REPLACE "varac") (SPREAD (SPLIT 1) ((THEN (EXPAND "nth_ac") (HIDE-ALL-BUT 1) (GRIND)) (THEN (HIDE-ALL-BUT (-1 "varac not single value")) (ASSERT))))) (THEN (REPLACE "re" 1) (ASSERT)))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (REVEAL "varac") (GRIND))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac" "varac not single value")) (EXPAND "length") (GRIND))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST "cache comp pairs on" "k-1") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (REPLACE "cache eval" 2 :DIR RL) (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 3) (SKEEP) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "idxs_bounded" "cache idxs bound") (INST?) (EXPAND "idxs_ac") (USE "beyond_last_idx_notmember") (ASSERT) (EXPAND "next_idx") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))))) (SPREAD (CASE "k=0") ((THEN (REPLACES -1) (FLATTEN) (EXPAND "nth" (-1 -2)) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (SKOLEM "cached in cache" "j") (INST "cache comp pairs on" "j") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (ASSERT) (LEMMA "powvar_comp_noise_extension") (SPREAD (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((THEN (ASSERT) (REPLACE "varac" -1) (REPLACES "cached in cache" :DIR RL) (REPLACE "pownoises" -1) (REPLACE "cached idx re" "cached N compatible") (REPLACE "re" "cached N compatible") (REPLACE "nwidxs" 1) (REPLACE "pownoises" 1) (REPLACE "re" (-1 1)) (REPLACE "newoff" 1) (REVEAL "opn name") (ASSERT) (EXPAND "varidx_powvar") (ASSERT)) (THEN (REPLACE "pownoises" 1) (EXPAND "idxs_bounded" "cache idxs bound") (INST "cache idxs bound" "j") (SPREAD (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") ((THEN (REPLACE -1 "cache idxs bound" :HIDE? T) (SPREAD (USE "last_take_nth[nat,<]") ((THEN (REPLACE -1 1 :HIDE? T) (ASSERT)) (THEN (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (REPLACE "cached in cache") (ASSERT) (FLATTEN) (REPLACE "varac") (REPLACE "cached idx re") (REPLACE "re") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (THEN (REPLACE "cached in cache") (USE "cache_powvar_correct") (REPLACE "cached in cache") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached as AC" 1) (USE "next_idx_pow_var_ac") (REPLACE "cached idx re" -1) (REPLACE "re" -1) (REPLACE "varac" "varac not single value") (ASSERT) (REPLACE "cached idx re" 1) (REPLACE "re" 1) (ASSERT) (EXPAND "varidx_powvar") (PROPAX)) (THEN (USE "cache_powvar_correct") (REPLACE "cached in cache") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (ASSERT) (REPLACE "varac" "varac not single value") (REPLACE "cached idx re" -1) (REPLACE "re" -1) (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (THEN (USE "cache_powvar_correct") (REPLACE "cached in cache") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (ASSERT) (REPLACE "varac" "varac not single value") (REPLACE "pownoises" 1) (REPLACE "varac" 1) (REPLACE "cached idx re" "cached cond ok") (REPLACE "re" "cached cond ok") (ASSERT) (EXPAND "varidx_powvar") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (ASSERT)) (THEN (EXPAND "length" "varac not single value") (ASSERT)) (THEN (REPLACE "re" 1) (ASSERT))))) (THEN (FLATTEN) (SPREAD (INST "cache comp pairs on" "k-1") ((THEN (INST "cache comp pairs on" "n") (EXPAND "nth" 2) (ASSERT) (FLATTEN) (EXPAND "nth" (-1 -2)) (ASSERT) (EXPAND "pow_var_compatible?") (FLATTEN) (SKOLEM 2 "i") (ASSERT) (INST "cache comp pairs on" "i") (SPREAD (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                            	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") ((THEN (REPLACES -1) (SPREAD (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                                                                                             upd_noise_burst(N,
                                                                                                                                                                                                                                                                                             nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                             LAMBDA
                                                                                                                                                                                                                                                                                             (i: nat):
                                                                                                                                                                                                                                                                                             (get_noise_by_idx
                                                                                                                                                                                                                                                                                              (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                              ^
                                                                                                                                                                                                                                                                                              (1 + i +opn))))
                                                                                                                                                                                                                                                             ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                                                                                             N)
                                                                                                                                                                                                                                                             ^ (2 + i)") ((REPLACES -1) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (HIDE 2) (USE "member_nats") (ASSERT) (HIDE -2) (FLATTEN) (TYPEPRED "nextfreeidx") (EXPAND "nth_ac" -2) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (EXPAND "next_idx") (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (USE "last_idx_box") (EXPAND "next_idx") (EXPAND "last_idx") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (USE "olidx_car_last[nzBaseType]") (EXPAND_OL) (EXPAND "nth" -4 1) (ASSERT) (EXPAND "nth_ac") (ASSERT)) (THEN (ASSERT) (HIDE-ALL-BUT (-1 -7)) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))))) (THEN (HIDE 3) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (USE "member_nats") (ASSERT) (HIDE -2) (FLATTEN) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (LEMMA "next_idx_pow_var_ac") (INST? -1 :WHERE "cache idxs bound") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (TYPEPRED "cached") (ASSERT)) (THEN (FLATTEN) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACE -1 "cache idxs bound" :HIDE? T) (TYPEPRED "i") (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (EXPAND ">=") (SPREAD (CASE "i = opn(nth(cache, k - 1)`1) - 2") ((THEN (REPLACES -1) (HIDE -1) (ASSERT)) (SPREAD (CASE "i < opn(nth(cache, k - 1)`1) - 2") ((THEN (HIDE -2) (LEMMA "nth_ol[nat,<]") (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (ASSERT)) (ASSERT)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (TYPEPRED "k") (HIDE-ALL-BUT (-1 1 2)) (ASSERT) (GRIND)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (ASSERT)))) (THEN (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "compatible_pairs?") (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (SPREAD (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") ((SPREAD (SPLIT 2) ((THEN (EXPAND "vars_in_box_compatible?") (SKOLEM 1 "k") (INST "N vars in box" "k") (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (SPREAD (SPLIT 1) ((THEN (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (ASSERT)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((EXPAND_OL) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)))))))) (THEN (FLATTEN) (ASSERT) (REPLACES "single intervals in box" 1 :DIR RL) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (REPLACES "nwidxs" -1) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (GRIND)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)))))))) (THEN (EXPAND "compatible_pairs_on?") (SKOLEM 1 "k") (SKEEP) (SPREAD (SPLIT 1) ((SPREAD (CASE "k=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "eval_ACExpr_Env" 1) (REPLACES "acRes") (EXPAND "eval") (LEMMA "containment_pow_var_ac") (EXPAND "eval" 1) (REPLACE "re" 1) (ASSERT) (SPREAD (INST -1 "upd_noise_burst(N,
                                                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                           LAMBDA
                                                                                                                                                                                           (i: nat):
                                                                                                                                                                                           (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                            ^
                                                                                                                                                                                            (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") ((THEN (ASSERT) (HIDE 2) (SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (INST "N vars in box" "idx") (REPLACE "varac" 1) (EXPAND "nth_ac" 1) (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 2) (SKOLEM 1 "j") (FLATTEN) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "nextfreeidx") (USE "last_idx_box") (GRIND)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (REVEAL "varac") (REPLACES "varac") (EXPAND "nth_ac") (EXPAND "length") (ASSERT))))) (THEN (REPLACES "varac") (EXPAND "length") (EXPAND "nth_ac") (ASSERT))))) (THEN (FLATTEN) (REPLACES "nwidxs" -1) (USE "member_nats") (ASSERT) (FLATTEN) (REPLACES "varac") (TYPEPRED "nextfreeidx") (USE "last_idx_box") (GRIND)) (SPREAD (USE "pow_var_compatible_noise") ((ASSERT) (THEN (REPLACES "varac") (HIDE-ALL-BUT 1) (GRIND))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (EXPAND "length") (ASSERT))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST "cache comp pairs on" "k-1") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (REPLACES "eval cache" 2 :DIR RL) (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 3) (SKOLEM 1 "i") (FLATTEN) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (EXPAND "next_idx") (LEMMA "beyond_last_idx_notmember") (INST -1 "i" "pd(nth(cache, k - 1)`2)") (ASSERT) (EXPAND "idxs_ac") (PROPAX)) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (EXPAND "length") (ASSERT))))))) (SPREAD (CASE "k=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACE "re" 1) (ASSERT) (SPREAD (USE "pow_var_compatible_noise") ((THEN (REPLACES "nwidxs") (REPLACES "varac") (EXPAND "powvar?") (EXPAND "varidx_powvar") (ASSERT)) (THEN (EXPAND "nth_ac") (REPLACES "varac") (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "varidx_powvar") (GRIND))))) (THEN (EXPAND "nth" 2) (EXPAND "varidx_powvar") (ASSERT) (FLATTEN) (INST "cache comp pairs on" "k-1") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (ASSERT) (EXPAND "pow_var_compatible?") (FLATTEN) (ASSERT) (SKOLEM 2 "j") (INST "cache if powvar" "j") (SPREAD (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                     0)`1,
                                                                                                                                                                                                                                 upd_noise_burst(N,
                                                                                                                                                                                                                                                 nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                 LAMBDA
                                                                                                                                                                                                                                                 (i: nat):
                                                                                                                                                                                                                                                 (get_noise_by_idx
                                                                                                                                                                                                                                                  (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                  ^
                                                                                                                                                                                                                                                  (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                     0)`1,
                                                                                                                                                                                                                                 N)") ((THEN (REPLACES -1) (SPREAD (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                      upd_noise_burst(N,
                                                                                                                                                                                                                                                                      nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                      LAMBDA
                                                                                                                                                                                                                                                                      (i: nat):
                                                                                                                                                                                                                                                                      (get_noise_by_idx
                                                                                                                                                                                                                                                                       (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                       ^
                                                                                                                                                                                                                                                                       (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                      N)") ((THEN (REPLACES -1) (GRIND)) (THEN (HIDE 3) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "idxs_bounded") (INST?) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (LEMMA "next_idx_pow_var_ac") (INST? -1 :WHERE "cache idxs bound") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACE -1 "cache idxs bound" :HIDE? T) (TYPEPRED "j") (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (EXPAND ">=") (SPREAD (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") ((THEN (HIDE -2) (REPLACES -1) (ASSERT)) (SPREAD (CASE "j < opn(nth(cache, k - 1)`1) - 2") ((THEN (HIDE (-2 1)) (LEMMA "nth_ol[nat,<]") (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (ASSERT)) (ASSERT)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (ASSERT) (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)))))))) (THEN (HIDE 3) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "nextfreeidx") (EXPAND "nth_ac" -2) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (EXPAND "next_idx") (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (USE "last_idx_box") (EXPAND "next_idx") (EXPAND "last_idx") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (USE "olidx_car_last[nzBaseType]") (EXPAND_OL) (EXPAND "nth" -4 1) (ASSERT) (EXPAND "nth_ac") (ASSERT)) (THEN (FLATTEN) (EXPAND "last_idx_in_box") (ASSERT) (EXPAND "somevidx") (EXPAND "varidx_powvar") (ASSERT) (GRIND))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)) (THEN (EXPAND "varidx_powvar") (ASSERT)) (THEN (EXPAND "varidx_powvar") (PROPAX)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (ASSERT))))))) (THEN (REPLACE "newoff" 1) (EXPAND ">=") (SPREAD (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((THEN (REPLACES -1) (SPREAD (CASE "0 < pow - opn(val(cached)`1)") ((THEN (HIDE-ALL-BUT (1 -1)) (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (ASSERT)) (GRIND)))) (ASSERT)))) (THEN (REPLACE "newoff" 1) (EXPAND "idxs_bounded" 1) (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACE "acRes" 1) (USE "next_idx_pow_var_ac") (REPLACES -1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (SPLIT 3) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (REPLACE "nwidxs" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (SPREAD (CASE "pow - 1 = opn(val(cached)`1)") ((THEN (REPLACE -1 1 :DIR RL) (ASSERT) (SPREAD (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                                    pow - 2) = nextfreeidx") ((ASSERT) (THEN (HIDE 2) (SPREAD (CASE "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                                  nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") ((THEN (REPLACES -1 1) (USE "length_take[nat]") (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (CASE "length(pownoises) = pow - 2") ((THEN (REPLACES -1 2) (GRIND)) (SPREAD (CASE "length(pownoises) > opn(val(cached)`1) - 2") ((ASSERT) (THEN (REPLACE "pownoises" 1) (TYPEPRED "cached") (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "varac" "varac not single value") (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (EXPAND "varidx_powvar") (ASSERT)))))))))) (THEN (USE "more_list_props[nat].nth_append") (SPREAD (SPLIT -1) ((THEN (REPLACES -1 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (USE "length_take[nat]") (REPLACE -1 -2) (EXPAND "min") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (ASSERT))))) (PROPAX)))) (THEN (USE "length_append[nat]") (USE "length_take[nat]") (REPLACE -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (REPLACE "pownoises" 1) (HIDE -1 -2) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached idx re" "cached cond ok") (REPLACE "re" "cached cond ok") (ASSERT) (EXPAND "varidx_powvar") (ASSERT)))))))) (SPREAD (SPLIT 1) ((THEN (USE "length_take[nat]") (REPLACES -1 1) (GRIND)) (THEN (USE "length_append[nat]") (USE "length_take[nat]") (REPLACE -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (REPLACE "pownoises" 1) (HIDE -1 -2) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached idx re" "cached cond ok") (REPLACE "re" "cached cond ok") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))))))))))) (SPREAD (CASE "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                          =
                                                          nth(nats(nextfreeidx, newoff - 1),
                                                              pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") ((THEN (REPLACES -1 2) (SPREAD (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                         pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") ((THEN (REPLACES -1 2) (REPLACE "newoff" 2) (ASSERT)) (SPREAD (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") ((THEN (REPLACES -1 1) (REPLACES "newoff" 1) (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (INST? -5) (REPLACE -5 2) (ASSERT)) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 1) (EXPAND "min" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACES "pownoises" 1) (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "cached" "cached correct" :DIR RL) (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT))))) (SPREAD (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((THEN (REPLACE -1 1) (ASSERT)) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 1) (EXPAND "min" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACES "pownoises" 1) (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))))))) (ASSERT)))))))) (SPREAD (USE "more_list_props[nat].nth_append") ((SPREAD (SPLIT -1) ((THEN (REPLACES -1 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 -2) (EXPAND "min") (LIFT-IF -2) (SPREAD (SPLIT -2) ((ASSERT) (THEN (ASSERT) (FLATTEN) (ASSERT))))) (ASSERT)))) (PROPAX)))) (SPREAD (USE "length_take[nat]") ((THEN (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((ASSERT) (THEN (FLATTEN) (REPLACES "pownoises" 1) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "varac") (REPLACE "cached idx re" "cached cond ok") (REPLACE "re") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT))))) (ASSERT) (ASSERT))) (SPREAD (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((SPREAD (SPLIT 1) ((THEN (REPLACES -1 1) (ASSERT)) (SPREAD (USE "length_append[nat]") ((THEN (REPLACES -1 1) (SPREAD (USE "length_take[nat]") ((THEN (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((ASSERT) (THEN (FLATTEN) (REPLACES "pownoises" 1) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "varac") (REPLACE "cached idx re" "cached cond ok") (REPLACE "re") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT)))) (ASSERT) (ASSERT))))) (THEN (HIDE 2) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 1) (EXPAND "min" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACES "pownoises" 1) (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "cached" "cached correct" :DIR RL) (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT)))) (ASSERT))) (ASSERT) (ASSERT)))))) (THEN (FLATTEN) (REPLACE "newoff" 2) (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (INST? -5) (REPLACES -5 3) (ASSERT))))))))))) (THEN (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (EXPAND "idxs_bounded" "cache idxs bounded") (EXPAND "nth" 2) (ASSERT) (INST "cache idxs bounded" "i-1") (EXPAND ">=") (SPREAD (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((THEN (REPLACES -1) (SPREAD (CASE "0 < pow - opn(val(cached)`1)") ((THEN (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (ASSERT)) (GRIND)))) (GRIND)))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-2 |nil| 3637347318 ("" (THEN (SKEEP*) (REPLACES -5) (SPREAD (TYPEPRED "nats(nextfreeidx, newoff - 1)") ((THEN (REPLACES -4) (SPREAD (SPLIT 8) ((THEN (REPLACES -8) (ASSERT)) (THEN (FLATTEN) (EXPAND "car_ol") (REPLACES -3) (EXPAND "next_idx") (USE "last_idx_box") (REPLACES -6) (EXPAND "next_idx") (TYPEPRED "nextfreeidx") (ASSERT))))) (THEN (REPLACES -4) (ASSERT))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-1 |nil| 3631872799 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "cached" -4) (LABEL "idxs" -5) (LABEL "pownoises" -6) (LABEL "newoff" -7) (LABEL "nwidxs" -8) (LABEL "acRes" -9) (LABEL "result" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "every") (("1" (SPLIT 1) (("1" (REPLACE "nwidxs" 1) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT (-1 "cache correct")) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (SPLIT "cached cond ok") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (TYPEPRED "nwidxs2") (("1" (EXPAND "append_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "appendable_ol?") (("2" (FLATTEN) (("2" (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (REPLACES -1 3) (("1" (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (REPLACES -1 3) (("1" (SKEEP "cached cache idx") (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "cached cache idx" 1 :DIR RL) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST "cache idxs bound" "i") (("1" (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (("1" (REPLACE "cached`2 is powvarac" "cache idxs bound") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF "cache idxs bound") (("1" (SPLIT "cache idxs bound") (("1" (ASSERT) (("1" (REPLACE "varac" "varac not single value") (("1" (REPLACE "cached cache idx" "cache idxs bound") (("1" (REPLACE "cached`1 varidx" "cache idxs bound") (("1" (REPLACE "re") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (SPLIT "cache idxs bound") (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND ">=") (("2" (REPLACE "pownoises" 6) (("2" (REPLACE "cached cache idx" 6 :DIR RL) (("2" (HIDE-ALL-BUT ("cache idxs bound" 6)) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (EXPAND "nats" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (EXPAND "first_ol") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "last_take_nth[nat,<]") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (USE "take_ol[nat,<]") (("4" (ASSERT) NIL NIL)) NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL) ("2" (REPLACE "cached`1 varidx" "cached cond ok") (("2" (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (TYPEPRED "cache") (("2" (GENERALIZE "cache" "cache") (("2" (INDUCT "cache") (("1" (GRIND) NIL NIL) ("2" (SKOLEM 1 ("h" "t")) (("2" (FLATTEN) (("2" (EXPAND "every" 1) (("2" (SPLIT 1) (("1" (TYPEPRED "h`3") (("1" (ASSERT) NIL NIL)) NIL) ("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "correct_cache?" -1) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (EXPAND "compatible_pairs?") (("3" (SKEEP) (("3" (INST?) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (EXPAND "nth" -3) (("3" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (EXPAND "nth" -3) (("4" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "correct_cache?" -1) (("5" (FLATTEN) NIL NIL)) NIL) ("6" (EXPAND "compatible_pairs?") (("6" (SKEEP) (("6" (INST?) (("6" (ASSERT) (("6" (EXPAND "compatible_pairs_on?") (("6" (SKEEP) (("6" (EXPAND "nth" -3) (("6" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (EXPAND "idxs_bounded") (("7" (SKEEP) (("7" (EXPAND "nth" -3) (("7" (INST -3 "i+1") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "correct_cache?") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "re" 1) (("2" (ASSERT) (("2" (LIFT-IF "nwidxs") (("2" (SPLIT "nwidxs") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (REPLACE "nwidxs" 1) (("1" (SPLIT 1) (("1" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (WITH-LABELS (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (REPLACES "nats length" 2) (("1" (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises") (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                        nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (REPLACES -1 2) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (USE "cache_powvar_correct_result") (("1" (WITH-LABELS (ASSERT -1) (("cached correct"))) (("1" (REPLACE "cached" "cached correct" :DIR RL) (("1" (EXPAND "CacheData_correct?" "cached correct") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (FLATTEN) (("1" (SPLIT "cached correct") (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (REPLACE -4 "cached correct") (("1" (REPLACE "re" "cached correct") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "append" 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "take" -1) (("1" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1) (("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "take" 2) (("2" (CASE "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "pownoises" 1) (("3" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (USE "cache_powvar_correct_result") (("3" (WITH-LABELS (ASSERT) (("cached correct"))) (("3" (REPLACE "cached" "cached correct" :DIR RL) (("3" (EXPAND "CacheData_correct?" "cached correct") (("3" (TYPEPRED "cached") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (SPLIT "cached correct") (("1" (EXPAND "length") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -3 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1 2) (("2" (SPLIT 2) (("1" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACE -4 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (INST -5 "0") (("1" (EXPAND "nth") (("1" (REPLACE -5 3) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REPLACE "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (HIDE-ALL-BUT (1 "pow gt opn" "opw gt opn")) (("3" (CASE "opn(val(cached)`1) < pow") (("1" (HIDE "pow gt opn" "opw gt opn") (("1" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 <= pow - opn(val(cached)`1)") (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC66 0 (RE2AC_TCC66-1 "" 3789917914 ("" (SKEEP*) (("" (GRIND) NIL NIL)) NIL) ((/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC61-3 |nil| 3637347692 ("" (THEN (SKEEP*) (GRIND)) NIL NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC61-2 |nil| 3632079158 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached some" -3) (LABEL "cached" -4) (LABEL "idxs" -5) (LABEL "pownoises" -6) (LABEL "newoff" -7) (LABEL "nwidxs" -8) (LABEL "acRes" -9) (LABEL "result" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (HIDE -11) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (HIDE "opn name") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "containment_pow_var_ac") (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LEMMA "eval_pd_noise_rec_pds_def") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACE "varac" :DIR RL) (("2" (FLATTEN) (("2" (REPLACE "nwidxs" -1 :HIDE? T) (("2" (USE "member_append_fi[nat]") (("2" (ASSERT) (("2" (HIDE -2) (("2" (SPLIT -1) (("1" (SPLIT "cached cond ok") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (REPLACE "pownoises") (("1" (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (("1" (REPLACES "varac") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (USE "take_ol[nat,<]") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) (("2" (HIDE -2) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (REPLACE "varac") (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (("2" (USE "olidx_car_last[nzBaseType]") (("2" (SPLIT -1) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REVEAL "cache comp pairs on") (("3" (INST "cache comp pairs on" "i") (("3" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("3" (ASSERT) (("3" (LEMMA "powvar_comp_noise_extension") (("3" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached cache idx" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i") (("2" (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached cache idx") (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (REPLACE "varac") (("4" (SPLIT 1) (("1" (EXPAND "nth_ac") (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 "varac not single value")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL "varac") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac" "varac not single value")) (("4" (EXPAND "length") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "j") (("2" (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "cached in cache") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re") (("2" (REPLACE "re") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached in cache") (("2" (USE "cache_powvar_correct") (("2" (REPLACE "cached in cache") (("2" (EXPAND "CacheData_correct?") (("2" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (REPLACE "cached idx re" -1) (("2" (REPLACE "re" -1) (("2" (REPLACE "varac" "varac not single value") (("2" (ASSERT) (("2" (REPLACE "cached idx re" 1) (("2" (REPLACE "re" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "cached idx re" -1) (("3" (REPLACE "re" -1) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (REPLACE "cached idx re" "cached cond ok") (("3" (REPLACE "re" "cached cond ok") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (ASSERT) NIL NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                      	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                                               0)`1,
                                                                                                                                           upd_noise_burst(N,
                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                           LAMBDA
                                                                                                                                                           (i: nat):
                                                                                                                                                           (get_noise_by_idx
                                                                                                                                                            (car(pd(varac))`1, N)
                                                                                                                                                            ^
                                                                                                                                                            (1 + i +opn))))
                                                                                                                           ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                                               0)`1,
                                                                                                                                           N)
                                                                                                                           ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "i = opn(nth(cache, k - 1)`1) - 2") (("1" (REPLACES -1) (("1" (HIDE -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE -2) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "opn >= 2")) (("4" (SKEEP) (("4" (REVEAL "opn name") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (1 "varac not single value")) (("5" (EXPAND "length") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (LEMMA "containment_pow_var_ac") (("1" (INST -1 "upd_noise_burst(N,
                                                                                                          nats(nextfreeidx, newoff - 1),
                                                                                                          LAMBDA
                                                                                                          (i: nat):
                                                                                                          (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                           ^
                                                                                                           (2+i)))" "vs(varidx(re))" "varac" "pow" "nwidxs") (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (REPLACE "re" -1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (REPLACE "box eval" 1 :DIR RL) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (EXPAND "nth_ac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                           0)`1,
                                                                                                                       upd_noise_burst(N,
                                                                                                                                       nats(nextfreeidx, newoff - 1),
                                                                                                                                       LAMBDA
                                                                                                                                       (i: nat):
                                                                                                                                       (get_noise_by_idx
                                                                                                                                        (car(pd(varac))`1, N)
                                                                                                                                        ^
                                                                                                                                        (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                           0)`1,
                                                                                                                       N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                upd_noise_burst(N,
                                                                                                                                                nats(nextfreeidx, newoff - 1),
                                                                                                                                                LAMBDA
                                                                                                                                                (i: nat):
                                                                                                                                                (get_noise_by_idx
                                                                                                                                                 (car(pd(varac))`1, N)
                                                                                                                                                 ^
                                                                                                                                                 (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "j < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE (-2 1)) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -8)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                          nats(nextfreeidx, newoff - 1)),
                                                                                                   pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (USE "nth_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SPLIT 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (REPLACE -1 1) (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "nth_append[nat]") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                            pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (SPLIT 1) (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC61-1 |nil| 3631872799 ("" (CASES-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}"))) (RE2AC_TCC67 0 (RE2AC_TCC67-1 "" 3789917915 ("" (SKEEP*) (("" (EXPAND "nth_ac") (("" (REPLACES -4) (("" (HIDE-ALL-BUT 7) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC62-3 |nil| 3637352058 ("" (THEN (SKEEP*) (EXPAND "nth_ac") (REPLACES -4) (HIDE-ALL-BUT 7) (GRIND)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC62-2 |nil| 3637348807 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (("" (HIDE -13) (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(:(re, acRes, nwidxs):)") (("1" (EXPAND "append" 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (LIFT-IF "nwidxs") (("2" (SPLIT NWIDXS) (("1" (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (HIDE "opn name") (("1" (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (EXPAND "compatible_pairs?") (("1" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (SKOLEM "cached cache idx" "i") (("1" (INST "cache comp pairs on" "i") (("1" (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (REPLACE "cached cache idx") (("1" (EXPAND "eval_ACExpr_Env" "cache eval") (("1" (ASSERT) (("1" (USE "cache_powvar_correct") (("1" (REPLACE "cached cache idx") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (REPLACE "cached as AC" "cache eval") (("1" (REPLACE "re") (("1" (ASSERT) (("1" (REPLACE "cached idx re") (("1" (REPLACE "varac" 1) (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (EXPAND "eval" 1) (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (REPLACE -17) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1 2) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (LEMMA "eval_pd_noise_rec_pds_def") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACE "varac" :DIR RL) (("2" (FLATTEN) (("2" (REPLACE "nwidxs" -1 :HIDE? T) (("2" (USE "member_append_fi[nat]") (("2" (ASSERT) (("2" (HIDE -2) (("2" (SPLIT -1) (("1" (SPLIT "cached cond ok") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (REPLACE "pownoises") (("1" (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (("1" (REPLACES "varac") (("1" (USE "olidx_car_last[nzBaseType]") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (USE "notmember_ol_nat") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (USE "take_ol[nat,<]") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) (("2" (HIDE -2) (("2" (FLATTEN) (("2" (TYPEPRED "nextfreeidx") (("2" (REPLACE "varac") (("2" (USE "last_idx_box") (("2" (EXPAND "next_idx") (("2" (EXPAND "last_idx") (("2" (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (("2" (USE "olidx_car_last[nzBaseType]") (("2" (SPLIT -1) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REVEAL "cache comp pairs on") (("3" (INST "cache comp pairs on" "i") (("3" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("3" (ASSERT) (("3" (LEMMA "powvar_comp_noise_extension") (("3" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached cache idx" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "i") (("2" (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE "cached cache idx") (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "varac" "varac not single value") (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "varidx_powvar") (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (REPLACE "varac") (("4" (SPLIT 1) (("1" (EXPAND "nth_ac") (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 "varac not single value")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL "varac") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac" "varac not single value")) (("4" (EXPAND "length") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (REPLACE "cache eval" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKEEP) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded" "cache idxs bound") (("1" (INST?) (("1" (EXPAND "idxs_ac") (("1" (USE "beyond_last_idx_notmember") (("1" (ASSERT) (("1" (EXPAND "next_idx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (EXPAND "nth" 1) (("1" (TYPEPRED "cached") (("1" (ASSERT) (("1" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (SKOLEM "cached in cache" "j") (("1" (INST "cache comp pairs on" "j") (("1" (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (ASSERT) (("1" (LEMMA "powvar_comp_noise_extension") (("1" (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (ASSERT) (("1" (REPLACE "varac" -1) (("1" (REPLACES "cached in cache" :DIR RL) (("1" (REPLACE "pownoises" -1) (("1" (REPLACE "cached idx re" "cached N compatible") (("1" (REPLACE "re" "cached N compatible") (("1" (REPLACE "nwidxs" 1) (("1" (REPLACE "pownoises" 1) (("1" (REPLACE "re" (-1 1)) (("1" (REPLACE "newoff" 1) (("1" (REVEAL "opn name") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "pownoises" 1) (("2" (EXPAND "idxs_bounded" "cache idxs bound") (("2" (INST "cache idxs bound" "j") (("2" (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (REPLACE -1 "cache idxs bound" :HIDE? T) (("1" (USE "last_take_nth[nat,<]") (("1" (REPLACE -1 1 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (REPLACE "cached in cache") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cached in cache") (("2" (USE "cache_powvar_correct") (("2" (REPLACE "cached in cache") (("2" (EXPAND "CacheData_correct?") (("2" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached as AC" 1) (("2" (USE "next_idx_pow_var_ac") (("2" (REPLACE "cached idx re" -1) (("2" (REPLACE "re" -1) (("2" (REPLACE "varac" "varac not single value") (("2" (ASSERT) (("2" (REPLACE "cached idx re" 1) (("2" (REPLACE "re" 1) (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "cached idx re" -1) (("3" (REPLACE "re" -1) (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "cache_powvar_correct") (("3" (REPLACE "cached in cache") (("3" (EXPAND "CacheData_correct?") (("3" (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (ASSERT) (("3" (REPLACE "varac" "varac not single value") (("3" (REPLACE "pownoises" 1) (("3" (REPLACE "varac" 1) (("3" (REPLACE "cached idx re" "cached cond ok") (("3" (REPLACE "re" "cached cond ok") (("3" (ASSERT) (("3" (EXPAND "varidx_powvar") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "length" "varac not single value") (("4" (ASSERT) NIL NIL)) NIL) ("5" (REPLACE "re" 1) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "nth" (-1 -2)) (("1" (ASSERT) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (SKOLEM 2 "i") (("1" (ASSERT) (("1" (INST "cache comp pairs on" "i") (("1" (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                           	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                      0)`1,
                                                                                                                                                                  upd_noise_burst(N,
                                                                                                                                                                                  nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                  LAMBDA
                                                                                                                                                                                  (i: nat):
                                                                                                                                                                                  (get_noise_by_idx
                                                                                                                                                                                   (car(pd(varac))`1, N)
                                                                                                                                                                                   ^
                                                                                                                                                                                   (1 + i +opn))))
                                                                                                                                                  ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                      0)`1,
                                                                                                                                                                  N)
                                                                                                                                                  ^ (2 + i)") (("1" (REPLACES -1) NIL NIL) ("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT (-1 -7)) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (TYPEPRED "cached") (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "i") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "i = opn(nth(cache, k - 1)`1) - 2") (("1" (REPLACES -1) (("1" (HIDE -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE -2) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (ASSERT) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "opn >= 2")) (("4" (SKEEP) (("4" (REVEAL "opn name") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (1 "varac not single value")) (("5" (EXPAND "length") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "k") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "opn >= 2")) (("3" (SKEEP) (("3" (REVEAL "opn name") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (SPLIT 2) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKOLEM 1 "k") (("1" (INST "N vars in box" "k") (("1" (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "k") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKOLEM 1 "k") (("2" (SPLIT 1) (("1" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (REPLACES "acRes") (("1" (EXPAND "eval") (("1" (LEMMA "containment_pow_var_ac") (("1" (EXPAND "eval" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (INST -1 "upd_noise_burst(N,
                                                                                                                        nats(nextfreeidx, newoff - 1),
                                                                                                                        LAMBDA
                                                                                                                        (i: nat):
                                                                                                                        (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                         ^
                                                                                                                         (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (REPLACE "varac" 1) (("1" (EXPAND "nth_ac" 1) (("1" (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REVEAL "varac") (("2" (REPLACES "varac") (("2" (EXPAND "nth_ac") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (EXPAND "nth_ac") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACES "varac") (("2" (TYPEPRED "nextfreeidx") (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (USE "pow_var_compatible_noise") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (REPLACES "eval cache" 2 :DIR RL) (("2" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SKOLEM 1 "i") (("1" (FLATTEN) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (LEMMA "beyond_last_idx_notmember") (("1" (INST -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (ASSERT) (("1" (EXPAND "idxs_ac") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("2" (REPLACES "varac") (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value" "varac")) (("3" (REPLACES "varac") (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "re" 1) (("1" (ASSERT) (("1" (USE "pow_var_compatible_noise") (("1" (REPLACES "nwidxs") (("1" (REPLACES "varac") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac") (("2" (REPLACES "varac") (("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (EXPAND "varidx_powvar") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) (("2" (FLATTEN) (("2" (INST "cache comp pairs on" "k-1") (("2" (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKOLEM 2 "j") (("2" (INST "cache if powvar" "j") (("2" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                              0)`1,
                                                                                                                                          upd_noise_burst(N,
                                                                                                                                                          nats(nextfreeidx, newoff - 1),
                                                                                                                                                          LAMBDA
                                                                                                                                                          (i: nat):
                                                                                                                                                          (get_noise_by_idx
                                                                                                                                                           (car(pd(varac))`1, N)
                                                                                                                                                           ^
                                                                                                                                                           (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                              0)`1,
                                                                                                                                          N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                     upd_noise_burst(N,
                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                     LAMBDA
                                                                                                                                                                     (i: nat):
                                                                                                                                                                     (get_noise_by_idx
                                                                                                                                                                      (car(pd(varac))`1, N)
                                                                                                                                                                      ^
                                                                                                                                                                      (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                     N)") (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST?) (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (REPLACE -1 "cache idxs bound" :HIDE? T) (("2" (TYPEPRED "j") (("2" (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (("2" (EXPAND ">=") (("2" (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (HIDE -2) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "j < opn(nth(cache, k - 1)`1) - 2") (("1" (HIDE (-2 1)) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "nth_ac" -2) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache idxs bound" "k-1") (("1" (EXPAND "next_idx") (("1" (NAME-REPLACE "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (USE "last_idx_box") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (USE "olidx_car_last[nzBaseType]") (("1" (EXPAND_OL) (("1" (EXPAND "nth" -4 1) (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACES -17) (("2" (EXPAND "varidx_powvar") (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (EXPAND "varidx_powvar") (("5" (ASSERT) NIL NIL)) NIL) ("6" (EXPAND "varidx_powvar") (("6" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE "newoff" 1) (("3" (EXPAND ">=") (("3" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (1 -1)) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (REPLACE "newoff" 1) (("4" (EXPAND "idxs_bounded" 1) (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACE "acRes" 1) (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "nwidxs" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE "pow - 1 = opn(val(cached)`1)") (("1" (REPLACE -1 1 :DIR RL) (("1" (ASSERT) (("1" (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                             nats(nextfreeidx, newoff - 1)),
                                                                                                                      pow - 2) = nextfreeidx") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (USE "nth_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "length(pownoises) = pow - 2") (("1" (REPLACES -1 2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "length(pownoises) > opn(val(cached)`1) - 2") (("1" (ASSERT) NIL NIL) ("2" (REPLACE "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "varac" "varac not single value") (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SPLIT 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (REPLACE -1 1) (("2" (USE "length_take[nat]") (("2" (REPLACE -1 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "pownoises" 1) (("2" (HIDE -1 -2) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re" "cached cond ok") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "nth_append[nat]") (("1" (REPLACES -1 2) (("1" (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (REPLACES -1 2) (("1" (REPLACE "newoff" 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (REPLACES -1 1) (("1" (REPLACES "newoff" 1) (("1" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (INST? -5) (("1" (REPLACE -5 2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (REPLACE -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (SPLIT 1) (("1" (REPLACES -1 1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (USE "length_append[nat]") (("1" (REPLACES -1 1) (("1" (USE "length_take[nat]") (("1" (REPLACES -1 1) (("1" (EXPAND "min") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (SKOLEM "cached cache idx" "j") (("2" (REPLACE "cached cache idx" :DIR RL) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) (("2" (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (REPLACE "varac") (("2" (REPLACE "cached idx re" "cached cond ok") (("2" (REPLACE "re") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "length_take[nat]") (("1" (REPLACE -1 1) (("1" (EXPAND "min" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (REPLACES "pownoises" 1) (("2" (USE "cache_powvar_correct_result") (("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (WITH-LABELS (ASSERT) (("cached correct"))) (("2" (EXPAND "CacheData_correct?" "cached correct") (("2" (TYPEPRED "cached") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE "cached" "cached correct" :DIR RL) (("2" (REPLACE -2 "cached correct") (("2" (REPLACE "re" "cached correct") (("2" (ASSERT) (("2" (EXPAND "varidx_powvar") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE "newoff" 2) (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (INST? -5) (("2" (REPLACES -5 3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (EXPAND "idxs_bounded" "cache idxs bounded") (("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST "cache idxs bounded" "i-1") (("2" (EXPAND ">=") (("2" (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (REPLACES -1) (("1" (CASE "0 < pow - opn(val(cached)`1)") (("1" (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (("1" (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC62-1 |nil| 3632064917 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC68 0 (RE2AC_TCC63-2 |nil| 3767021364 ("" (SKEEP*) (("" (REPLACES -7) (("" (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("1" (REPLACES -4) (("1" (SPLIT 8) (("1" (REPLACES -10) (("1" (ASSERT) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "car_ol") (("2" (REPLACES -3) (("2" (EXPAND "next_idx") (("2" (USE "last_idx_box") (("2" (REPLACES -8) (("2" (EXPAND "next_idx") (("2" (TYPEPRED "nextfreeidx") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -6) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (> CONST-DECL "bool" |reals| NIL) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (<= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC63-1 |nil| 3632064917 ("" (THEN (SKEEP*) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (WITH-LABELS (SPLIT "not in cache 1") (("pow gt opn cached`1"))) (SPREAD (WITH-LABELS (SPLIT "not in cache 2") (("pow gt opn cached`1"))) ((THEN (EXPAND "/=") (PROPAX)) (THEN (REPLACES "nwidxs" 7) (SPREAD (SPLIT 7) ((THEN (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (ASSERT) (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (SPREAD (SPLIT "cached cond ok") ((SPREAD (SPLIT "cached correct") ((THEN (FLATTEN) (SPREAD (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") ((THEN (TYPEPRED "nwidxs2") (EXPAND "append_ol") (ASSERT)) (THEN (EXPAND "appendable_ol?") (FLATTEN) (SPREAD (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") ((THEN (REPLACES -1 3) (SPREAD (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") ((THEN (REPLACE -1 3 :HIDE? T) (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (SKEEP "cached cache idx") (HIDE 4) (REPLACE "pownoises" 1) (REPLACE "cached cache idx" 1 :DIR RL) (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (EXPAND "idxs_bounded") (EXPAND "nth_ac") (REPLACE "pownoises") (INST "cache correct" "i") (REPLACE "cached`2 is powvarac") (USE "next_idx_pow_var_ac") (REPLACES -1) (GRIND)) (THEN (HIDE-ALL-BUT (1 3 "cached correct" "pow gt opn cached`1")) (REPLACES -2 1) (EXPAND "nats" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((GRIND) (THEN (FLATTEN) (EXPAND_OL) (EXPAND "first_ol") (PROPAX)))))))) (SPREAD (USE "last_take_nth[nat,<]") ((ASSERT) (ASSERT))) (ASSERT) (ASSERT)))) (THEN (USE "take_ol[nat,<]") (ASSERT)) (ASSERT)))) (PROPAX))) (THEN (REPLACE "cached`1 varidx" "cached cond ok") (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (GRIND))))) (THEN (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (SPREAD (SPLIT 1) ((SPREAD (USE "length_append[nat]") ((THEN (REPLACES -1) (SPREAD (TYPEPRED "nats(nextfreeidx, newoff - 1)") ((THEN (REPLACES -4 2) (SPREAD (USE "length_take[nat]") ((THEN (REPLACES -1 2) (SPREAD (CASE "length(pownoises) > opn(val(cached)`1) - 2") ((THEN (EXPAND "min" 2) (LIFT-IF 2) (SPREAD (CASE "length(pownoises) = opn(val(cached)`1) - 1") ((ASSERT) (ASSERT)))) (THEN (REPLACE "pownoises" 1) (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (ASSERT) (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (REPLACE "cached`1 varidx" "cached cond ok") (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (GRIND))))) (ASSERT)))) (ASSERT)))) (ASSERT) (ASSERT))) (THEN (FLATTEN) (REPLACE "pownoises" 2) (WITH-LABELS (TYPEPRED "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (ASSERT) (WITH-LABELS (FLATTEN) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (REPLACE "cached`1 varidx" "cached cond ok") (SPREAD (SPLIT "cached cond ok") ((THEN (FLATTEN) (REPLACES "varac" 2) (REPLACE "re" "cached cond ok") (ASSERT) (SPREAD (CASE "car[nat]
                                                                                                   (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                           nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") ((THEN (REPLACES -1) (ASSERT) (GRIND)) (THEN (EXPAND "take" 1) (EXPAND "append" 1) (PROPAX)) (GRIND)))) (THEN (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (GRIND)))))))) (THEN (FLATTEN) (SPREAD (SPLIT 2) ((SPREAD (TYPEPRED "nats(nextfreeidx, newoff - 1)") ((THEN (REPLACE -4 2) (REPLACE "newoff" 2) (ASSERT)) (ASSERT))) (THEN (FLATTEN) (EXPAND "nats" 2) (REPLACE "newoff" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (ASSERT) (REPLACE "varac" 1) (TYPEPRED "nextfreeidx") (USE "last_idx_box") (ASSERT)) (THEN (FLATTEN) (EXPAND_OL) (REPLACE "varac" 2) (TYPEPRED "nextfreeidx") (USE "last_idx_box") (ASSERT))))))))))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC69 0 (RE2AC_TCC69-1 "" 3803769691 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached" -5) (LABEL "newoff" -6) (LABEL "nwidxs" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 6) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 4))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "correct_cache?") (("1" (EXPAND "CacheData_correct?") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (REPLACES "nwidxs" 2) (("1" (EXPAND "nats" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1 1 :DIR RL) (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (REPLACES -1) (("1" (CASE "0<=pow - 1") (("1" (NAME-REPLACE "A" "pow -1 ") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (<= CONST-DECL "bool" |reals| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (C CONST-DECL "posnat" |binomial| |reals|) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nzreal_exp| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|nzreal_expt| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (> CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-3 |nil| 3767021404 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached" -5) (LABEL "newoff" -6) (LABEL "nwidxs" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "correct_cache?") (("1" (EXPAND "CacheData_correct?") (("1" (EXPAND "powvar?") (("1" (EXPAND "varidx_powvar") (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (REPLACES "nwidxs" 2) (("1" (EXPAND "nats" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1 1 :DIR RL) (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (REPLACES -1) (("1" (CASE "0<=pow - 1") (("1" (NAME-REPLACE "A" "pow -1 ") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-2 |nil| 3632080211 ("" (THEN (SKEEP*) (ASSERT) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (REPLACES "result") (ASSERT) (SPREAD (SPLIT 7) ((THEN (EXPAND "every") (SPREAD (SPLIT 1) ((THEN (REPLACE "nwidxs" 1) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT (-1 "cache correct")) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (ASSERT) (WITH-LABELS (FLATTEN "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (SPREAD (SPLIT "cached cond ok") ((SPREAD (SPLIT 1) ((THEN (FLATTEN) (SPREAD (NAME "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") ((THEN (TYPEPRED "nwidxs2") (EXPAND "append_ol") (ASSERT)) (THEN (EXPAND "appendable_ol?") (FLATTEN) (SPREAD (CASE "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") ((THEN (REPLACES -1 3) (SPREAD (CASE "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") ((THEN (REPLACES -1 3) (SKEEP "cached cache idx") (REPLACE "pownoises" 1) (REPLACE "cached cache idx" 1 :DIR RL) (EXPAND "idxs_bounded" "cache idxs bound") (INST "cache idxs bound" "i") (REPLACE "cached cache idx" "cached`2 is powvarac" :DIR RL) (REPLACE "cached`2 is powvarac" "cache idxs bound") (USE "next_idx_pow_var_ac") (REPLACES -1) (LIFT-IF "cache idxs bound") (SPREAD (SPLIT "cache idxs bound") ((THEN (ASSERT) (REPLACE "varac" "varac not single value") (REPLACE "cached cache idx" "cache idxs bound") (REPLACE "cached`1 varidx" "cache idxs bound") (REPLACE "re") (ASSERT) (GRIND)) (THEN (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (SPREAD (SPLIT "cache idxs bound") ((THEN (FLATTEN) (GROUND)) (THEN (WITH-LABELS (FLATTEN "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (EXPAND ">=") (REPLACE "pownoises" 6) (REPLACE "cached cache idx" 6 :DIR RL) (HIDE-ALL-BUT ("cache idxs bound" 6)) (ASSERT)))))))) (THEN (HIDE-ALL-BUT (1 3 5 -1 "pow gt opn" "opw gt opn")) (EXPAND "nats" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((GRIND) (THEN (FLATTEN) (EXPAND_OL) (EXPAND "first_ol") (PROPAX))))) (SPREAD (USE "last_take_nth[nat,<]") ((ASSERT) (ASSERT)))))) (SPREAD (USE "last_take_nth[nat,<]") ((ASSERT) (ASSERT))) (ASSERT) (ASSERT)))) (ASSERT) (THEN (USE "take_ol[nat,<]") (ASSERT)) (ASSERT)))) (PROPAX))) (THEN (REPLACE "cached`1 varidx" "cached cond ok") (HIDE-ALL-BUT ("varac" "varac not single value" "cached cond ok" "re")) (GRIND))))) (THEN (HIDE-ALL-BUT 1) (TYPEPRED "cache") (GENERALIZE "cache" "cache") (SPREAD (INDUCT "cache") ((GRIND) (THEN (SKOLEM 1 ("h" "t")) (FLATTEN) (EXPAND "every" 1) (SPREAD (SPLIT 1) ((THEN (TYPEPRED "h`3") (ASSERT)) (SPREAD (SPLIT -1) ((PROPAX) (THEN (EXPAND "correct_cache?" -1) (FLATTEN)) (THEN (EXPAND "compatible_pairs?") (SKEEP) (INST?) (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (EXPAND "nth" -3) (SPREAD (INST -3 "i+1") ((ASSERT) (THEN (TYPEPRED "i") (ASSERT) (GRIND))))) (THEN (EXPAND "idxs_bounded") (SKEEP) (EXPAND "nth" -3) (SPREAD (INST -3 "i+1") ((ASSERT) (THEN (TYPEPRED "i") (GRIND))))) (THEN (EXPAND "correct_cache?" -1) (FLATTEN)) (THEN (EXPAND "compatible_pairs?") (SKEEP) (INST?) (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (EXPAND "nth" -3) (SPREAD (INST -3 "i+1") ((ASSERT) (THEN (TYPEPRED "i") (ASSERT) (GRIND))))) (THEN (EXPAND "idxs_bounded") (SKEEP) (EXPAND "nth" -3) (SPREAD (INST -3 "i+1") ((ASSERT) (THEN (TYPEPRED "i") (GRIND)))))))))))))))) (THEN (EXPAND "correct_cache?") (EXPAND "CacheData_correct?") (REPLACE "re" 1) (ASSERT) (LIFT-IF "nwidxs") (SPREAD (SPLIT "nwidxs") ((THEN (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (REPLACE "nwidxs" 1) (EXPAND "powvar?") (EXPAND "varidx_powvar") (SPREAD (SPLIT 1) ((SPREAD (USE "length_append[nat]") ((THEN (REPLACES -1 1) (SPREAD (WITH-LABELS (TYPEPRED "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) ((THEN (REPLACES "nats length" 2) (SPREAD (CASE "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") ((THEN (REPLACES -1 2) (REPLACE "newoff" 2) (ASSERT)) (SPREAD (USE "length_take[nat]") ((THEN (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACE "pownoises") (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT -1) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (HIDE -3 "nats i") (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT))) (ASSERT)))) (ASSERT)))) (ASSERT) (ASSERT))) (THEN (FLATTEN) (SPREAD (CASE "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                      nats(nextfreeidx, newoff - 1))) = car(pownoises)") ((THEN (REPLACES -1 2) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT -1) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (SPREAD (SPLIT "cached correct") ((THEN (FLATTEN) (SPREAD (SPLIT -2) ((THEN (REPLACE -4 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (GRIND)) (THEN (EXPAND "length") (ASSERT))))) (THEN (REPLACE "varac" "varac not single value") (REPLACE -3 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (GRIND))))) (THEN (EXPAND "append" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "take" -1) (SPREAD (CASE "length(pownoises) >= opn(val(cached)`1) - 1") ((ASSERT) (THEN (HIDE -1) (REPLACE "pownoises" 1) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "varac" "varac not single value") (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (GRIND))))) (THEN (FLATTEN) (ASSERT) (EXPAND "take" 2) (SPREAD (CASE "length(pownoises) >= opn(val(cached)`1) - 1") ((ASSERT) (THEN (REPLACE "pownoises" 1) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "varac" "varac not single value") (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (GRIND)))))))) (THEN (REPLACE "pownoises" 1) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (USE "cache_powvar_correct_result") (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (SPREAD (SPLIT "cached correct") ((THEN (EXPAND "length") (ASSERT)) (THEN (REPLACE "varac" "varac not single value") (REPLACE -3 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (GRIND))))) (ASSERT) (ASSERT)))) (THEN (REPLACES "varac") (REPLACES "idx") (ASSERT))))) (THEN (FLATTEN) (REPLACE -1 2) (SPREAD (SPLIT 2) ((SPREAD (TYPEPRED "nats(nextfreeidx, newoff - 1)") ((THEN (EXPAND "varidx_powvar") (ASSERT)) (ASSERT))) (THEN (FLATTEN) (SPREAD (TYPEPRED "nats(nextfreeidx, newoff - 1)") ((SPREAD (INST -5 "0") ((THEN (EXPAND "nth") (TYPEPRED "nextfreeidx") (USE "last_idx_box") (ASSERT)) (THEN (REPLACE -4 1) (REPLACE "newoff" 1) (ASSERT)))) (ASSERT)))) (THEN (REPLACES "varac") (EXPAND "varidx_powvar") (REPLACES -5) (ASSERT)))))))) (THEN (REPLACES "newoff") (HIDE-ALL-BUT (1 "pow gt opn" "opw gt opn")) (SPREAD (CASE "opn(val(cached)`1) < pow") ((THEN (HIDE "pow gt opn" "opw gt opn") (SPREAD (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((THEN (REPLACES -1) (SPREAD (CASE "0 <= pow - opn(val(cached)`1)") ((THEN (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (ASSERT)) (ASSERT)))) (ASSERT)))) (ASSERT))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-1 |nil| 3632064917 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC70 0 (RE2AC_TCC70-1 "" 3803770723 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -10) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -4) (LABEL "cached" -5) (LABEL "newoff" -6) (LABEL "nwidxs" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 6) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 4))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(: (re, acRes, nwidxs) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N vars in box" "i_1") (("1" (WITH-LABELS (FLATTEN) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "powvar?") (("2" (SKEEP* 1) (("2" (CASE "i_1=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "varidx_powvar") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval" 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (FLATTEN) (("1" (EXPAND "eval" 1) (("1" (REPLACE -7 :DIR RL) (("1" (REPLACE "N vars in box" 1 :DIR RL) (("1" (REPLACE "acRes" 1) (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (HIDE 2) (("1" (REPLACES "varac") (("1" (EXPAND "nth_ac") (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "k") (("1" (FLATTEN) (("1" (USE "idxs_ac_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND ">") (("1" (REPLACES "varac") (("1" (USE "last_idx_box") (("1" (EXPAND ">=") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND "last_ol") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (USE "pow_var_compatible_noise") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "pow_var_compatible_noise") (("1" (REPLACE "varac" 1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache comp pairs on" "i_1 -1 ") (("1" (INST "cache comp pairs on" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES "cache comp pairs on" 2 :DIR RL) (("1" (SPLIT 2) (("1" (USE "eval_updb_no_idxs") (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache idxs bound" "i_1 - 1") (("2" (EXPAND "idxs_ac") (("2" (EXPAND "next_idx") (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (INST?) (("2" (CASE "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                                          upd_noise_burst(N,
                                                                                                                                                                                                          nwidxs,
                                                                                                                                                                                                          LAMBDA
                                                                                                                                                                                                          (i: nat):
                                                                                                                                                                                                          (get_noise_by_idx
                                                                                                                                                                                                           (car(pd(varac))`1, N)
                                                                                                                                                                                                           ^
                                                                                                                                                                                                           (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                                          N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                             upd_noise_burst(N,
                                                                                                                                                                                                                             nwidxs,
                                                                                                                                                                                                                             LAMBDA
                                                                                                                                                                                                                             (i: nat):
                                                                                                                                                                                                                             (get_noise_by_idx
                                                                                                                                                                                                                              (car(pd(varac))`1, N)
                                                                                                                                                                                                                              ^
                                                                                                                                                                                                                              (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                             N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACE "nwidxs" -1) (("1" (EXPAND "nth" -1 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (LEMMA "last_idx_box") (("1" (INST? -1 :WHERE -2) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (CASE "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))))") (("1" (ASSERT) (("1" (LEMMA "olidx_car_last[nzBaseType]") (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE "cache comp pairs on") (("1" (REPLACE "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST? "cache idxs bound") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (EXPAND "powvar?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND ">=") (("2" (REPLACE -1 "cache idxs bound") (("2" (TYPEPRED "i_2") (("2" (HIDE-ALL-BUT (-6 -1 "cache idxs bound")) (("2" (CASE "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") (("1" (HIDE -2) (("1" (REPLACES -1 :DIR RL) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") (("1" (HIDE -2 1) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (EXPAND ">=") (("3" (HIDE-ALL-BUT (1 "pow <= 1")) (("3" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "nwidxs") (("1" (CASE "length(nwidxs)=0") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "newoff") (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (REPLACES "nwidxs") (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (INST -5 "pow-2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (2 -3 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (> CONST-DECL "bool" |reals| NIL) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (N SKOLEM-CONST-DECL "Noise" |affine_expr_Eval_fnd| NIL) (|varac| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|get_noise_by_idx| DEF-DECL "Epsilon" |affine| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (<= CONST-DECL "bool" |reals| NIL) (|upd_noise_burst| CONST-DECL "Noise" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|i_1| SKOLEM-CONST-DECL "below(length(cons((POW(re1, pow), acRes, nwidxs), cache)))" |affine_expr_Eval_fnd| NIL) (|nwidxs| SKOLEM-CONST-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) =
     nextfreeidx
     AND
     length(r) = newoff - nextfreeidx AND
      FORALL (i: below(length(r))): nth(r, i) = i + nextfreeidx}" |affine_expr_Eval_fnd| NIL) (|acRes| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|pow| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|beyond_last_idx_notmember| FORMULA-DECL NIL |affine| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|olidx_car_last| FORMULA-DECL NIL |indexed_list| |structures|) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|nth_ol| FORMULA-DECL NIL |ordered_list| |structures|) (|i_2| SKOLEM-CONST-DECL "below(opn(nth[CacheData](cache, i_1 - 1)`1) - 1)" |affine_expr_Eval_fnd| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|pow_var_compatible_noise| FORMULA-DECL NIL |affine_pow| NIL) (|last_idx_box| FORMULA-DECL NIL |affine_box| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|nzreal_expt| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|nzreal_exp| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|idxs_ac_var_ac| FORMULA-DECL NIL |affine| NIL) (|idx| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|eval_updb_no_idxs| FORMULA-DECL NIL |affine| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|containment_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|gnbi_updb_2| FORMULA-DECL NIL |affine| NIL) (|member_nats| FORMULA-DECL NIL |affine_pow| NIL) (|newoff| SKOLEM-CONST-DECL "int" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|power_Epsilon_is_Epsilon| FORMULA-DECL NIL |affine_pow| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|i_1| SKOLEM-CONST-DECL "below(length(box))" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|eval_pd_noise_rec_pds_def| FORMULA-DECL NIL |affine| NIL) (|lt_idx_strict_order| FORMULA-DECL NIL |indexed_list| |structures|) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-3 |nil| 3767021668 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -10) (("" (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached" -5) (LABEL "newoff" -6) (LABEL "nwidxs" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(: (re, acRes, nwidxs) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N vars in box" "i_1") (("1" (WITH-LABELS (FLATTEN) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (EXPAND "powvar?") (("2" (SKEEP* 1) (("2" (CASE "i_1=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "varidx_powvar") (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "eval" 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (FLATTEN) (("1" (EXPAND "eval" 1) (("1" (REPLACE -7 :DIR RL) (("1" (REPLACE "N vars in box" 1 :DIR RL) (("1" (REPLACE "acRes" 1) (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (HIDE 2) (("1" (REPLACES "varac") (("1" (EXPAND "nth_ac") (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "k") (("1" (FLATTEN) (("1" (USE "idxs_ac_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND ">") (("1" (REPLACES "varac") (("1" (USE "last_idx_box") (("1" (EXPAND ">=") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND "last_ol") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (USE "pow_var_compatible_noise") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "pow_var_compatible_noise") (("1" (REPLACE "varac" 1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache comp pairs on" "i_1 -1 ") (("1" (INST "cache comp pairs on" "n") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES "cache comp pairs on" 2 :DIR RL) (("1" (SPLIT 2) (("1" (USE "eval_updb_no_idxs") (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache idxs bound" "i_1 - 1") (("2" (EXPAND "idxs_ac") (("2" (EXPAND "next_idx") (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (INST?) (("2" (CASE "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                       upd_noise_burst(N,
                                                                                                                                                                                       nwidxs,
                                                                                                                                                                                       LAMBDA
                                                                                                                                                                                       (i: nat):
                                                                                                                                                                                       (get_noise_by_idx
                                                                                                                                                                                        (car(pd(varac))`1, N)
                                                                                                                                                                                        ^
                                                                                                                                                                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                       N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                            0)`1,
                                                                                                                                                                                        upd_noise_burst(N,
                                                                                                                                                                                                        nwidxs,
                                                                                                                                                                                                        LAMBDA
                                                                                                                                                                                                        (i: nat):
                                                                                                                                                                                                        (get_noise_by_idx
                                                                                                                                                                                                         (car(pd(varac))`1, N)
                                                                                                                                                                                                         ^
                                                                                                                                                                                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                            0)`1,
                                                                                                                                                                                        N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACE "nwidxs" -1) (("1" (EXPAND "nth" -1 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (LEMMA "last_idx_box") (("1" (INST? -1 :WHERE -2) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (CASE "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))))") (("1" (ASSERT) (("1" (LEMMA "olidx_car_last[nzBaseType]") (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE "cache comp pairs on") (("1" (REPLACE "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST? "cache idxs bound") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (EXPAND "powvar?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND ">=") (("2" (REPLACE -1 "cache idxs bound") (("2" (TYPEPRED "i_2") (("2" (HIDE-ALL-BUT (-6 -1 "cache idxs bound")) (("2" (CASE "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") (("1" (HIDE -2) (("1" (REPLACES -1 :DIR RL) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") (("1" (HIDE -2 1) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (ASSERT) (("2" (EXPAND "length") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (EXPAND ">=") (("3" (HIDE-ALL-BUT (1 "pow <= 1")) (("3" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "nwidxs") (("1" (CASE "length(nwidxs)=0") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "newoff") (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (REPLACES "nwidxs") (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (INST -5 "pow-2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (2 -3 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-2 |nil| 3637401898 ("" (THEN (SKEEP*) (ASSERT) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached some" -5) (LABEL "cached" -6) (LABEL "idxs" -7) (LABEL "pownoises" -8) (LABEL "newoff" -9) (LABEL "nwidxs" -10) (LABEL "acRes" -11) (LABEL "result" -12) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "cv not 0" 4) (LABEL "pow gt opn" 5) (LABEL "opw gt opn" 6))) (HIDE -13) (REPLACES "result") (ASSERT) (SPREAD (SPLIT 7) ((SPREAD (INST 1 "(:(re, acRes, nwidxs):)") ((THEN (EXPAND "append" 1) (GRIND)) (GRIND))) (THEN (LIFT-IF "nwidxs") (SPREAD (SPLIT NWIDXS) ((THEN (WITH-LABELS (NAME "opn" "opn(val(cached)`1)") (("opn name"))) (HIDE "opn name") (WITH-LABELS (FLATTEN "nwidxs") (("opn >= 2" "nwidxs"))) (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "compatible_pairs?") (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (SPREAD (INST 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") ((SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (SKOLEM 1 "k") (INST "N vars in box" "k") (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (SPREAD (SPLIT 1) ((THEN (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1 2) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (ASSERT)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((EXPAND_OL) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)))))))) (THEN (FLATTEN) (ASSERT) (REPLACE "single intervals in box" 1 :DIR RL :HIDE? T) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (REPLACES "nwidxs" -1) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (GRIND)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)))))))) (THEN (EXPAND "compatible_pairs_on?") (SKOLEM 1 "k") (SKEEP) (SPREAD (SPLIT 1) ((SPREAD (CASE "k=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "eval_ACExpr_Env" 1) (REPLACES "acRes") (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "i") (INST "cache comp pairs on" "i") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN) (("cache eval" "cache if powvar" "UNKNOWN"))) (REPLACE "cached cache idx") (EXPAND "eval_ACExpr_Env" "cache eval") (ASSERT) (USE "cache_powvar_correct") (REPLACE "cached cache idx") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached as AC" "cache eval") (REPLACE "re") (ASSERT) (REPLACE "cached idx re") (REPLACE "varac" 1) (LEMMA "containment_pow_var_ac") (EXPAND "eval" 1) (EXPAND "eval" 1) (SPREAD (INST? -1 :WHERE 1) ((THEN (ASSERT) (HIDE 2) (SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (INST "N vars in box" "idx") (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (REPLACE -17) (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "nth_ac") (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1 2) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "last_idx_in_box") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT))))) (FLATTEN)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1) (LEMMA "eval_pd_noise_rec_pds_def") (GRIND))))) (THEN (EXPAND "nth_ac") (REPLACE "varac" :DIR RL) (FLATTEN) (REPLACE "nwidxs" -1 :HIDE? T) (USE "member_append_fi[nat]") (ASSERT) (HIDE -2) (SPREAD (SPLIT -1) ((SPREAD (SPLIT "cached cond ok") ((THEN (EXPAND "next_idx") (EXPAND "last_idx") (REPLACE "pownoises") (HIDE-ALL-BUT (-1 -2 "varac" "varac not single value")) (REPLACES "varac") (USE "olidx_car_last[nzBaseType]") (ASSERT) (EXPAND "car_ol") (SPREAD (USE "notmember_ol_nat") ((THEN (ASSERT) (GRIND)) (USE "take_ol[nat,<]")))) (GRIND))) (THEN (USE "member_nats") (ASSERT) (HIDE -2) (FLATTEN) (TYPEPRED "nextfreeidx") (REPLACE "varac") (USE "last_idx_box") (EXPAND "next_idx") (EXPAND "last_idx") (HIDE-ALL-BUT (-1 -2 -3 "varac not single value")) (USE "olidx_car_last[nzBaseType]") (SPREAD (SPLIT -1) ((THEN (EXPAND "car_ol") (ASSERT)) (THEN (EXPAND "length") (ASSERT)))))))) (THEN (REVEAL "cache comp pairs on") (HIDE -1) (INST "cache comp pairs on" "i") (ASSERT) (LEMMA "powvar_comp_noise_extension") (SPREAD (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((THEN (ASSERT) (REPLACE "varac" -1) (REPLACES "cached cache idx" :DIR RL) (REPLACE "pownoises" -1) (REPLACE "nwidxs" 1) (REPLACE "pownoises" 1) (REPLACE "re" (-1 1)) (REPLACE "newoff" 1) (REVEAL "opn name") (ASSERT) (GRIND)) (THEN (HIDE 2) (REPLACE "pownoises" 1) (EXPAND "idxs_bounded" "cache idxs bound") (INST "cache idxs bound" "i") (SPREAD (CASE "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") ((THEN (REPLACE -1 "cache idxs bound" :HIDE? T) (SPREAD (USE "last_take_nth[nat,<]") ((THEN (REPLACE -1 1 :HIDE? T) (ASSERT)) (GRIND)))) (THEN (REPLACE "cached cache idx") (REPLACE "cached as AC" 1) (USE "next_idx_pow_var_ac") (ASSERT) (GRIND)) (THEN (REPLACE "varac" "varac not single value") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (THEN (EXPAND "varidx_powvar") (REPLACE "varac" "varac not single value") (REPLACE "pownoises" 1) (REPLACE "varac" 1) (FLATTEN) (ASSERT) (FLATTEN) (ASSERT)) (THEN (EXPAND "length" "varac not single value") (REPLACE "varac") (SPREAD (SPLIT 1) ((THEN (EXPAND "nth_ac") (HIDE-ALL-BUT 1) (GRIND)) (THEN (HIDE-ALL-BUT (-1 "varac not single value")) (ASSERT))))) (THEN (REPLACE "re" 1) (ASSERT)))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (REVEAL "varac") (GRIND))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac" "varac not single value")) (EXPAND "length") (GRIND))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST "cache comp pairs on" "k-1") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (REPLACE "cache eval" 2 :DIR RL) (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 3) (SKEEP) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "idxs_bounded" "cache idxs bound") (INST?) (EXPAND "idxs_ac") (USE "beyond_last_idx_notmember") (ASSERT) (EXPAND "next_idx") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))))) (SPREAD (CASE "k=0") ((THEN (REPLACES -1) (FLATTEN) (EXPAND "nth" (-1 -2)) (EXPAND "nth" 1) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached in cache"))) (SKOLEM "cached in cache" "j") (INST "cache comp pairs on" "j") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (ASSERT) (LEMMA "powvar_comp_noise_extension") (SPREAD (INST -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((THEN (ASSERT) (REPLACE "varac" -1) (REPLACES "cached in cache" :DIR RL) (REPLACE "pownoises" -1) (REPLACE "cached idx re" "cached N compatible") (REPLACE "re" "cached N compatible") (REPLACE "nwidxs" 1) (REPLACE "pownoises" 1) (REPLACE "re" (-1 1)) (REPLACE "newoff" 1) (REVEAL "opn name") (ASSERT) (EXPAND "varidx_powvar") (ASSERT)) (THEN (REPLACE "pownoises" 1) (EXPAND "idxs_bounded" "cache idxs bound") (INST "cache idxs bound" "j") (SPREAD (CASE "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") ((THEN (REPLACE -1 "cache idxs bound" :HIDE? T) (SPREAD (USE "last_take_nth[nat,<]") ((THEN (REPLACE -1 1 :HIDE? T) (ASSERT)) (THEN (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (REPLACE "cached in cache") (ASSERT) (FLATTEN) (REPLACE "varac") (REPLACE "cached idx re") (REPLACE "re") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (THEN (REPLACE "cached in cache") (USE "cache_powvar_correct") (REPLACE "cached in cache") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached as AC" 1) (USE "next_idx_pow_var_ac") (REPLACE "cached idx re" -1) (REPLACE "re" -1) (REPLACE "varac" "varac not single value") (ASSERT) (REPLACE "cached idx re" 1) (REPLACE "re" 1) (ASSERT) (EXPAND "varidx_powvar") (PROPAX)) (THEN (USE "cache_powvar_correct") (REPLACE "cached in cache") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (ASSERT) (REPLACE "varac" "varac not single value") (REPLACE "cached idx re" -1) (REPLACE "re" -1) (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (THEN (USE "cache_powvar_correct") (REPLACE "cached in cache") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (ASSERT) (REPLACE "varac" "varac not single value") (REPLACE "pownoises" 1) (REPLACE "varac" 1) (REPLACE "cached idx re" "cached cond ok") (REPLACE "re" "cached cond ok") (ASSERT) (EXPAND "varidx_powvar") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (ASSERT)) (THEN (EXPAND "length" "varac not single value") (ASSERT)) (THEN (REPLACE "re" 1) (ASSERT))))) (THEN (FLATTEN) (SPREAD (INST "cache comp pairs on" "k-1") ((THEN (INST "cache comp pairs on" "n") (EXPAND "nth" 2) (ASSERT) (FLATTEN) (EXPAND "nth" (-1 -2)) (ASSERT) (EXPAND "pow_var_compatible?") (FLATTEN) (SKOLEM 2 "i") (ASSERT) (INST "cache comp pairs on" "i") (SPREAD (CASE "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") ((THEN (REPLACES -1) (SPREAD (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                                                                                                                              nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                              LAMBDA
                                                                                                                                                                                                                                                              (i: nat):
                                                                                                                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                               ^
                                                                                                                                                                                                                                                               (1 + i +opn))))
                                                                                                                                                                                                                              ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              N)
                                                                                                                                                                                                                              ^ (2 + i)") ((REPLACES -1) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (HIDE 2) (USE "member_nats") (ASSERT) (HIDE -2) (FLATTEN) (TYPEPRED "nextfreeidx") (EXPAND "nth_ac" -2) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (EXPAND "next_idx") (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (USE "last_idx_box") (EXPAND "next_idx") (EXPAND "last_idx") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (USE "olidx_car_last[nzBaseType]") (EXPAND_OL) (EXPAND "nth" -4 1) (ASSERT) (EXPAND "nth_ac") (ASSERT)) (THEN (ASSERT) (HIDE-ALL-BUT (-1 -7)) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))))) (THEN (HIDE 3) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (USE "member_nats") (ASSERT) (HIDE -2) (FLATTEN) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (LEMMA "next_idx_pow_var_ac") (INST? -1 :WHERE "cache idxs bound") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (TYPEPRED "cached") (ASSERT)) (THEN (FLATTEN) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACE -1 "cache idxs bound" :HIDE? T) (TYPEPRED "i") (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (EXPAND ">=") (SPREAD (CASE "i = opn(nth(cache, k - 1)`1) - 2") ((THEN (REPLACES -1) (HIDE -1) (ASSERT)) (SPREAD (CASE "i < opn(nth(cache, k - 1)`1) - 2") ((THEN (HIDE -2) (LEMMA "nth_ol[nat,<]") (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (ASSERT)) (ASSERT)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (TYPEPRED "k") (HIDE-ALL-BUT (-1 1 2)) (ASSERT) (GRIND)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (THEN (HIDE-ALL-BUT (1 "opn >= 2")) (SKEEP) (REVEAL "opn name") (ASSERT)) (ASSERT)))) (THEN (WITH-LABELS (FLATTEN "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "compatible_pairs?") (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (SPREAD (INST 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") ((SPREAD (SPLIT 2) ((THEN (EXPAND "vars_in_box_compatible?") (SKOLEM 1 "k") (INST "N vars in box" "k") (WITH-LABELS (FLATTEN "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (SPREAD (SPLIT 1) ((THEN (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (ASSERT)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (ASSERT)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((EXPAND_OL) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)))))))) (THEN (FLATTEN) (ASSERT) (REPLACES "single intervals in box" 1 :DIR RL) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (REPLACES "nwidxs" -1) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "k") (TYPEPRED "nextfreeidx") (GRIND)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)))))))) (THEN (EXPAND "compatible_pairs_on?") (SKOLEM 1 "k") (SKEEP) (SPREAD (SPLIT 1) ((SPREAD (CASE "k=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "eval_ACExpr_Env" 1) (REPLACES "acRes") (EXPAND "eval") (LEMMA "containment_pow_var_ac") (EXPAND "eval" 1) (REPLACE "re" 1) (ASSERT) (SPREAD (INST -1 "upd_noise_burst(N,
                                                                                                                                                                       nats(nextfreeidx, newoff - 1),
                                                                                                                                                                       LAMBDA
                                                                                                                                                                       (i: nat):
                                                                                                                                                                       (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                        ^
                                                                                                                                                                        (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") ((THEN (ASSERT) (HIDE 2) (SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (INST "N vars in box" "idx") (REPLACE "varac" 1) (EXPAND "nth_ac" 1) (WITH-LABELS (FLATTEN "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 2) (SKOLEM 1 "j") (FLATTEN) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "nextfreeidx") (USE "last_idx_box") (GRIND)) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (REVEAL "varac") (REPLACES "varac") (EXPAND "nth_ac") (EXPAND "length") (ASSERT))))) (THEN (REPLACES "varac") (EXPAND "length") (EXPAND "nth_ac") (ASSERT))))) (THEN (FLATTEN) (REPLACES "nwidxs" -1) (USE "member_nats") (ASSERT) (FLATTEN) (REPLACES "varac") (TYPEPRED "nextfreeidx") (USE "last_idx_box") (GRIND)) (SPREAD (USE "pow_var_compatible_noise") ((ASSERT) (THEN (REPLACES "varac") (HIDE-ALL-BUT 1) (GRIND))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (EXPAND "length") (ASSERT))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST "cache comp pairs on" "k-1") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (REPLACES "eval cache" 2 :DIR RL) (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 3) (SKOLEM 1 "i") (FLATTEN) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (EXPAND "next_idx") (LEMMA "beyond_last_idx_notmember") (INST -1 "i" "pd(nth(cache, k - 1)`2)") (ASSERT) (EXPAND "idxs_ac") (PROPAX)) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value" "varac")) (REPLACES "varac") (EXPAND "length") (ASSERT))))))) (SPREAD (CASE "k=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACE "re" 1) (ASSERT) (SPREAD (USE "pow_var_compatible_noise") ((THEN (REPLACES "nwidxs") (REPLACES "varac") (EXPAND "powvar?") (EXPAND "varidx_powvar") (ASSERT)) (THEN (EXPAND "nth_ac") (REPLACES "varac") (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "varidx_powvar") (GRIND))))) (THEN (EXPAND "nth" 2) (EXPAND "varidx_powvar") (ASSERT) (FLATTEN) (INST "cache comp pairs on" "k-1") (INST "cache comp pairs on" "n") (WITH-LABELS (FLATTEN "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (ASSERT) (EXPAND "pow_var_compatible?") (FLATTEN) (ASSERT) (SKOLEM 2 "j") (INST "cache if powvar" "j") (SPREAD (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                            0)`1,
                                                                                                                                                                                                        upd_noise_burst(N,
                                                                                                                                                                                                                        nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                        LAMBDA
                                                                                                                                                                                                                        (i: nat):
                                                                                                                                                                                                                        (get_noise_by_idx
                                                                                                                                                                                                                         (car(pd(varac))`1, N)
                                                                                                                                                                                                                         ^
                                                                                                                                                                                                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                            0)`1,
                                                                                                                                                                                                        N)") ((THEN (REPLACES -1) (SPREAD (CASE "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                          upd_noise_burst(N,
                                                                                                                                                                                                                                          nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                          LAMBDA
                                                                                                                                                                                                                                          (i: nat):
                                                                                                                                                                                                                                          (get_noise_by_idx
                                                                                                                                                                                                                                           (car(pd(varac))`1, N)
                                                                                                                                                                                                                                           ^
                                                                                                                                                                                                                                           (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                          N)") ((THEN (REPLACES -1) (GRIND)) (THEN (HIDE 3) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (USE "member_nats") (ASSERT) (FLATTEN) (EXPAND "idxs_bounded") (INST?) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (LEMMA "next_idx_pow_var_ac") (INST? -1 :WHERE "cache idxs bound") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (REPLACE -1 "cache idxs bound" :HIDE? T) (TYPEPRED "j") (HIDE-ALL-BUT (-1 -5 "cache idxs bound")) (EXPAND ">=") (SPREAD (CASE "j = opn(nth(cache, k - 1)`1) - 2 ") ((THEN (HIDE -2) (REPLACES -1) (ASSERT)) (SPREAD (CASE "j < opn(nth(cache, k - 1)`1) - 2") ((THEN (HIDE (-2 1)) (LEMMA "nth_ol[nat,<]") (INST -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (ASSERT)) (ASSERT)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (ASSERT) (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)))))))) (THEN (HIDE 3) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (USE "member_nats") (ASSERT) (FLATTEN) (TYPEPRED "nextfreeidx") (EXPAND "nth_ac" -2) (EXPAND "idxs_bounded") (INST "cache idxs bound" "k-1") (EXPAND "next_idx") (NAME-REPLACE "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (USE "last_idx_box") (EXPAND "next_idx") (EXPAND "last_idx") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (USE "olidx_car_last[nzBaseType]") (EXPAND_OL) (EXPAND "nth" -4 1) (ASSERT) (EXPAND "nth_ac") (ASSERT)) (THEN (FLATTEN) (EXPAND "last_idx_in_box") (ASSERT) (EXPAND "somevidx") (EXPAND "varidx_powvar") (ASSERT) (GRIND))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)) (THEN (EXPAND "varidx_powvar") (ASSERT)) (THEN (EXPAND "varidx_powvar") (PROPAX)))))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)) (ASSERT))))))) (THEN (REPLACE "newoff" 1) (EXPAND ">=") (SPREAD (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((THEN (REPLACES -1) (SPREAD (CASE "0 < pow - opn(val(cached)`1)") ((THEN (HIDE-ALL-BUT (1 -1)) (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (ASSERT)) (GRIND)))) (ASSERT)))) (THEN (REPLACE "newoff" 1) (EXPAND "idxs_bounded" 1) (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACE "acRes" 1) (USE "next_idx_pow_var_ac") (REPLACES -1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (SPLIT 3) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (REPLACE "nwidxs" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (FLATTEN) (SPREAD (CASE "pow - 1 = opn(val(cached)`1)") ((THEN (REPLACE -1 1 :DIR RL) (ASSERT) (SPREAD (CASE "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                         pow - 2) = nextfreeidx") ((ASSERT) (THEN (HIDE 2) (SPREAD (CASE "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                    nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") ((THEN (REPLACES -1 1) (USE "length_take[nat]") (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (CASE "length(pownoises) = pow - 2") ((THEN (REPLACES -1 2) (GRIND)) (SPREAD (CASE "length(pownoises) > opn(val(cached)`1) - 2") ((ASSERT) (THEN (REPLACE "pownoises" 1) (TYPEPRED "cached") (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))) (REPLACE "cached" "cached correct" :DIR RL) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "varac" "varac not single value") (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (EXPAND "varidx_powvar") (ASSERT)))))))))) (THEN (USE "more_list_props[nat].nth_append") (SPREAD (SPLIT -1) ((THEN (REPLACES -1 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (USE "length_take[nat]") (REPLACE -1 -2) (EXPAND "min") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (ASSERT))))) (PROPAX)))) (THEN (USE "length_append[nat]") (USE "length_take[nat]") (REPLACE -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (REPLACE "pownoises" 1) (HIDE -1 -2) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached idx re" "cached cond ok") (REPLACE "re" "cached cond ok") (ASSERT) (EXPAND "varidx_powvar") (ASSERT)))))))) (SPREAD (SPLIT 1) ((THEN (USE "length_take[nat]") (REPLACES -1 1) (GRIND)) (THEN (USE "length_append[nat]") (USE "length_take[nat]") (REPLACE -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (ASSERT)) (THEN (FLATTEN) (REPLACE "pownoises" 1) (HIDE -1 -2) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "cached idx re" "cached cond ok") (REPLACE "re" "cached cond ok") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))))))))))) (SPREAD (CASE "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                =
                                nth(nats(nextfreeidx, newoff - 1),
                                    pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") ((THEN (REPLACES -1 2) (SPREAD (CASE "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                            pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") ((THEN (REPLACES -1 2) (REPLACE "newoff" 2) (ASSERT)) (SPREAD (CASE "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") ((THEN (REPLACES -1 1) (REPLACES "newoff" 1) (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (INST? -5) (REPLACE -5 2) (ASSERT)) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 1) (EXPAND "min" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACES "pownoises" 1) (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "cached" "cached correct" :DIR RL) (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT))))) (SPREAD (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((THEN (REPLACE -1 1) (ASSERT)) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 1) (EXPAND "min" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACES "pownoises" 1) (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))))))) (ASSERT)))))))) (SPREAD (USE "more_list_props[nat].nth_append") ((SPREAD (SPLIT -1) ((THEN (REPLACES -1 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 -2) (EXPAND "min") (LIFT-IF -2) (SPREAD (SPLIT -2) ((ASSERT) (THEN (ASSERT) (FLATTEN) (ASSERT))))) (ASSERT)))) (PROPAX)))) (SPREAD (USE "length_take[nat]") ((THEN (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((ASSERT) (THEN (FLATTEN) (REPLACES "pownoises" 1) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "varac") (REPLACE "cached idx re" "cached cond ok") (REPLACE "re") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT))))) (ASSERT) (ASSERT))) (SPREAD (CASE "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((SPREAD (SPLIT 1) ((THEN (REPLACES -1 1) (ASSERT)) (SPREAD (USE "length_append[nat]") ((THEN (REPLACES -1 1) (SPREAD (USE "length_take[nat]") ((THEN (REPLACES -1 1) (EXPAND "min") (LIFT-IF 1) (SPREAD (SPLIT 1) ((ASSERT) (THEN (FLATTEN) (REPLACES "pownoises" 1) (TYPEPRED "cached") (ASSERT) (WITH-LABELS (FLATTEN -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (SKOLEM "cached cache idx" "j") (REPLACE "cached cache idx" :DIR RL) (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (ASSERT) (WITH-LABELS (FLATTEN -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (REPLACE "varac") (REPLACE "cached idx re" "cached cond ok") (REPLACE "re") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT)))) (ASSERT) (ASSERT))))) (THEN (HIDE 2) (SPREAD (USE "length_take[nat]") ((THEN (REPLACE -1 1) (EXPAND "min" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((PROPAX) (THEN (FLATTEN) (REPLACES "pownoises" 1) (USE "cache_powvar_correct_result") (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (WITH-LABELS (ASSERT) (("cached correct"))) (EXPAND "CacheData_correct?" "cached correct") (TYPEPRED "cached") (ASSERT) (FLATTEN) (ASSERT) (FLATTEN) (REPLACE "cached" "cached correct" :DIR RL) (REPLACE -2 "cached correct") (REPLACE "re" "cached correct") (ASSERT) (EXPAND "varidx_powvar") (ASSERT))))) (ASSERT)))) (ASSERT))) (ASSERT) (ASSERT)))))) (THEN (FLATTEN) (REPLACE "newoff" 2) (TYPEPRED "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (INST? -5) (REPLACES -5 3) (ASSERT))))))))))) (THEN (WITH-LABELS (TYPEPRED "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (EXPAND "idxs_bounded" "cache idxs bounded") (EXPAND "nth" 2) (ASSERT) (INST "cache idxs bounded" "i-1") (EXPAND ">=") (SPREAD (CASE "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((THEN (REPLACES -1) (SPREAD (CASE "0 < pow - opn(val(cached)`1)") ((THEN (HIDE-ALL-BUT (-1 2 "cache idxs bounded")) (NAME-REPLACE "A" "pow - opn(val(cached)`1)") (ASSERT)) (GRIND)))) (GRIND)))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-1 |nil| 3632064917 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached" -3) (LABEL "newoff" -4) (LABEL "nwidxs" -5) (LABEL "acRes" -6) (LABEL "result" -7) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (EXPAND "correct_cache?") (("1" (EXPAND "CacheData_correct?") (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (REPLACES "nwidxs" 2) (("1" (EXPAND "nats" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1 1 :DIR RL) (("1" (USE "last_idx_box") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND_OL) (("2" (USE "last_idx_box") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (REPLACES -1) (("1" (CASE "0<=pow - 1") (("1" (NAME-REPLACE "A" "pow -1 ") (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC71 0 (RE2AC_TCC71-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC72 0 (RE2AC_TCC66-3 |nil| 3637402164 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|restrict| CONST-DECL "R" |restrict| NIL)) NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL")) (RE2AC_TCC66-2 |nil| 3632080585 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -8) (("" (APPLY (THEN (LABEL "re" -1) (LABEL "varac" -2) (LABEL "cached" -3) (LABEL "newoff" -4) (LABEL "nwidxs" -5) (LABEL "acRes" -6) (LABEL "result" -7) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (("" (REPLACES "re") (("" (REPLACES "result") (("" (ASSERT) (("" (SPLIT 7) (("1" (INST 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (GRIND) NIL NIL)) NIL) ("2" (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (EXPAND "compatible_pairs?") (("2" (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (INST 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (INST "N vars in box" "i_1") (("1" (WITH-LABELS (FLATTEN) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (SPLIT 1) (("1" (REPLACE "eval box is vs" 1 :DIR RL) (("1" (EXPAND "var_ac" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "eval_ac_noise" 2) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (HIDE-ALL-BUT (1 "pow <= 1")) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "eval_ac_noise" 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("2" (ASSERT) (("2" (EXPAND_OL) (("2" (REPLACES -1 1) (("2" (USE "eval_pd_noise_rec_pds_def") (("1" (EXPAND_OL) NIL NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REPLACES "single intervals in box" 1 :DIR RL) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "i_1") (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP 1) (("2" (CASE "i_1=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "eval_ACExpr_Env" 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (INST "N vars in box" "idx") (("1" (FLATTEN) (("1" (REPLACE "N vars in box" 1 :DIR RL) (("1" (REPLACE "acRes" 1) (("1" (SPLIT 1) (("1" (USE "containment_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (HIDE 2) (("1" (REPLACES "varac") (("1" (EXPAND "nth_ac") (("1" (USE "eval_updb_no_idxs") (("1" (ASSERT) (("1" (HIDE 2) (("1" (SKOLEM 1 "k") (("1" (FLATTEN) (("1" (USE "idxs_ac_var_ac") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (FLATTEN) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "nextfreeidx") (("1" (EXPAND "last_idx_in_box") (("1" (EXPAND ">") (("1" (REPLACES "varac") (("1" (USE "last_idx_box") (("1" (EXPAND ">=") (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (EXPAND "last_ol") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (USE "pow_var_compatible_noise") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "pow_var_compatible_noise") (("1" (REPLACE "varac" 1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "cache comp pairs on" "i_1 -1 ") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES "cache comp pairs on" 2 :DIR RL) (("1" (SPLIT 2) (("1" (USE "eval_updb_no_idxs") (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache idxs bound" "i_1 - 1") (("2" (EXPAND "idxs_ac") (("2" (EXPAND "next_idx") (("2" (USE "beyond_last_idx_notmember") (("2" (ASSERT) (("2" (REPLACES "nwidxs" -1) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "pow_var_compatible?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (INST?) (("2" (CASE "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                upd_noise_burst(N,
                                                                                                nwidxs,
                                                                                                LAMBDA
                                                                                                (i: nat):
                                                                                                (get_noise_by_idx
                                                                                                 (car(pd(varac))`1, N)
                                                                                                 ^
                                                                                                 (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                N)") (("1" (REPLACES -1) (("1" (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                                           0)`1,
                                                                                       upd_noise_burst(N,
                                                                                                       nwidxs,
                                                                                                       LAMBDA
                                                                                                       (i: nat):
                                                                                                       (get_noise_by_idx
                                                                                                        (car(pd(varac))`1, N)
                                                                                                        ^
                                                                                                        (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                                           0)`1,
                                                                                       N)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (REPLACE "nwidxs" -1) (("1" (EXPAND "nth" -1 1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (LEMMA "last_idx_box") (("1" (INST? -1 :WHERE -2) (("1" (EXPAND "next_idx") (("1" (EXPAND "last_idx") (("1" (CASE "NOT null?(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))))") (("1" (ASSERT) (("1" (LEMMA "olidx_car_last[nzBaseType]") (("1" (INST? -1 :WHERE 1) (("1" (ASSERT) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) (("1" (EXPAND "car_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (USE "gnbi_updb_2") (("1" (ASSERT) (("1" (HIDE 1) (("1" (HIDE "cache comp pairs on") (("1" (REPLACE "nwidxs" -1) (("1" (USE "member_nats") (("1" (ASSERT) (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_bounded") (("1" (INST? "cache idxs bound") (("1" (USE "cache_powvar_correct") (("1" (EXPAND "CacheData_correct?") (("1" (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (LEMMA "next_idx_pow_var_ac") (("1" (INST? -1 :WHERE "cache idxs bound") (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND ">=") (("2" (REPLACE -1 "cache idxs bound") (("2" (TYPEPRED "i_2") (("2" (HIDE-ALL-BUT (-6 -1 "cache idxs bound")) (("2" (CASE "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") (("1" (HIDE -2) (("1" (REPLACES -1 :DIR RL) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") (("1" (HIDE -2 1) (("1" (LEMMA "nth_ol[nat,<]") (("1" (INST -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES "newoff") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 "varac not single value")) (("3" (SKEEP) (("3" (USE "power_Epsilon_is_Epsilon") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 "varac not single value")) (("4" (EXPAND "length") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 "varac not single value")) (("2" (SKEEP) (("2" (ASSERT) (("2" (USE "power_Epsilon_is_Epsilon") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES "newoff") (("3" (EXPAND ">=") (("3" (HIDE-ALL-BUT (1 "pow <= 1")) (("3" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "cache") (("4" (EXPAND "idxs_bounded") (("4" (SKEEP) (("4" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (REPLACES "acRes") (("1" (USE "next_idx_pow_var_ac") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED "nwidxs") (("1" (CASE "length(nwidxs)=0") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES "newoff") (("2" (ASSERT) (("2" (EXPAND ">=") (("2" (REPLACES "nwidxs") (("2" (TYPEPRED "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (INST -5 "pow-2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (INST?) (("2" (REPLACES "newoff") (("2" (HIDE-ALL-BUT (2 -3 "pow <= 1")) (("2" (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (REPLACES -1) (("1" (CASE "1<=(pow - 1)") (("1" (NAME-REPLACE "A" "pow-1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL")) (RE2AC_TCC66-1 |nil| 3632064917 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL"))) (RE2AC_TCC73 0 (RE2AC_TCC73-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC74 0 (RE2AC_TCC74-1 "" 3789917959 ("" (SKEEP*) (("" (ASSERT) NIL NIL)) NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC67-2 |nil| 3637402446 ("" (THEN (SKEEP*) (REPLACE -4 7) (EXPAND "nth_ac") (EXPAND "represents_var?") (EXPAND "var_ac") (ASSERT) (HIDE-ALL-BUT 7) (LIFT-IF 1) (EXPAND_OL) (ASSERT)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC67-1 |nil| 3632064917 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC75 0 (RE2AC_TCC68-1 |nil| 3632064917 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC76 0 (RE2AC_TCC76-1 "" 3789917962 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC69-2 |nil| 3767022173 ("" (SKEEP*) (("" (REPLACES -1) (("" (TYPEPRED "res1") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC69-1 |nil| 3632130329 ("" (THEN (SKEEP*) (ASSERT) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached" -5) (LABEL "newoff" -6) (LABEL "nwidxs" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (REPLACES "re") (REPLACES "result") (ASSERT) (SPREAD (SPLIT 7) ((THEN (EXPAND "correct_cache?") (EXPAND "CacheData_correct?") (EXPAND "powvar?") (EXPAND "varidx_powvar") (FLATTEN) (TYPEPRED "nextfreeidx") (REPLACES "nwidxs" 2) (EXPAND "nats" 2) (LIFT-IF 2) (SPREAD (SPLIT 2) ((THEN (ASSERT) (FLATTEN) (REPLACES -1 1 :DIR RL) (USE "last_idx_box") (GRIND)) (THEN (FLATTEN) (EXPAND_OL) (USE "last_idx_box") (GRIND))))) (THEN (REPLACES "newoff") (HIDE-ALL-BUT (1 "pow <= 1")) (SPREAD (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") ((THEN (REPLACES -1) (SPREAD (CASE "0<=pow - 1") ((THEN (NAME-REPLACE "A" "pow -1 ") (ASSERT)) (ASSERT)))) (ASSERT))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC77 0 (RE2AC_TCC77-1 "" 3789917963 ("" (SKEEP*) (("" (TYPEPRED "res1") (("" (ASSERT) (("" (REPLACES -5 :DIR RL) (("" (FLATTEN) (("" (ASSERT) (("" (EXPAND "compatible_pairs?") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC70-2 |nil| 3767022221 ("" (SKEEP*) (("" (REPLACES -1) (("" (TYPEPRED "res1") (("" (ASSERT) (("" (REPLACES -5 :DIR RL) (("" (FLATTEN) (("" (ASSERT) (("" (EXPAND "compatible_pairs?") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC70-1 |nil| 3632130329 ("" (THEN (SKEEP*) (ASSERT) (HIDE -10) (APPLY (THEN (LABEL "re" -2) (LABEL "varac" -4) (LABEL "cached" -5) (LABEL "newoff" -6) (LABEL "nwidxs" -7) (LABEL "acRes" -8) (LABEL "result" -9) (LABEL "idx" 1) (LABEL "pow <= 1" 2) (LABEL "varac not single value" 3) (LABEL "not in cache 3" 4) (LABEL "not in cache 2" 5) (LABEL "not in cache 1" 6))) (REPLACES "re") (REPLACES "result") (ASSERT) (SPREAD (SPLIT 7) ((THEN (INST 1 "(: (re, acRes, nwidxs) :)") (GRIND)) (THEN (WITH-LABELS (TYPEPRED "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (EXPAND "compatible_pairs?") (WITH-LABELS (SKEEP "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (SPREAD (INST 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") ((SPREAD (SPLIT 1) ((THEN (EXPAND "vars_in_box_compatible?") (SKEEP) (INST "N vars in box" "i_1") (WITH-LABELS (FLATTEN) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (SPREAD (SPLIT 1) ((THEN (REPLACE "eval box is vs" 1 :DIR RL) (EXPAND "var_ac" 1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (EXPAND "eval_ac_noise" 2) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (ASSERT) (EXPAND_OL) (REPLACES -1) (USE "eval_pd_noise_rec_pds_def") (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((THEN (EXPAND_OL) (REPLACES -1) (ASSERT) (TYPEPRED "nextfreeidx") (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 2) (REPLACES "nwidxs" -1) (SPREAD (USE "member_nats") ((THEN (ASSERT) (FLATTEN) (TYPEPRED "i_1") (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (ASSERT)) (THEN (REPLACES "newoff" 1) (HIDE-ALL-BUT (1 "pow <= 1")) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (ASSERT)))) (THEN (FLATTEN) (EXPAND "eval_ac_noise" 1) (USE "eval_pd_noise_rec_pds_def") (ASSERT) (EXPAND_OL) (REPLACES -1 1) (SPREAD (USE "eval_pd_noise_rec_pds_def") ((EXPAND_OL) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)))))))) (THEN (FLATTEN) (ASSERT) (REPLACES "single intervals in box" 1 :DIR RL) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (REPLACES "nwidxs" -1) (SPREAD (USE "member_nats") ((THEN (ASSERT) (FLATTEN) (TYPEPRED "i_1") (TYPEPRED "nextfreeidx") (GRIND)) (THEN (REPLACES "newoff" 1) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT)))))))) (THEN (EXPAND "compatible_pairs_on?") (EXPAND "powvar?") (SKEEP* 1) (SPREAD (CASE "i_1=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (EXPAND "varidx_powvar") (EXPAND "eval_ACExpr_Env" 1) (EXPAND "eval" 1) (EXPAND "vars_in_box_compatible?") (INST "N vars in box" "idx") (FLATTEN) (EXPAND "eval" 1) (REPLACE -7 :DIR RL) (REPLACE "N vars in box" 1 :DIR RL) (REPLACE "acRes" 1) (SPREAD (SPLIT 1) ((SPREAD (USE "containment_pow_var_ac") ((THEN (ASSERT) (SPREAD (SPLIT 1) ((THEN (HIDE 2) (REPLACES "varac") (EXPAND "nth_ac") (SPREAD (USE "eval_updb_no_idxs") ((THEN (ASSERT) (HIDE 2) (SKOLEM 1 "k") (FLATTEN) (USE "idxs_ac_var_ac") (ASSERT) (REPLACES -1) (REPLACES "nwidxs" -1) (SPREAD (USE "member_nats") ((THEN (ASSERT) (TYPEPRED "nextfreeidx") (GRIND)) (THEN (REPLACES "newoff" 1) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (GRIND)))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (GRIND))))) (THEN (HIDE 2) (FLATTEN) (REPLACES "nwidxs" -1) (SPREAD (USE "member_nats") ((THEN (ASSERT) (FLATTEN) (TYPEPRED "nextfreeidx") (EXPAND "last_idx_in_box") (EXPAND ">") (REPLACES "varac") (USE "last_idx_box") (EXPAND ">=") (EXPAND "next_idx") (EXPAND "last_idx") (EXPAND "last_ol") (ASSERT) (GRIND)) (THEN (REPLACES "newoff" 1) (ASSERT))))) (THEN (HIDE 2) (USE "pow_var_compatible_noise") (GRIND))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (GRIND)))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)))) (SPREAD (USE "pow_var_compatible_noise") ((THEN (REPLACE "varac" 1) (PROPAX)) (THEN (HIDE-ALL-BUT 1) (GRIND))))))) (SPREAD (INST "cache comp pairs on" "i_1 -1 ") ((THEN (INST "cache comp pairs on" "n") (EXPAND "nth" 2) (ASSERT) (FLATTEN) (REPLACES "cache comp pairs on" 2 :DIR RL) (SPREAD (SPLIT 2) ((SPREAD (USE "eval_updb_no_idxs") ((SPREAD (SPLIT -1) ((PROPAX) (THEN (HIDE 2) (SKEEP) (EXPAND "idxs_bounded") (INST "cache idxs bound" "i_1 - 1") (EXPAND "idxs_ac") (EXPAND "next_idx") (USE "beyond_last_idx_notmember") (ASSERT) (REPLACES "nwidxs" -1) (SPREAD (USE "member_nats") ((ASSERT) (THEN (REPLACES "newoff" 1) (ASSERT))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (GRIND)))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (GRIND)))) (THEN (FLATTEN) (ASSERT) (EXPAND "pow_var_compatible?") (FLATTEN) (ASSERT) (SKEEP) (INST?) (SPREAD (CASE "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                              nwidxs,
                                                                                                                                                              LAMBDA
                                                                                                                                                              (i: nat):
                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                               ^
                                                                                                                                                               (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                              N)") ((THEN (REPLACES -1) (SPREAD (CASE "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                0)`1,
                                                                                                                                                            upd_noise_burst(N,
                                                                                                                                                                            nwidxs,
                                                                                                                                                                            LAMBDA
                                                                                                                                                                            (i: nat):
                                                                                                                                                                            (get_noise_by_idx
                                                                                                                                                                             (car(pd(varac))`1, N)
                                                                                                                                                                             ^
                                                                                                                                                                             (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                0)`1,
                                                                                                                                                            N)") ((REPLACES -1) (THEN (HIDE 2) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (REPLACE "nwidxs" -1) (EXPAND "nth" -1 1) (SPREAD (USE "member_nats") ((THEN (ASSERT) (HIDE -2) (FLATTEN) (LEMMA "last_idx_box") (INST? -1 :WHERE -2) (EXPAND "next_idx") (EXPAND "last_idx") (SPREAD (CASE "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))))") ((THEN (ASSERT) (LEMMA "olidx_car_last[nzBaseType]") (INST? -1 :WHERE 1) (ASSERT) (TYPEPRED "nextfreeidx") (ASSERT) (EXPAND "car_ol") (ASSERT)) (GRIND)))) (THEN (REPLACES "newoff" 1) (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)))))))) (THEN (HIDE 2) (SPREAD (USE "gnbi_updb_2") ((THEN (ASSERT) (HIDE 1) (HIDE "cache comp pairs on") (REPLACE "nwidxs" -1) (SPREAD (USE "member_nats") ((THEN (ASSERT) (HIDE -2) (FLATTEN) (EXPAND "idxs_bounded") (INST? "cache idxs bound") (USE "cache_powvar_correct") (EXPAND "CacheData_correct?") (EXPAND "powvar?") (WITH-LABELS (FLATTEN -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (REPLACE "cache_k-1`2 pow_var_ac" "cache idxs bound") (LEMMA "next_idx_pow_var_ac") (INST? -1 :WHERE "cache idxs bound") (LIFT-IF -1) (SPREAD (SPLIT -1) ((THEN (FLATTEN) (GRIND)) (THEN (FLATTEN) (SPREAD (SPLIT -1) ((GRIND) (THEN (FLATTEN) (EXPAND ">=") (REPLACE -1 "cache idxs bound") (TYPEPRED "i_2") (HIDE-ALL-BUT (-6 -1 "cache idxs bound")) (SPREAD (CASE "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") ((THEN (HIDE -2) (REPLACES -1 :DIR RL) (ASSERT)) (SPREAD (CASE "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") ((THEN (HIDE -2 1) (LEMMA "nth_ol[nat,<]") (INST -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (ASSERT)) (ASSERT)))))))))))) (THEN (REPLACES "newoff") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (SPREAD (USE "power_Epsilon_is_Epsilon") ((THEN (FLATTEN) (ASSERT)) (THEN (EXPAND "length") (ASSERT))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (EXPAND "length") (ASSERT)))))))) (THEN (TYPEPRED "i_1") (HIDE-ALL-BUT (-1 1 2)) (GRIND))))))))) (THEN (HIDE-ALL-BUT (1 "varac not single value")) (SKEEP) (ASSERT) (USE "power_Epsilon_is_Epsilon") (FLATTEN) (ASSERT))))) (THEN (REPLACES "newoff") (EXPAND ">=") (HIDE-ALL-BUT (1 "pow <= 1")) (SPREAD (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") ((THEN (REPLACES -1) (SPREAD (CASE "1<=(pow - 1)") ((THEN (NAME-REPLACE "A" "pow-1") (ASSERT)) (GRIND)))) (GRIND)))) (THEN (TYPEPRED "cache") (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (REPLACES "acRes") (USE "next_idx_pow_var_ac") (REPLACES -1) (LIFT-IF 1) (SPREAD (SPLIT 1) ((THEN (FLATTEN) (TYPEPRED "nwidxs") (SPREAD (CASE "length(nwidxs)=0") ((ASSERT) (GRIND)))) (THEN (FLATTEN) (REPLACES "newoff") (ASSERT) (EXPAND ">=") (REPLACES "nwidxs") (TYPEPRED "nats(nextfreeidx, nextfreeidx - 2 + pow)") (INST -5 "pow-2") (ASSERT))))) (THEN (EXPAND "nth" 2) (ASSERT) (INST?) (REPLACES "newoff") (HIDE-ALL-BUT (2 -3 "pow <= 1")) (SPREAD (CASE "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") ((THEN (REPLACES -1) (SPREAD (CASE "1<=(pow - 1)") ((THEN (NAME-REPLACE "A" "pow-1") (ASSERT)) (GRIND)))) (GRIND)))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}"))) (RE2AC_TCC78 0 (RE2AC_TCC71-1 |nil| 3632130329 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|restrict| CONST-DECL "R" |restrict| NIL)) NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "NIL"))) (RE2AC_TCC79 0 (RE2AC_TCC79-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC80 0 (RE2AC_TCC72-2 |nil| 3632130837 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC72-1 |nil| 3632130329 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC81 0 (RE2AC_TCC73-2 |nil| 3637403131 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)")) (RE2AC_TCC73-1 |nil| 3632130329 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC82 0 (RE2AC_TCC74-1 |nil| 3632130329 ("" (TERMINATION-TCC) NIL NIL) ((|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|)) NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC83 0 (RE2AC_TCC75-2 |nil| 3767022444 ("" (SKEEP*) (("" (ASSERT) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (WITH-LABELS (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|sub_pd_pd| CONST-DECL "ErrorTerms" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|sub_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC75-1 |nil| 3632130329 ("" (THEN (SKEEP*) (REPLACES -1) (TYPEPRED "res1") (ASSERT) (REPLACES -5 :DIR RL) (FLATTEN) (ASSERT) (EXPAND "compatible_pairs?") (PROPAX)) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC84 0 (RE2AC_TCC76-2 |nil| 3767022805 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -11) (("" (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES2 NIL (WITH-LABELS (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (SPLIT 3) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (TYPEPRED_RES2) (("2" (SKOLEM "cache2-form" "l2") (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" "cache2-form") (("2" (REPLACE "cache2-form" 3) (("2" (INST 3 "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (HIDE-ALL-BUT 3) (("1" (EXPAND "append" 1 3) (("1" (USE "append_assoc[CacheData]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES2) (("3" (SKOLEM "N2" "N2") (("3" (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (INST 2 "N2") (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP) (("3" (CASE "i=0") (("1" (SKEEP 2) (("1" (REPLACES -1) (("1" (EXPAND "nth" 2) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "powvar?" 2) (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (EXPAND "eval" 2) (("1" (REPLACES "re") (("1" (ASSERT) (("1" (USE "containment_sub") (("1" (ASSERT) (("1" (HIDE 3) (("1" (SPLIT 1) (("1" (TYPEPRED_RES1) (("1" (REPLACES "re1" :DIR RL) (("1" (SKOLEM "N1" "N1") (("1" (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                      eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                       eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (REPLACE "ac1") (("1" (INST -1 "0") (("1" (EXPAND "nth" -1) (("1" (REPLACES -1) (("1" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("1" (INST "N1 compatible pairs" "0") (("1" (INST "N1 compatible pairs" "n") (("1" (EXPAND "nth" "N1 compatible pairs") (("1" (FLATTEN) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (("2" (SKEEP) (("2" (INST "N1 compatible pairs" "i!1") (("2" (INST "N1 compatible pairs" "n") (("2" (SKOLEM "cache2-form" "l2") (("2" (REPLACE "cache2-form" "N2 compatible pairs") (("2" (INST "N2 compatible pairs" "length(l2)+i!1") (("1" (INST "N2 compatible pairs" "n") (("1" (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (USE "more_list_props[CacheData].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE "cache2-form" 1) (("2" (USE "length_append[CacheData]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST "N2 compatible pairs" "0") (("1" (INST "N2 compatible pairs" "n") (("1" (EXPAND "nth" "N2 compatible pairs") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME "j" "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length") (("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REPLACE "result") (("2" (ASSERT) (("2" (INST "N2 compatible pairs" "j") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES2) (("4" (TYPEPRED_RES1) NIL NIL)) NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_sub_ac_ac") (("1" (EXPAND ">=") (("1" (TYPEPRED_RES2) (("1" (TYPEPRED_RES1) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (INST "cache2-idxs_bound" "0") (("1" (EXPAND "nth" "cache2-idxs_bound") (("1" (REPLACE "ac2" :DIR RL) (("1" (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (EXPAND "max") (("1" (LIFT-IF -4) (("1" (SPLIT -4) (("1" (FLATTEN) (("1" (EXPAND ">=") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES2) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache2-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (PROPAX) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|next_idx_sub_ac_ac| FORMULA-DECL NIL |affine| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|ac1| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|ac2| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((re, sub_ac_ac(ac1, ac2), null), cache2)))" |affine_expr_Eval_fnd| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|containment_sub| FORMULA-DECL NIL |affine| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|cache1| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|l2| SKOLEM-CONST-DECL "list[CacheData]" |affine_expr_Eval_fnd| NIL) (|i!1| SKOLEM-CONST-DECL "below(length(cache1))" |affine_expr_Eval_fnd| NIL) (|cache2| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|append_assoc| FORMULA-DECL NIL |list_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|sub_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|sub_pd_pd| CONST-DECL "ErrorTerms" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC76-1 |nil| 3632130329 ("" (THEN (SKEEP*) (REPLACES -1) (TYPEPRED "res1") (ASSERT) (REPLACES -5 :DIR RL) (FLATTEN) (ASSERT) (EXPAND "compatible_pairs?") (PROPAX)) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC85 0 (RE2AC_TCC77-1 |nil| 3632130329 ("" (TERMINATION-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IntervalExpr])" |IntervalExpr_adt| |interval_arith|) (|restrict| CONST-DECL "R" |restrict| NIL)) NIL (RE2AC TERMINATION "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "NIL"))) (RE2AC_TCC86 0 (RE2AC_TCC86-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC87 0 (RE2AC_TCC78-2 |nil| 3767022785 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC78-1 |nil| 3632130329 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC88 0 (RE2AC_TCC79-2 |nil| 3632131028 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)")) (RE2AC_TCC79-1 |nil| 3632130329 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC89 0 (RE2AC_TCC80-2 |nil| 3637403250 ("" (GRIND) NIL NIL) ((|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|)) NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC80-1 |nil| 3632130329 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (RE2AC SUBTYPE "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC90 0 (RE2AC_TCC81-1 |nil| 3632130329 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|last_ol| DEF-DECL "T" |ordered_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|neg_ac| CONST-DECL "AffineCombination" |affine| NIL)) NIL (RE2AC SUBTYPE "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC91 0 (RE2AC_TCC82-2 |nil| 3767022969 ("" (SKEEP*) (("" (ASSERT) (("" (HIDE -7) (("" (APPLY (THEN (LABEL "result" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (("" (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (SPLIT 2) (("1" (GRIND) NIL NIL) ("2" (REPLACES "result") (("2" (ASSERT) (("2" (TYPEPRED_RES1) (("2" (SKOLEM "cache1-form" "l1") (("2" (REPLACE "cache1-form" 2) (("2" (INST 2 "cons((re, neg_ac(ac1), null)::CacheData, l1)") (("1" (HIDE-ALL-BUT 2) (("1" (EXPAND "append" 1 2) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (EXPAND "ordered_list?") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED_RES1) (("3" (SKOLEM "N1" "N1") (("3" (INST 2 "N1") (("3" (WITH-LABELS (FLATTEN "N1") (("N1 vars in box" "N1 comp on pairs"))) (("3" (ASSERT) (("3" (EXPAND "compatible_pairs_on?") (("3" (SKEEP* 2) (("3" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 2) (("1" (REPLACE "result") (("1" (ASSERT) (("1" (EXPAND "powvar?") (("1" (EXPAND "eval_ACExpr_Env" 2) (("1" (EXPAND "eval" 2) (("1" (REPLACES "re") (("1" (ASSERT) (("1" (USE "containment_neg") (("1" (ASSERT) (("1" (HIDE 3) (("1" (INST "N1 comp on pairs" "0") (("1" (INST "N1 comp on pairs" "n") (("1" (WITH-LABELS (FLATTEN "N1 comp on pairs") (("eval" "powvar"))) (("1" (EXPAND "nth" "eval") (("1" (ASSERT) (("1" (EXPAND "varidx_powvar") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (INST "N1 comp on pairs" "i-1") (("1" (INST "N1 comp on pairs" "n") (("1" (REPLACES "result") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES "result") (("4" (ASSERT) (("4" (TYPEPRED_RES1) NIL NIL)) NIL)) NIL) ("5" (REPLACES "result") (("5" (ASSERT) (("5" (EXPAND "idxs_bounded") (("5" (SKEEP) (("5" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (USE "next_idx_neg_ac") (("1" (EXPAND ">=") (("1" (TYPEPRED_RES1) (("1" (EXPAND "idxs_bounded") (("1" (INST "cache1-idxs_bound" "0") (("1" (EXPAND "nth" "cache1-idxs_bound") (("1" (REPLACE "ac1" :DIR RL) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED_RES1) (("2" (EXPAND "idxs_bounded") (("2" (INST "cache1-idxs_bound" "i-1") (("1" (EXPAND "nth" 3) (("1" (PROPAX) NIL NIL)) NIL) ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|neg_ac| CONST-DECL "AffineCombination" |affine| NIL) (|minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|containment_neg| FORMULA-DECL NIL |affine| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|cache1| SKOLEM-CONST-DECL "(correct_cache?(box))" |affine_expr_Eval_fnd| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|result| SKOLEM-CONST-DECL "[nat, (cons?)]" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(result`2))" |affine_expr_Eval_fnd| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((re, neg_ac(ac1), null), cache1)))" |affine_expr_Eval_fnd| NIL) (|ac1| SKOLEM-CONST-DECL "AffineCombination" |affine_expr_Eval_fnd| NIL) (|re| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|next_idx_neg_ac| FORMULA-DECL NIL |affine| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC82-1 |nil| 3632131428 ("" (THEN (SKEEP*) (ASSERT) (HIDE -11) (APPLY (THEN (LABEL "result" -10) (LABEL "ac2" -9) (LABEL "cache2" -8) (LABEL "newid2" -7) (LABEL "res2" -6) (LABEL "ac1" -5) (LABEL "cache1" -4) (LABEL "newid1" -3) (LABEL "res1" -2) (LABEL "re" -1))) (DEFTACTIC TYPEPRED_RES2 NIL (WITH-LABELS (THEN (TYPEPRED "res2") (REPLACE "cache2" -1 :DIR RL) (REPLACE "newid2" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (DEFTACTIC TYPEPRED_RES1 NIL (WITH-LABELS (THEN (TYPEPRED "res1") (REPLACE "cache1" -1 :DIR RL) (REPLACE "newid1" -1 :DIR RL) (ASSERT) (FLATTEN)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (SPREAD (SPLIT 3) ((GRIND) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES1) (TYPEPRED_RES2) (SKOLEM "cache2-form" "l2") (SKOLEM "cache1-form" "l1") (REPLACE "cache1-form" "cache2-form") (REPLACE "cache2-form" 3) (SPREAD (INST 3 "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") ((THEN (HIDE-ALL-BUT 3) (EXPAND "append" 1 3) (USE "append_assoc[CacheData]") (ASSERT)) (GRIND)))) (THEN (TYPEPRED_RES2) (SKOLEM "N2" "N2") (WITH-LABELS (FLATTEN) (("N2 vars in box comp" "N2 compatible pairs"))) (INST 2 "N2") (ASSERT) (EXPAND "compatible_pairs_on?") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 2) (REPLACE "result") (ASSERT) (EXPAND "eval_ACExpr_Env" 2) (REPLACES "re") (ASSERT) (USE "containment_sub") (ASSERT) (HIDE 3) (SPREAD (SPLIT 1) ((THEN (TYPEPRED_RES1) (REPLACES "re1" :DIR RL) (SKOLEM "N1" "N1") (WITH-LABELS (FLATTEN) (("N1 vars in box comp" "N1 compatible pairs"))) (SPREAD (CASE "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                          eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                           eval_ac_noise(nth(cache1, i)`2, N1)") ((THEN (REPLACE "ac1") (SPREAD (INST -1 "0") ((THEN (EXPAND "nth" -1) (REPLACES -1) (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SPREAD (INST "N1 compatible pairs" "0") ((THEN (EXPAND "nth" "N1 compatible pairs") (FLATTEN)) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "length") (ASSERT))))) (THEN (EXPAND "compatible_pairs_on?" "N1 compatible pairs") (SKEEP) (INST "N1 compatible pairs" "i!1") (SKOLEM "cache2-form" "l2") (REPLACE "cache2-form" "N2 compatible pairs") (SPREAD (INST "N2 compatible pairs" "length(l2)+i!1") ((SPREAD (CASE "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((THEN (FLATTEN) (REPLACES -1) (ASSERT)) (THEN (HIDE-ALL-BUT 1) (SPREAD (USE "nth_append[CacheData]") ((ASSERT) (THEN (USE "length_append[CacheData]") (REPLACES -1) (TYPEPRED "i!1") (ASSERT))))))) (THEN (REPLACE "cache2-form" 1) (USE "length_append[CacheData]") (REPLACES -1) (ASSERT)))))))) (SPREAD (INST "N2 compatible pairs" "0") ((THEN (EXPAND "nth" "N2 compatible pairs") (ASSERT)) (THEN (EXPAND "length") (ASSERT))))))) (THEN (NAME "j" "i-1") (TYPEPRED "i") (EXPAND "length") (EXPAND "nth" 3) (ASSERT) (REPLACE -2) (REPLACE "result") (ASSERT) (INST "N2 compatible pairs" "j"))))) (THEN (REPLACES "result") (ASSERT) (TYPEPRED_RES2) (TYPEPRED_RES1)) (THEN (REPLACES "result") (ASSERT) (EXPAND "idxs_bounded") (SKEEP) (SPREAD (CASE "i=0") ((THEN (REPLACES -1) (EXPAND "nth" 1) (USE "next_idx_sub_ac_ac") (EXPAND ">=") (TYPEPRED_RES2) (TYPEPRED_RES1) (EXPAND "idxs_bounded") (SPREAD (INST "cache1-idxs_bound" "0") ((THEN (EXPAND "nth" "cache1-idxs_bound") (REPLACE "ac1" :DIR RL) (SPREAD (INST "cache2-idxs_bound" "0") ((THEN (EXPAND "nth" "cache2-idxs_bound") (REPLACE "ac2" :DIR RL) (HIDE-ALL-BUT (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (EXPAND "max") (LIFT-IF -4) (SPREAD (SPLIT -4) ((THEN (FLATTEN) (EXPAND ">=") (ASSERT)) (THEN (FLATTEN) (ASSERT))))) (GRIND)))) (GRIND)))) (THEN (TYPEPRED_RES2) (EXPAND "idxs_bounded") (SPREAD (INST "cache2-idxs_bound" "i-1") ((THEN (EXPAND "nth" 3) (PROPAX)) (THEN (TYPEPRED "i") (GRIND))))))))))) NIL NIL) NIL NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC92 0 (RE2AC_TCC92-1 |nil| 3789916158 ("" (SUBTYPE-TCC) NIL NIL) ((|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (RE2AC SUBTYPE "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (|iacniig_RE2AC_preservation_TCC1| 0 (|iacniig_RE2AC_preservation_TCC1-1| |nil| 3638728665 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (|iacniig_RE2AC_preservation| SUBTYPE "affine_expr_Eval_fnd.nextfreeidx" "nat"))) (|iacniig_RE2AC_preservation_TCC2| 0 (|iacniig_RE2AC_preservation_TCC2-1| |nil| 3639415198 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|iacniig_RE2AC_preservation| SUBTYPE "affine_expr_Eval_fnd.nextfreeidx" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (|iacniig_RE2AC_preservation| 0 (|iacniig_RE2AC_preservation-1| |nil| 3638722505 ("" (SKOLEM 1 ("box" "vs" "_")) (("" (INDUCT "re") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "re!1") (("2" (ASSERT) NIL NIL)) NIL) ("3" (SKEEP*) (("3" (HIDE -1) (("3" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("3" (EXPAND "RE2AC") (("3" (SKEEP :PREDS? T) (("3" (EXPAND "RE2AC") (("3" (CASE "i = 0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 1) (("1" (EXPAND "idxs_ac") (("1" (EXPAND "idxs_pd") (("1" (EXPAND "const_ac") (("1" (EXPAND_OL) (("1" (ASSERT) (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "i-1") (("1" (EXPAND "nth" 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (HIDE -1) (("4" (EXPAND "RE2AC") (("4" (LIFT-IF -2) (("4" (ASSERT) (("4" (SPLIT -2) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 1) (("1" (EXPAND "nth" 1) (("1" (SKEEP) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (TYPEPRED "cache_get(cache)(VARIDX(VARIDX1_var))") (("1" (ASSERT) (("1" (SKOLEM -1 "cidx") (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL :HIDE? T) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -4) (("1" (INST -4 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (SKEEP) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 3) (("1" (EXPAND "nth_ac") (("1" (EXPAND "var_ac") (("1" (EXPAND "idxs_ac") (("1" (EXPAND "idxs_pd") (("1" (ASSERT) (("1" (EXPAND_OL) (("1" (ASSERT) (("1" (SKEEP) (("1" (LIFT-IF -2) (("1" (EXPAND "member") (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (EXPAND "idxs_pd") (("1" (EXPAND "null_ol?") (("1" (EXPAND "member") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 4) (("2" (ASSERT) (("2" (INST -1 "i-1") (("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (HIDE -3) (("5" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (EXPAND "RE2AC" -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (ASSERT) (("2" (INST -1 "first_added_idx" "val
                                                      (RE2AC
                                                       (ADD1_var,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1" "val
                                                      (RE2AC
                                                       (ADD1_var,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2") (("1" (INST -2 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 3) (("1" (SKEEP) (("1" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 3) (("1" (SKEEP) (("1" (USE "idxs_ac_add_ac_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -3) (("1" (INST -3 "0") (("1" (INST -3 "j") (("1" (EXPAND "nth" -3) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -2) (("2" (INST -2 "0") (("1" (EXPAND "nth" -2) (("1" (INST -2 "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(ADD2_var, box, vs,
                                         val[[nat, (correct_cache?(box))]]
                                             (RE2AC(ADD1_var, box, vs, nextfreeidx,
                                                    cache))`1,
                                         val[[nat, (correct_cache?(box))]]
                                             (RE2AC(ADD1_var, box, vs, nextfreeidx,
                                                    cache))`2)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 4) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -1) (("2" (INST -1 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "nextfreeidx") (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "ADD2_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "ADD1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("6" (EXPAND "RE2AC") (("6" (PROPAX) NIL NIL)) NIL) ("7" (SKEEP) (("7" (HIDE -2) (("7" (SPLIT -1) (("1" (SKEEP*) (("1" (EXPAND "RE2AC" -3) (("1" (LIFT-IF -3) (("1" (SPLIT -3) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (EXPAND "RE2AC" 2) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" 2) (("2" (SKOLEM 2 "i") (("2" (CASE "i=0") (("1" (HIDE -2) (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (LEMMA "idxs_ac_neg_ac") (("1" (INST -1 "car(val(RE2AC
                                    (NEG1_var,
                                     box,
                                     vs,
                                     nextfreeidx,
                                     cache))`2)`2" "j") (("1" (ASSERT) (("1" (REVEAL -2) (("1" (INST -1 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -1) (("1" (INST -1 "0") (("1" (INST -1 "j") (("1" (ASSERT) (("1" (EXPAND "nth") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(NEG1_var, box, vs, nextfreeidx, cache)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (INST -1 "first_added_idx" "nextfreeidx" "cache") (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (INST -1 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "NEG1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (HIDE -3) (("8" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (EXPAND "RE2AC" -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (ASSERT) (("2" (INST -1 "first_added_idx" "val
                                                                  (RE2AC
                                                                   (SUB1_var,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`1" "val
                                                                  (RE2AC
                                                                   (SUB1_var,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`2") (("1" (INST -2 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 3) (("1" (SKEEP) (("1" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "nth" 3) (("1" (SKEEP) (("1" (USE "idxs_ac_sub_ac_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -3) (("1" (INST -3 "0") (("1" (INST -3 "j") (("1" (EXPAND "nth" -3) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(SUB1_var, box, vs, nextfreeidx, cache)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -2) (("2" (INST -2 "0") (("1" (EXPAND "nth" -2) (("1" (INST -2 "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(SUB2_var, box, vs,
                                                               val[[nat, (correct_cache?(box))]]
                                                                   (RE2AC(SUB1_var, box, vs, nextfreeidx,
                                                                          cache))`1,
                                                               val[[nat, (correct_cache?(box))]]
                                                                   (RE2AC(SUB1_var, box, vs, nextfreeidx,
                                                                          cache))`2)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 4) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -1) (("2" (INST -1 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "nextfreeidx") (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "RE2AC(SUB1_var, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "SUB2_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "SUB1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP*) (("9" (HIDE -3) (("9" (SPLIT -1) (("1" (SPLIT -2) (("1" (EXPAND "RE2AC" -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (EXPAND "RE2AC" 1) (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 1) (("1" (EXPAND "nth" 1) (("1" (SKEEP) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (TYPEPRED "cache_get(cache)(MULT(MULT1_var, MULT2_var))") (("1" (ASSERT) (("1" (SKOLEM -1 "cidx") (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL :HIDE? T) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -6) (("1" (INST -6 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -4) (("2" (INST -4 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 4) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" 4) (("2" (SKOLEM 4 "i") (("2" (CASE "i=0") (("1" (EXPAND "nth" 4) (("1" (ASSERT) (("1" (SKOLEM 4 "j") (("1" (FLATTEN) (("1" (USE "idxs_ac_mult_ac_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (HIDE -6) (("1" (INST -4 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -4) (("1" (INST -4 "0") (("1" (INST -4 "j") (("1" (EXPAND "nth" -4) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -6) (("2" (INST -3 "first_added_idx" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`1" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`2") (("1" (ASSERT) (("1" (INST -4 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -3) (("1" (INST -3 "0") (("1" (INST -3 "j") (("1" (ASSERT) (("1" (EXPAND "nth") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(MULT2_var, box, vs,
                                           val[[nat, (correct_cache?(box))]]
                                               (RE2AC(MULT1_var, box, vs, nextfreeidx,
                                                      cache))`1,
                                           val[[nat, (correct_cache?(box))]]
                                               (RE2AC(MULT1_var, box, vs, nextfreeidx,
                                                      cache))`2)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "RE2AC(MULT2_var, box, vs,
                                   val(RE2AC(MULT1_var, box, vs, nextfreeidx, cache))`1,
                                   val(RE2AC(MULT1_var, box, vs, nextfreeidx, cache))`2)") (("3" (ASSERT) (("3" (FLATTEN) (("3" (TYPEPRED "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 5) (("2" (ASSERT) (("2" (SKOLEM 5 "j") (("2" (INST -1 "first_added_idx" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`1" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`2") (("1" (ASSERT) (("1" (INST -2 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -1) (("1" (INST -1 "i-1") (("1" (INST -1 "j") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (TYPEPRED "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (GROUND) NIL NIL)) NIL) ("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "MULT2_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "MULT1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (EXPAND "RE2AC") (("10" (PROPAX) NIL NIL)) NIL) ("11" (SKEEP*) (("11" (SPLIT -1) (("1" (HIDE -2) (("1" (EXPAND "RE2AC" -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 2) (("2" (ASSERT) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 1) (("1" (SKOLEM 1 "i") (("1" (CASE "i=0") (("1" (EXPAND "nth" 1) (("1" (ASSERT) (("1" (EXPAND "null_ol") (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "idxs_ac_pow_var_ac") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -4) (("2" (INST -4 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 1) (("1" (SKOLEM 1 "i") (("1" (CASE "i=0") (("1" (EXPAND "nth" 1) (("1" (ASSERT) (("1" (TYPEPRED "cache_get_powvar(cache)
                                           (POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 2) (("1" (SKOLEM 2 "i") (("1" (CASE "i=0") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (USE "idxs_ac_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (TYPEPRED "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("2" (ASSERT) (("2" (FLATTEN) (("2" (SKOLEM -3 "cidx") (("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -10) (("2" (INST -10 "cidx") (("2" (INST -10 "j") (("2" (ASSERT) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (REPLACE -3 :HIDE? T) (("2" (SPLIT -2) (("1" (FLATTEN) (("1" (LEMMA "idxs_ac_pow_var_ac_2") (("1" (INST? -1 :WHERE 8) (("1" (ASSERT) (("1" (REPLACE -5 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (LEMMA "member_take_1[nat]") (("1" (INST -1 "nth(cache, cidx)`3" "POW2_var - 1" "opn(nth(cache, cidx)`1) - 1" "j") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -4) (("2" (EXPAND "varidx_powvar" -1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap" 1) (("1" (SKEEP) (("1" (CASE "i=0") (("1" (EXPAND "nth" 1) (("1" (ASSERT) (("1" (SKOLEM 1 "j") (("1" (FLATTEN) (("1" (USE "idxs_ac_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (HIDE -7) (("2" (TYPEPRED "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("2" (ASSERT) (("2" (FLATTEN) (("2" (SKOLEM -3 "cidx") (("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -9) (("2" (INST -9 "cidx") (("2" (INST -9 "j") (("2" (ASSERT) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (REPLACE -3 :HIDE? T) (("2" (CASE "member(j, take[nat]
                             (nth(cache, cidx)`3,
                              opn(nth(cache, cidx)`1) - 1)) OR
             member(j, nats(nextfreeidx,
                              POW2_var - 1 - opn(nth(cache, cidx)`1) +
                               nextfreeidx))") (("1" (SPLIT -1) (("1" (LEMMA "idxs_ac_pow_var_ac_2") (("1" (INST? -1 :WHERE 10) (("1" (ASSERT) (("1" (REPLACE -5 1) (("1" (EXPAND "varidx_powvar" 1) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "member_nats") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (-1 -6 1 2)) (("1" (CASE "length(append(take[nat]
                             (nth(cache, cidx)`3,
                              opn(nth(cache, cidx)`1) - 1),
                         nats(nextfreeidx,
                              POW2_var - 1 - opn(nth(cache, cidx)`1) +
                               nextfreeidx))) = 
                  POW2_var - 1") (("1" (NAME-REPLACE "app" "append(take[nat]
                             (nth(cache, cidx)`3,
                              opn(nth(cache, cidx)`1) - 1),
                         nats(nextfreeidx,
                              POW2_var - 1 - opn(nth(cache, cidx)`1) +
                               nextfreeidx))") (("1" (REPLACE -1 -3 :DIR RL :HIDE? T) (("1" (USE "take_prop_2[nat]") (("1" (REPLACE -1 -3 :HIDE? T) (("1" (EXPAND "app") (("1" (USE "member_append_fi[nat]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[nat]") (("2" (REPLACE -1 :HIDE? T) (("2" (TYPEPRED "nats(nextfreeidx,
                 POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("2" (REPLACE -4 :HIDE? T) (("2" (USE "length_take[nat]") (("2" (REPLACE -1 :HIDE? T) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" 2) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (USE "idxs_ac_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (HIDE -6) (("2" (USE "take_nats") (("2" (REPLACE -1 -2 :HIDE? T) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -4) (("2" (INST -4 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" 2) (("2" (SKEEP) (("2" (CASE "i=0") (("1" (EXPAND "nth" 2) (("1" (ASSERT) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (USE "idxs_ac_pow_var_ac") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (HIDE -5) (("2" (USE "take_nats") (("2" (REPLACE -1 -2 :HIDE? T) (("2" (USE "member_nats") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 3) (("2" (ASSERT) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "POW1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("12" (EXPAND "RE2AC") (("12" (PROPAX) NIL NIL)) NIL) ("13" (EXPAND "RE2AC") (("13" (PROPAX) NIL NIL)) NIL) ("14" (EXPAND "RE2AC") (("14" (PROPAX) NIL NIL)) NIL) ("15" (EXPAND "RE2AC") (("15" (PROPAX) NIL NIL)) NIL) ("16" (ASSERT) NIL NIL) ("17" (ASSERT) NIL NIL) ("18" (ASSERT) NIL NIL) ("19" (ASSERT) NIL NIL) ("20" (ASSERT) NIL NIL) ("21" (ASSERT) NIL NIL) ("22" (ASSERT) NIL NIL) ("23" (ASSERT) NIL NIL) ("24" (SKEEP* :PREDS? T) (("24" (ASSERT) NIL NIL)) NIL) ("25" (EXPAND "RE2AC") (("25" (PROPAX) NIL NIL)) NIL) ("26" (SKEEP* :PREDS? T) (("26" (ASSERT) NIL NIL)) NIL) ("27" (SKEEP* :PREDS? T) (("27" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_ac_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (RE2AC DEF-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|IntervalExpr_induction| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|i| SKOLEM-CONST-DECL "below(length(val(RE2AC(CONST(CONST1_var, CONST2_var), box, vs, nextfreeidx,
                       cache))`2))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|CONST2_var| SKOLEM-CONST-DECL "(Includes?(CONST1_var(unit)))" |affine_expr_Eval_fnd| NIL) (|CONST1_var| SKOLEM-CONST-DECL "[Unit -> real]" |affine_expr_Eval_fnd| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|const_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|member| DEF-DECL "bool" |list_props| NIL) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cdr_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|idxs_pd| DEF-DECL "list[nat]" |affine| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|Unit| TYPE-DECL NIL |Unit_adt| |structures|) (|Includes?| CONST-DECL "bool" |interval| |interval_arith|) (|unit?| ADT-RECOGNIZER-DECL "[Unit -> boolean]" |Unit_adt| |structures|) (|unit| ADT-CONSTRUCTOR-DECL "(unit?)" |Unit_adt| |structures|) (CONST ADT-CONSTRUCTOR-DECL "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" |IntervalExpr_adt| |interval_arith|) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|None| ADT-CONSTRUCTOR-DECL "(none?)" |Maybe| |structures|) (|none?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (VARIDX ADT-CONSTRUCTOR-DECL "[nat -> (varidx?)]" |IntervalExpr_adt| |interval_arith|) (|cache_get| DEF-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|VARIDX1_var| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(IF some?(cache_get(cache)(VARIDX(VARIDX1_var)))
        THEN length(cons((VARIDX(VARIDX1_var),
                          val(cache_get(cache)(VARIDX(VARIDX1_var))),
                          null),
                         cache))
      ELSE IF VARIDX1_var >= length(box) THEN length(val(None)`2)
           ELSE length(cons((VARIDX(VARIDX1_var), nth_ac(box, VARIDX1_var),
                             null),
                            cache))
           ENDIF
      ENDIF)" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((VARIDX(VARIDX1_var), nth_ac(box, VARIDX1_var), null),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|ADD1_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|add_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (ADD ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (add?)]" |IntervalExpr_adt| |interval_arith|) (|idxs_ac_add_ac_ac| FORMULA-DECL NIL |affine| NIL) (|ADD2_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((ADD(ADD1_var, ADD2_var),
                   add_ac_ac(car(val(RE2AC(ADD1_var, box, vs, nextfreeidx,
                                           cache))`2)`2,
                             car(val(RE2AC(ADD2_var, box, vs,
                                           val(RE2AC(ADD1_var, box, vs,
                                                     nextfreeidx,
                                                     cache))`1,
                                           val(RE2AC(ADD1_var, box, vs,
                                                     nextfreeidx,
                                                     cache))`2))`2)`2),
                   null),
                  val(RE2AC(ADD2_var, box, vs,
                            val(RE2AC(ADD1_var, box, vs, nextfreeidx,
                                      cache))`1,
                            val(RE2AC(ADD1_var, box, vs, nextfreeidx,
                                      cache))`2))`2)))" |affine_expr_Eval_fnd| NIL) (|add_pd_pd| CONST-DECL "ErrorTerms" |affine| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((NEG(NEG1_var),
                   neg_ac(car(val(RE2AC(NEG1_var, box, vs, nextfreeidx,
                                        cache))`2)`2),
                   null),
                  val(RE2AC(NEG1_var, box, vs, nextfreeidx, cache))`2)))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|NEG1_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|idxs_ac_neg_ac| FORMULA-DECL NIL |affine| NIL) (NEG ADT-CONSTRUCTOR-DECL "[RealExpr -> (neg?)]" |IntervalExpr_adt| |interval_arith|) (|neg_ac| CONST-DECL "AffineCombination" |affine| NIL) (|SUB1_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|sub_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (SUB ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (sub?)]" |IntervalExpr_adt| |interval_arith|) (|idxs_ac_sub_ac_ac| FORMULA-DECL NIL |affine| NIL) (|SUB2_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((SUB(SUB1_var, SUB2_var),
                   sub_ac_ac(car(val(RE2AC(SUB1_var, box, vs, nextfreeidx,
                                           cache))`2)`2,
                             car(val(RE2AC(SUB2_var, box, vs,
                                           val(RE2AC(SUB1_var, box, vs,
                                                     nextfreeidx,
                                                     cache))`1,
                                           val(RE2AC(SUB1_var, box, vs,
                                                     nextfreeidx,
                                                     cache))`2))`2)`2),
                   null),
                  val(RE2AC(SUB2_var, box, vs,
                            val(RE2AC(SUB1_var, box, vs, nextfreeidx,
                                      cache))`1,
                            val(RE2AC(SUB1_var, box, vs, nextfreeidx,
                                      cache))`2))`2)))" |affine_expr_Eval_fnd| NIL) (|sub_pd_pd| CONST-DECL "ErrorTerms" |affine| NIL) (MULT ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (mult?)]" |IntervalExpr_adt| |interval_arith|) (|MULT1_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|MULT2_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((MULT(MULT1_var, MULT2_var),
                   val(cache_get(cache)(MULT(MULT1_var, MULT2_var))),
                   null),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|idxs_ac_mult_ac_ac| FORMULA-DECL NIL |affine| NIL) (|add_ET| CONST-DECL "ErrorTerms" |affine| NIL) (|append_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|next_idx_2| CONST-DECL "nat" |affine| NIL) (|mult_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              nats(nextfreeidx,
                                   POW2_var - 2 + nextfreeidx)),
                   nats(nextfreeidx, POW2_var - 2 + nextfreeidx)),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              nats(nextfreeidx,
                                   POW2_var - 1 -
                                    opn(val(cache_get_powvar(cache)
                                                            (POW(POW1_var,
                                                                 POW2_var)))`1)
                                    + nextfreeidx)),
                   nats(nextfreeidx,
                        POW2_var - 1 -
                         opn(val(cache_get_powvar(cache)
                                                 (POW(POW1_var,
                                                      POW2_var)))`1)
                         + nextfreeidx)),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|take_nats| FORMULA-DECL NIL |affine_pow| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              append(take[nat]
                                         (val(cache_get_powvar(cache)
                                                              (POW(POW1_var,
                                                                   POW2_var)))`3,
                                          opn(val(cache_get_powvar(cache)
                                                                  (POW(POW1_var,
                                                                       POW2_var)))`1)
                                           - 1),
                                     nats(nextfreeidx,
                                          POW2_var - 1 -
                                           opn(val(cache_get_powvar(cache)
                                                                   (POW(POW1_var,
                                                                        POW2_var)))`1)
                                           + nextfreeidx))),
                   append(take[nat]
                              (val(cache_get_powvar(cache)
                                                   (POW(POW1_var,
                                                        POW2_var)))`3,
                               opn(val(cache_get_powvar(cache)
                                                       (POW(POW1_var,
                                                            POW2_var)))`1)
                                - 1),
                          nats(nextfreeidx,
                               POW2_var - 1 -
                                opn(val(cache_get_powvar(cache)
                                                        (POW(POW1_var,
                                                             POW2_var)))`1)
                                + nextfreeidx))),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|factorial| DEF-DECL "posnat" |factorial| |ints|) (C CONST-DECL "posnat" |binomial| |reals|) (|pow_var_pd| DEF-DECL "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" |affine_pow| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|member_nats| FORMULA-DECL NIL |affine_pow| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|length_take| FORMULA-DECL NIL |more_list_props| |structures|) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|cidx| SKOLEM-CONST-DECL "below(length(cache))" |affine_expr_Eval_fnd| NIL) (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|take_prop_2| FORMULA-DECL NIL |more_list_props| |structures|) (|app| SKOLEM-CONST-DECL "list[nat]" |affine_expr_Eval_fnd| NIL) (|member_append_fi| FORMULA-DECL NIL |more_list_props| |structures|) (|take| DEF-DECL "list[T]" |more_list_props| |structures|) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              val(cache_get_powvar(cache)
                                                  (POW(POW1_var,
                                                       POW2_var)))`3),
                   val(cache_get_powvar(cache)
                                       (POW(POW1_var, POW2_var)))`3),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|member_take_1| FORMULA-DECL NIL |more_list_props| |structures|) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|idxs_ac_pow_var_ac_2| FORMULA-DECL NIL |affine_pow| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   val(cache_get_powvar(cache)(POW(POW1_var, POW2_var)))`2,
                   val(cache_get_powvar(cache)
                                       (POW(POW1_var, POW2_var)))`3),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|cache_get_powvar| DEF-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|POW1_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|POW2_var| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              null_ol
                                  [nat,
                                   restrict[[real, real], [nat, nat], bool]
                                       (<)]),
                   null),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|idxs_ac_pow_var_ac| FORMULA-DECL NIL |affine_pow| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL)) SHOSTAK)) (|iacniig_box_growing_preservation_TCC1| 0 (|iacniig_box_growing_preservation_TCC1-1| |nil| 3638720158 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (>= CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL)) NIL (|iacniig_box_growing_preservation| SUBTYPE "affine_expr_Eval_fnd.first_added_idx" "upfrom((number_fields.+)(1, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box)))"))) (|iacniig_box_growing_preservation_TCC2| 0 (|iacniig_box_growing_preservation_TCC2-1| |nil| 3638720158 ("" (SKEEP :PREDS? T) (("" (EXPAND "last_idx_in_box") (("" (USE "length_append[Interval]") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|iacniig_box_growing_preservation| SUBTYPE "affine_expr_Eval_fnd.first_added_idx" "upfrom((number_fields.+)(1, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)))))"))) (|iacniig_box_growing_preservation| 0 (|iacniig_box_growing_preservation-1| |nil| 3638721845 ("" (SKEEP*) (("" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("" (SKEEP) (("" (INST?) (("" (SKEEP) (("" (INST?) (("" (ASSERT) (("" (USE "length_append[Interval]") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|idxs_ac_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|nicniig_RE2AC_preservation| 0 (|nicniig_RE2AC_preservation-2| "" 3883675177 ("" (INDUCT "re") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "re!1") (("2" (ASSERT) NIL NIL)) NIL) ("3" (SKEEP*) (("3" (EXPAND "RE2AC") (("3" (HIDE -1 -3) (("3" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("3" (SKEEP :PREDS? T) (("3" (EXPAND "length" -1) (("3" (CASE "i=0") (("1" (EXPAND "nth" 1) (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2 1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (HIDE -1) (("4" (EXPAND "RE2AC") (("4" (LIFT-IF -2) (("4" (ASSERT) (("4" (SPLIT -2) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (CASE "i=0") (("1" (EXPAND "nth" 3 1) (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 4 1) (("2" (ASSERT) (("2" (EXPAND "nth" 4 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKOLEM 1 ("re1" "re2")) (("5" (FLATTEN) (("5" (HIDE -3) (("5" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (INST -1 "box" "vs") (("1" (INST -2 "box" "vs") (("1" (EXPAND "RE2AC" -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 4 3) (("2" (INST -2 "first_added_idx" "val(RE2AC(re1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`1" "val(RE2AC(re1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`2") (("1" (INST -3 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("1" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (EXPAND RE2AC) (("6" (PROPAX) NIL NIL)) NIL) ("7" (SKOLEM 1 "op") (("7" (FLATTEN) (("7" (SPLIT -1) (("1" (HIDE -2) (("1" (SKEEP*) (("1" (INST -1 "box" "vs") (("1" (INST -1 "first_added_idx" "nextfreeidx" "cache") (("1" (EXPAND "RE2AC" -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 2) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKOLEM 1 ("re1" "re2")) (("8" (FLATTEN) (("8" (HIDE -3) (("8" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (INST -1 "box" "vs") (("1" (INST -2 "box" "vs") (("1" (EXPAND "RE2AC" -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 4 3) (("2" (INST -2 "first_added_idx" "val(RE2AC(re1,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`1" "val(RE2AC(re1,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`2") (("1" (INST -3 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("1" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKOLEM 1 ("re1" "re2")) (("9" (FLATTEN) (("9" (SPLIT -1) (("1" (SPLIT -2) (("1" (HIDE -3) (("1" (SKEEP*) (("1" (EXPAND "RE2AC" -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (EXPAND "RE2AC" 1) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 4) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 4) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 4 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 5 3) (("2" (INST -2 "box" "vs" "first_added_idx" "val(RE2AC(re1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1" "val(RE2AC(re1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2") (("1" (INST -3 "box" "vs" "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("1" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP*) (("10" (EXPAND "RE2AC") (("10" (PROPAX) NIL NIL)) NIL)) NIL) ("11" (SKEEP*) (("11" (HIDE -2) (("11" (SPLIT -1) (("1" (INST -1 "box" "vs") (("1" (EXPAND "RE2AC" -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (EXPAND "RE2AC" 1) (("1" (ASSERT) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT -3) (("1" (PROPAX) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKOLEM 1 "i") (("1" (CASE "i=0") (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2 1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (HIDE -3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (CASE "i=0") (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (EXPAND "nth" 1 2) (("1" (HIDE -6) (("1" (TYPEPRED "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2 1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (HIDE -5) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (CASE "i=0") (("1" (EXPAND "nth" 2 1) (("1" (ASSERT) (("1" (EXPAND "nth" 2 2) (("1" (ASSERT) (("1" (HIDE -6) (("1" (TYPEPRED "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 3 1) (("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (HIDE -5) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "nth" 1 2) (("1" (TYPEPRED "cache_get_powvar
                                                            (cache)(POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (HIDE -8) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") (("1" (SKEEP 1) (("1" (CASE "j<length(take[nat]
                                                  (nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1))") (("1" (CASE "nth(append(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1),
                 nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)),
          j)
       = nth(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1), j)") (("1" (REPLACE -1 :HIDE? T) (("1" (INST -10 "j") (("1" (SPLIT -10) (("1" (USE "nth_take2[nat]") (("1" (ASSERT) NIL NIL) ("2" (USE "length_take[nat]") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL) ("3" (PROPAX) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)) NIL) ("2" (CASE "nth(append(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1),
                 nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)),
          j)
       =
       nth(nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx),
           j - length(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1)))") (("1" (REPLACE -1 :HIDE? T) (("1" (TYPEPRED "nats(nextfreeidx,
                                           POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("1" (INST? -5 :WHERE 3) (("1" (REPLACE -5 :HIDE? T) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (ASSERT) (("1" (USE "length_append[nat]") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL) ("3" (ASSERT) (("3" (USE "length_append[nat]") (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (HIDE -5) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "nth" 2 2) (("1" (HIDE -5) (("1" (TYPEPRED "cache_get_powvar(cache)
                                                                      (POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (TYPEPRED "nats(nextfreeidx,
                                       POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("1" (INST? -5 :WHERE 3) (("1" (REPLACE -5 :HIDE? T) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (HIDE -4) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -4) (("2" (INST -4 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "nth" 2 2) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (TYPEPRED "nats(nextfreeidx, POW2_var - 2 + nextfreeidx)") (("1" (INST? -5 :WHERE 3) (("1" (REPLACE -5 :HIDE? T) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (HIDE -3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "POW1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP*) (("12" (EXPAND "RE2AC") (("12" (PROPAX) NIL NIL)) NIL)) NIL) ("13" (SKEEP*) (("13" (HIDE-ALL-BUT -4) (("13" (EXPAND "RE2AC") (("13" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("14" (SKEEP*) (("14" (HIDE-ALL-BUT -5) (("14" (EXPAND "RE2AC") (("14" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("15" (SKEEP*) (("15" (HIDE-ALL-BUT -5) (("15" (EXPAND "RE2AC") (("15" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("16" (ASSERT) NIL NIL) ("17" (ASSERT) NIL NIL) ("18" (ASSERT) NIL NIL) ("19" (ASSERT) NIL NIL) ("20" (ASSERT) NIL NIL) ("21" (ASSERT) NIL NIL) ("22" (ASSERT) NIL NIL) ("23" (ASSERT) NIL NIL) ("24" (GRIND) NIL NIL) ("25" (GRIND) NIL NIL) ("26" (HIDE 2) (("26" (SKEEP* :PREDS? T) (("26" (EXPAND "last_idx_in_box") (("26" (TYPEPRED "length(box)") (("26" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("27" (HIDE 2) (("27" (SKEEP* :PREDS? T) (("27" (EXPAND "last_idx_in_box") (("27" (TYPEPRED "length(box)") (("27" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|nicniig_RE2AC_preservation-1| |nil| 3638809473 ("" (INDUCT "re") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "re!1") (("2" (ASSERT) NIL NIL)) NIL) ("3" (SKEEP*) (("3" (EXPAND "RE2AC") (("3" (HIDE -1 -3) (("3" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("3" (SKEEP :PREDS? T) (("3" (EXPAND "length" -1) (("3" (CASE "i=0") (("1" (EXPAND "nth" 1) (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2 1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (HIDE -1) (("4" (EXPAND RE2AC) (("4" (LIFT-IF -2) (("4" (ASSERT) (("4" (SPLIT -2) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (CASE "i=0") (("1" (EXPAND "nth" 3 1) (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 4 1) (("2" (ASSERT) (("2" (EXPAND "nth" 4 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKOLEM 1 ("re1" "re2")) (("5" (FLATTEN) (("5" (HIDE -3) (("5" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (INST -1 "box" "vs") (("1" (INST -2 "box" "vs") (("1" (EXPAND RE2AC -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 3) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 4 3) (("2" (INST -2 "first_added_idx" "val(RE2AC(re1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`1" "val(RE2AC(re1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`2") (("1" (INST -3 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("1" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (EXPAND RE2AC) (("6" (PROPAX) NIL NIL)) NIL) ("7" (SKOLEM 1 "op") (("7" (FLATTEN) (("7" (SPLIT -1) (("1" (HIDE -2) (("1" (SKEEP*) (("1" (INST -1 "box" "vs") (("1" (INST -1 "first_added_idx" "nextfreeidx" "cache") (("1" (EXPAND RE2AC -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 2) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKOLEM 1 ("re1" "re2")) (("8" (FLATTEN) (("8" (HIDE -3) (("8" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (INST -1 "box" "vs") (("1" (INST -2 "box" "vs") (("1" (EXPAND RE2AC -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 3) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 4 3) (("2" (INST -2 "first_added_idx" "val(RE2AC(re1,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`1" "val(RE2AC(re1,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`2") (("1" (INST -3 "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("1" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKOLEM 1 ("re1" "re2")) (("9" (FLATTEN) (("9" (SPLIT -1) (("1" (SPLIT -2) (("1" (HIDE -3) (("1" (SKEEP*) (("1" (EXPAND RE2AC -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (EXPAND RE2AC 1) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 4) (("2" (ASSERT) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 4) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 4 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 5 3) (("2" (INST -2 "box" "vs" "first_added_idx" "val(RE2AC(re1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1" "val(RE2AC(re1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2") (("1" (INST -3 "box" "vs" "first_added_idx" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -2) (("1" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("4" (ASSERT) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP*) (("10" (EXPAND RE2AC) (("10" (PROPAX) NIL NIL)) NIL)) NIL) ("11" (SKEEP*) (("11" (HIDE -2) (("11" (SPLIT -1) (("1" (INST -1 "box" "vs") (("1" (EXPAND RE2AC -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (EXPAND "RE2AC" 1) (("1" (ASSERT) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT -3) (("1" (PROPAX) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKOLEM 1 "i") (("1" (CASE "i=0") (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2 1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (HIDE -3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (CASE "i=0") (("1" (EXPAND "nth" 1 1) (("1" (ASSERT) (("1" (EXPAND "nth" 1 2) (("1" (HIDE -6) (("1" (TYPEPRED "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 2 1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (HIDE -5) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (CASE "i=0") (("1" (EXPAND "nth" 2 1) (("1" (ASSERT) (("1" (EXPAND "nth" 2 2) (("1" (ASSERT) (("1" (HIDE -6) (("1" (TYPEPRED "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 3 1) (("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (HIDE -5) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "nth" 1 2) (("1" (TYPEPRED "cache_get_powvar
                                                            (cache)(POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (HIDE -8) (("1" (EXPAND "new_idxs_cache_not_in_idx_gap" -8) (("1" (INST -8 "cidx") (("1" (SKEEP 1) (("1" (CASE "j<length(take[nat]
                                                  (nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1))") (("1" (CASE "nth(append(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1),
                 nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)),
          j)
       = nth(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1), j)") (("1" (REPLACE -1 :HIDE? T) (("1" (INST -10 "j") (("1" (SPLIT -10) (("1" (USE "nth_take2[nat]") (("1" (ASSERT) NIL NIL) ("2" (USE "length_take[nat]") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL) ("2" (USE "length_take[nat]") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (ASSERT) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL) ("3" (PROPAX) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)) NIL) ("2" (CASE "nth(append(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1),
                 nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)),
          j)
       =
       nth(nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx),
           j - length(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1)))") (("1" (REPLACE -1 :HIDE? T) (("1" (TYPEPRED "nats(nextfreeidx,
                                           POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("1" (INST? -5 :WHERE 3) (("1" (REPLACE -5 :HIDE? T) (("1" (TYPEPRED "nextfreeidx") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "more_list_props[nat].nth_append") (("1" (ASSERT) (("1" (USE "length_append[nat]") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL) ("3" (ASSERT) (("3" (USE "length_append[nat]") (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 2 3) (("2" (HIDE -5) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (ASSERT) (("2" (EXPAND "nth" 2 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "nth" 2 2) (("1" (HIDE -5) (("1" (TYPEPRED "cache_get_powvar(cache)
                                                                      (POW(POW1_var, POW2_var))") (("1" (ASSERT) (("1" (FLATTEN) (("1" (SKOLEM -3 "cidx") (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (TYPEPRED "nats(nextfreeidx,
                                       POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("1" (INST? -5 :WHERE 3) (("1" (REPLACE -5 :HIDE? T) (("1" (TYPEPRED NEXTFREEIDX) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (HIDE -4) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -4) (("2" (INST -4 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "nth" 2 2) (("1" (SKOLEM 2 "j") (("1" (FLATTEN) (("1" (TYPEPRED "nats(nextfreeidx, POW2_var - 2 + nextfreeidx)") (("1" (INST? -5 :WHERE 3) (("1" (REPLACE -5 :HIDE? T) (("1" (TYPEPRED "nextfreeidx") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth" 3 3) (("2" (HIDE -3) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap" -3) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "POW1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP*) (("12" (EXPAND RE2AC) (("12" (PROPAX) NIL NIL)) NIL)) NIL) ("13" (SKEEP*) (("13" (HIDE-ALL-BUT -4) (("13" (EXPAND RE2AC) (("13" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("14" (SKEEP*) (("14" (HIDE-ALL-BUT -5) (("14" (EXPAND RE2AC) (("14" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("15" (SKEEP*) (("15" (HIDE-ALL-BUT -5) (("15" (EXPAND RE2AC) (("15" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("16" (ASSERT) NIL NIL) ("17" (ASSERT) NIL NIL) ("18" (ASSERT) NIL NIL) ("19" (ASSERT) NIL NIL) ("20" (ASSERT) NIL NIL) ("21" (ASSERT) NIL NIL) ("22" (ASSERT) NIL NIL) ("23" (ASSERT) NIL NIL) ("24" (GRIND) NIL NIL) ("25" (GRIND) NIL NIL) ("26" (HIDE 2) (("26" (SKEEP* :PREDS? T) (("26" (EXPAND "last_idx_in_box") (("26" (TYPEPRED "length(box)") (("26" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("27" (HIDE 2) (("27" (SKEEP* :PREDS? T) (("27" (EXPAND "last_idx_in_box") (("27" (TYPEPRED "length(box)") (("27" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|length_append| FORMULA-DECL NIL |list_props| NIL) (|nth_take2| FORMULA-DECL NIL |more_list_props| |structures|) (|j| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|cidx| SKOLEM-CONST-DECL "below(length(cache))" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|length_take| FORMULA-DECL NIL |more_list_props| |structures|) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|take| DEF-DECL "list[T]" |more_list_props| |structures|) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|cache_get_powvar| DEF-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|POW1_var| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|POW2_var| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              null_ol
                                  [nat,
                                   restrict[[real, real], [nat, nat], bool]
                                       (<)]),
                   null),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|represents_var?| CONST-DECL "bool" |affine| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|mult_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|next_idx_2| CONST-DECL "nat" |affine| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (MULT ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (mult?)]" |IntervalExpr_adt| |interval_arith|) (|sub_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (SUB ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (sub?)]" |IntervalExpr_adt| |interval_arith|) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (NEG ADT-CONSTRUCTOR-DECL "[RealExpr -> (neg?)]" |IntervalExpr_adt| |interval_arith|) (|neg_ac| CONST-DECL "AffineCombination" |affine| NIL) (|add_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (ADD ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (add?)]" |IntervalExpr_adt| |interval_arith|) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(first_added_idx)" |affine_expr_Eval_fnd| NIL) (|first_added_idx| SKOLEM-CONST-DECL "upfrom(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|re1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|None| ADT-CONSTRUCTOR-DECL "(none?)" |Maybe| |structures|) (|none?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (VARIDX ADT-CONSTRUCTOR-DECL "[nat -> (varidx?)]" |IntervalExpr_adt| |interval_arith|) (|cache_get| DEF-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|const_ac| CONST-DECL "AffineCombination" |affine| NIL) (CONST ADT-CONSTRUCTOR-DECL "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" |IntervalExpr_adt| |interval_arith|) (|unit| ADT-CONSTRUCTOR-DECL "(unit?)" |Unit_adt| |structures|) (|unit?| ADT-RECOGNIZER-DECL "[Unit -> boolean]" |Unit_adt| |structures|) (|Includes?| CONST-DECL "bool" |interval| |interval_arith|) (|Unit| TYPE-DECL NIL |Unit_adt| |structures|) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nth| DEF-DECL "T" |list_props| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|IntervalExpr_induction| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (RE2AC DEF-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|new_idxs_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|Maybe| TYPE-DECL NIL |Maybe| |structures|)) SHOSTAK)) (|nicniig_box_growing_preservation_TCC1| 0 (|nicniig_box_growing_preservation_TCC1-1| |nil| 3638720158 ("" (SKEEP :PREDS? T) (("" (EXPAND "last_idx_in_box") (("" (USE "length_append[Interval]") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|nicniig_box_growing_preservation| SUBTYPE "affine_expr_Eval_fnd.first_added_idx" "upfrom((number_fields.+)(1, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)))))"))) (|nicniig_box_growing_preservation| 0 (|nicniig_box_growing_preservation-1| |nil| 3638721912 ("" (SKEEP*) (("" (EXPAND "new_idxs_cache_not_in_idx_gap") (("" (PROPAX) NIL NIL)) NIL)) NIL) ((|new_idxs_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|vrcib_RE2AC_preservation| 0 (|vrcib_RE2AC_preservation-1| |nil| 3638893564 ("" (ASSERT) (("" (INDUCT "re") (("1" (TYPEPRED "re!1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (SKEEP*) (("2" (HIDE -1) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (SKOLEM 1 "i") (("2" (EXPAND "RE2AC") (("2" (EXPAND "nth" 1) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (ASSERT) (("2" (INST -1 "i-1") (("2" (TYPEPRED "i") (("2" (EXPAND "RE2AC") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP*) (("3" (HIDE -1) (("3" (EXPAND RE2AC) (("3" (LIFT-IF -2) (("3" (ASSERT) (("3" (SPLIT -2) (("1" (EXPAND "varidxs_re_cache_in_box" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (TYPEPRED "cache_get(cache)(VARIDX(VARIDX1_var))") (("1" (ASSERT) (("1" (SKEEP -1) (("1" (EXPAND "varidxs_re_cache_in_box" -6) (("1" (INST -6 "i!1") (("1" (REPLACE -1 :HIDE? T) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -3) (("2" (INST -3 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKOLEM 1 ("op1" "op2")) (("4" (FLATTEN) (("4" (HIDE -3) (("4" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (EXPAND RE2AC -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 3) (("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (INST -3 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("1" (INST -4 "box" "vs" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "varidxs_re_cache_in_box" -3) (("1" (SKEEP) (("1" (EXPAND "subterm" -6) (("1" (INST -3 "0") (("1" (EXPAND "nth" -3) (("1" (TYPEPRED "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("1" (ASSERT) (("1" (NAME-REPLACE "eval2" "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (NAME-REPLACE "eval1" "RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache)") (("1" (TYPEPRED "eval1") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" -13) (("1" (INST -13 "0") (("1" (EXPAND "nth" -13) (("1" (INST -12 "subexpr") (("1" (INST -13 "subexpr") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (INST -2 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("2" (INST -3 "box" "vs" "nextfreeidx" "cache") (("2" (ASSERT) (("2" (ASSERT) (("2" (NAME-REPLACE "eval2" "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("2" (EXPAND "varidxs_re_cache_in_box" -2) (("2" (INST -2 "i-1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "op1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP*) (("5" (EXPAND RE2AC) (("5" (PROPAX) NIL NIL)) NIL)) NIL) ("6" (SKOLEM 1 "op") (("6" (FLATTEN) (("6" (HIDE -2) (("6" (SPLIT -1) (("1" (SKEEP*) (("1" (INST -1 "box" "vs" "nextfreeidx" "cache") (("1" (EXPAND RE2AC -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (PROPAX) NIL NIL) ("2" (ASSERT) (("2" (EXPAND RE2AC 2) (("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (EXPAND "varidxs_re_cache_in_box" -3) (("1" (INST -3 "0") (("1" (EXPAND "nth" -3) (("1" (TYPEPRED "RE2AC(op, box, vs, nextfreeidx, cache)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(op, box, vs, nextfreeidx, cache)") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (SKOLEM 1 ("op1" "op2")) (("7" (FLATTEN) (("7" (HIDE -3) (("7" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (EXPAND RE2AC -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 3) (("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" 3) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 3) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (INST -3 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("1" (INST -4 "box" "vs" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "varidxs_re_cache_in_box" -3) (("1" (SKEEP) (("1" (EXPAND "subterm" -6) (("1" (INST -3 "0") (("1" (EXPAND "nth" -3) (("1" (TYPEPRED "RE2AC(op2, box, vs,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2)") (("1" (ASSERT) (("1" (NAME-REPLACE "eval2" "RE2AC(op2, box, vs,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2)") (("1" (FLATTEN) (("1" (REPLACES -1) (("1" (NAME-REPLACE "eval1" "RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache)") (("1" (TYPEPRED "eval1") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" -13) (("1" (INST -13 "0") (("1" (EXPAND "nth" -13) (("1" (INST -12 "subexpr") (("1" (INST -13 "subexpr") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length" 1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "RE2AC(op2, box, vs,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2)") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (INST -2 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("2" (INST -3 "box" "vs" "nextfreeidx" "cache") (("2" (ASSERT) (("2" (ASSERT) (("2" (NAME-REPLACE "eval2" "RE2AC(op2, box, vs,
                                            val(RE2AC(op1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`1,
                                            val(RE2AC(op1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`2)") (("2" (EXPAND "varidxs_re_cache_in_box" -2) (("2" (INST -2 "i-1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "op1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKOLEM 1 ("op1" "op2")) (("8" (FLATTEN) (("8" (HIDE -3) (("8" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (EXPAND RE2AC -4) (("1" (LIFT-IF -4) (("1" (ASSERT) (("1" (SPLIT -4) (("1" (EXPAND RE2AC 1) (("1" (ASSERT) (("1" (EXPAND "varidxs_re_cache_in_box" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (TYPEPRED "cache_get(cache)(MULT(op1, op2))") (("1" (ASSERT) (("1" (SKEEP -1) (("1" (EXPAND "varidxs_re_cache_in_box" -8) (("1" (INST -8 "i!1") (("1" (REPLACE -1 :HIDE? T) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 4) (("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" 4) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 4) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (INST -3 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("1" (INST -4 "box" "vs" "nextfreeidx" "cache") (("1" (ASSERT) (("1" (ASSERT) (("1" (NAME-REPLACE "eval2" "RE2AC(op2,
                                        box,
                                        vs,
                                        val
                                        (RE2AC
                                         (op1,
                                          box,
                                          vs,
                                          nextfreeidx,
                                          cache))`1,
                                        val
                                        (RE2AC
                                         (op1,
                                          box,
                                          vs,
                                          nextfreeidx,
                                          cache))`2)") (("1" (NAME-REPLACE "eval1" "RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache)") (("1" (TYPEPRED "eval1") (("1" (ASSERT) (("1" (FLATTEN) (("1" (TYPEPRED "eval2") (("1" (ASSERT) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" -13) (("1" (INST -13 "0") (("1" (EXPAND "varidxs_re_cache_in_box" -14) (("1" (INST -14 "0") (("1" (EXPAND "nth" (-13 -14)) (("1" (SKEEP 6) (("1" (INST -13 "subexpr") (("1" (INST -14 "subexpr") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (INST -2 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("2" (INST -3 "box" "vs" "nextfreeidx" "cache") (("2" (ASSERT) (("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -2) (("2" (INST -2 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "op1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP*) (("9" (EXPAND RE2AC) (("9" (PROPAX) NIL NIL)) NIL)) NIL) ("10" (SKOLEM 1 ("op" "power")) (("10" (FLATTEN) (("10" (HIDE -2) (("10" (SPLIT -1) (("1" (SKEEP*) (("1" (INST -1 "box" "vs" "nextfreeidx" "cache") (("1" (EXPAND RE2AC -3) (("1" (LIFT-IF -3) (("1" (ASSERT) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 2) (("2" (ASSERT) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (HIDE -5) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -5) (("2" (INST -5 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -6) (("2" (INST -6 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" 2) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 2) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -6) (("2" (INST -6 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND "varidxs_re_cache_in_box" 1) (("1" (SKEEP :PREDS? T) (("1" (EXPAND "length" -1) (("1" (EXPAND "nth" 1) (("1" (CASE "i=0") (("1" (ASSERT) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -6) (("2" (INST -6 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "varidxs_re_cache_in_box" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "nth" 2) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -5) (("2" (INST -5 "i-1") (("2" (EXPAND "length" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "varidxs_re_cache_in_box" 2) (("2" (SKEEP :PREDS? T) (("2" (EXPAND "length" -1) (("2" (EXPAND "nth" 2) (("2" (CASE "i=0") (("1" (ASSERT) (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "varidxs_re_cache_in_box" -4) (("2" (INST -4 "i-1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP*) (("11" (EXPAND RE2AC) (("11" (PROPAX) NIL NIL)) NIL)) NIL) ("12" (SKEEP*) (("12" (EXPAND RE2AC) (("12" (PROPAX) NIL NIL)) NIL)) NIL) ("13" (SKEEP*) (("13" (EXPAND RE2AC) (("13" (PROPAX) NIL NIL)) NIL)) NIL) ("14" (SKEEP*) (("14" (EXPAND "RE2AC") (("14" (PROPAX) NIL NIL)) NIL)) NIL) ("15" (ASSERT) NIL NIL) ("16" (ASSERT) NIL NIL) ("17" (ASSERT) NIL NIL) ("18" (ASSERT) NIL NIL) ("19" (ASSERT) NIL NIL) ("20" (ASSERT) NIL NIL) ("21" (ASSERT) NIL NIL) ("22" (ASSERT) NIL NIL) ("23" (ASSERT) NIL NIL) ("24" (SKEEP*) (("24" (EXPAND "RE2AC") (("24" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|varidxs_re_cache_in_box| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (RE2AC DEF-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" |affine_expr_Eval_fnd| NIL) (|IntervalExpr_induction| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|nth| DEF-DECL "T" |list_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|CONST1_var| SKOLEM-CONST-DECL "[Unit -> real]" |affine_expr_Eval_fnd| NIL) (|CONST2_var| SKOLEM-CONST-DECL "(Includes?(CONST1_var(unit)))" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(val(RE2AC(CONST(CONST1_var, CONST2_var), box, vs, nextfreeidx,
                       cache))`2))" |affine_expr_Eval_fnd| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|const_ac| CONST-DECL "AffineCombination" |affine| NIL) (|subterm| ADT-DEF-DECL "boolean" |IntervalExpr_adt| |interval_arith|) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|Unit| TYPE-DECL NIL |Unit_adt| |structures|) (|Includes?| CONST-DECL "bool" |interval| |interval_arith|) (|unit?| ADT-RECOGNIZER-DECL "[Unit -> boolean]" |Unit_adt| |structures|) (|unit| ADT-CONSTRUCTOR-DECL "(unit?)" |Unit_adt| |structures|) (CONST ADT-CONSTRUCTOR-DECL "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" |IntervalExpr_adt| |interval_arith|) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|cache_get| DEF-DECL "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" |affine_expr_Eval_fnd| NIL) (VARIDX ADT-CONSTRUCTOR-DECL "[nat -> (varidx?)]" |IntervalExpr_adt| |interval_arith|) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL) (|none?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (|None| ADT-CONSTRUCTOR-DECL "(none?)" |Maybe| |structures|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((VARIDX(VARIDX1_var), nth_ac(box, VARIDX1_var), null),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|VARIDX1_var| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((ADD(op1, op2),
                   add_ac_ac(car(val(RE2AC(op1, box, vs, nextfreeidx,
                                           cache))`2)`2,
                             car(val(RE2AC(op2, box, vs,
                                           val(RE2AC(op1, box, vs,
                                                     nextfreeidx,
                                                     cache))`1,
                                           val(RE2AC(op1, box, vs,
                                                     nextfreeidx,
                                                     cache))`2))`2)`2),
                   null),
                  val(RE2AC(op2, box, vs,
                            val(RE2AC(op1, box, vs, nextfreeidx, cache))`1,
                            val(RE2AC(op1, box, vs, nextfreeidx,
                                      cache))`2))`2)))" |affine_expr_Eval_fnd| NIL) (|eval2| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op2)
     AND (EXISTS (l: list[CacheData]):
            val(result)`2 =
             append(l, val(RE2AC(op1, box, vs, nextfreeidx, cache))`2))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= val(RE2AC(op1, box, vs, nextfreeidx, cache))`1)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|op1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|op2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|eval1| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|next_idx| CONST-DECL "nat" |affine| NIL) (ADD ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (add?)]" |IntervalExpr_adt| |interval_arith|) (|add_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|neg_ac| CONST-DECL "AffineCombination" |affine| NIL) (NEG ADT-CONSTRUCTOR-DECL "[RealExpr -> (neg?)]" |IntervalExpr_adt| |interval_arith|) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|op| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(cons((SUB(op1, op2),
                   sub_ac_ac(car(val(RE2AC(op1, box, vs, nextfreeidx,
                                           cache))`2)`2,
                             car(val(RE2AC(op2, box, vs,
                                           val(RE2AC(op1, box, vs,
                                                     nextfreeidx,
                                                     cache))`1,
                                           val(RE2AC(op1, box, vs,
                                                     nextfreeidx,
                                                     cache))`2))`2)`2),
                   null),
                  val(RE2AC(op2, box, vs,
                            val(RE2AC(op1, box, vs, nextfreeidx, cache))`1,
                            val(RE2AC(op1, box, vs, nextfreeidx,
                                      cache))`2))`2)))" |affine_expr_Eval_fnd| NIL) (|eval2| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op2)
     AND (EXISTS (l: list[CacheData]):
            val(result)`2 =
             append(l, val(RE2AC(op1, box, vs, nextfreeidx, cache))`2))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= val(RE2AC(op1, box, vs, nextfreeidx, cache))`1)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|op1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|op2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|eval1| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (SUB ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (sub?)]" |IntervalExpr_adt| |interval_arith|) (|sub_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (MULT ADT-CONSTRUCTOR-DECL "[[RealExpr, RealExpr] -> (mult?)]" |IntervalExpr_adt| |interval_arith|) (|eval2| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op2)
     AND (EXISTS (l: list[CacheData]):
            val(result)`2 =
             append(l, val(RE2AC(op1, box, vs, nextfreeidx, cache))`2))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= val(RE2AC(op1, box, vs, nextfreeidx, cache))`1)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|op1| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|op2| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|eval1| SKOLEM-CONST-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" |affine_expr_Eval_fnd| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|next_idx_2| CONST-DECL "nat" |affine| NIL) (|mult_ac_ac| CONST-DECL "AffineCombination" |affine| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|represents_var?| CONST-DECL "bool" |affine| NIL) (POW ADT-CONSTRUCTOR-DECL "[[RealExpr, nat] -> (pow?)]" |IntervalExpr_adt| |interval_arith|) (|cache_get_powvar| DEF-DECL "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" |affine_expr_Eval_fnd| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nats| DEF-DECL "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" |affine_pow| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|take| DEF-DECL "list[T]" |more_list_props| |structures|) (|i| SKOLEM-CONST-DECL "below(length(cons((POW(op, power),
                   pow_var_ac(nth_ac(box, varidx(op)), power,
                              nats(nextfreeidx,
                                   -1 -
                                    opn(val(cache_get_powvar(cache)
                                                            (POW(op,
                                                                 power)))`1)
                                    + nextfreeidx
                                    + power)),
                   nats(nextfreeidx,
                        -1 -
                         opn(val(cache_get_powvar(cache)
                                                 (POW(op, power)))`1)
                         + nextfreeidx
                         + power)),
                  cache)))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" |affine_expr_Eval_fnd| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (|power| SKOLEM-CONST-DECL "nat" |affine_expr_Eval_fnd| NIL) (|op| SKOLEM-CONST-DECL "RealExpr" |affine_expr_Eval_fnd| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) SHOSTAK)) (|vrcib_box_growing_preservation| 0 (|vrcib_box_growing_preservation-1| |nil| 3638721939 ("" (SKEEP*) (("" (EXPAND "varidxs_re_cache_in_box") (("" (SKEEP) (("" (INST?) (("" (SKEEP) (("" (INST?) (("" (ASSERT) (("" (USE "length_append[Interval]") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|varidxs_re_cache_in_box| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK)) (|RE2AC_box_vs_expansion_TCC1| 0 (|RE2AC_box_vs_expansion_TCC1-2| |nil| 3638720433 ("" (SKEEP*) (("" (EXPAND "last_idx_in_box") (("" (USE "length_append[Interval]") (("" (REPLACE -1 1 :HIDE? T) (("" (TYPEPRED "added_idx") (("" (EXPAND "last_idx_in_box") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (> CONST-DECL "bool" |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|RE2AC_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.nextfreeidx" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :))))}")) (|RE2AC_box_vs_expansion_TCC1-1| |nil| 3638607084 ("" (GRIND) NIL NIL) NIL NIL (|RE2AC_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.nextfreeidx" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :))))}"))) (|RE2AC_box_vs_expansion_TCC2| 0 (|RE2AC_box_vs_expansion_TCC2-4| |nil| 3644607770 ("" (SKEEP*) (("" (TYPEPRED "cache") (("" (SPLIT 1) (("1" (USE "correct_cache?_alt_def") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "correct_cache?_alt_def") (("1" (REPLACE -1 :HIDE? T) (("1" (LEMMA "every_implies[CacheData]") (("1" (INST? -1 :WHERE 1) (("1" (INST? -1 :WHERE -2) (("1" (ASSERT) (("1" (USE "CacheData_correct?_inclusion") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs?") (("2" (SKEEP -2) (("2" (TYPEPRED "x") (("2" (SKEEP -1) (("2" (INST 1 "upd_noise(N, length(box), IF SingInterval?(I) THEN 0 ELSE e ENDIF)") (("2" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (CASE "i< length(box)") (("1" (INST -4 "i") (("1" (FLATTEN) (("1" (CASE "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "updated_noise_on_varac1") (("1" (ASSERT) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i = length(box)") (("1" (HIDE 1) (("1" (REPLACES -1) (("1" (CASE "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACES -1) (("1" (USE "gnbi_upd") (("1" (REPLACES -1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT 1) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "length_append[Interval]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (INST -4 "i") (("2" (SKEEP) (("2" (INST -4 "n") (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("1" (INST -8 "i") (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REPLACE -4 1 :HIDE? T) (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (ASSERT) (("1" (HIDE 2) (("1" (EXPAND "varidxs_re_cache_in_box") (("1" (INST -9 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -9 "length(box)") (("2" (ASSERT) (("2" (TYPEPRED "added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (CASE "nth_ac(box, varidx_powvar(nth(cache, i)`1)) = nth_ac(append[Interval](box, (: I :)),
                                                                                                                                       varidx_powvar(nth(cache, i)`1))") (("1" (REPLACES -1) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -9 "i_1") (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (EXPAND "nth" 1 1 :ASSERT? NIL) (("2" (EXPAND "nth_ac" (1 -4)) (("2" (EXPAND "var_ac" -4) (("2" (EXPAND_OL) (("2" (LIFT-IF -4) (("2" (ASSERT) (("2" (SPLIT -4) (("1" (ASSERT) (("1" (EXPAND "var_ac" 1) (("1" (ASSERT) (("1" (EXPAND "cons_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE 2) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap") (("2" (INST -14 "i") (("2" (INST -14 "i_1") (("2" (ASSERT) (("2" (HIDE 1) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (EXPAND "nth_ac") (("2" (CASE "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
                            nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "added_idx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME-REPLACE "k" "varidx_powvar(nth(cache, i)`1)") (("2" (HIDE-ALL-BUT (1 -4)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac" 1) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|upd_noise| DEF-DECL "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|n| SKOLEM-CONST-DECL "upfrom(length(append[Interval](box, (: I :))))" |affine_expr_Eval_fnd| NIL) (|eval_vs_idempotence| FORMULA-DECL NIL |interval_expr| |interval_arith|) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|varidxs_re_cache_in_box| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|eval_upd_no_idxs_ac| FORMULA-DECL NIL |affine| NIL) (|idxs_ac_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|new_idxs_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|updated_noise_on_varac1| FORMULA-DECL NIL |affine| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|gnbi_upd_2| FORMULA-DECL NIL |affine| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (I SKOLEM-CONST-DECL "Interval" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(append[Interval](box, (: I :))))" |affine_expr_Eval_fnd| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|eval_var_ac| FORMULA-DECL NIL |affine| NIL) (|gnbi_upd| FORMULA-DECL NIL |affine| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|correct_cache?_alt_def| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|every_implies| FORMULA-DECL NIL |more_list_props| |structures|) (|CacheData_correct?_inclusion| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|RE2AC_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}")) (|RE2AC_box_vs_expansion_TCC2-3| |nil| 3638720475 ("" (SKEEP*) (("" (TYPEPRED "cache") (("" (SPLIT 1) (("1" (USE "correct_cache?_alt_def") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "correct_cache?_alt_def") (("1" (REPLACE -1 :HIDE? T) (("1" (LEMMA "every_implies[CacheData]") (("1" (INST? -1 :WHERE 1) (("1" (INST? -1 :WHERE -2) (("1" (ASSERT) (("1" (USE "CacheData_correct?_inclusion") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs?") (("2" (SKEEP -2) (("2" (TYPEPRED "x") (("2" (SKEEP -1) (("2" (INST 1 "upd_noise(N, length(box), IF SingInterval?(I) THEN 0 ELSE e ENDIF)") (("2" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (CASE "i< length(box)") (("1" (INST -4 "i") (("1" (FLATTEN) (("1" (CASE "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "updated_noise_on_varac1") (("1" (ASSERT) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i = length(box)") (("1" (HIDE 1) (("1" (REPLACES -1) (("1" (CASE "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACES -1) (("1" (USE "gnbi_upd") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (HIDE-ALL-BUT 1) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "length_append[Interval]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (INST -4 "i") (("2" (SKEEP) (("2" (INST -4 "n") (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("1" (INST -8 "i") (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REPLACE -4 1 :HIDE? T) (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (ASSERT) (("1" (HIDE 2) (("1" (EXPAND "varidxs_re_cache_in_box") (("1" (INST -9 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -9 "length(box)") (("2" (ASSERT) (("2" (TYPEPRED "added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (CASE "nth_ac(box, varidx_powvar(nth(cache, i)`1)) = nth_ac(append[Interval](box, (: I :)),
                                                                                                                      varidx_powvar(nth(cache, i)`1))") (("1" (REPLACES -1) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -9 "i_1") (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (EXPAND "nth" 1 1 :ASSERT? NIL) (("2" (EXPAND "nth_ac" (1 -4)) (("2" (EXPAND "var_ac" -4) (("2" (EXPAND_OL) (("2" (LIFT-IF -4) (("2" (ASSERT) (("2" (SPLIT -4) (("1" (ASSERT) (("1" (EXPAND "var_ac" 1) (("1" (ASSERT) (("1" (EXPAND "cons_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE 2) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap") (("2" (INST -14 "i") (("2" (INST -14 "i_1") (("2" (ASSERT) (("2" (HIDE 1) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (EXPAND "nth_ac") (("2" (CASE "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
       nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (TYPEPRED "added_idx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME-REPLACE "k" "varidx_powvar(nth(cache, i)`1)") (("2" (HIDE-ALL-BUT (1 -4)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac" 1) (("2" (USE "nth_append2[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|RE2AC_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}")) (|RE2AC_box_vs_expansion_TCC2-2| |nil| 3638644378 ("" (SKEEP*) (("" (EXPAND "last_idx_in_box") (("" (USE "length_append[Interval]") (("" (REPLACE -1 1 :HIDE? T) (("" (TYPEPRED "added_idx") (("" (EXPAND "last_idx_in_box") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|RE2AC_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}")) (|RE2AC_box_vs_expansion_TCC2-1| |nil| 3638607084 ("" (SKEEP*) (("" (TYPEPRED "cache") (("" (SPLIT 1) (("1" (USE "correct_cache?_alt_def") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "correct_cache?_alt_def") (("1" (REPLACE -1 :HIDE? T) (("1" (LEMMA "every_implies[CacheData]") (("1" (INST? -1 :WHERE 1) (("1" (INST? -1 :WHERE -2) (("1" (ASSERT) (("1" (USE "CacheData_correct?_inclusion") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs?") (("2" (SKEEP -2) (("2" (TYPEPRED "x") (("2" (SKEEP -1) (("2" (INST 1 "upd_noise(N, length(box), IF SingInterval?(I) THEN 0 ELSE e ENDIF)") (("2" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?") (("1" (SKEEP) (("1" (CASE "i< length(box)") (("1" (INST -4 "i") (("1" (FLATTEN) (("1" (USE "nth_append2[Interval]") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (USE "updated_noise_on_varac1") (("1" (ASSERT) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i = length(box)") (("1" (HIDE 1) (("1" (REPLACES -1) (("1" (USE "nth_append[Interval]") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACES -1) (("1" (USE "gnbi_upd") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?") (("2" (SKEEP) (("2" (INST -4 "i") (("2" (SKEEP) (("2" (INST -4 "n") (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("1" (INST -8 "i") (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REPLACE -4 1 :HIDE? T) (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (ASSERT) (("1" (HIDE 2) (("1" (EXPAND "varidxs_re_cache_in_box") (("1" (INST -9 "i") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -9 "length(box)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (CASE "nth_ac(box, varidx_powvar(nth(cache, i)`1)) = nth_ac(append[Interval](box, (: I :)),
                                                                   varidx_powvar(nth(cache, i)`1))") (("1" (REPLACES -1) (("1" (EXPAND "pow_var_compatible?") (("1" (FLATTEN) (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -9 "i_1") (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACES -1) NIL NIL) ("2" (HIDE 2) (("2" (EXPAND "nth" 1 1 :ASSERT? NIL) (("2" (EXPAND "nth_ac" (1 -4)) (("2" (EXPAND "var_ac" -4) (("2" (EXPAND_OL) (("2" (LIFT-IF -4) (("2" (ASSERT) (("2" (SPLIT -4) (("1" (ASSERT) (("1" (EXPAND "var_ac" 1) (("1" (ASSERT) (("1" (EXPAND "cons_ol") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i_1") (("2" (HIDE 2) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap") (("2" (INST -14 "i") (("2" (INST -14 "i_1") (("2" (ASSERT) (("2" (HIDE 1) (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (EXPAND "nth_ac") (("2" (USE "nth_append2[Interval]") (("2" (REPLACES -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth_ac" 1) (("2" (USE "nth_append2[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "cache") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|RE2AC_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}"))) (|RE2AC_box_vs_expansion| 0 (|RE2AC_box_vs_expansion-2| "" 3638644743 ("" (INDUCT "re") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "re!1") (("2" (ASSERT) NIL NIL)) NIL) ("3" (SKEEP*) (("3" (HIDE -1) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (HIDE -1) (("4" (EXPAND "RE2AC" -5) (("4" (LIFT-IF -5) (("4" (ASSERT) (("4" (SPLIT -5) (("1" (EXPAND RE2AC 1 1) (("1" (ASSERT) (("1" (EXPAND RE2AC 1 1) (("1" (EXPAND RE2AC 1 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "RE2AC" 1) (("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (ASSERT) (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (USE "length_append[Interval]") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "nth_ac") (("2" (USE "nth_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP*) (("5" (EXPAND "RE2AC" -8) (("5" (LIFT-IF -8) (("5" (ASSERT) (("5" (SPLIT -8) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (LIFT-IF 3) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (SPLIT -2) (("1" (INST -2 "box" "vs" "nextfreeidx" "cache" "I" "x" "added_idx") (("1" (ASSERT) (("1" (INST -1 "box" "vs" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`1" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`2" "I" "x" "added_idx") (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (HIDE 4) (("3" (FLATTEN) (("3" (TYPEPRED "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE 4) (("4" (LEMMA "iacniig_RE2AC_preservation") (("4" (ASSERT) (("4" (INST -1 "box" "vs" "ADD1_var" "added_idx" "nextfreeidx" "cache") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE 4) (("5" (LEMMA "nicniig_RE2AC_preservation") (("5" (INST -1 "box" "vs" "ADD1_var" "added_idx" "nextfreeidx" "cache") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("6" (HIDE 4) (("6" (USE "vrcib_RE2AC_preservation") (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "ADD2_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "ADD1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (EXPAND "RE2AC") (("6" (PROPAX) NIL NIL)) NIL) ("7" (SKOLEM 1 "op") (("7" (FLATTEN) (("7" (HIDE -2) (("7" (SPLIT -1) (("1" (SKEEP*) (("1" (EXPAND RE2AC -6) (("1" (LIFT-IF -6) (("1" (ASSERT) (("1" (SPLIT -6) (("1" (PROPAX) NIL NIL) ("2" (INST -1 "box" "vs" "nextfreeidx" "cache" "I" "x" "added_idx") (("2" (SPLIT -1) (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (PROPAX) NIL NIL) ("4" (PROPAX) NIL NIL) ("5" (PROPAX) NIL NIL) ("6" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "op") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKOLEM 1 ("re1" "re2")) (("8" (FLATTEN) (("8" (SKEEP*) (("8" (EXPAND "RE2AC" -8) (("8" (LIFT-IF -8) (("8" (ASSERT) (("8" (SPLIT -8) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (LIFT-IF 3) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (SPLIT -2) (("1" (INST -2 "box" "vs" "nextfreeidx" "cache" "I" "x" "added_idx") (("1" (ASSERT) (("1" (INST -1 "box" "vs" "val(RE2AC(re1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(re1, box, vs, nextfreeidx, cache))`2" "I" "x" "added_idx") (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (HIDE 4) (("3" (FLATTEN) (("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE 4) (("4" (LEMMA "iacniig_RE2AC_preservation") (("4" (ASSERT) (("4" (INST -1 "box" "vs" "re1" "added_idx" "nextfreeidx" "cache") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE 4) (("5" (LEMMA "nicniig_RE2AC_preservation") (("5" (INST -1 "box" "vs" "re1" "added_idx" "nextfreeidx" "cache") (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("6" (HIDE 4) (("6" (USE "vrcib_RE2AC_preservation") (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKOLEM 1 ("re1" "re2")) (("9" (FLATTEN) (("9" (HIDE -3) (("9" (SPLIT -1) (("1" (SPLIT -2) (("1" (SKEEP*) (("1" (LABEL "ind hyp 1" -1) (("1" (HIDE "ind hyp 1") (("1" (LABEL "ind hyp 2" -1) (("1" (HIDE "ind hyp 2") (("1" (EXPAND RE2AC -5) (("1" (LIFT-IF -5) (("1" (ASSERT) (("1" (SPLIT -5) (("1" (EXPAND RE2AC 1 1) (("1" (ASSERT) (("1" (EXPAND RE2AC 1 1) (("1" (EXPAND RE2AC 1 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 4 1) (("2" (ASSERT) (("2" (REVEAL "ind hyp 1") (("2" (INST -1 "box" "vs") (("2" (INST -1 "val(RE2AC(re1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(re1, box, vs, nextfreeidx, cache))`2" "I" "x" "added_idx") (("2" (SPLIT "ind hyp 1") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REVEAL "ind hyp 2") (("1" (INST -1 "box" "vs") (("1" (INST -1 "nextfreeidx" "cache" "I" "x" "added_idx") (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND RE2AC 4) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (TYPEPRED "RE2AC(re1, box, vs, nextfreeidx, cache)") (("3" (ASSERT) NIL NIL)) NIL) ("4" (HIDE-ALL-BUT (-2 1)) (("4" (USE "iacniig_RE2AC_preservation") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT (-3 1)) (("5" (USE "nicniig_RE2AC_preservation") (("5" (ASSERT) NIL NIL)) NIL)) NIL) ("6" (HIDE-ALL-BUT (-4 1)) (("6" (USE "vrcib_RE2AC_preservation") (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re2") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "re1") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("10" (EXPAND "RE2AC") (("10" (PROPAX) NIL NIL)) NIL) ("11" (SKOLEM 1 ("re" "n")) (("11" (FLATTEN) (("11" (SPLIT -1) (("1" (SKEEP*) (("1" (LABEL "ind hyp" -1) (("1" (HIDE "ind hyp") (("1" (HIDE -1) (("1" (EXPAND RE2AC -5) (("1" (LIFT-IF -5) (("1" (ASSERT) (("1" (SPLIT -5) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (EXPAND RE2AC 2 1) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (ASSERT) (("1" (USE "length_append[Interval]") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "nth_ac" -1) (("1" (SPLIT -1) (("1" (EXPAND RE2AC 1) (("1" (ASSERT) (("1" (EXPAND "null_ol") (("1" (EXPAND "nth_ac") (("1" (USE "nth_append[Interval]") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND RE2AC 1) (("2" (EXPAND "nth_ac") (("2" (USE "nth_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND RE2AC 1 1) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append[Interval]") (("1" (ASSERT) (("1" (EXPAND RE2AC 1 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND RE2AC 2 1) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append[Interval]") (("1" (ASSERT) (("1" (EXPAND RE2AC 2 1) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND RE2AC 1 1) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append[Interval]") (("1" (ASSERT) (("1" (EXPAND RE2AC 1 1) (("1" (EXPAND "nth_ac") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND RE2AC 2 1) (("2" (EXPAND "nth_ac") (("2" (USE "nth_append[Interval]") (("2" (ASSERT) (("2" (EXPAND RE2AC 2 1) (("2" (EXPAND "nth_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND RE2AC 2 1) (("2" (EXPAND "nth_ac") (("2" (USE "nth_append[Interval]") (("2" (ASSERT) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND RE2AC 1 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND RE2AC 2 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (EXPAND RE2AC 1 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "re") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (EXPAND "RE2AC") (("12" (PROPAX) NIL NIL)) NIL) ("13" (EXPAND "RE2AC") (("13" (PROPAX) NIL NIL)) NIL) ("14" (EXPAND "RE2AC") (("14" (PROPAX) NIL NIL)) NIL) ("15" (EXPAND "RE2AC") (("15" (PROPAX) NIL NIL)) NIL) ("16" (ASSERT) NIL NIL) ("17" (ASSERT) NIL NIL) ("18" (ASSERT) NIL NIL) ("19" (ASSERT) NIL NIL) ("20" (ASSERT) NIL NIL) ("21" (ASSERT) NIL NIL) ("22" (ASSERT) NIL NIL) ("23" (ASSERT) NIL NIL) ("24" (SKEEP*) (("24" (USE "RE2AC_box_vs_expansion_TCC2") (("24" (ASSERT) NIL NIL)) NIL)) NIL) ("25" (EXPAND "RE2AC") (("25" (PROPAX) NIL NIL)) NIL) ("26" (HIDE 2) (("26" (SKEEP*) (("26" (USE "RE2AC_box_vs_expansion_TCC2") (("26" (ASSERT) (("26" (INST? -1) (("26" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("27" (HIDE 2) (("27" (SKEEP*) (("27" (USE "RE2AC_box_vs_expansion_TCC1") (("27" (ASSERT) (("27" (INST? -1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|RE2AC_box_vs_expansion_TCC1| SUBTYPE-TCC NIL |affine_expr_Eval_fnd| NIL) (|bconst?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|bnot?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|band?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|bor?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|bimplies?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|brel?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|bincludes?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|bite?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|bletin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|BoolExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (BLETIN ADT-CONSTRUCTOR-DECL "[[IntervalExpr, BoolExpr] -> (bletin?)]" |IntervalExpr_adt| |interval_arith|) (|RE2AC_box_vs_expansion_TCC2| SUBTYPE-TCC NIL |affine_expr_Eval_fnd| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nzreal_expt| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|null_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|varidx| ADT-ACCESSOR-DECL "[(varidx?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|neg_ac| CONST-DECL "AffineCombination" |affine| NIL) (|minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|vrcib_RE2AC_preservation| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|nicniig_RE2AC_preservation| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|iacniig_RE2AC_preservation| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|idxs_ac| CONST-DECL "list[nat]" |affine| NIL) (|subterm| ADT-DEF-DECL "boolean" |IntervalExpr_adt| |interval_arith|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|const_ac| CONST-DECL "AffineCombination" |affine| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|IntervalExpr_induction| FORMULA-DECL NIL |IntervalExpr_adt| |interval_arith|) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (> CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|idxs_ac_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|new_idxs_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|varidxs_re_cache_in_box| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Maybe| TYPE-DECL NIL |Maybe| |structures|) (|some?| ADT-RECOGNIZER-DECL "[Maybe -> boolean]" |Maybe| |structures|) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|val| ADT-ACCESSOR-DECL "[(some?) -> T]" |Maybe| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (RE2AC DEF-DECL "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" |affine_expr_Eval_fnd| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|length| DEF-DECL "nat" |list_props| NIL)) SHOSTAK) (|RE2AC_box_vs_expansion-1| |nil| 3638632016 ("" (INDUCT "re") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "re!1") (("2" (ASSERT) NIL NIL)) NIL) ("3" (SKEEP*) (("3" (HIDE -1) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (HIDE -1) (("4" (EXPAND "RE2AC" -5) (("4" (LIFT-IF -5) (("4" (ASSERT) (("4" (SPLIT -5) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (USE "length_append[Interval]") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (EXPAND "nth_ac") (("2" (USE "nth_append2[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP*) (("5" (EXPAND "RE2AC" -8) (("5" (LIFT-IF -8) (("5" (ASSERT) (("5" (SPLIT -8) (("1" (PROPAX) NIL NIL) ("2" (FLATTEN) (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "RE2AC" 3) (("2" (LIFT-IF 3) (("2" (ASSERT) (("2" (SPLIT -1) (("1" (SPLIT -2) (("1" (INST? -2 :WHERE 2) (("1" (INST? -2 :WHERE 3) (("1" (INST -2 "new_idx_gap") (("1" (ASSERT) (("1" (INST -1 "box" "vs" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`1" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`2" "I" "x" "new_idx_gap") (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (HIDE 4) (("3" (FLATTEN) (("3" (TYPEPRED "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE 4) (("4" (USE "iacniig_RE2AC_preservation") (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (HIDE 4) (("5" (USE "nicniig_RE2AC_preservation") (("5" (ASSERT) NIL NIL)) NIL)) NIL) ("6" (HIDE 4) (("6" (USE "vrcib_RE2AC_preservation") (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "ADD2_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "ADD1_var") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (EXPAND "RE2AC") (("6" (PROPAX) NIL NIL)) NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (EXPAND "RE2AC") (("10" (PROPAX) NIL NIL)) NIL) ("11" (POSTPONE) NIL NIL) ("12" (EXPAND "RE2AC") (("12" (PROPAX) NIL NIL)) NIL) ("13" (EXPAND "RE2AC") (("13" (PROPAX) NIL NIL)) NIL) ("14" (EXPAND "RE2AC") (("14" (PROPAX) NIL NIL)) NIL) ("15" (ASSERT) NIL NIL) ("16" (ASSERT) NIL NIL) ("17" (ASSERT) NIL NIL) ("18" (ASSERT) NIL NIL) ("19" (ASSERT) NIL NIL) ("20" (ASSERT) NIL NIL) ("21" (ASSERT) NIL NIL) ("22" (ASSERT) NIL NIL) ("23" (ASSERT) NIL NIL) ("24" (POSTPONE) NIL NIL) ("25" (POSTPONE) NIL NIL)) NIL) NIL SHOSTAK)) (|cp_box_vs_expansion_TCC1| 0 (|cp_box_vs_expansion_TCC1-1| |nil| 3639411132 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (>= CONST-DECL "bool" |reals| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (^ CONST-DECL "real" |exponentiation| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|)) NIL (|cp_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.nextfreeidx" "nat"))) (|cp_box_vs_expansion_TCC2| 0 (|cp_box_vs_expansion_TCC2-1| |nil| 3639411132 ("" (SKEEP*) (("" (TYPEPRED "cache") (("" (USE "correct_cache?_alt_def") (("" (REPLACE -1 :HIDE? T) (("" (USE "correct_cache?_alt_def") (("" (REPLACE -1 :HIDE? T) (("" (LEMMA "every_implies[CacheData]") (("" (INST? -1 :WHERE 1) (("" (INST? -1 :WHERE -2) (("" (ASSERT) (("" (USE "CacheData_correct?_inclusion") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (< CONST-DECL "bool" |reals| NIL) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (> CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData_correct?_inclusion| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|every_implies| FORMULA-DECL NIL |more_list_props| |structures|) (|append| DEF-DECL "list[T]" |list_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|correct_cache?_alt_def| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL (|cp_box_vs_expansion| SUBTYPE "affine_expr_Eval_fnd.cache" "(affine_expr_Eval_fnd.correct_cache?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :))))"))) (|cp_box_vs_expansion| 0 (|cp_box_vs_expansion-7| "" 3883676554 ("" (SKEEP*) (("" (LABEL "iacniig" -1) (("" (HIDE "iacniig") (("" (LABEL "vrcib" -1) (("" (HIDE "vrcib") (("" (LABEL "nicniig" -1) (("" (HIDE "nicniig") (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (CASE "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 -1)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (CASE "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "length_append[Interval]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (CASE "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
       nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "pow_var_compatible?" 1) (("1" (FLATTEN) (("1" (EXPAND "pow_var_compatible?" -10) (("1" (ASSERT) (("1" (SKOLEM 1 "i_") (("1" (INST -10 "i_") (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (EXPAND "var_ac" 1) (("1" (ASSERT) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (EXPAND "cons_ol") (("1" (EXPAND "nth" -1 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "nicniig") (("2" (EXPAND "new_idxs_cache_not_in_idx_gap") (("2" (INST "nicniig" "i") (("2" (INST "nicniig" "i_") (("2" (SPLIT "nicniig") (("1" (TYPEPRED "added_idx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i_") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME-REPLACE "k" "varidx_powvar(nth(cache, i)`1)") (("2" (HIDE-ALL-BUT (-1 1)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "vrcib") (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (EXPAND "varidx_powvar") (("2" (INST "vrcib" "i") (("2" (INST?) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "iacniig") (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (INST "iacniig" "i") (("2" (INST? "iacniig" :WHERE -2) (("2" (ASSERT) (("2" (TYPEPRED "added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "vrcib") (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (INST "vrcib" "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|cp_box_vs_expansion-6| |nil| 3639419412 ("" (SKEEP*) (("" (LABEL "iacniig" -1) (("" (HIDE "iacniig") (("" (LABEL "vrcib" -1) (("" (HIDE VRCIB) (("" (LABEL NICNIIG -1) (("" (HIDE NICNIIG) (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (CASE "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 -1)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (CASE "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (USE "length_append[Interval]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (CASE "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
       nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "pow_var_compatible?" 1) (("1" (FLATTEN) (("1" (EXPAND "pow_var_compatible?" -10) (("1" (ASSERT) (("1" (SKOLEM 1 "i_") (("1" (INST -10 "i_") (("1" (USE "gnbi_upd_2") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (HIDE 2) (("1" (EXPAND "var_ac" 1) (("1" (ASSERT) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (EXPAND "cons_ol") (("1" (EXPAND "nth" -1 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL NICNIIG) (("2" (EXPAND "new_idxs_cache_not_in_idx_gap") (("2" (INST NICNIIG I) (("2" (INST NICNIIG I_) (("2" (SPLIT NICNIIG) (("1" (TYPEPRED "added_idx") (("1" (EXPAND "last_idx_in_box") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "i_") (("2" (USE "cache_powvar_correct") (("2" (EXPAND "CacheData_correct?") (("2" (FLATTEN) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME-REPLACE "k" "varidx_powvar(nth(cache, i)`1)") (("2" (HIDE-ALL-BUT (-1 1)) (("2" (USE "more_list_props[Interval].nth_append") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL VRCIB) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (EXPAND "varidx_powvar") (("2" (INST VRCIB I) (("2" (INST?) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL IACNIIG) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (INST IACNIIG I) (("2" (INST? IACNIIG :WHERE -2) (("2" (ASSERT) (("2" (TYPEPRED "added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL VRCIB) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (INST VRCIB I) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|compatible_pairs?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|le_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|e_| SKOLEM-CONST-DECL "real" |affine_expr_Eval_fnd| NIL) (|nzEpsilon| TYPE-EQ-DECL NIL |affine| NIL) (|lt_idx| CONST-DECL "bool" |indexed_list| |structures|) (|Noise| TYPE-EQ-DECL NIL |affine| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null_ol?| CONST-DECL "bool" |ordered_list| |structures|) (|car_ol| CONST-DECL "T" |ordered_list| |structures|) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|upd_noise| DEF-DECL "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" |affine| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|gt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|opn| ADT-ACCESSOR-DECL "[(pow?) -> nat]" |IntervalExpr_adt| |interval_arith|) (|nzBaseType| TYPE-EQ-DECL NIL |affine| NIL) (|ac_proj_pd| FORMULA-DECL NIL |affine| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|new_idxs_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData_correct?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_ac| CONST-DECL "AffineCombination" |affine_pow| NIL) (|cache_powvar_correct| FORMULA-DECL NIL |affine_expr_Eval_fnd| NIL) (|varidxs_re_cache_in_box| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|subterm| ADT-DEF-DECL "boolean" |IntervalExpr_adt| |interval_arith|) (|i| SKOLEM-CONST-DECL "below(length(cache))" |affine_expr_Eval_fnd| NIL) (|cache| SKOLEM-CONST-DECL "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" |affine_expr_Eval_fnd| NIL) (|nextfreeidx| SKOLEM-CONST-DECL "upfrom(added_idx)" |affine_expr_Eval_fnd| NIL) (|added_idx| SKOLEM-CONST-DECL "above(1 + last_idx_in_box(box))" |affine_expr_Eval_fnd| NIL) (|vs| SKOLEM-CONST-DECL "Env" |affine_expr_Eval_fnd| NIL) (|eval| DEF-DECL "real" |interval_expr| |interval_arith|) (|op| SHARED-ADT-ACCESSOR-DECL "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" |IntervalExpr_adt| |interval_arith|) (|bincludes?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|idxs_ac_cache_not_in_idx_gap| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |box| |interval_arith|) (|eval_vs_idempotence| FORMULA-DECL NIL |interval_expr| |interval_arith|) (|n| SKOLEM-CONST-DECL "upfrom(length(append(box, (: I :))))" |affine_expr_Eval_fnd| NIL) (|vars_in_box_compatible?| CONST-DECL "bool" |affine_box| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|append| DEF-DECL "list[T]" |list_props| NIL) (|length_append| FORMULA-DECL NIL |list_props| NIL) (|gnbi_upd| FORMULA-DECL NIL |affine| NIL) (|eval_var_ac| FORMULA-DECL NIL |affine| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|ge_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|lt_realorder| NAME-JUDGEMENT "RealOrder" |real_orders| |reals|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|eval_upd_no_idxs_ac| FORMULA-DECL NIL |affine| NIL) (|var_ac| CONST-DECL "AffineCombination" |affine| NIL) (|box| SKOLEM-CONST-DECL "Box" |affine_expr_Eval_fnd| NIL) (I SKOLEM-CONST-DECL "Interval" |affine_expr_Eval_fnd| NIL) (|i| SKOLEM-CONST-DECL "below(length(append(box, (: I :))))" |affine_expr_Eval_fnd| NIL) (|idxs_ac_var_ac| FORMULA-DECL NIL |affine| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|next_idx| CONST-DECL "nat" |affine| NIL) (|last_idx| CONST-DECL "int" |indexed_list| |structures|) (|compatible_pairs_on?| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|pow_var_compatible?| CONST-DECL "bool" |affine_pow| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nth_ac| CONST-DECL "AffineCombination" |affine_box| NIL) (|varidx_powvar| CONST-DECL "nat" |affine_expr| NIL) (|powvar?| CONST-DECL "bool" |affine_expr| NIL) (|eval_ACExpr_Env| CONST-DECL "BaseType" |affine_expr| NIL) (|eval_ac_noise| CONST-DECL "real" |affine| NIL) (|{\|\|}| CONST-DECL "AffineCombination" |affine| NIL) (|cons_ol| CONST-DECL "ordered_list" |ordered_list| |structures|) (|empty_ErrorTerms| CONST-DECL "ErrorTerms" |affine| NIL) (|gnbi_upd_2| FORMULA-DECL NIL |affine| NIL) (|nth_append| FORMULA-DECL NIL |more_list_props| |structures|) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|SingInterval?| CONST-DECL "bool" |affine| NIL) (<= CONST-DECL "bool" |reals| NIL) (|Epsilon| TYPE-EQ-DECL NIL |affine| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|null_is_noise| NAME-JUDGEMENT "Noise" |affine| NIL) (|null_is_ErrorTerms| NAME-JUDGEMENT "ErrorTerms" |affine| NIL) (|above| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|last_idx_in_box| CONST-DECL "upfrom(-1)" |affine_box| NIL) (|upfrom| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (> CONST-DECL "bool" |reals| NIL) (|idxs_bounded| CONST-DECL "bool" |affine_expr_Eval_fnd| NIL) (|Env| TYPE-EQ-DECL NIL |affine_box| NIL) (|correct_cache?| DEF-DECL "bool" |affine_expr_Eval_fnd| NIL) (|CacheData| TYPE-EQ-DECL NIL |affine_expr_Eval_fnd| NIL) (|ordered_list| TYPE-EQ-DECL NIL |ordered_list| |structures|) (|ordered_list?| DEF-DECL "bool" |ordered_list| |structures|) (< CONST-DECL "bool" |reals| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|AffineCombination| TYPE-EQ-DECL NIL |affine| NIL) (|ErrorTerms| TYPE-EQ-DECL NIL |affine| NIL) (|BaseType| TYPE-EQ-DECL NIL |affine| NIL) (|RealExpr| TYPE-EQ-DECL NIL |IntervalExpr_adt| |interval_arith|) (|fun4?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|letin?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun2?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|fun?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|div?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|pow?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sq?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|mult?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|sub?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|neg?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|abs?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|add?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|varidx?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (|const?| ADT-RECOGNIZER-DECL "[IntervalExpr -> boolean]" |IntervalExpr_adt| |interval_arith|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|IntervalExpr| TYPE-DECL NIL |IntervalExpr_adt| |interval_arith|) (|Box| TYPE-EQ-DECL NIL |box| |interval_arith|) (|list| TYPE-DECL NIL |list_adt| NIL) (|Interval| TYPE-EQ-DECL NIL |interval| |interval_arith|) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_div_nzreal_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)) NIL) (|cp_box_vs_expansion-5| |nil| 3639419365 ("" (SKEEP*) (("" (LABEL "iacniig" -1) (("" (HIDE "iacniig") (("" (LABEL "vrcib" -1) (("" (HIDE VRCIB) (("" (LABEL NICNIIG -1) (("" (HIDE NICNIIG) (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL))))))) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL))))))) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL))))) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))))) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (USE "nth_append[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL))))) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))))))) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL))))))))) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL))))))))))))) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (POSTPONE) NIL))))))))) ("2" (REVEAL VRCIB) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (EXPAND "varidx_powvar") (("2" (INST VRCIB I) (("2" (INST?) (("2" (ASSERT) (("2" (GRIND) NIL))))))))))))))))))))) ("2" (REVEAL IACNIIG) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (INST IACNIIG I) (("2" (INST? IACNIIG :WHERE -2) (("2" (ASSERT) (("2" (TYPEPRED "first_added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) NIL))))))))))))))))) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL))))))))) ("2" (REVEAL VRCIB) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (INST VRCIB I) NIL))))))))))) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL))))))))))))))))))) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL)))))))))))))))))))))))))))))))))) NIL) NIL NIL) (|cp_box_vs_expansion-4| |nil| 3639418619 ("" (SKEEP*) (("" (LABEL "iacniig" -1) (("" (HIDE "iacniig") (("" (LABEL "vrcib" -1) (("" (HIDE VRCIB) (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (USE "nth_append[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL VRCIB) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (EXPAND "varidx_powvar") (("2" (INST VRCIB I) (("2" (INST?) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL IACNIIG) (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (INST IACNIIG I) (("2" (INST? IACNIIG :WHERE -2) (("2" (ASSERT) (("2" (TYPEPRED "first_added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL VRCIB) (("2" (EXPAND "varidxs_re_cache_in_box") (("2" (INST VRCIB I) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|cp_box_vs_expansion-3| |nil| 3639417319 ("" (SKEEP*) (("" (LABEL "iacniig" -1) (("" (HIDE "iacniig") (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (USE "nth_append[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REVEAL "iacniig") (("2" (EXPAND "idxs_ac_cache_not_in_idx_gap") (("2" (INST IACNIIG I) (("2" (INST IACNIIG "varidx_powvar(nth(cache, i)`1)") (("2" (CASE "member(varidx_powvar(nth(cache, i)`1), idxs_ac(nth(cache, i)`2))") (("1" (SPLIT IACNIIG) (("1" (PROPAX) NIL NIL) ("2" (TYPEPRED "first_added_idx") (("2" (EXPAND "last_idx_in_box") (("2" (POSTPONE) NIL NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|cp_box_vs_expansion-2| |nil| 3639417284 ("" (SKEEP*) (("" (LABEL "iacniig" 1) (("" (HIDE "iacniig") (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL))))))) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL))))))) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL))))) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))))) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (USE "nth_append[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL))))) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL))))))))))))) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL))))))))) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL))))))))))))) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (POSTPONE) NIL))))))))) ("2" (POSTPONE) NIL))))))))) ("2" (POSTPONE) NIL))) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL))))))))) ("2" (POSTPONE) NIL))))))) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL))))))))))))))))))) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL)))))))))))))))))))))))))) NIL) NIL NIL) (|cp_box_vs_expansion-1| |nil| 3639411515 ("" (SKEEP*) (("" (EXPAND "compatible_pairs?" 1) (("" (TYPEPRED "cache") (("" (EXPAND "compatible_pairs?" -2) (("" (SKOLEM -2 "N") (("" (FLATTEN) (("" (TYPEPRED "x") (("" (SKOLEM -1 "e") (("" (NAME "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (INST 1 "upd_noise(N,length(box),e_)") (("1" (SPLIT 1) (("1" (EXPAND "vars_in_box_compatible?" 1) (("1" (SKOLEM 1 "i") (("1" (TYPEPRED "i") (("1" (CASE "i<length(box)") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd_2") (("1" (ASSERT) (("1" (REPLACE -1 :HIDE? T) (("1" (EXPAND "vars_in_box_compatible?" -6) (("1" (INST -6 "i") NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (USE "idxs_ac_var_ac") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -3 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "i=length(box)") (("1" (REPLACE -1 :HIDE? T) (("1" (HIDE -1 1) (("1" (USE "nth_append[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (EXPAND "nth" 1) (("1" (USE "eval_var_ac") (("1" (REPLACE -1 :HIDE? T) (("1" (USE "gnbi_upd") (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 :DIR RL :HIDE? T) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "compatible_pairs_on?" 1) (("2" (SKOLEM 1 "i") (("2" (SKOLEM 1 "n") (("2" (EXPAND "compatible_pairs_on?" -5) (("2" (INST -5 "i") (("2" (INST -5 "n") (("1" (EXPAND "eval_ACExpr_Env") (("1" (USE "eval_vs_idempotence") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T :DIR RL) (("1" (FLATTEN) (("1" (USE "eval_upd_no_idxs_ac") (("1" (SPLIT -1) (("1" (REPLACE -1 :HIDE? T) (("1" (ASSERT) (("1" (FLATTEN) (("1" (CASE "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (ASSERT) (("1" (EXPAND "nth_ac") (("1" (USE "nth_append2[Interval]") (("1" (REPLACE -1 :HIDE? T) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "n") (("2" (USE "length_append[Interval]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)))
