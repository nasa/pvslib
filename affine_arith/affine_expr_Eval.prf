(affine_expr_Eval
 (Eval_wCache_TCC1 0
  (Eval_wCache_TCC1-2 nil 3632143418 ("" (tcc) nil nil)
   ((ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil)
  (Eval_wCache_TCC1-1 nil 3632143264 ("" (well-founded-tcc) nil nil)
   nil nil))
 (Eval_wCache_TCC2 0
  (Eval_wCache_TCC2-2 nil 3632156352
   (""
    (then (lemma "well_founded_restrict[IntervalExpr, RealExpr]")
     (inst?) (expand "well_founded?") (propax))
    nil nil)
   ((RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (well_founded_restrict judgement-tcc nil restrict_order_props nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/"))
   nil)
  (Eval_wCache_TCC2-1 nil 3632143264 ("" (tcc))
   ((ordered_list? def-decl "bool" ordered_list "structures/")) nil))
 (Eval_wCache_TCC3 0
  (Eval_wCache_TCC3-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (Includes? const-decl "bool" interval "interval_arith/")
    (Unit type-decl nil Unit_adt "structures/")
    (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt
           "structures/")
    (unit adt-constructor-decl "(unit?)" Unit_adt "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (/= const-decl "boolean" notequal nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (length def-decl "nat" list_props nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (const_ac const-decl "AffineCombination" affine nil))
   nil))
 (Eval_wCache_TCC4 0
  (Eval_wCache_TCC4-2 nil 3632156461
   (""
    (then (skeep*) (assert) (replaces -1) (replaces -1) (hide -1)
     (assert)
     (spread (split 1)
      ((spread
        (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)")
        ((grind) (grind) (then (expand "ordered_list?") (propax))))
       (then (typepred "cache") (expand "idxs_bounded") (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth") (typepred "nextfreeidx")
           (typepred "opC") (replaces -1) (expand "next_idx")
           (expand "const_ac") (hide-all-but (1 -1)) (grind))
          (then (expand "nth" 2) (assert)
           (inst? :subst ("i" "i-1")))))))))
    nil nil)
   ((empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (append def-decl "list[T]" list_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (const_ac const-decl "AffineCombination" affine nil)
    (CONST adt-constructor-decl
     "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]"
     IntervalExpr_adt "interval_arith/")
    (unit adt-constructor-decl "(unit?)" Unit_adt "structures/")
    (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt
           "structures/")
    (Includes? const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Unit type-decl nil Unit_adt "structures/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (next_idx const-decl "nat" affine nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (|##| const-decl "bool" interval "interval_arith/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   nil)
  (Eval_wCache_TCC4-1 nil 3632143264 ("" (subtype-tcc) nil nil) nil
   nil))
 (Eval_wCache_TCC5 0
  (Eval_wCache_TCC5-1 nil 3632143264 ("" (tcc) nil nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/")) nil))
 (Eval_wCache_TCC6 0
  (Eval_wCache_TCC6-1 nil 3632143264 ("" (tcc))
   ((ordered_list? def-decl "bool" ordered_list "structures/"))
   shostak))
 (Eval_wCache_TCC7 0
  (Eval_wCache_TCC7-1 nil 3632143264 ("" (tcc))
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (powvar? const-decl "bool" affine_expr nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC8 0
  (Eval_wCache_TCC8-1 nil 3632143264
   ("" (skeep*)
    (("" (assert)
      (("" (split 1)
        (("1" (grind) nil nil)
         ("2" (replace -4 1)
          (("2" (assert)
            (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil))
              nil))
            nil))
          nil)
         ("3" (typepred "cache")
          (("3" (replace -6 :hide? t)
            (("3" (assert)
              (("3" (expand "idxs_bounded" 1)
                (("3" (skeep :preds? t)
                  (("3" (expand "length" -1)
                    (("3" (expand "nth" 1)
                      (("3" (lift-if 1)
                        (("3" (split 1)
                          (("1" (flatten)
                            (("1" (replaces -1)
                              (("1"
                                (typepred "cached")
                                (("1"
                                  (assert)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (replace -2 :dir rl :hide? t)
                                      (("1"
                                        (expand "idxs_bounded")
                                        (("1" (inst -4 "i!1") nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (expand "idxs_bounded" -3)
                              (("2"
                                (inst -3 "i-1")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (cache skolem-const-decl
     "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (cached skolem-const-decl "{res: Maybe[AffineCombination] |
         some?(res) IMPLIES
          (EXISTS (i: below(length(cache))):
             nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res))}"
     affine_expr_Eval nil)
    (i skolem-const-decl
     "below(length(cons((re, val(cached), null), cache)))"
     affine_expr_Eval nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length def-decl "nat" list_props nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (> const-decl "bool" reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil))
   nil))
 (Eval_wCache_TCC9 0
  (Eval_wCache_TCC9-2 nil 3632157019 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC9-1 nil 3632143264 ("" (tcc)) nil shostak))
 (Eval_wCache_TCC10 0
  (Eval_wCache_TCC10-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC11 0
  (Eval_wCache_TCC11-1 nil 3632143264 ("" (tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (Eval_wCache_TCC12 0
  (Eval_wCache_TCC12-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (varidx_powvar const-decl "nat" affine_expr nil)
    (powvar? const-decl "bool" affine_expr nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (Eval_wCache_TCC13 0
  (Eval_wCache_TCC13-1 nil 3632143264
   ("" (skeep*)
    (("" (replaces -1)
      (("" (replaces -3)
        (("" (assert)
          (("" (split 3)
            (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)")
              (("1" (expand "append") (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil)
             ("2" (hide -3)
              (("2" (typepred "cache")
                (("2" (expand "idxs_bounded" 1)
                  (("2" (skeep)
                    (("2" (case "i=0")
                      (("1" (replaces -1)
                        (("1" (expand "nth" 1)
                          (("1" (typepred "nextfreeidx")
                            (("1" (use "last_idx_box")
                              (("1"
                                (expand "nth_ac")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "idxs_bounded")
                        (("2" (expand "nth" 2)
                          (("2" (assert) (("2" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (last_idx_box formula-decl nil affine_box nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt
     "interval_arith/")
    (append def-decl "list[T]" list_props nil))
   nil))
 (Eval_wCache_TCC14 0
  (Eval_wCache_TCC14-1 nil 3632143264 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC15 0
  (Eval_wCache_TCC15-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (Eval_wCache_TCC16 0
  (Eval_wCache_TCC16-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC17 0
  (Eval_wCache_TCC17-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   nil))
 (Eval_wCache_TCC18 0
  (Eval_wCache_TCC18-1 nil 3632143264
   ("" (then (skeep*) (typepred "cache1") (typepred "res1") (assert))
    nil nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil))
   shostak))
 (Eval_wCache_TCC19 0
  (Eval_wCache_TCC19-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil))
   shostak))
 (Eval_wCache_TCC20 0
  (Eval_wCache_TCC20-1 nil 3632143264 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC21 0
  (Eval_wCache_TCC21-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC22 0
  (Eval_wCache_TCC22-3 nil 3632158042 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC22-2 nil 3632157213
   ("" (skeep*)
    (("" (assert)
      (("" (hide -11)
        ((""
          (apply (then (label "result" -10) (label "ac2" -9)
                  (label "cache2" -8) (label "newid2" -7)
                  (label "res2" -6) (label "ac1" -5)
                  (label "cache1" -4) (label "newid1" -3)
                  (label "res1" -2) (label "re" -1)))
          ((""
            (deftactic typepred_res2 nil
             (with-labels
              (then (typepred "res2") (replace "cache2" -1 :dir RL)
               (replace "newid2" -1 :dir RL) (assert) (flatten))
              (("cache2 not null" "re2" "cache2-form" "N2"
                "newid2-prop" "cache2-idxs_bound" "UNKNOWN"))))
            ((""
              (deftactic typepred_res1 nil
               (with-labels
                (then (typepred "res1") (replace "cache1" -1 :dir RL)
                 (replace "newid1" -1 :dir RL) (assert) (flatten))
                (("cache1 not null" "re1" "cache1-form" "N1"
                  "newid1-prop" "cache1-idxs_bound" "UNKNOWN"))))
              (("" (split 3)
                (("1" (grind) nil)
                 ("2" (replaces "result")
                  (("2" (assert)
                    (("2" (typepred_res1)
                      (("2" (typepred_res2)
                        (("2" (skolem "cache2-form" "l2")
                          (("2" (skolem "cache1-form" "l1")
                            (("2" (replace "cache1-form" "cache2-form")
                              (("2"
                                (replace "cache2-form" 3)
                                (("2"
                                  (inst
                                   3
                                   "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))")
                                  (("1"
                                    (hide-all-but 3)
                                    (("1"
                                      (expand "append" 1 3)
                                      (("1"
                                        (use "append_assoc[CacheData]")
                                        (("1" (assert) nil)))))))
                                   ("2" (grind) nil)))))))))))))))))))
                 ("3" (replaces "result")
                  (("3" (assert)
                    (("3" (typepred_res2)
                      (("3" (typepred_res1) nil)))))))
                 ("4" (replaces "result")
                  (("4" (assert)
                    (("4" (expand "idxs_bounded")
                      (("4" (skeep)
                        (("4" (case "i=0")
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1"
                                (use "next_idx_add_ac_ac")
                                (("1"
                                  (expand ">=")
                                  (("1"
                                    (typepred_res2)
                                    (("1"
                                      (typepred_res1)
                                      (("1"
                                        (expand "idxs_bounded")
                                        (("1"
                                          (inst
                                           "cache1-idxs_bound"
                                           "0")
                                          (("1"
                                            (expand
                                             "nth"
                                             "cache1-idxs_bound")
                                            (("1"
                                              (replace "ac1" :dir RL)
                                              (("1"
                                                (inst
                                                 "cache2-idxs_bound"
                                                 "0")
                                                (("1"
                                                  (expand
                                                   "nth"
                                                   "cache2-idxs_bound")
                                                  (("1"
                                                    (replace
                                                     "ac2"
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (hide-all-but
                                                       (3
                                                        "cache2-idxs_bound"
                                                        "newid2-prop"
                                                        "cache1-idxs_bound"
                                                        -11))
                                                      (("1"
                                                        (expand "max")
                                                        (("1"
                                                          (lift-if -4)
                                                          (("1"
                                                            (split -4)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (expand
                                                                 ">=")
                                                                (("1"
                                                                  (assert)
                                                                  nil)))))
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (assert)
                                                                nil)))))))))))))))
                                                 ("2"
                                                  (grind)
                                                  nil)))))))
                                           ("2"
                                            (grind)
                                            nil)))))))))))))))))
                           ("2" (typepred_res2)
                            (("2" (expand "idxs_bounded")
                              (("2"
                                (inst "cache2-idxs_bound" "i-1")
                                (("1"
                                  (expand "nth" 3)
                                  (("1" (propax) nil)))
                                 ("2"
                                  (typepred "i")
                                  (("2"
                                    (grind)
                                    nil))))))))))))))))))))))))))))))))
    nil)
   nil nil)
  (Eval_wCache_TCC22-1 nil 3632143264 ("" (tcc))
   ((BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil))
   shostak))
 (Eval_wCache_TCC23 0
  (Eval_wCache_TCC23-1 nil 3632143264 ("" (tcc) nil nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/")) nil))
 (Eval_wCache_TCC24 0
  (Eval_wCache_TCC24-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (length def-decl "nat" list_props nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (add_pd_pd const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (add_ac_ac const-decl "AffineCombination" affine nil))
   shostak))
 (Eval_wCache_TCC25 0
  (Eval_wCache_TCC25-1 nil 3632143264
   ("" (skeep*)
    (("" (assert)
      (("" (hide -11)
        ((""
          (apply (then (label "result" -10) (label "ac2" -9)
                  (label "cache2" -8) (label "newid2" -7)
                  (label "res2" -6) (label "ac1" -5)
                  (label "cache1" -4) (label "newid1" -3)
                  (label "res1" -2) (label "re" -1)))
          ((""
            (deftactic typepred_res2 nil
             (with-labels
              (then (typepred "res2") (replace "cache2" -1 :dir RL)
               (replace "newid2" -1 :dir RL) (assert) (flatten))
              (("cache2 not null" "re2" "cache2-form" "newid2-prop"
                "cache2-idxs_bound" "UNKNOWN"))))
            ((""
              (deftactic typepred_res1 nil
               (with-labels
                (then (typepred "res1") (replace "cache1" -1 :dir RL)
                 (replace "newid1" -1 :dir RL) (assert) (flatten))
                (("cache1 not null" "re1" "cache1-form" "newid1-prop"
                  "cache1-idxs_bound" "UNKNOWN"))))
              (("" (split 3)
                (("1" (grind) nil nil)
                 ("2" (replaces "result")
                  (("2" (assert)
                    (("2" (typepred_res1)
                      (("2" (typepred_res2)
                        (("2" (skolem "cache2-form" "l2")
                          (("2" (skolem "cache1-form" "l1")
                            (("2" (replace "cache1-form" "cache2-form")
                              (("2"
                                (replace "cache2-form" 3)
                                (("2"
                                  (inst
                                   3
                                   "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))")
                                  (("1"
                                    (hide-all-but 3)
                                    (("1"
                                      (expand "append" 1 3)
                                      (("1"
                                        (use "append_assoc[CacheData]")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replaces "result")
                  (("3" (assert)
                    (("3" (typepred_res2)
                      (("3" (typepred_res1) nil nil)) nil))
                    nil))
                  nil)
                 ("4" (replaces "result")
                  (("4" (assert)
                    (("4" (expand "idxs_bounded")
                      (("4" (skeep)
                        (("4" (case "i=0")
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1"
                                (use "next_idx_add_ac_ac")
                                (("1"
                                  (expand ">=")
                                  (("1"
                                    (typepred_res2)
                                    (("1"
                                      (typepred_res1)
                                      (("1"
                                        (expand "idxs_bounded")
                                        (("1"
                                          (inst
                                           "cache1-idxs_bound"
                                           "0")
                                          (("1"
                                            (expand
                                             "nth"
                                             "cache1-idxs_bound")
                                            (("1"
                                              (replace "ac1" :dir RL)
                                              (("1"
                                                (inst
                                                 "cache2-idxs_bound"
                                                 "0")
                                                (("1"
                                                  (expand
                                                   "nth"
                                                   "cache2-idxs_bound")
                                                  (("1"
                                                    (replace
                                                     "ac2"
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (hide-all-but
                                                       (3
                                                        "cache2-idxs_bound"
                                                        "newid2-prop"
                                                        "cache1-idxs_bound"
                                                        -9))
                                                      (("1"
                                                        (expand "max")
                                                        (("1"
                                                          (lift-if -4)
                                                          (("1"
                                                            (split -4)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (expand
                                                                 ">=")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred_res2)
                            (("2" (expand "idxs_bounded")
                              (("2"
                                (inst "cache2-idxs_bound" "i-1")
                                (("1"
                                  (expand "nth" 3)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (typepred "i")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (next_idx_add_ac_ac formula-decl nil affine nil)
    (i skolem-const-decl
     "below(length(cons((re, add_ac_ac(ac1, ac2), null), cache2)))"
     affine_expr_Eval nil)
    (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append_assoc formula-decl nil list_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (add_pd_pd const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (add_ac_ac const-decl "AffineCombination" affine nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (Eval_wCache_TCC26 0
  (Eval_wCache_TCC26-2 nil 3632158301 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (restrict const-decl "R" restrict nil))
   nil)
  (Eval_wCache_TCC26-1 nil 3632143264 ("" (subtype-tcc) nil nil)
   ((BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (idxs_ac const-decl "list[nat]" affine nil))
   shostak))
 (Eval_wCache_TCC27 0
  (Eval_wCache_TCC27-1 nil 3632143264 ("" (tcc) nil nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/")) nil))
 (Eval_wCache_TCC28 0
  (Eval_wCache_TCC28-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (powvar? const-decl "bool" affine_expr nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (Eval_wCache_TCC29 0
  (Eval_wCache_TCC29-1 nil 3632143264
   (""
    (then (skeep*) (assert)
     (spread (split 1)
      ((grind)
       (then (replace -4 1) (assert) (inst 1 "(:car(result`2):)")
        (grind))
       (then (hide -5) (replace -4) (assert) (typepred "cache")
        (expand "idxs_bounded") (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1)
           (typepred "cache_get(cache)(re)") (assert) (skeep)
           (inst? :subst ("i" "i!1")) (assert))
          (then (expand "nth" 2) (assert)
           (inst? :subst ("i" "i-1")))))))))
    nil nil)
   ((append def-decl "list[T]" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (> const-decl "bool" reals nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cache_get def-decl "{res: Maybe[AffineCombination] |
         some?(res) IMPLIES
          (EXISTS (i: below(length(cache))):
             nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res))}"
     affine_expr_Eval_fnd nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil))
   shostak))
 (Eval_wCache_TCC30 0
  (Eval_wCache_TCC30-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil))
   shostak))
 (Eval_wCache_TCC31 0
  (Eval_wCache_TCC31-1 nil 3632143264 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC32 0
  (Eval_wCache_TCC32-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC33 0
  (Eval_wCache_TCC33-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (Eval_wCache_TCC34 0
  (Eval_wCache_TCC34-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   shostak))
 (Eval_wCache_TCC35 0
  (Eval_wCache_TCC35-1 nil 3632143264
   ("" (then (skeep* :preds? t) (assert)) nil nil)
   ((ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (Eval_wCache_TCC36 0
  (Eval_wCache_TCC36-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil))
   nil))
 (Eval_wCache_TCC37 0
  (Eval_wCache_TCC37-2 nil 3632158377 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC37-1 nil 3632143264 ("" (tcc))
   ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil))
   shostak))
 (Eval_wCache_TCC38 0
  (Eval_wCache_TCC38-1 nil 3632143264 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC39 0
  (Eval_wCache_TCC39-2 nil 3632158836 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC39-1 nil 3632143264 ("" (tcc))
   ((ordered_list? def-decl "bool" ordered_list "structures/"))
   shostak))
 (Eval_wCache_TCC40 0
  (Eval_wCache_TCC40-2 nil 3632158947
   (""
    (then (skeep*) (expand "next_idx_2") (typepred "res2") (assert)
     (flatten) (replace -13 :dir RL) (typepred "res1") (assert)
     (flatten) (replaces -16) (hide-all-but (6 -8 -4 -9 -16))
     (expand "idxs_bounded")
     (spread (inst -1 "0")
      ((spread (inst? :subst ("i" "0"))
        ((then (expand "nth") (grind)) (grind)
         (then (reveal 1) (grind))))
       (then (reveal 1) (grind)))))
    nil nil)
   ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (length def-decl "nat" list_props nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (re1 skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (cache skolem-const-decl
     "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (res1 skolem-const-decl
     "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
               NOT null?(val(result)`2) AND car(val(result)`2)`1 = re1
           AND EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache)
           AND val(result)`1 >= nextfreeidx
           AND idxs_bounded(val(result)`1)(val(result)`2)}"
     affine_expr_Eval nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (next_idx_2 const-decl "nat" affine nil))
   nil)
  (Eval_wCache_TCC40-1 nil 3632143264 ("" (tcc)) nil shostak))
 (Eval_wCache_TCC41 0
  (Eval_wCache_TCC41-1 nil 3632143264 ("" (tcc) nil nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/"))
   shostak))
 (Eval_wCache_TCC42 0
  (Eval_wCache_TCC42-1 nil 3632143264
   ("" (then (skeep*) (assert) (hide 1) (hide -6) (grind)) nil nil)
   ((null_ol? const-decl "bool" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (add_ET const-decl "ErrorTerms" affine nil)
    (append_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (mult_ac_ac const-decl "AffineCombination" affine nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (/= const-decl "boolean" notequal nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (length def-decl "nat" list_props nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (Eval_wCache_TCC43 0
  (Eval_wCache_TCC43-1 nil 3632143264
   (""
    (then (skeep*) (assert) (hide -12)
     (apply (then (label "result" -11) (label "ac2" -10)
             (label "cache2" -9) (label "newid2" -8) (label "res2" -7)
             (label "ac1" -6) (label "cache1" -5) (label "newid1" -4)
             (label "res1" -3) (label "cached" -2) (label "re" -1)))
     (deftactic typepred_res2 nil
      (then (typepred "res2") (replace "cache2" -1 :dir RL)
       (replace "newid2" -1 :dir RL) (assert)
       (with-labels (flatten)
        (("cache2 not null" "re2" "cache2-form" "newid2-prop"
          "cache2-idxs_bound")))))
     (deftactic typepred_res1 nil
      (then (typepred "res1") (replace "cache1" -1 :dir RL)
       (replace "newid1" -1 :dir RL) (assert)
       (with-labels (flatten)
        (("cache1 not null" "re1" "cache1-form" "newid1-prop"
          "cache1-idxs_bound")))))
     (spread (split 4)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (typepred_res2) (skolem "cache2-form" "l2")
        (skolem "cache1-form" "l1")
        (replace "cache1-form" "cache2-form") (replace "cache2-form" 3)
        (spread
         (inst 3
          "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))")
         ((then (hide-all-but 3) (expand "append" 1 3)
           (use "append_assoc[CacheData]") (assert))
          (grind)
          (then (expand "next_idx_2") (expand ">=")
           (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL)
              (spread (inst "cache2-idxs_bound" "0")
               ((then (expand "nth" "cache2-idxs_bound")
                 (replace "ac2" :dir RL)
                 (hide-all-but
                  (1 "cache2-idxs_bound" "newid2-prop"
                   "cache1-idxs_bound"))
                 (expand "max") (lift-if 1)
                 (spread (split 1)
                  ((then (flatten) (expand ">=") (propax))
                   (then (flatten) (assert) (expand ">=") (grind)))))
                (grind))))
             (then (hide-all-but (1 4)) (grind))))))))
       (then (replaces "result") (assert) (typepred_res2)
        (typepred_res1) (hide-all-but (3 "newid2-prop" "newid1-prop"))
        (expand ">=")
        (spread (case "nextfreeidx <= newid2")
         ((then (hide-all-but (-1 1)) (lemma "lt_plus_lt2")
           (inst -1 "newid2" "0" "1" "nextfreeidx") (assert))
          (then (hide 2) (assert) (typepred "reals.<=")
           (expand "total_order?") (expand "partial_order?")
           (expand "preorder?") (expand "reflexive?")
           (expand "transitive?") (flatten)
           (inst - "nextfreeidx" "newid1" "newid2")
           (spread (split -) ((propax) (propax) (propax)))))))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1)
           (use "next_idx_mult_ac_ac") (expand ">=") (propax))
          (then (typepred_res2) (expand "idxs_bounded")
           (spread (inst "cache2-idxs_bound" "i-1")
            ((then (expand "nth" 3)
              (hide-all-but (3 "cache2-idxs_bound")) (expand ">=")
              (lemma "lt_plus_lt2")
              (inst -1 "newid2" "0" "1"
               "next_idx(pd(nth(cache2, i - 1)`2))")
              (assert))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (mult_ac_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (append_ol const-decl "ordered_list" ordered_list "structures/")
    (add_ET const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (nth def-decl "T" list_props nil)
    (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (length def-decl "nat" list_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (append_assoc formula-decl nil list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (next_idx_2 const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (newid2 skolem-const-decl "nat" affine_expr_Eval nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (lt_plus_lt2 formula-decl nil real_props nil)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (i skolem-const-decl
     "below(length(cons((re, mult_ac_ac(ac1, ac2, newid2), null), cache2)))"
     affine_expr_Eval nil)
    (below type-eq-decl nil nat_types nil)
    (next_idx_mult_ac_ac formula-decl nil affine nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (Eval_wCache_TCC44 0
  (Eval_wCache_TCC44-1 nil 3632143264 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   shostak))
 (Eval_wCache_TCC45 0
  (Eval_wCache_TCC45-1 nil 3632149132 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/"))
   shostak))
 (Eval_wCache_TCC46 0
  (Eval_wCache_TCC46-2 nil 3632159098
   ("" (then (skeep*) (expand "represents_var?") (grind)) nil nil)
   ((length def-decl "nat" list_props nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (represents_var? const-decl "bool" affine nil))
   nil)
  (Eval_wCache_TCC46-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC47 0
  (Eval_wCache_TCC47-2 nil 3637405210 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (restrict const-decl "R" restrict nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil))
   nil)
  (Eval_wCache_TCC47-1 nil 3632149132
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (replace -11 2)
        (("" (split 2)
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (inst 1 "(: (re, acRes, null) :)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (assert)
            (("3" (expand "idxs_bounded" 1)
              (("3" (skeep)
                (("3" (expand "nth" 1)
                  (("3" (lift-if 1)
                    (("3" (split 1)
                      (("1" (flatten)
                        (("1" (replace -11 1)
                          (("1" (expand "null_ol")
                            (("1" (expand "pow_var_ac" 1)
                              (("1"
                                (lift-if 1)
                                (("1"
                                  (split 1)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split 2)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split 2)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (replace -1 :hide? t)
                                                  (("1"
                                                    (replace
                                                     -10
                                                     :hide?
                                                     t)
                                                    (("1"
                                                      (expand
                                                       "next_idx"
                                                       1)
                                                      (("1"
                                                        (expand
                                                         "last_idx")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (lift-if 1)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (use
                                                                   "last_idx_box")
                                                                  (("1"
                                                                    (expand
                                                                     "next_idx"
                                                                     -1)
                                                                    (("1"
                                                                      (expand
                                                                       "last_idx"
                                                                       -1)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split 2)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "cons_ol")
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (case "pow=1")
                                                  (("1"
                                                    (replaces -1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "cons_ol")
                                                        (("1"
                                                          (expand
                                                           "next_idx"
                                                           2)
                                                          (("1"
                                                            (expand
                                                             "last_idx")
                                                            (("1"
                                                              (expand
                                                               "last_ol")
                                                              (("1"
                                                                (expand
                                                                 "empty_ErrorTerms")
                                                                (("1"
                                                                  (replace
                                                                   -9
                                                                   :hide?
                                                                   t)
                                                                  (("1"
                                                                    (use
                                                                     "last_idx_box")
                                                                    (("1"
                                                                      (expand
                                                                       "next_idx"
                                                                       -1)
                                                                      (("1"
                                                                        (expand
                                                                         "last_idx"
                                                                         -1)
                                                                        (("1"
                                                                          (expand
                                                                           "nth")
                                                                          (("1"
                                                                            (lift-if
                                                                             -1)
                                                                            (("1"
                                                                              (split
                                                                               -1)
                                                                              (("1"
                                                                                (flatten)
                                                                                (("1"
                                                                                  (use
                                                                                   "olidx_car_last[nzBaseType]")
                                                                                  (("1"
                                                                                    (assert)
                                                                                    (("1"
                                                                                      (expand
                                                                                       "car_ol")
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (assert)
                                                                                (("2"
                                                                                  (expand
                                                                                   "length")
                                                                                  (("2"
                                                                                    (propax)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (expand "idxs_bounded" -4)
                          (("2" (inst -4 "i-1")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (ac_proj_pd formula-decl nil affine nil)
    (last_idx_box formula-decl nil affine_box nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (nzBaseType type-eq-decl nil affine nil)
    (olidx_car_last formula-decl nil indexed_list "structures/")
    (lt_idx const-decl "bool" indexed_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (null_ol const-decl "ordered_list" ordered_list "structures/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC48 0
  (Eval_wCache_TCC48-2 nil 3637417843 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol const-decl "ordered_list" ordered_list "structures/")
    (length def-decl "nat" list_props nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil)
  (Eval_wCache_TCC48-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil))
   nil))
 (Eval_wCache_TCC49 0
  (Eval_wCache_TCC49-2 nil 3632159201
   (""
    (then (skeep*) (assert) (expand "null_ol") (hide 1) (hide -6)
     (spread (split 1)
      ((grind)
       (then (replace -5 1) (assert)
        (inst 1 "(: (re, acRes,null)::CacheData :)") (grind))
       (then (replace -5 1) (assert) (typepred "cache")
        (expand "idxs_bounded") (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (replaces -7)
           (use "next_idx_pow_var_ac") (assert) (replaces -1)
           (typepred "nextfreeidx") (replaces -7)
           (expand "last_idx_in_box") (expand "nth_ac") (assert)
           (expand "next_idx") (expand "last_idx") (expand "last_ol")
           (reveal 1) (grind))
          (then (expand "nth" 2) (assert)
           (inst? :subst ("i" "i-1")))))))))
    nil nil)
   ((null_ol const-decl "ordered_list" ordered_list "structures/")
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil)
  (Eval_wCache_TCC49-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC50 0
  (Eval_wCache_TCC50-3 "" 3635153604
   (""
    (then (skeep*) (skeep*) (assert) (expand "null_ol") (hide 1)
     (grind))
    nil nil)
   ((null_ol const-decl "ordered_list" ordered_list "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (length def-decl "nat" list_props nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak)
  (Eval_wCache_TCC50-2 nil 3632159278
   ("" (skeep*)
    (("" (assert)
      (("" (hide -7)
        ((""
          (apply (then (label "re" -1) (label "varac" -2)
                  (label "cached some" -3) (label "pow is cached" -4)
                  (label "cached" -5) (label "result" -6)
                  (label "idx" 1) (label "pow <= 1" 2)
                  (label "varac not single" 3)))
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (split 4)
                  (("1"
                    (inst 1
                     "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (typepred "cache")
                    (("2" (expand "idxs_bounded")
                      (("2" (skeep)
                        (("2" (case "i=0")
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1"
                                (typepred "cached")
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (replaces -3 1 :dir RL)
                                        (("1" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "nth" 2)
                            (("2" (assert) (("2" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   nil)
  (Eval_wCache_TCC50-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC51 0
  (Eval_wCache_TCC51-3 nil 3637420984
   (""
    (then (skeep* :preds? t) (assert) (replace -14 2)
     (spread (split 2)
      ((grind)
       (then (assert)
        (spread
         (inst 1
          "cons[CacheData]( (re, acRes, null)::CacheData, null[CacheData])")
         ((then (expand "append") (expand "append") (propax))
          (then (expand "ordered_list?") (propax)))))
       (then (assert) (expand "idxs_bounded" 1) (skeep)
        (expand "nth" 1) (lift-if 1)
        (spread (split 1)
         ((then (flatten) (replace -14 1) (expand "null_ol")
           (expand "pow_var_ac" 1) (lift-if 1)
           (spread (split 1)
            ((then (flatten) (assert) (expand "next_idx")
              (expand "empty_ErrorTerms") (expand "last_idx") (assert))
             (then (flatten)
              (spread (split 2)
               ((then (flatten) (assert) (expand "next_idx")
                 (expand "empty_ErrorTerms") (expand "last_idx")
                 (assert))
                (then (flatten)
                 (spread (split 2)
                  ((then (flatten)
                    (spread (split 1)
                     ((then (flatten) (replace -1 :hide? t)
                       (replace -10 :hide? t) (expand "next_idx" 1)
                       (expand "last_idx") (assert) (lift-if 1)
                       (spread (split 1)
                        ((then (flatten) (use "last_idx_box")
                          (expand "next_idx" -1) (expand "last_idx" -1)
                          (assert))
                         (assert))))
                      (then (flatten) (assert)))))
                   (then (flatten)
                    (spread (split 2)
                     ((then (assert) (expand "cons_ol") (propax))
                      (then (flatten)
                       (spread (case "pow=1")
                        ((then (replaces -1) (assert)
                          (expand "cons_ol") (expand "next_idx" 2)
                          (expand "last_idx") (expand "last_ol")
                          (expand "empty_ErrorTerms")
                          (replace -9 :hide? t) (use "last_idx_box")
                          (expand "next_idx" -1) (expand "last_idx" -1)
                          (expand "nth") (lift-if -1)
                          (spread (split -1)
                           ((then (flatten)
                             (use "olidx_car_last[nzBaseType]")
                             (assert) (expand "car_ol") (assert))
                            (then (assert) (expand "length")
                             (propax)))))
                         (assert))))))))))))))))
          (then (flatten) (expand "idxs_bounded" -5) (inst -5 "i-1")
           (assert))))))))
    nil nil)
   ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl
     "below(length(cons((re, acRes, null), cache)))" affine_expr_Eval
     nil)
    (cache skolem-const-decl
     "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (acRes skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (null_ol const-decl "ordered_list" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (olidx_car_last formula-decl nil indexed_list "structures/")
    (/= const-decl "boolean" notequal nil)
    (nzBaseType type-eq-decl nil affine nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (last_idx_box formula-decl nil affine_box nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (ac_proj_pd formula-decl nil affine nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (nth def-decl "T" list_props nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (append def-decl "list[T]" list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil)
  (Eval_wCache_TCC51-2 nil 3635153659
   ("" (skeep*)
    (("" (assert)
      (("" (hide -7)
        ((""
          (apply (then (label "re" -1) (label "varac" -2)
                  (label "cached some" -3) (label "pow is cached" -4)
                  (label "cached" -5) (label "result" -6)
                  (label "idx" 1) (label "pow <= 1" 2)
                  (label "varac not single" 3)))
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (split 4)
                  (("1"
                    (inst 1
                     "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (typepred "cache")
                    (("2" (expand "idxs_bounded")
                      (("2" (skeep)
                        (("2" (case "i=0")
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1"
                                (typepred "cached")
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (replaces -3 1 :dir RL)
                                        (("1" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "nth" 2)
                            (("2" (assert) (("2" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil))
   nil)
  (Eval_wCache_TCC51-1 nil 3632149132
   ("" (skeep*)
    (("" (assert)
      (("" (replace -6 4 :hide? t)
        (("" (assert)
          (("" (split 4)
            (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)")
              (("1" (grind) nil nil)) nil)
             ("2" (typepred "cache")
              (("2" (expand "idxs_bounded")
                (("2" (skeep)
                  (("2" (expand "nth" 1)
                    (("2" (lift-if 1)
                      (("2" (split 1)
                        (("1" (flatten) (("1" (postpone) nil nil)) nil)
                         ("2" (inst -2 "i-1")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (represents_var? const-decl "bool" affine nil))
   nil))
 (Eval_wCache_TCC52 0
  (Eval_wCache_TCC52-3 nil 3637421193
   ("" (then (skeep*) (replaces -2) (expand "powvar?") (propax)) nil
    nil)
   ((powvar? const-decl "bool" affine_expr nil)) nil)
  (Eval_wCache_TCC52-2 nil 3632159338
   ("" (skeep*)
    (("" (use "cache_powvar_correct_result")
      (("" (assert)
        (("" (replace -6 -1 :dir RL)
          (("" (expand "CacheData_correct?")
            (("" (typepred "cached")
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (flatten)
                      (("" (split -5)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (replaces -8)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_pd def-decl "list[nat]" affine nil)
    (car_ol const-decl "T" ordered_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (factorial def-decl "posnat" factorial "ints/")
    (C const-decl "posnat" binomial "reals/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (represents_var? const-decl "bool" affine nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC52-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC53 0
  (Eval_wCache_TCC53-3 nil 3635153725
   (""
    (then (skeep*) (assert)
     (apply (then (label "re" -1) (label "varac" -2)
             (label "cached some" -3) (label "pow is cached" -4)
             (label "cached" -5) (label "result" -6) (label "idx" 1)
             (label "pow <= 1" 2) (label "varac not single" 3)))
     (replaces "re") (replaces "result") (assert) (typepred "cache")
     (expand "correct_cache?" 4) (expand "CacheData_correct?")
     (typepred "cached") (assert) (flatten)
     (use "cache_powvar_correct_result") (assert)
     (replace "cached" -1 :dir RL) (expand "CacheData_correct?")
     (flatten)
     (spread (split -2)
      ((then (flatten) (assert) (reveal "re") (grind))
       (then (reveal "re") (grind)))))
    nil nil)
   ((nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil))
   nil)
  (Eval_wCache_TCC53-2 nil 3632159420
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached some" -3) (label "pow < cached pow" -4)
                (label "cached" -5) (label "idxs" -6)
                (label "pownoises" -7) (label "acRes" -8)
                (label "result" -9) (label "idx" 1)
                (label "pow <= 1" 2) (label "no single value" 3)
                (label "no cv 0" 4)))
        (("" (hide 5)
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (expand "correct_cache?" 5)
                  (("" (expand "CacheData_correct?")
                    ((""
                      (with-labels (typepred "cache")
                       (("cache compatible pairs" "cache idxs bound"
                         "cache correct" "UNKNOWN")))
                      (("" (typepred "cached")
                        (("" (assert)
                          ((""
                            (with-labels (flatten)
                             (("cached`1 is powvar" "cached`1 varidx"
                               "cached cache idx" "UNKNOWN")))
                            (("" (skeep "cached cache idx")
                              ((""
                                (use "cache_powvar_correct_result")
                                ((""
                                  (with-labels
                                   (assert)
                                   ("cached is correct" "UNKNOWN"))
                                  ((""
                                    (replace
                                     "cached"
                                     "cached is correct"
                                     :dir
                                     RL)
                                    ((""
                                      (expand "CacheData_correct?")
                                      ((""
                                        (with-labels
                                         (flatten)
                                         (("cached idx in box"
                                           "cached cond ok"
                                           "cached`2 is powvarac"
                                           "UNKNOWN")))
                                        ((""
                                          (split "cached cond ok")
                                          (("1"
                                            (replace
                                             "pownoises"
                                             "cached cond ok"
                                             :dir
                                             RL)
                                            (("1"
                                              (replace
                                               "cached`1 varidx"
                                               "cached cond ok")
                                              (("1"
                                                (reveal "re")
                                                (("1"
                                                  (replace
                                                   "re"
                                                   "cached cond ok")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten
                                                       "cached cond ok")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace
                                             "cached`1 varidx"
                                             "cached cond ok")
                                            (("2"
                                              (replace
                                               "varac"
                                               "no single value")
                                              (("2"
                                                (reveal "re")
                                                (("2"
                                                  (hide-all-but
                                                   ("no single value"
                                                    "cached cond ok"
                                                    "re"))
                                                  (("2"
                                                    (replaces "re")
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC53-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC54 0
  (Eval_wCache_TCC54-4 nil 3637421292
   (""
    (then (skeep*) (assert)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "pow is cached" -6)
             (label "cached" -7) (label "result" -6) (label "idx" 1)
             (label "pow <= 1" 2) (label "varac not single" 3)))
     (replaces "re") (replaces "result") (assert) (typepred "cache")
     (expand "correct_cache?" 4) (expand "CacheData_correct?")
     (typepred "cached") (assert) (flatten)
     (use "cache_powvar_correct_result") (assert)
     (replace "cached" -1 :dir RL) (expand "CacheData_correct?")
     (flatten)
     (spread (split -2)
      ((then (flatten) (assert) (reveal "re") (grind))
       (then (reveal "re") (grind)))))
    nil nil)
   ((nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil))
   nil)
  (Eval_wCache_TCC54-3 nil 3635153793
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached some" -3) (label "pow < cached pow" -4)
                (label "cached" -5) (label "idxs" -6)
                (label "pownoises" -7) (label "acRes" -8)
                (label "result" -9) (label "idx" 1)
                (label "pow <= 1" 2) (label "no single value" 3)
                (label "no cv 0" 4)))
        (("" (hide 5)
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (expand "correct_cache?" 5)
                  (("" (expand "CacheData_correct?")
                    ((""
                      (with-labels (typepred "cache")
                       (("cache compatible pairs" "cache idxs bound"
                         "cache correct" "UNKNOWN")))
                      (("" (typepred "cached")
                        (("" (assert)
                          ((""
                            (with-labels (flatten)
                             (("cached`1 is powvar" "cached`1 varidx"
                               "cached cache idx" "UNKNOWN")))
                            (("" (skeep "cached cache idx")
                              ((""
                                (use "cache_powvar_correct_result")
                                ((""
                                  (with-labels
                                   (assert)
                                   ("cached is correct" "UNKNOWN"))
                                  ((""
                                    (replace
                                     "cached"
                                     "cached is correct"
                                     :dir
                                     RL)
                                    ((""
                                      (expand "CacheData_correct?")
                                      ((""
                                        (with-labels
                                         (flatten)
                                         (("cached idx in box"
                                           "cached cond ok"
                                           "cached`2 is powvarac"
                                           "UNKNOWN")))
                                        ((""
                                          (split "cached cond ok")
                                          (("1"
                                            (replace
                                             "pownoises"
                                             "cached cond ok"
                                             :dir
                                             RL)
                                            (("1"
                                              (replace
                                               "cached`1 varidx"
                                               "cached cond ok")
                                              (("1"
                                                (reveal "re")
                                                (("1"
                                                  (replace
                                                   "re"
                                                   "cached cond ok")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten
                                                       "cached cond ok")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace
                                             "cached`1 varidx"
                                             "cached cond ok")
                                            (("2"
                                              (replace
                                               "varac"
                                               "no single value")
                                              (("2"
                                                (reveal "re")
                                                (("2"
                                                  (hide-all-but
                                                   ("no single value"
                                                    "cached cond ok"
                                                    "re"))
                                                  (("2"
                                                    (replaces "re")
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC54-2 nil 3632159702
   ("" (skeep*)
    (("" (assert)
      (("" (hide -10)
        ((""
          (apply (then (label "re" -1) (label "varac" -2)
                  (label "cached some" -3)
                  (label "pow < cached pow" -4) (label "cached" -5)
                  (label "idxs" -6) (label "pownoises" -7)
                  (label "acRes" -8) (label "result" -9)
                  (label "idx" 1) (label "pow <= 1" 2)
                  (label "no single value" 3) (label "no cv 0" 4)))
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (split 5)
                  (("1"
                    (inst 1
                     "(: (POWVAR(idx, pow), acRes, pownoises) :)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (expand "idxs_bounded")
                    (("2" (skeep)
                      (("2" (case "i=0")
                        (("1" (replaces -1)
                          (("1" (expand "nth" 1)
                            (("1" (replaces "acRes")
                              (("1"
                                (with-labels
                                 (typepred "cache")
                                 (("cache correct"
                                   "cache idxs bound"
                                   "UNKNOWN")))
                                (("1"
                                  (expand
                                   "idxs_bounded"
                                   "cache idxs bound")
                                  (("1"
                                    (typepred "cached")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (flatten -1)
                                         (("cached`1 is powvar"
                                           "cached`1 varidx"
                                           "cached cache idx"
                                           "UNKNOWN")))
                                        (("1"
                                          (skeep "cached cache idx")
                                          (("1"
                                            (inst
                                             "cache idxs bound"
                                             "i!1")
                                            (("1"
                                              (use
                                               "cache_powvar_correct_result")
                                              (("1"
                                                (with-labels
                                                 (assert
                                                  (-1 "cache correct"))
                                                 ("cached is correct"
                                                  "UNKNOWN"))
                                                (("1"
                                                  (replace
                                                   "cached"
                                                   "cached is correct"
                                                   :dir
                                                   RL)
                                                  (("1"
                                                    (expand
                                                     "CacheData_correct?")
                                                    (("1"
                                                      (assert
                                                       ("cached is correct"
                                                        "cached`1 is powvar"))
                                                      (("1"
                                                        (with-labels
                                                         (flatten)
                                                         (("cached idx in box"
                                                           "cached cond ok"
                                                           "cached`2 is powvarac"
                                                           "UNKNOWN")))
                                                        (("1"
                                                          (split
                                                           "cached cond ok")
                                                          (("1"
                                                            (replace
                                                             "cached cache idx"
                                                             "cached`2 is powvarac"
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (replace
                                                               "cached`2 is powvarac"
                                                               "cache idxs bound")
                                                              (("1"
                                                                (replace
                                                                 "cached cache idx"
                                                                 "pownoises"
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (replace
                                                                   "pownoises"
                                                                   "cache idxs bound"
                                                                   :dir
                                                                   RL)
                                                                  (("1"
                                                                    (replace
                                                                     "cached cache idx"
                                                                     "cached`1 varidx"
                                                                     :dir
                                                                     RL)
                                                                    (("1"
                                                                      (replace
                                                                       "cached`1 varidx"
                                                                       "cache idxs bound")
                                                                      (("1"
                                                                        (reveal
                                                                         "re")
                                                                        (("1"
                                                                          (replace
                                                                           "re"
                                                                           "cache idxs bound")
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (use
                                                                               "next_idx_pow_var_ac")
                                                                              (("1"
                                                                                (replaces
                                                                                 -1)
                                                                                (("1"
                                                                                  (use
                                                                                   "next_idx_pow_var_ac")
                                                                                  (("1"
                                                                                    (replaces
                                                                                     -1)
                                                                                    (("1"
                                                                                      (lift-if
                                                                                       1)
                                                                                      (("1"
                                                                                        (split
                                                                                         1)
                                                                                        (("1"
                                                                                          (flatten)
                                                                                          (("1"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (flatten)
                                                                                          (("2"
                                                                                            (split
                                                                                             3)
                                                                                            (("1"
                                                                                              (flatten)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil)
                                                                                             ("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (hide-all-but
                                                                                                 (1
                                                                                                  "cache idxs bound"
                                                                                                  "pow < cached pow"
                                                                                                  "cached cache idx"))
                                                                                                (("2"
                                                                                                  (replaces
                                                                                                   "cached cache idx"
                                                                                                   :dir
                                                                                                   RL)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     ">")
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       ">=")
                                                                                                      (("2"
                                                                                                        (lemma
                                                                                                         "nth_ol[nat,<]")
                                                                                                        (("2"
                                                                                                          (inst
                                                                                                           -1
                                                                                                           "pownoises"
                                                                                                           "opn(nth(cache, i!1)`1)-2"
                                                                                                           "pow-2")
                                                                                                          (("2"
                                                                                                            (assert)
                                                                                                            nil
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (replace
                                                             "cached`1 varidx"
                                                             "cached cond ok")
                                                            (("2"
                                                              (replace
                                                               "varac"
                                                               "no single value")
                                                              (("2"
                                                                (reveal
                                                                 "re")
                                                                (("2"
                                                                  (hide-all-but
                                                                   ("no single value"
                                                                    "cached cond ok"
                                                                    "re"))
                                                                  (("2"
                                                                    (replaces
                                                                     "re")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "nth" 2)
                          (("2" (assert)
                            (("2"
                              (with-labels (typepred "cache")
                               (("cache correct"
                                 "cache idxs bound"
                                 "UNKNOWN")))
                              (("2"
                                (expand
                                 "idxs_bounded"
                                 "cache idxs bound")
                                (("2"
                                  (inst "cache idxs bound" "i-1")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (nth_ol formula-decl nil ordered_list "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC54-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC55 0
  (Eval_wCache_TCC55-3 nil 3637421557
   (""
    (then (skeep*) (assert) (hide -9)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "pow is cached" -6)
             (label "cached" -7) (label "result" -8) (label "idx" 1)
             (label "pow <= 1" 2) (label "varac not single" 3)))
     (replaces "re") (replaces "result") (assert)
     (spread (split 4)
      ((then (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)")
        (grind))
       (then (typepred "cache") (expand "idxs_bounded") (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (typepred "cached")
           (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?))
          (then (expand "nth" 2) (assert) (inst?))))))))
    nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (powvar? const-decl "bool" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (length def-decl "nat" list_props nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil))
   nil)
  (Eval_wCache_TCC55-2 nil 3635153830
   ("" (skeep*)
    (("" (assert)
      (("" (hide -10)
        ((""
          (apply (then (label "re" -1) (label "varac" -2)
                  (label "cached some" -3)
                  (label "pow < cached pow" -4) (label "cached" -5)
                  (label "idxs" -6) (label "pownoises" -7)
                  (label "acRes" -8) (label "result" -9)
                  (label "idx" 1) (label "pow <= 1" 2)
                  (label "no single value" 3) (label "no cv 0" 4)))
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (split 5)
                  (("1"
                    (inst 1
                     "(: (POWVAR(idx, pow), acRes, pownoises) :)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (expand "idxs_bounded")
                    (("2" (skeep)
                      (("2" (case "i=0")
                        (("1" (replaces -1)
                          (("1" (expand "nth" 1)
                            (("1" (replaces "acRes")
                              (("1"
                                (with-labels
                                 (typepred "cache")
                                 (("cache correct"
                                   "cache idxs bound"
                                   "UNKNOWN")))
                                (("1"
                                  (expand
                                   "idxs_bounded"
                                   "cache idxs bound")
                                  (("1"
                                    (typepred "cached")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (flatten -1)
                                         (("cached`1 is powvar"
                                           "cached`1 varidx"
                                           "cached cache idx"
                                           "UNKNOWN")))
                                        (("1"
                                          (skeep "cached cache idx")
                                          (("1"
                                            (inst
                                             "cache idxs bound"
                                             "i!1")
                                            (("1"
                                              (use
                                               "cache_powvar_correct_result")
                                              (("1"
                                                (with-labels
                                                 (assert
                                                  (-1 "cache correct"))
                                                 ("cached is correct"
                                                  "UNKNOWN"))
                                                (("1"
                                                  (replace
                                                   "cached"
                                                   "cached is correct"
                                                   :dir
                                                   RL)
                                                  (("1"
                                                    (expand
                                                     "CacheData_correct?")
                                                    (("1"
                                                      (assert
                                                       ("cached is correct"
                                                        "cached`1 is powvar"))
                                                      (("1"
                                                        (with-labels
                                                         (flatten)
                                                         (("cached idx in box"
                                                           "cached cond ok"
                                                           "cached`2 is powvarac"
                                                           "UNKNOWN")))
                                                        (("1"
                                                          (split
                                                           "cached cond ok")
                                                          (("1"
                                                            (replace
                                                             "cached cache idx"
                                                             "cached`2 is powvarac"
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (replace
                                                               "cached`2 is powvarac"
                                                               "cache idxs bound")
                                                              (("1"
                                                                (replace
                                                                 "cached cache idx"
                                                                 "pownoises"
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (replace
                                                                   "pownoises"
                                                                   "cache idxs bound"
                                                                   :dir
                                                                   RL)
                                                                  (("1"
                                                                    (replace
                                                                     "cached cache idx"
                                                                     "cached`1 varidx"
                                                                     :dir
                                                                     RL)
                                                                    (("1"
                                                                      (replace
                                                                       "cached`1 varidx"
                                                                       "cache idxs bound")
                                                                      (("1"
                                                                        (reveal
                                                                         "re")
                                                                        (("1"
                                                                          (replace
                                                                           "re"
                                                                           "cache idxs bound")
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (use
                                                                               "next_idx_pow_var_ac")
                                                                              (("1"
                                                                                (replaces
                                                                                 -1)
                                                                                (("1"
                                                                                  (use
                                                                                   "next_idx_pow_var_ac")
                                                                                  (("1"
                                                                                    (replaces
                                                                                     -1)
                                                                                    (("1"
                                                                                      (lift-if
                                                                                       1)
                                                                                      (("1"
                                                                                        (split
                                                                                         1)
                                                                                        (("1"
                                                                                          (flatten)
                                                                                          (("1"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (flatten)
                                                                                          (("2"
                                                                                            (split
                                                                                             3)
                                                                                            (("1"
                                                                                              (flatten)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil)
                                                                                             ("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (hide-all-but
                                                                                                 (1
                                                                                                  "cache idxs bound"
                                                                                                  "pow < cached pow"
                                                                                                  "cached cache idx"))
                                                                                                (("2"
                                                                                                  (replaces
                                                                                                   "cached cache idx"
                                                                                                   :dir
                                                                                                   RL)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     ">")
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       ">=")
                                                                                                      (("2"
                                                                                                        (lemma
                                                                                                         "nth_ol[nat,<]")
                                                                                                        (("1"
                                                                                                          (inst
                                                                                                           -1
                                                                                                           "pownoises"
                                                                                                           "opn(nth(cache, i!1)`1)-2"
                                                                                                           "pow-2")
                                                                                                          (("1"
                                                                                                            (assert)
                                                                                                            nil
                                                                                                            nil))
                                                                                                          nil)
                                                                                                         ("2"
                                                                                                          (typepred
                                                                                                           "reals.<")
                                                                                                          (("2"
                                                                                                            (grind)
                                                                                                            nil
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (replace
                                                             "cached`1 varidx"
                                                             "cached cond ok")
                                                            (("2"
                                                              (replace
                                                               "varac"
                                                               "no single value")
                                                              (("2"
                                                                (reveal
                                                                 "re")
                                                                (("2"
                                                                  (hide-all-but
                                                                   ("no single value"
                                                                    "cached cond ok"
                                                                    "re"))
                                                                  (("2"
                                                                    (replaces
                                                                     "re")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "nth" 2)
                          (("2" (assert)
                            (("2"
                              (with-labels (typepred "cache")
                               (("cache correct"
                                 "cache idxs bound"
                                 "UNKNOWN")))
                              (("2"
                                (expand
                                 "idxs_bounded"
                                 "cache idxs bound")
                                (("2"
                                  (inst "cache idxs bound" "i-1")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (nth_ol formula-decl nil ordered_list "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC55-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil))
   nil))
 (Eval_wCache_TCC56 0
  (Eval_wCache_TCC56-2 nil 3637421797
   (""
    (then (skeep*) (use "cache_powvar_correct_result") (assert)
     (replace -6 -1 :dir RL) (expand "CacheData_correct?")
     (typepred "cached") (assert) (flatten) (assert) (flatten)
     (spread (split -5)
      ((then (flatten) (assert) (flatten) (assert) (replaces -8)
        (grind))
       (grind))))
    nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (idxs_pd def-decl "list[nat]" affine nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (factorial def-decl "posnat" factorial "ints/")
    (C const-decl "posnat" binomial "reals/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (represents_var? const-decl "bool" affine nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (powvar? const-decl "bool" affine_expr nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil))
   nil)
  (Eval_wCache_TCC56-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil))
   nil))
 (Eval_wCache_TCC57 0
  (Eval_wCache_TCC57-1 nil 3632149132
   (""
    (then (skeep*) (use "cache_powvar_correct_result") (assert)
     (replace -8 -1 :dir RL) (expand "CacheData_correct?")
     (typepred "cached") (assert) (flatten) (assert) (flatten) (assert)
     (replaces -8) (grind))
    nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (idxs_ac const-decl "list[nat]" affine nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (C const-decl "posnat" binomial "reals/")
    (factorial def-decl "posnat" factorial "ints/")
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (car_ol const-decl "T" ordered_list "structures/")
    (idxs_pd def-decl "list[nat]" affine nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (powvar? const-decl "bool" affine_expr nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil))
   nil))
 (Eval_wCache_TCC58 0
  (Eval_wCache_TCC58-1 nil 3632149132
   (""
    (then (skeep*) (assert)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "pow < cached pow" -6)
             (label "cached" -7) (label "idxs" -8)
             (label "pownoises" -9) (label "acRes" -10)
             (label "result" -11) (label "idx" 1) (label "pow <= 1" 2)
             (label "no single value" 3) (label "no cv 0" 4)))
     (hide 5) (replaces "re") (replaces "result") (assert)
     (expand "correct_cache?" 5) (expand "CacheData_correct?")
     (expand "powvar?") (expand "varidx_powvar")
     (with-labels (typepred "cache")
      (("cache compatible pairs" "cache idxs bound" "cache correct"
        "UNKNOWN")))
     (typepred "cached") (assert)
     (with-labels (flatten)
      (("cached`1 is powvar" "cached`1 varidx" "cached cache idx"
        "UNKNOWN")))
     (skeep "cached cache idx") (use "cache_powvar_correct_result")
     (with-labels (assert) ("cached is correct" "UNKNOWN"))
     (replace "cached" "cached is correct" :dir RL)
     (expand "CacheData_correct?")
     (with-labels (flatten)
      (("cached idx in box" "cached cond ok" "cached`2 is powvarac"
        "UNKNOWN")))
     (spread (split "cached cond ok")
      ((then (replace "pownoises" "cached cond ok" :dir RL)
        (replace "cached`1 varidx" "cached cond ok") (reveal "re")
        (replace "re" "cached cond ok") (assert)
        (flatten "cached cond ok") (assert) (flatten) (assert)
        (expand "varidx_powvar") (propax))
       (then (replace "cached`1 varidx" "cached cond ok")
        (replace "varac" "no single value") (reveal "re")
        (hide-all-but ("no single value" "cached cond ok" "re"))
        (replaces "re") (assert) (expand "varidx_powvar") (grind)))))
    nil nil)
   ((CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (powvar? const-decl "bool" affine_expr nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (Eval_wCache_TCC59 0
  (Eval_wCache_TCC59-2 nil 3632159972
   (""
    (then (skeep*) (assert) (hide -12)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "pow < cached pow" -6)
             (label "cached" -7) (label "idxs" -8)
             (label "pownoises" -9) (label "acRes" -10)
             (label "result" -11) (label "idx" 1) (label "pow <= 1" 2)
             (label "no single value" 3) (label "no cv 0" 4)))
     (replaces "re") (replaces "result") (assert)
     (spread (split 5)
      ((then (inst 1 "(: (re, acRes, pownoises) :)") (grind))
       (then (expand "idxs_bounded") (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (replaces "acRes")
           (with-labels (typepred "cache")
            (("cache correct" "cache idxs bound" "UNKNOWN")))
           (expand "idxs_bounded" "cache idxs bound")
           (typepred "cached") (assert)
           (with-labels (flatten -1)
            (("cached`1 is powvar" "cached`1 varidx" "cached cache idx"
              "UNKNOWN")))
           (skeep "cached cache idx") (inst "cache idxs bound" "i!1")
           (use "cache_powvar_correct_result")
           (with-labels (assert (-1 "cache correct"))
            ("cached is correct" "UNKNOWN"))
           (replace "cached" "cached is correct" :dir RL)
           (expand "CacheData_correct?")
           (assert ("cached is correct" "cached`1 is powvar"))
           (with-labels (flatten)
            (("cached idx in box" "cached cond ok"
              "cached`2 is powvarac" "UNKNOWN")))
           (spread (split "cached cond ok")
            ((then
              (replace "cached cache idx" "cached`2 is powvarac"
                :dir RL)
              (replace "cached`2 is powvarac" "cache idxs bound")
              (replace "cached cache idx" "pownoises" :dir RL)
              (replace "pownoises" "cache idxs bound" :dir RL)
              (replace "cached cache idx" "cached`1 varidx" :dir RL)
              (replace "cached`1 varidx" "cache idxs bound")
              (reveal "re") (replace "re" "cache idxs bound") (assert)
              (use "next_idx_pow_var_ac") (replaces -1)
              (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1)
              (spread (split 1)
               ((then (flatten) (assert))
                (then (flatten)
                 (spread (split 3)
                  ((then (flatten) (assert))
                   (then (assert)
                    (hide-all-but
                     (1 "cache idxs bound" "pow < cached pow"
                      "cached cache idx"))
                    (replaces "cached cache idx" :dir RL) (expand ">")
                    (expand ">=")
                    (spread (lemma "nth_ol[nat,<]")
                     ((then
                       (inst -1 "pownoises" "opn(nth(cache, i!1)`1)-2"
                        "pow-2")
                       (assert) (expand "varidx_powvar") (grind))
                      (then (typepred "reals.<") (grind)))))))))))
             (then (replace "cached`1 varidx" "cached cond ok")
              (replace "varac" "no single value") (reveal "re")
              (hide-all-but ("no single value" "cached cond ok" "re"))
              (replaces "re") (assert) (expand "varidx_powvar")
              (grind)))))
          (then (expand "nth" 2) (assert)
           (with-labels (typepred "cache")
            (("cache correct" "cache idxs bound" "UNKNOWN")))
           (expand "idxs_bounded" "cache idxs bound")
           (inst "cache idxs bound" "i-1"))))))))
    nil nil)
   ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (below type-eq-decl nil naturalnumbers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (varidx_powvar const-decl "nat" affine_expr nil)
    (below type-eq-decl nil nat_types nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (nth_ol formula-decl nil ordered_list "structures/")
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (trichotomous? const-decl "bool" orders nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (strict_total_order? const-decl "bool" orders nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (next_idx const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (represents_var? const-decl "bool" affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil)
  (Eval_wCache_TCC59-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC60 0
  (Eval_wCache_TCC60-4 nil 3635154099 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (Eval_wCache_TCC60-3 nil 3635153975
   ("" (skeep*)
    ((""
      (apply (then (label "re" -1) (label "varac" -2)
              (label "cached some" -3) (label "cached" -4)
              (label "idxs" -5) (label "pownoises" -6)
              (label "newoff" -7) (label "nwidxs" -8) (label "idx" 1)
              (label "pow <= 1" 2) (label "varac not single value" 3)
              (label "cv not 0" 4) (label "not in cache 2" 5)
              (label "not in cache 1" 6)))
      ((""
        (with-labels (split "not in cache 1")
         (("pow gt opn cached`1")))
        ((""
          (with-labels (split "not in cache 2")
           (("pow gt opn cached`1")))
          (("1" (expand "/=") (("1" (propax) nil)))
           ("2" (replaces "nwidxs" 7)
            (("2" (split 7)
              (("1" (use "cache_powvar_correct_result")
                (("1" (with-labels (assert) (("cached correct")))
                  (("1" (replace "cached" "cached correct" :dir RL)
                    (("1"
                      (expand "CacheData_correct?" "cached correct")
                      (("1" (typepred "cached")
                        (("1" (assert)
                          (("1"
                            (with-labels (flatten)
                             (("cached`1 is powvar" "cached`1 varidx"
                               "cached cache idx" "UNKNOWN")))
                            (("1" (assert)
                              (("1"
                                (with-labels
                                 (flatten)
                                 (("cached idx in box"
                                   "cached cond ok"
                                   "cached`2 is powvarac"
                                   "UNKNOWN")))
                                (("1"
                                  (split "cached cond ok")
                                  (("1"
                                    (split "cached correct")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (name
                                         "nwidxs2"
                                         "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))")
                                        (("1"
                                          (typepred "nwidxs2")
                                          (("1"
                                            (expand "append_ol")
                                            (("1" (assert) nil)))))
                                         ("2"
                                          (expand "appendable_ol?")
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (case
                                               "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)")
                                              (("1"
                                                (replaces -1 3)
                                                (("1"
                                                  (case
                                                   "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx")
                                                  (("1"
                                                    (replaces -1 3)
                                                    (("1"
                                                      (with-labels
                                                       (typepred
                                                        "cache")
                                                       (("cache compatible pairs"
                                                         "cache correct"
                                                         "UNKNOWN")))
                                                      (("1"
                                                        (skeep
                                                         "cached cache idx")
                                                        (("1"
                                                          (replace
                                                           "pownoises"
                                                           1)
                                                          (("1"
                                                            (replace
                                                             "cached cache idx"
                                                             1
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (replace
                                                               "cached cache idx"
                                                               "cached`2 is powvarac"
                                                               :dir
                                                               RL)
                                                              (("1"
                                                                (use
                                                                 "next_idx_pow_var_ac")
                                                                (("1"
                                                                  (replaces
                                                                   -1)
                                                                  (("1"
                                                                    (grind)
                                                                    nil)))))))))))))))))
                                                   ("2"
                                                    (hide-all-but
                                                     (1
                                                      3
                                                      "cached correct"
                                                      "pow gt opn cached`1"))
                                                    (("2"
                                                      (replaces -2 1)
                                                      (("2"
                                                        (expand
                                                         "nats"
                                                         1)
                                                        (("2"
                                                          (lift-if 1)
                                                          (("2"
                                                            (split 1)
                                                            (("1"
                                                              (grind)
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (expand_ol)
                                                                (("2"
                                                                  (expand
                                                                   "first_ol")
                                                                  (("2"
                                                                    (propax)
                                                                    nil)))))))))))))))))))))
                                               ("2"
                                                (use
                                                 "last_take_nth[nat,<]")
                                                (("1" (assert) nil)
                                                 ("2" (assert) nil)))
                                               ("3" (assert) nil)
                                               ("4" (assert) nil)))))))
                                         ("3"
                                          (use "take_ol[nat,<]")
                                          (("3" (assert) nil)))
                                         ("4" (assert) nil)))))
                                     ("2" (propax) nil)))
                                   ("2"
                                    (replace
                                     "cached`1 varidx"
                                     "cached cond ok")
                                    (("2"
                                      (hide-all-but
                                       ("varac"
                                        "varac not single value"
                                        "cached cond ok"
                                        "re"))
                                      (("2"
                                        (grind)
                                        nil)))))))))))))))))))))))))
               ("2" (lift-if 1)
                (("2" (split 1)
                  (("1" (flatten)
                    (("1" (split 1)
                      (("1" (use "length_append[nat]")
                        (("1" (replaces -1)
                          (("1"
                            (typepred "nats(nextfreeidx, newoff - 1)")
                            (("1" (replaces -4 2)
                              (("1"
                                (use "length_take[nat]")
                                (("1"
                                  (replaces -1 2)
                                  (("1"
                                    (case
                                     "length(pownoises) > opn(val(cached)`1) - 2")
                                    (("1"
                                      (expand "min" 2)
                                      (("1"
                                        (lift-if 2)
                                        (("1"
                                          (case
                                           "length(pownoises) = opn(val(cached)`1) - 1")
                                          (("1" (assert) nil)
                                           ("2" (assert) nil)))))))
                                     ("2"
                                      (replace "pownoises" 1)
                                      (("2"
                                        (with-labels
                                         (typepred "cache")
                                         (("cache compatible pairs"
                                           "cache correct"
                                           "UNKNOWN")))
                                        (("2"
                                          (use
                                           "cache_powvar_correct_result")
                                          (("2"
                                            (with-labels
                                             (assert)
                                             (("cached correct")))
                                            (("2"
                                              (replace
                                               "cached"
                                               "cached correct"
                                               :dir
                                               RL)
                                              (("2"
                                                (expand
                                                 "CacheData_correct?"
                                                 "cached correct")
                                                (("2"
                                                  (typepred "cached")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (with-labels
                                                       (flatten)
                                                       (("cached`1 is powvar"
                                                         "cached`1 varidx"
                                                         "cached cache idx"
                                                         "UNKNOWN")))
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (with-labels
                                                           (flatten)
                                                           (("cached idx in box"
                                                             "cached cond ok"
                                                             "cached`2 is powvarac"
                                                             "UNKNOWN")))
                                                          (("2"
                                                            (replace
                                                             "cached`1 varidx"
                                                             "cached cond ok")
                                                            (("2"
                                                              (hide-all-but
                                                               ("varac"
                                                                "varac not single value"
                                                                "cached cond ok"
                                                                "re"))
                                                              (("2"
                                                                (grind)
                                                                nil)))))))))))))))))))))))))))))))
                                 ("2" (assert) nil)))))
                             ("2" (assert) nil)))))
                         ("2" (assert) nil) ("3" (assert) nil)))
                       ("2" (flatten)
                        (("2" (replace "pownoises" 2)
                          (("2"
                            (with-labels (typepred "cache")
                             (("cache compatible pairs" "cache correct"
                               "UNKNOWN")))
                            (("2" (use "cache_powvar_correct_result")
                              (("2"
                                (with-labels
                                 (assert)
                                 (("cached correct")))
                                (("2"
                                  (replace
                                   "cached"
                                   "cached correct"
                                   :dir
                                   RL)
                                  (("2"
                                    (expand
                                     "CacheData_correct?"
                                     "cached correct")
                                    (("2"
                                      (typepred "cached")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (with-labels
                                           (flatten)
                                           (("cached`1 is powvar"
                                             "cached`1 varidx"
                                             "cached cache idx"
                                             "UNKNOWN")))
                                          (("2"
                                            (assert)
                                            (("2"
                                              (with-labels
                                               (flatten)
                                               (("cached idx in box"
                                                 "cached cond ok"
                                                 "cached`2 is powvarac"
                                                 "UNKNOWN")))
                                              (("2"
                                                (replace
                                                 "cached`1 varidx"
                                                 "cached cond ok")
                                                (("2"
                                                  (split
                                                   "cached cond ok")
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (replaces
                                                       "varac"
                                                       2)
                                                      (("1"
                                                        (replace
                                                         "re"
                                                         "cached cond ok")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (case
                                                             "car[nat]
                                                                            (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                    nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)")
                                                            (("1"
                                                              (replaces
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (grind)
                                                                  nil)))))
                                                             ("2"
                                                              (expand
                                                               "take"
                                                               1)
                                                              (("2"
                                                                (expand
                                                                 "append"
                                                                 1)
                                                                (("2"
                                                                  (propax)
                                                                  nil)))))
                                                             ("3"
                                                              (grind)
                                                              nil)))))))))))
                                                   ("2"
                                                    (hide-all-but
                                                     ("varac"
                                                      "varac not single value"
                                                      "cached cond ok"
                                                      "re"))
                                                    (("2"
                                                      (grind)
                                                      nil)))))))))))))))))))))))))))))))))))
                   ("2" (flatten)
                    (("2" (split 2)
                      (("1" (typepred "nats(nextfreeidx, newoff - 1)")
                        (("1" (replace -4 2)
                          (("1" (replace "newoff" 2)
                            (("1" (assert) nil)))))
                         ("2" (assert) nil)))
                       ("2" (flatten)
                        (("2" (expand "nats" 2)
                          (("2" (replace "newoff" 2)
                            (("2" (lift-if 2)
                              (("2"
                                (split 2)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace "varac" 1)
                                      (("1"
                                        (typepred "nextfreeidx")
                                        (("1"
                                          (use "last_idx_box")
                                          (("1" (assert) nil)))))))))))
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (expand_ol)
                                    (("2"
                                      (replace "varac" 2)
                                      (("2"
                                        (typepred "nextfreeidx")
                                        (("2"
                                          (use "last_idx_box")
                                          (("2"
                                            (assert)
                                            nil))))))))))))))))))))))))))))))))))))))))
    nil)
   nil nil)
  (Eval_wCache_TCC60-2 nil 3632160081
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached some" -3) (label "cached" -4)
                (label "idxs" -5) (label "pownoises" -6)
                (label "newoff" -7) (label "nwidxs" -8)
                (label "acRes" -9) (label "result" -10) (label "idx" 1)
                (label "pow <= 1" 2) (label "varac not single value" 3)
                (label "cv not 0" 4) (label "pow gt opn" 5)
                (label "opw gt opn" 6)))
        (("" (replaces "result")
          (("" (assert)
            (("" (split 7)
              (("1" (expand "every")
                (("1" (split 1)
                  (("1" (replace "nwidxs" 1)
                    (("1"
                      (with-labels (typepred "cache")
                       (("cache correct" "cache idxs bound"
                         "UNKNOWN")))
                      (("1" (use "cache_powvar_correct_result")
                        (("1"
                          (with-labels (assert (-1 "cache correct"))
                           (("cached correct")))
                          (("1"
                            (replace "cached" "cached correct" :dir RL)
                            (("1"
                              (expand "CacheData_correct?"
                                      "cached correct")
                              (("1"
                                (typepred "cached")
                                (("1"
                                  (assert)
                                  (("1"
                                    (with-labels
                                     (flatten)
                                     (("cached`1 is powvar"
                                       "cached`1 varidx"
                                       "cached cache idx"
                                       "UNKNOWN")))
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (flatten "cached correct")
                                         (("cached idx in box"
                                           "cached cond ok"
                                           "cached`2 is powvarac"
                                           "UNKNOWN")))
                                        (("1"
                                          (split "cached cond ok")
                                          (("1"
                                            (split 1)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (name
                                                 "nwidxs2"
                                                 "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))")
                                                (("1"
                                                  (typepred "nwidxs2")
                                                  (("1"
                                                    (expand
                                                     "append_ol")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand
                                                   "appendable_ol?")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (case
                                                       "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)")
                                                      (("1"
                                                        (replaces -1 3)
                                                        (("1"
                                                          (case
                                                           "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             3)
                                                            (("1"
                                                              (skeep
                                                               "cached cache idx")
                                                              (("1"
                                                                (replace
                                                                 "pownoises"
                                                                 1)
                                                                (("1"
                                                                  (replace
                                                                   "cached cache idx"
                                                                   1
                                                                   :dir
                                                                   RL)
                                                                  (("1"
                                                                    (expand
                                                                     "idxs_bounded"
                                                                     "cache idxs bound")
                                                                    (("1"
                                                                      (inst
                                                                       "cache idxs bound"
                                                                       "i")
                                                                      (("1"
                                                                        (replace
                                                                         "cached cache idx"
                                                                         "cached`2 is powvarac"
                                                                         :dir
                                                                         RL)
                                                                        (("1"
                                                                          (replace
                                                                           "cached`2 is powvarac"
                                                                           "cache idxs bound")
                                                                          (("1"
                                                                            (use
                                                                             "next_idx_pow_var_ac")
                                                                            (("1"
                                                                              (case
                                                                               "NOT length(pd(nth_ac(box, varidx(nth(cache, i)`1)))) = 0")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (replace
                                                                                   -1
                                                                                   :hide?
                                                                                   t)
                                                                                  (("1"
                                                                                    (lift-if
                                                                                     "cache idxs bound")
                                                                                    (("1"
                                                                                      (split
                                                                                       "cache idxs bound")
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (hide-all-but
                                                                                           (-1
                                                                                            -3
                                                                                            "cached cond ok"
                                                                                            "cached cache idx"
                                                                                            2))
                                                                                          (("1"
                                                                                            (replaces
                                                                                             "cached cache idx")
                                                                                            (("1"
                                                                                              (grind)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (flatten)
                                                                                        (("2"
                                                                                          (expand
                                                                                           ">=")
                                                                                          (("2"
                                                                                            (hide-all-but
                                                                                             ("cache idxs bound"
                                                                                              4))
                                                                                            (("2"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (hide-all-but
                                                                                 (-1
                                                                                  "cached cache idx"
                                                                                  "varac"
                                                                                  "varac not single value"
                                                                                  "cached`1 varidx"
                                                                                  "re"))
                                                                                (("2"
                                                                                  (replaces
                                                                                   "re")
                                                                                  (("2"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide-all-but
                                                             (1
                                                              3
                                                              5
                                                              -1
                                                              "pow gt opn"
                                                              "opw gt opn"))
                                                            (("2"
                                                              (expand
                                                               "nats"
                                                               1)
                                                              (("2"
                                                                (lift-if
                                                                 1)
                                                                (("2"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (expand_ol)
                                                                      (("2"
                                                                        (expand
                                                                         "first_ol")
                                                                        (("2"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (use
                                                             "last_take_nth[nat,<]")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (use
                                                         "last_take_nth[nat,<]")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("4"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3" (assert) nil nil)
                                                 ("4"
                                                  (use
                                                   "take_ol[nat,<]")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil)
                                           ("2"
                                            (replace
                                             "cached`1 varidx"
                                             "cached cond ok")
                                            (("2"
                                              (hide-all-but
                                               ("varac"
                                                "varac not single value"
                                                "cached cond ok"
                                                "re"))
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (typepred "cache")
                      (("2" (generalize "cache" "cache")
                        (("2" (induct "cache")
                          (("1" (grind) nil nil)
                           ("2" (skolem 1 ("h" "t"))
                            (("2" (flatten)
                              (("2"
                                (expand "every" 1)
                                (("2"
                                  (split 1)
                                  (("1"
                                    (typepred "h`3")
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (split -1)
                                      (("1"
                                        (expand "correct_cache?" -1)
                                        (("1" (flatten) nil nil))
                                        nil)
                                       ("2"
                                        (expand "idxs_bounded")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (expand "nth" -2)
                                            (("2"
                                              (inst?
                                               :subst
                                               ("i" "i+1"))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (typepred "i")
                                                (("2" (grind) nil nil))
                                                nil)
                                               ("3"
                                                (typepred "i")
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (expand "correct_cache?" -1)
                                        (("3" (flatten) nil nil))
                                        nil)
                                       ("4"
                                        (expand "idxs_bounded")
                                        (("4"
                                          (skeep)
                                          (("4"
                                            (expand "nth" -2)
                                            (("4"
                                              (inst?
                                               :subst
                                               ("i" "i+1"))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (typepred "i")
                                                (("2" (grind) nil nil))
                                                nil)
                                               ("3"
                                                (typepred "i")
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "correct_cache?")
                (("2" (expand "CacheData_correct?")
                  (("2" (replace "re" 1)
                    (("2" (assert)
                      (("2" (lift-if "nwidxs")
                        (("2" (split "nwidxs")
                          (("1"
                            (with-labels (flatten "nwidxs")
                             (("opn >= 2" "nwidxs")))
                            (("1" (replace "nwidxs" 1)
                              (("1"
                                (split 1)
                                (("1"
                                  (use "length_append[nat]")
                                  (("1"
                                    (replaces -1 1)
                                    (("1"
                                      (with-labels
                                       (typepred
                                        "nats(nextfreeidx, newoff - 1)")
                                       (("nats list[nat]"
                                         "nats ol"
                                         "nats not null"
                                         "nats car"
                                         "nats length"
                                         "nats i")
                                        ("newoff >= 1")))
                                      (("1"
                                        (replaces "nats length" 2)
                                        (("1"
                                          (case
                                           "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                                          (("1"
                                            (replaces -1 2)
                                            (("1"
                                              (replace "newoff" 2)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use "length_take[nat]")
                                            (("1"
                                              (replaces -1 1)
                                              (("1"
                                                (expand "min")
                                                (("1"
                                                  (lift-if 1)
                                                  (("1"
                                                    (split 1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (replace
                                                         "pownoises")
                                                        (("2"
                                                          (with-labels
                                                           (typepred
                                                            "cache")
                                                           (("cache correct"
                                                             "cache idxs bounded"
                                                             "UNKNOWN")))
                                                          (("2"
                                                            (use
                                                             "cache_powvar_correct_result")
                                                            (("2"
                                                              (with-labels
                                                               (assert
                                                                -1)
                                                               (("cached correct")))
                                                              (("2"
                                                                (replace
                                                                 "cached"
                                                                 "cached correct"
                                                                 :dir
                                                                 RL)
                                                                (("2"
                                                                  (expand
                                                                   "CacheData_correct?"
                                                                   "cached correct")
                                                                  (("2"
                                                                    (typepred
                                                                     "cached")
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (replace
                                                                               -2
                                                                               "cached correct")
                                                                              (("2"
                                                                                (replace
                                                                                 "re"
                                                                                 "cached correct")
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil)
                                           ("3" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil)
                                   ("3" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (case
                                     "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                     nats(nextfreeidx, newoff - 1))) = car(pownoises)")
                                    (("1"
                                      (replaces -1 2)
                                      (("1"
                                        (with-labels
                                         (typepred "cache")
                                         (("cache correct"
                                           "cache idxs bounded"
                                           "UNKNOWN")))
                                        (("1"
                                          (use
                                           "cache_powvar_correct_result")
                                          (("1"
                                            (with-labels
                                             (assert -1)
                                             (("cached correct")))
                                            (("1"
                                              (replace
                                               "cached"
                                               "cached correct"
                                               :dir
                                               RL)
                                              (("1"
                                                (expand
                                                 "CacheData_correct?"
                                                 "cached correct")
                                                (("1"
                                                  (typepred "cached")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (split
                                                             "cached correct")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (split
                                                                 -2)
                                                                (("1"
                                                                  (replace
                                                                   -4
                                                                   "cached correct")
                                                                  (("1"
                                                                    (replace
                                                                     "re"
                                                                     "cached correct")
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (expand
                                                                   "length")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (replace
                                                               "varac"
                                                               "varac not single value")
                                                              (("2"
                                                                (replace
                                                                 -3
                                                                 "cached correct")
                                                                (("2"
                                                                  (replace
                                                                   "re"
                                                                   "cached correct")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "append" 1)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand "take" -1)
                                              (("1"
                                                (case
                                                 "length(pownoises) >= opn(val(cached)`1) - 1")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (hide -1)
                                                  (("2"
                                                    (replace
                                                     "pownoises"
                                                     1)
                                                    (("2"
                                                      (with-labels
                                                       (typepred
                                                        "cache")
                                                       (("cache correct"
                                                         "cache idxs bounded"
                                                         "UNKNOWN")))
                                                      (("2"
                                                        (use
                                                         "cache_powvar_correct_result")
                                                        (("2"
                                                          (with-labels
                                                           (assert)
                                                           (("cached correct")))
                                                          (("2"
                                                            (replace
                                                             "cached"
                                                             "cached correct"
                                                             :dir
                                                             RL)
                                                            (("2"
                                                              (expand
                                                               "CacheData_correct?"
                                                               "cached correct")
                                                              (("2"
                                                                (typepred
                                                                 "cached")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (replace
                                                                           "varac"
                                                                           "varac not single value")
                                                                          (("2"
                                                                            (replace
                                                                             -2
                                                                             "cached correct")
                                                                            (("2"
                                                                              (replace
                                                                               "re"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "take" 2)
                                                (("2"
                                                  (case
                                                   "length(pownoises) >= opn(val(cached)`1) - 1")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (replace
                                                     "pownoises"
                                                     1)
                                                    (("2"
                                                      (with-labels
                                                       (typepred
                                                        "cache")
                                                       (("cache correct"
                                                         "cache idxs bounded"
                                                         "UNKNOWN")))
                                                      (("2"
                                                        (use
                                                         "cache_powvar_correct_result")
                                                        (("2"
                                                          (with-labels
                                                           (assert)
                                                           (("cached correct")))
                                                          (("2"
                                                            (replace
                                                             "cached"
                                                             "cached correct"
                                                             :dir
                                                             RL)
                                                            (("2"
                                                              (expand
                                                               "CacheData_correct?"
                                                               "cached correct")
                                                              (("2"
                                                                (typepred
                                                                 "cached")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (replace
                                                                           "varac"
                                                                           "varac not single value")
                                                                          (("2"
                                                                            (replace
                                                                             -2
                                                                             "cached correct")
                                                                            (("2"
                                                                              (replace
                                                                               "re"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (replace "pownoises" 1)
                                      (("3"
                                        (with-labels
                                         (typepred "cache")
                                         (("cache correct"
                                           "cache idxs bounded"
                                           "UNKNOWN")))
                                        (("3"
                                          (use
                                           "cache_powvar_correct_result")
                                          (("3"
                                            (with-labels
                                             (assert)
                                             (("cached correct")))
                                            (("3"
                                              (replace
                                               "cached"
                                               "cached correct"
                                               :dir
                                               RL)
                                              (("3"
                                                (expand
                                                 "CacheData_correct?"
                                                 "cached correct")
                                                (("3"
                                                  (typepred "cached")
                                                  (("3"
                                                    (assert)
                                                    (("3"
                                                      (flatten)
                                                      (("3"
                                                        (assert)
                                                        (("3"
                                                          (flatten)
                                                          (("3"
                                                            (split
                                                             "cached correct")
                                                            (("1"
                                                              (expand
                                                               "length")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (replace
                                                               "varac"
                                                               "varac not single value")
                                                              (("2"
                                                                (replace
                                                                 -3
                                                                 "cached correct")
                                                                (("2"
                                                                  (replace
                                                                   "re"
                                                                   "cached correct")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4" (assert) nil nil)
                                     ("5" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (replace -1 2)
                              (("2"
                                (split 2)
                                (("1"
                                  (typepred
                                   "nats(nextfreeidx, newoff - 1)")
                                  (("1"
                                    (replace -4 2)
                                    (("1"
                                      (replace "newoff" 2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (typepred
                                     "nats(nextfreeidx, newoff - 1)")
                                    (("1"
                                      (inst -5 "0")
                                      (("1"
                                        (expand "nth")
                                        (("1"
                                          (replace -5 3)
                                          (("1"
                                            (typepred "nextfreeidx")
                                            (("1"
                                              (use "last_idx_box")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (replace -4 1)
                                        (("2"
                                          (replace "newoff" 1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (replaces "newoff")
                (("3" (hide-all-but (1 "pow gt opn" "opw gt opn"))
                  (("3" (case "opn(val(cached)`1) < pow")
                    (("1" (hide "pow gt opn" "opw gt opn")
                      (("1"
                        (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                        (("1" (replaces -1)
                          (("1" (case "0 <= pow - opn(val(cached)`1)")
                            (("1"
                              (name-replace "A"
                               "pow - opn(val(cached)`1)")
                              (("1" (assert) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (take_ol formula-decl nil ordered_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (first_ol const-decl "T" ordered_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (represents_var? const-decl "bool" affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (last_take_nth formula-decl nil ordered_list "structures/")
    (appendable_ol? const-decl "bool" ordered_list "structures/")
    (append_ol const-decl "ordered_list" ordered_list "structures/")
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_idx_box formula-decl nil affine_box nil))
   nil)
  (Eval_wCache_TCC60-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC61 0
  (Eval_wCache_TCC61-4 nil 3637421951 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (Eval_wCache_TCC61-3 nil 3635154882
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached some" -3) (label "cached" -4)
                (label "idxs" -5) (label "pownoises" -6)
                (label "newoff" -7) (label "nwidxs" -8)
                (label "acRes" -9) (label "result" -10) (label "idx" 1)
                (label "pow <= 1" 2) (label "varac not single value" 3)
                (label "cv not 0" 4) (label "pow gt opn" 5)
                (label "opw gt opn" 6)))
        (("" (replaces "result")
          (("" (assert)
            (("" (split 7)
              (("1" (expand "every")
                (("1" (split 1)
                  (("1" (replace "nwidxs" 1)
                    (("1"
                      (with-labels (typepred "cache")
                       (("cache correct" "cache idxs bound"
                         "UNKNOWN")))
                      (("1" (use "cache_powvar_correct_result")
                        (("1"
                          (with-labels (assert (-1 "cache correct"))
                           (("cached correct")))
                          (("1"
                            (replace "cached" "cached correct" :dir RL)
                            (("1"
                              (expand "CacheData_correct?"
                                      "cached correct")
                              (("1"
                                (typepred "cached")
                                (("1"
                                  (assert)
                                  (("1"
                                    (with-labels
                                     (flatten)
                                     (("cached`1 is powvar"
                                       "cached`1 varidx"
                                       "cached cache idx"
                                       "UNKNOWN")))
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (flatten "cached correct")
                                         (("cached idx in box"
                                           "cached cond ok"
                                           "cached`2 is powvarac"
                                           "UNKNOWN")))
                                        (("1"
                                          (split "cached cond ok")
                                          (("1"
                                            (split 1)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (name
                                                 "nwidxs2"
                                                 "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))")
                                                (("1"
                                                  (typepred "nwidxs2")
                                                  (("1"
                                                    (expand
                                                     "append_ol")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (typepred
                                                     "reals.<")
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (assert)
                                                  (("3"
                                                    (expand
                                                     "appendable_ol?")
                                                    (("3"
                                                      (flatten)
                                                      (("3"
                                                        (case
                                                         "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)")
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           3)
                                                          (("1"
                                                            (case
                                                             "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx")
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               3)
                                                              (("1"
                                                                (skeep
                                                                 "cached cache idx")
                                                                (("1"
                                                                  (replace
                                                                   "pownoises"
                                                                   1)
                                                                  (("1"
                                                                    (replace
                                                                     "cached cache idx"
                                                                     1
                                                                     :dir
                                                                     RL)
                                                                    (("1"
                                                                      (expand
                                                                       "idxs_bounded"
                                                                       "cache idxs bound")
                                                                      (("1"
                                                                        (inst
                                                                         "cache idxs bound"
                                                                         "i")
                                                                        (("1"
                                                                          (replace
                                                                           "cached cache idx"
                                                                           "cached`2 is powvarac"
                                                                           :dir
                                                                           RL)
                                                                          (("1"
                                                                            (replace
                                                                             "cached`2 is powvarac"
                                                                             "cache idxs bound")
                                                                            (("1"
                                                                              (use
                                                                               "next_idx_pow_var_ac")
                                                                              (("1"
                                                                                (case
                                                                                 "NOT length(pd(nth_ac(box, varidx(nth(cache, i)`1)))) = 0")
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (hide-all-but
                                                                                   (-1
                                                                                    "cached cache idx"
                                                                                    "varac"
                                                                                    "varac not single value"
                                                                                    "cached`1 varidx"
                                                                                    "re"))
                                                                                  (("2"
                                                                                    (replaces
                                                                                     "re")
                                                                                    (("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide-all-but
                                                               (1
                                                                3
                                                                5
                                                                -1
                                                                "pow gt opn"
                                                                "opw gt opn"))
                                                              (("2"
                                                                (expand
                                                                 "nats"
                                                                 1)
                                                                (("2"
                                                                  (lift-if
                                                                   1)
                                                                  (("2"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (expand_ol)
                                                                        (("2"
                                                                          (expand
                                                                           "first_ol")
                                                                          (("2"
                                                                            (propax)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "last_take_nth[nat,<]")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (hide-all-but
                                                           1)
                                                          (("3"
                                                            (typepred
                                                             "reals.<")
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4" (assert) nil nil)
                                                 ("5"
                                                  (use
                                                   "take_ol[nat,<]")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (typepred
                                                       "reals.<")
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil)
                                           ("2"
                                            (replace
                                             "cached`1 varidx"
                                             "cached cond ok")
                                            (("2"
                                              (hide-all-but
                                               ("varac"
                                                "varac not single value"
                                                "cached cond ok"
                                                "re"))
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (typepred "cache")
                      (("2" (generalize "cache" "cache")
                        (("1" (induct "cache")
                          (("1" (grind) nil nil)
                           ("2" (skolem 1 ("h" "t"))
                            (("2" (flatten)
                              (("2"
                                (expand "every" 1)
                                (("2"
                                  (split 1)
                                  (("1"
                                    (typepred "h`3")
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (split -1)
                                      (("1"
                                        (expand "correct_cache?" -1)
                                        (("1" (flatten) nil nil))
                                        nil)
                                       ("2"
                                        (expand "idxs_bounded")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (expand "nth" -2)
                                            (("2"
                                              (inst?
                                               :subst
                                               ("i" "i+1"))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (typepred "i")
                                                (("2" (grind) nil nil))
                                                nil)
                                               ("3"
                                                (typepred "i")
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (expand "correct_cache?" -1)
                                        (("3" (flatten) nil nil))
                                        nil)
                                       ("4"
                                        (expand "idxs_bounded")
                                        (("4"
                                          (skeep)
                                          (("4"
                                            (expand "nth" -2)
                                            (("4"
                                              (inst?
                                               :subst
                                               ("i" "i+1"))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (typepred "i")
                                                (("2" (grind) nil nil))
                                                nil)
                                               ("3"
                                                (typepred "i")
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (hide-all-but 1)
                            (("3" (typepred "reals.<")
                              (("3" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (typepred "reals.<")
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("3" (hide-all-but 1)
                          (("3" (typepred "reals.<")
                            (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "correct_cache?")
                (("2" (expand "CacheData_correct?")
                  (("2" (replace "re" 1)
                    (("2" (assert)
                      (("2" (lift-if "nwidxs")
                        (("2" (split "nwidxs")
                          (("1"
                            (with-labels (flatten "nwidxs")
                             (("opn >= 2" "nwidxs")))
                            (("1" (replace "nwidxs" 1)
                              (("1"
                                (split 1)
                                (("1"
                                  (use "length_append[nat]")
                                  (("1"
                                    (replaces -1 1)
                                    (("1"
                                      (with-labels
                                       (typepred
                                        "nats(nextfreeidx, newoff - 1)")
                                       (("nats list[nat]"
                                         "nats ol"
                                         "nats not null"
                                         "nats car"
                                         "nats length"
                                         "nats i")
                                        ("newoff >= 1")))
                                      (("1"
                                        (replaces "nats length" 2)
                                        (("1"
                                          (case
                                           "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                                          (("1"
                                            (replaces -1 2)
                                            (("1"
                                              (replace "newoff" 2)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use "length_take[nat]")
                                            (("1"
                                              (replaces -1 1)
                                              (("1"
                                                (expand "min")
                                                (("1"
                                                  (lift-if 1)
                                                  (("1"
                                                    (split 1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (replace
                                                         "pownoises")
                                                        (("2"
                                                          (with-labels
                                                           (typepred
                                                            "cache")
                                                           (("cache correct"
                                                             "cache idxs bounded"
                                                             "UNKNOWN")))
                                                          (("2"
                                                            (use
                                                             "cache_powvar_correct_result")
                                                            (("2"
                                                              (with-labels
                                                               (assert
                                                                -1)
                                                               (("cached correct")))
                                                              (("2"
                                                                (replace
                                                                 "cached"
                                                                 "cached correct"
                                                                 :dir
                                                                 RL)
                                                                (("2"
                                                                  (expand
                                                                   "CacheData_correct?"
                                                                   "cached correct")
                                                                  (("2"
                                                                    (typepred
                                                                     "cached")
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (replace
                                                                               -2
                                                                               "cached correct")
                                                                              (("2"
                                                                                (replace
                                                                                 "re"
                                                                                 "cached correct")
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil)
                                           ("3" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil)
                                   ("3" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (case
                                     "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                  nats(nextfreeidx, newoff - 1))) = car(pownoises)")
                                    (("1"
                                      (replaces -1 2)
                                      (("1"
                                        (with-labels
                                         (typepred "cache")
                                         (("cache correct"
                                           "cache idxs bounded"
                                           "UNKNOWN")))
                                        (("1"
                                          (use
                                           "cache_powvar_correct_result")
                                          (("1"
                                            (with-labels
                                             (assert -1)
                                             (("cached correct")))
                                            (("1"
                                              (replace
                                               "cached"
                                               "cached correct"
                                               :dir
                                               RL)
                                              (("1"
                                                (expand
                                                 "CacheData_correct?"
                                                 "cached correct")
                                                (("1"
                                                  (typepred "cached")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (split
                                                             "cached correct")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (split
                                                                 -2)
                                                                (("1"
                                                                  (replace
                                                                   -4
                                                                   "cached correct")
                                                                  (("1"
                                                                    (replace
                                                                     "re"
                                                                     "cached correct")
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (expand
                                                                   "length")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (replace
                                                               "varac"
                                                               "varac not single value")
                                                              (("2"
                                                                (replace
                                                                 -3
                                                                 "cached correct")
                                                                (("2"
                                                                  (replace
                                                                   "re"
                                                                   "cached correct")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "append" 1)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand "take" -1)
                                              (("1"
                                                (case
                                                 "length(pownoises) >= opn(val(cached)`1) - 1")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (hide -1)
                                                  (("2"
                                                    (replace
                                                     "pownoises"
                                                     1)
                                                    (("2"
                                                      (with-labels
                                                       (typepred
                                                        "cache")
                                                       (("cache correct"
                                                         "cache idxs bounded"
                                                         "UNKNOWN")))
                                                      (("2"
                                                        (use
                                                         "cache_powvar_correct_result")
                                                        (("2"
                                                          (with-labels
                                                           (assert)
                                                           (("cached correct")))
                                                          (("2"
                                                            (replace
                                                             "cached"
                                                             "cached correct"
                                                             :dir
                                                             RL)
                                                            (("2"
                                                              (expand
                                                               "CacheData_correct?"
                                                               "cached correct")
                                                              (("2"
                                                                (typepred
                                                                 "cached")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (replace
                                                                           "varac"
                                                                           "varac not single value")
                                                                          (("2"
                                                                            (replace
                                                                             -2
                                                                             "cached correct")
                                                                            (("2"
                                                                              (replace
                                                                               "re"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "take" 2)
                                                (("2"
                                                  (case
                                                   "length(pownoises) >= opn(val(cached)`1) - 1")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (replace
                                                     "pownoises"
                                                     1)
                                                    (("2"
                                                      (with-labels
                                                       (typepred
                                                        "cache")
                                                       (("cache correct"
                                                         "cache idxs bounded"
                                                         "UNKNOWN")))
                                                      (("2"
                                                        (use
                                                         "cache_powvar_correct_result")
                                                        (("2"
                                                          (with-labels
                                                           (assert)
                                                           (("cached correct")))
                                                          (("2"
                                                            (replace
                                                             "cached"
                                                             "cached correct"
                                                             :dir
                                                             RL)
                                                            (("2"
                                                              (expand
                                                               "CacheData_correct?"
                                                               "cached correct")
                                                              (("2"
                                                                (typepred
                                                                 "cached")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (replace
                                                                           "varac"
                                                                           "varac not single value")
                                                                          (("2"
                                                                            (replace
                                                                             -2
                                                                             "cached correct")
                                                                            (("2"
                                                                              (replace
                                                                               "re"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (replace "pownoises" 1)
                                      (("3"
                                        (with-labels
                                         (typepred "cache")
                                         (("cache correct"
                                           "cache idxs bounded"
                                           "UNKNOWN")))
                                        (("3"
                                          (use
                                           "cache_powvar_correct_result")
                                          (("3"
                                            (with-labels
                                             (assert)
                                             (("cached correct")))
                                            (("3"
                                              (replace
                                               "cached"
                                               "cached correct"
                                               :dir
                                               RL)
                                              (("3"
                                                (expand
                                                 "CacheData_correct?"
                                                 "cached correct")
                                                (("3"
                                                  (typepred "cached")
                                                  (("3"
                                                    (assert)
                                                    (("3"
                                                      (flatten)
                                                      (("3"
                                                        (assert)
                                                        (("3"
                                                          (flatten)
                                                          (("3"
                                                            (split
                                                             "cached correct")
                                                            (("1"
                                                              (expand
                                                               "length")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (replace
                                                               "varac"
                                                               "varac not single value")
                                                              (("2"
                                                                (replace
                                                                 -3
                                                                 "cached correct")
                                                                (("2"
                                                                  (replace
                                                                   "re"
                                                                   "cached correct")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4" (assert) nil nil)
                                     ("5" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (replace -1 2)
                              (("2"
                                (split 2)
                                (("1"
                                  (typepred
                                   "nats(nextfreeidx, newoff - 1)")
                                  (("1"
                                    (replace -4 2)
                                    (("1"
                                      (replace "newoff" 2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (typepred
                                     "nats(nextfreeidx, newoff - 1)")
                                    (("1"
                                      (inst -5 "0")
                                      (("1"
                                        (expand "nth")
                                        (("1"
                                          (replace -5 3)
                                          (("1"
                                            (typepred "nextfreeidx")
                                            (("1"
                                              (use "last_idx_box")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (replace -4 1)
                                        (("2"
                                          (replace "newoff" 1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (replaces "newoff")
                (("3" (hide-all-but (1 "pow gt opn" "opw gt opn"))
                  (("3" (case "opn(val(cached)`1) < pow")
                    (("1" (hide "pow gt opn" "opw gt opn")
                      (("1"
                        (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                        (("1" (replaces -1)
                          (("1" (case "0 <= pow - opn(val(cached)`1)")
                            (("1"
                              (name-replace "A"
                               "pow - opn(val(cached)`1)")
                              (("1" (assert) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (take_ol formula-decl nil ordered_list "structures/")
    (last_take_nth formula-decl nil ordered_list "structures/")
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (first_ol const-decl "T" ordered_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (appendable_ol? const-decl "bool" ordered_list "structures/")
    (append_ol const-decl "ordered_list" ordered_list "structures/")
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_idx_box formula-decl nil affine_box nil))
   nil)
  (Eval_wCache_TCC61-2 nil 3632160598
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached some" -3) (label "cached" -4)
                (label "idxs" -5) (label "pownoises" -6)
                (label "newoff" -7) (label "nwidxs" -8)
                (label "acRes" -9) (label "result" -10) (label "idx" 1)
                (label "pow <= 1" 2) (label "varac not single value" 3)
                (label "cv not 0" 4) (label "pow gt opn" 5)
                (label "opw gt opn" 6)))
        (("" (hide -11)
          (("" (replaces "result")
            (("" (assert)
              (("" (split 7)
                (("1" (inst 1 "(:(re, acRes, nwidxs):)")
                  (("1" (expand "append" 1) (("1" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (replace "newoff" 1)
                  (("2" (expand ">=")
                    (("2"
                      (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                      (("1" (replaces -1)
                        (("1" (case "0 < pow - opn(val(cached)`1)")
                          (("1" (hide-all-but (1 -1))
                            (("1"
                              (name-replace "A"
                               "pow - opn(val(cached)`1)")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replace "newoff" 1)
                  (("3" (expand "idxs_bounded" 1)
                    (("3" (skeep)
                      (("3" (case "i=0")
                        (("1" (replaces -1)
                          (("1" (expand "nth" 1)
                            (("1" (replace "acRes" 1)
                              (("1"
                                (use "next_idx_pow_var_ac")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (lift-if 1)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (typepred "nextfreeidx")
                                          (("1"
                                            (use "last_idx_box")
                                            (("1"
                                              (case
                                               "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                                              (("1"
                                                (replaces -1)
                                                (("1"
                                                  (case
                                                   "0 < pow - opn(val(cached)`1)")
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 -2 -3 1))
                                                    (("1"
                                                      (name-replace
                                                       "A"
                                                       "pow - opn(val(cached)`1)")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (replace "nwidxs" 1)
                                          (("2"
                                            (lift-if 1)
                                            (("2"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (case
                                                   "pow - 1 = opn(val(cached)`1)")
                                                  (("1"
                                                    (replace
                                                     -1
                                                     1
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case
                                                         "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                         nats(nextfreeidx, newoff - 1)),
                                                                                                                  pow - 2) = nextfreeidx")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (hide 2)
                                                          (("2"
                                                            (use
                                                             "nth_append[nat]")
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               1)
                                                              (("1"
                                                                (use
                                                                 "length_take[nat]")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("1"
                                                                    (expand
                                                                     "min")
                                                                    (("1"
                                                                      (lift-if
                                                                       1)
                                                                      (("1"
                                                                        (split
                                                                         1)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (case
                                                                             "length(pownoises) = pow - 2")
                                                                            (("1"
                                                                              (replaces
                                                                               -1
                                                                               2)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (case
                                                                               "length(pownoises) > opn(val(cached)`1) - 2")
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil)
                                                                               ("2"
                                                                                (replace
                                                                                 "pownoises"
                                                                                 1)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (use
                                                                                     "cache_powvar_correct_result")
                                                                                    (("2"
                                                                                      (with-labels
                                                                                       (typepred
                                                                                        "cache")
                                                                                       (("correct cache"
                                                                                         "cache idxs bounded"
                                                                                         "UNKNOWN")))
                                                                                      (("2"
                                                                                        (with-labels
                                                                                         (assert)
                                                                                         (("cached correct")))
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "CacheData_correct?"
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (typepred
                                                                                               "cached")
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (flatten)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    (("2"
                                                                                                      (flatten)
                                                                                                      (("2"
                                                                                                        (replace
                                                                                                         "varac"
                                                                                                         "varac not single value")
                                                                                                        (("2"
                                                                                                          (replace
                                                                                                           -2
                                                                                                           "cached correct")
                                                                                                          (("2"
                                                                                                            (replace
                                                                                                             "re"
                                                                                                             "cached correct")
                                                                                                            (("2"
                                                                                                              (assert)
                                                                                                              nil
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (split 1)
                                                              (("1"
                                                                (use
                                                                 "length_take[nat]")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (use
                                                                 "length_append[nat]")
                                                                (("2"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("2"
                                                                    (use
                                                                     "length_take[nat]")
                                                                    (("2"
                                                                      (replaces
                                                                       -1
                                                                       1)
                                                                      (("2"
                                                                        (expand
                                                                         "min"
                                                                         1)
                                                                        (("2"
                                                                          (lift-if
                                                                           1)
                                                                          (("2"
                                                                            (split
                                                                             1)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (replaces
                                                                                 "pownoises"
                                                                                 1)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (use
                                                                                     "cache_powvar_correct_result")
                                                                                    (("2"
                                                                                      (with-labels
                                                                                       (typepred
                                                                                        "cache")
                                                                                       (("correct cache"
                                                                                         "cache idxs bounded"
                                                                                         "UNKNOWN")))
                                                                                      (("2"
                                                                                        (with-labels
                                                                                         (assert)
                                                                                         (("cached correct")))
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "CacheData_correct?"
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (flatten)
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (flatten)
                                                                                                    (("2"
                                                                                                      (replace
                                                                                                       "varac"
                                                                                                       "varac not single value")
                                                                                                      (("2"
                                                                                                        (grind)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "nth_append[nat]")
                                                    (("1"
                                                      (replaces -1 2)
                                                      (("1"
                                                        (case
                                                         "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                             pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ")
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           2)
                                                          (("1"
                                                            (replace
                                                             "newoff"
                                                             2)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (case
                                                           "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             1)
                                                            (("1"
                                                              (replaces
                                                               "newoff"
                                                               1)
                                                              (("1"
                                                                (typepred
                                                                 "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                                                                (("1"
                                                                  (inst?
                                                                   -5)
                                                                  (("1"
                                                                    (replace
                                                                     -5
                                                                     2)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "length_take[nat]")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 "min"
                                                                 1)
                                                                (("1"
                                                                  (lift-if
                                                                   1)
                                                                  (("1"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (replaces
                                                                         "pownoises"
                                                                         1)
                                                                        (("2"
                                                                          (use
                                                                           "cache_powvar_correct_result")
                                                                          (("2"
                                                                            (with-labels
                                                                             (typepred
                                                                              "cache")
                                                                             (("correct cache"
                                                                               "cache idxs bounded"
                                                                               "UNKNOWN")))
                                                                            (("2"
                                                                              (with-labels
                                                                               (assert)
                                                                               (("cached correct")))
                                                                              (("2"
                                                                                (expand
                                                                                 "CacheData_correct?"
                                                                                 "cached correct")
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (assert)
                                                                                    (("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (assert)
                                                                                        (("2"
                                                                                          (flatten)
                                                                                          (("2"
                                                                                            (replace
                                                                                             "cached"
                                                                                             "cached correct"
                                                                                             :dir
                                                                                             RL)
                                                                                            (("2"
                                                                                              (replace
                                                                                               -2
                                                                                               "cached correct")
                                                                                              (("2"
                                                                                                (replace
                                                                                                 "re"
                                                                                                 "cached correct")
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (case
                                                           "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "length_take[nat]")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 "min"
                                                                 1)
                                                                (("1"
                                                                  (lift-if
                                                                   1)
                                                                  (("1"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (replaces
                                                                         "pownoises"
                                                                         1)
                                                                        (("2"
                                                                          (use
                                                                           "cache_powvar_correct_result")
                                                                          (("2"
                                                                            (with-labels
                                                                             (typepred
                                                                              "cache")
                                                                             (("correct cache"
                                                                               "cache idxs bounded"
                                                                               "UNKNOWN")))
                                                                            (("2"
                                                                              (with-labels
                                                                               (assert)
                                                                               (("cached correct")))
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("4"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("5"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (case
                                                       "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           1)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "length_append[nat]")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             1)
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (use
                                                           "length_take[nat]")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1)
                                                            (("1"
                                                              (expand
                                                               "min"
                                                               1)
                                                              (("1"
                                                                (lift-if
                                                                 1)
                                                                (("1"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (replaces
                                                                       "pownoises"
                                                                       1)
                                                                      (("2"
                                                                        (use
                                                                         "cache_powvar_correct_result")
                                                                        (("2"
                                                                          (with-labels
                                                                           (typepred
                                                                            "cache")
                                                                           (("correct cache"
                                                                             "cache idxs bounded"
                                                                             "UNKNOWN")))
                                                                          (("2"
                                                                            (with-labels
                                                                             (assert)
                                                                             (("cached correct")))
                                                                            (("2"
                                                                              (expand
                                                                               "CacheData_correct?"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (typepred
                                                                                 "cached")
                                                                                (("2"
                                                                                  (assert)
                                                                                  (("2"
                                                                                    (flatten)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (flatten)
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (replace
                                                                                             -2
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (replace
                                                                                               "re"
                                                                                               "cached correct")
                                                                                              (("2"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("3"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (replace "newoff" 2)
                                                  (("2"
                                                    (typepred
                                                     "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                                                    (("2"
                                                      (inst? -5)
                                                      (("2"
                                                        (replaces -5 3)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2"
                          (with-labels (typepred "cache")
                           (("correct cache" "cache idxs bounded"
                             "UNKNOWN")))
                          (("2"
                            (expand "idxs_bounded"
                                    "cache idxs bounded")
                            (("2" (expand "nth" 2)
                              (("2"
                                (assert)
                                (("2"
                                  (inst "cache idxs bounded" "i-1")
                                  (("2"
                                    (expand ">=")
                                    (("2"
                                      (case
                                       "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (case
                                           "0 < pow - opn(val(cached)`1)")
                                          (("1"
                                            (hide-all-but
                                             (-1
                                              2
                                              "cache idxs bounded"))
                                            (("1"
                                              (name-replace
                                               "A"
                                               "pow - opn(val(cached)`1)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_box formula-decl nil affine_box nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (C const-decl "posnat" binomial "reals/")
    (factorial def-decl "posnat" factorial "ints/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (idxs_pd def-decl "list[nat]" affine nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (car_ol const-decl "T" ordered_list "structures/")
    (null_ol? const-decl "bool" ordered_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (represents_var? const-decl "bool" affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC61-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC62 0
  (Eval_wCache_TCC62-3 nil 3637422043
   ("" (then (skeep*) (grind)) nil nil)
   ((/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/"))
   nil)
  (Eval_wCache_TCC62-2 nil 3635155516
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached some" -3) (label "cached" -4)
                (label "idxs" -5) (label "pownoises" -6)
                (label "newoff" -7) (label "nwidxs" -8)
                (label "acRes" -9) (label "result" -10) (label "idx" 1)
                (label "pow <= 1" 2) (label "varac not single value" 3)
                (label "cv not 0" 4) (label "pow gt opn" 5)
                (label "opw gt opn" 6)))
        (("" (hide -11)
          (("" (replaces "result")
            (("" (assert)
              (("" (split 7)
                (("1" (inst 1 "(:(re, acRes, nwidxs):)")
                  (("1" (expand "append" 1) (("1" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (replace "newoff" 1)
                  (("2" (expand ">=")
                    (("2"
                      (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                      (("1" (replaces -1)
                        (("1" (case "0 < pow - opn(val(cached)`1)")
                          (("1" (hide-all-but (1 -1))
                            (("1"
                              (name-replace "A"
                               "pow - opn(val(cached)`1)")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replace "newoff" 1)
                  (("3" (expand "idxs_bounded" 1)
                    (("3" (skeep)
                      (("3" (case "i=0")
                        (("1" (replaces -1)
                          (("1" (expand "nth" 1)
                            (("1" (replace "acRes" 1)
                              (("1"
                                (use "next_idx_pow_var_ac")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (lift-if 1)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (typepred "nextfreeidx")
                                          (("1"
                                            (use "last_idx_box")
                                            (("1"
                                              (case
                                               "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                                              (("1"
                                                (replaces -1)
                                                (("1"
                                                  (case
                                                   "0 < pow - opn(val(cached)`1)")
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 -2 -3 1))
                                                    (("1"
                                                      (name-replace
                                                       "A"
                                                       "pow - opn(val(cached)`1)")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (replace "nwidxs" 1)
                                          (("2"
                                            (lift-if 1)
                                            (("2"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (case
                                                   "pow - 1 = opn(val(cached)`1)")
                                                  (("1"
                                                    (replace
                                                     -1
                                                     1
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case
                                                         "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                          nats(nextfreeidx, newoff - 1)),
                                                                                                                                   pow - 2) = nextfreeidx")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (hide 2)
                                                          (("2"
                                                            (use
                                                             "nth_append[nat]")
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               1)
                                                              (("1"
                                                                (use
                                                                 "length_take[nat]")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("1"
                                                                    (expand
                                                                     "min")
                                                                    (("1"
                                                                      (lift-if
                                                                       1)
                                                                      (("1"
                                                                        (split
                                                                         1)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (case
                                                                             "length(pownoises) = pow - 2")
                                                                            (("1"
                                                                              (replaces
                                                                               -1
                                                                               2)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (case
                                                                               "length(pownoises) > opn(val(cached)`1) - 2")
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil)
                                                                               ("2"
                                                                                (replace
                                                                                 "pownoises"
                                                                                 1)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (use
                                                                                     "cache_powvar_correct_result")
                                                                                    (("2"
                                                                                      (with-labels
                                                                                       (typepred
                                                                                        "cache")
                                                                                       (("correct cache"
                                                                                         "cache idxs bounded"
                                                                                         "UNKNOWN")))
                                                                                      (("2"
                                                                                        (with-labels
                                                                                         (assert)
                                                                                         (("cached correct")))
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "CacheData_correct?"
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (typepred
                                                                                               "cached")
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (flatten)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    (("2"
                                                                                                      (flatten)
                                                                                                      (("2"
                                                                                                        (replace
                                                                                                         "varac"
                                                                                                         "varac not single value")
                                                                                                        (("2"
                                                                                                          (replace
                                                                                                           -2
                                                                                                           "cached correct")
                                                                                                          (("2"
                                                                                                            (replace
                                                                                                             "re"
                                                                                                             "cached correct")
                                                                                                            (("2"
                                                                                                              (assert)
                                                                                                              nil
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (split 1)
                                                              (("1"
                                                                (use
                                                                 "length_take[nat]")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (use
                                                                 "length_append[nat]")
                                                                (("2"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("2"
                                                                    (use
                                                                     "length_take[nat]")
                                                                    (("2"
                                                                      (replaces
                                                                       -1
                                                                       1)
                                                                      (("2"
                                                                        (expand
                                                                         "min"
                                                                         1)
                                                                        (("2"
                                                                          (lift-if
                                                                           1)
                                                                          (("2"
                                                                            (split
                                                                             1)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (replaces
                                                                                 "pownoises"
                                                                                 1)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (use
                                                                                     "cache_powvar_correct_result")
                                                                                    (("2"
                                                                                      (with-labels
                                                                                       (typepred
                                                                                        "cache")
                                                                                       (("correct cache"
                                                                                         "cache idxs bounded"
                                                                                         "UNKNOWN")))
                                                                                      (("2"
                                                                                        (with-labels
                                                                                         (assert)
                                                                                         (("cached correct")))
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "CacheData_correct?"
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (flatten)
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (flatten)
                                                                                                    (("2"
                                                                                                      (replace
                                                                                                       "varac"
                                                                                                       "varac not single value")
                                                                                                      (("2"
                                                                                                        (grind)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "nth_append[nat]")
                                                    (("1"
                                                      (replaces -1 2)
                                                      (("1"
                                                        (case
                                                         "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ")
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           2)
                                                          (("1"
                                                            (replace
                                                             "newoff"
                                                             2)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (case
                                                           "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             1)
                                                            (("1"
                                                              (replaces
                                                               "newoff"
                                                               1)
                                                              (("1"
                                                                (typepred
                                                                 "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                                                                (("1"
                                                                  (inst?
                                                                   -5)
                                                                  (("1"
                                                                    (replace
                                                                     -5
                                                                     2)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "length_take[nat]")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 "min"
                                                                 1)
                                                                (("1"
                                                                  (lift-if
                                                                   1)
                                                                  (("1"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (replaces
                                                                         "pownoises"
                                                                         1)
                                                                        (("2"
                                                                          (use
                                                                           "cache_powvar_correct_result")
                                                                          (("2"
                                                                            (with-labels
                                                                             (typepred
                                                                              "cache")
                                                                             (("correct cache"
                                                                               "cache idxs bounded"
                                                                               "UNKNOWN")))
                                                                            (("2"
                                                                              (with-labels
                                                                               (assert)
                                                                               (("cached correct")))
                                                                              (("2"
                                                                                (expand
                                                                                 "CacheData_correct?"
                                                                                 "cached correct")
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (assert)
                                                                                    (("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (assert)
                                                                                        (("2"
                                                                                          (flatten)
                                                                                          (("2"
                                                                                            (replace
                                                                                             "cached"
                                                                                             "cached correct"
                                                                                             :dir
                                                                                             RL)
                                                                                            (("2"
                                                                                              (replace
                                                                                               -2
                                                                                               "cached correct")
                                                                                              (("2"
                                                                                                (replace
                                                                                                 "re"
                                                                                                 "cached correct")
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (case
                                                           "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "length_take[nat]")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 "min"
                                                                 1)
                                                                (("1"
                                                                  (lift-if
                                                                   1)
                                                                  (("1"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (replaces
                                                                         "pownoises"
                                                                         1)
                                                                        (("2"
                                                                          (use
                                                                           "cache_powvar_correct_result")
                                                                          (("2"
                                                                            (with-labels
                                                                             (typepred
                                                                              "cache")
                                                                             (("correct cache"
                                                                               "cache idxs bounded"
                                                                               "UNKNOWN")))
                                                                            (("2"
                                                                              (with-labels
                                                                               (assert)
                                                                               (("cached correct")))
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("4"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("5"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (case
                                                       "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           1)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "length_append[nat]")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             1)
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (use
                                                           "length_take[nat]")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1)
                                                            (("1"
                                                              (expand
                                                               "min"
                                                               1)
                                                              (("1"
                                                                (lift-if
                                                                 1)
                                                                (("1"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (replaces
                                                                       "pownoises"
                                                                       1)
                                                                      (("2"
                                                                        (use
                                                                         "cache_powvar_correct_result")
                                                                        (("2"
                                                                          (with-labels
                                                                           (typepred
                                                                            "cache")
                                                                           (("correct cache"
                                                                             "cache idxs bounded"
                                                                             "UNKNOWN")))
                                                                          (("2"
                                                                            (with-labels
                                                                             (assert)
                                                                             (("cached correct")))
                                                                            (("2"
                                                                              (expand
                                                                               "CacheData_correct?"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (typepred
                                                                                 "cached")
                                                                                (("2"
                                                                                  (assert)
                                                                                  (("2"
                                                                                    (flatten)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (flatten)
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (replace
                                                                                             -2
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (replace
                                                                                               "re"
                                                                                               "cached correct")
                                                                                              (("2"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("3"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (replace "newoff" 2)
                                                  (("2"
                                                    (typepred
                                                     "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                                                    (("2"
                                                      (inst? -5)
                                                      (("2"
                                                        (replaces -5 3)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2"
                          (with-labels (typepred "cache")
                           (("correct cache" "cache idxs bounded"
                             "UNKNOWN")))
                          (("2"
                            (expand "idxs_bounded"
                                    "cache idxs bounded")
                            (("2" (expand "nth" 2)
                              (("2"
                                (assert)
                                (("2"
                                  (inst "cache idxs bounded" "i-1")
                                  (("2"
                                    (expand ">=")
                                    (("2"
                                      (case
                                       "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (case
                                           "0 < pow - opn(val(cached)`1)")
                                          (("1"
                                            (hide-all-but
                                             (-1
                                              2
                                              "cache idxs bounded"))
                                            (("1"
                                              (name-replace
                                               "A"
                                               "pow - opn(val(cached)`1)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_box formula-decl nil affine_box nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (C const-decl "posnat" binomial "reals/")
    (factorial def-decl "posnat" factorial "ints/")
    (idxs_ac const-decl "list[nat]" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (idxs_pd def-decl "list[nat]" affine nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (car_ol const-decl "T" ordered_list "structures/")
    (null_ol? const-decl "bool" ordered_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (represents_var? const-decl "bool" affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC62-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil))
   nil))
 (Eval_wCache_TCC63 0
  (more_list_props "" 3644773828
   (""
    (then (skeep*) (replaces -4) (expand "represents_var?")
     (expand "nth_ac") (expand "var_ac") (assert) (lift-if 7)
     (expand_ol) (assert))
    nil nil)
   ((represents_var? const-decl "bool" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (length_null formula-decl nil more_list_props "structures/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (ac_proj_cv formula-decl nil affine nil)
    (ac_proj_pd formula-decl nil affine nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth_ac const-decl "AffineCombination" affine_box nil))
   shostak)
  (Eval_wCache_TCC63-2 nil 3637423816
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -2) (label "varac" -4)
                (label "cached some" -5) (label "cached" -6)
                (label "idxs" -7) (label "pownoises" -8)
                (label "newoff" -9) (label "nwidxs" -10)
                (label "acRes" -11) (label "result" -12)
                (label "idx" 1) (label "pow <= 1" 2)
                (label "varac not single value" 3) (label "cv not 0" 4)
                (label "pow gt opn" 5) (label "opw gt opn" 6)))
        (("" (hide -13)
          (("" (replaces "result")
            (("" (assert)
              (("" (split 7)
                (("1" (inst 1 "(:(re, acRes, nwidxs):)")
                  (("1" (expand "append" 1) (("1" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (replace "newoff" 1)
                  (("2" (expand ">=")
                    (("2"
                      (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                      (("1" (replaces -1)
                        (("1" (case "0 < pow - opn(val(cached)`1)")
                          (("1" (hide-all-but (1 -1))
                            (("1"
                              (name-replace "A"
                               "pow - opn(val(cached)`1)")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replace "newoff" 1)
                  (("3" (expand "idxs_bounded" 1)
                    (("3" (skeep)
                      (("3" (case "i=0")
                        (("1" (replaces -1)
                          (("1" (expand "nth" 1)
                            (("1" (replace "acRes" 1)
                              (("1"
                                (use "next_idx_pow_var_ac")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (lift-if 1)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (typepred "nextfreeidx")
                                          (("1"
                                            (use "last_idx_box")
                                            (("1"
                                              (case
                                               "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                                              (("1"
                                                (replaces -1)
                                                (("1"
                                                  (case
                                                   "0 < pow - opn(val(cached)`1)")
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 -2 -3 1))
                                                    (("1"
                                                      (name-replace
                                                       "A"
                                                       "pow - opn(val(cached)`1)")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (replace "nwidxs" 1)
                                          (("2"
                                            (lift-if 1)
                                            (("2"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (case
                                                   "pow - 1 = opn(val(cached)`1)")
                                                  (("1"
                                                    (replace
                                                     -1
                                                     1
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case
                                                         "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                           nats(nextfreeidx, newoff - 1)),
                                                                                                                                                    pow - 2) = nextfreeidx")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (hide 2)
                                                          (("2"
                                                            (use
                                                             "nth_append[nat]")
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               1)
                                                              (("1"
                                                                (use
                                                                 "length_take[nat]")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("1"
                                                                    (expand
                                                                     "min")
                                                                    (("1"
                                                                      (lift-if
                                                                       1)
                                                                      (("1"
                                                                        (split
                                                                         1)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (case
                                                                             "length(pownoises) = pow - 2")
                                                                            (("1"
                                                                              (replaces
                                                                               -1
                                                                               2)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (case
                                                                               "length(pownoises) > opn(val(cached)`1) - 2")
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil)
                                                                               ("2"
                                                                                (replace
                                                                                 "pownoises"
                                                                                 1)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (use
                                                                                     "cache_powvar_correct_result")
                                                                                    (("2"
                                                                                      (with-labels
                                                                                       (typepred
                                                                                        "cache")
                                                                                       (("correct cache"
                                                                                         "cache idxs bounded"
                                                                                         "UNKNOWN")))
                                                                                      (("2"
                                                                                        (with-labels
                                                                                         (assert)
                                                                                         (("cached correct")))
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "CacheData_correct?"
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (typepred
                                                                                               "cached")
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (flatten)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    (("2"
                                                                                                      (flatten)
                                                                                                      (("2"
                                                                                                        (replace
                                                                                                         "varac"
                                                                                                         "varac not single value")
                                                                                                        (("2"
                                                                                                          (replace
                                                                                                           -2
                                                                                                           "cached correct")
                                                                                                          (("2"
                                                                                                            (replace
                                                                                                             "re"
                                                                                                             "cached correct")
                                                                                                            (("2"
                                                                                                              (assert)
                                                                                                              (("2"
                                                                                                                (expand
                                                                                                                 "varidx_powvar")
                                                                                                                (("2"
                                                                                                                  (assert)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (split 1)
                                                              (("1"
                                                                (use
                                                                 "length_take[nat]")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (use
                                                                 "length_append[nat]")
                                                                (("2"
                                                                  (replaces
                                                                   -1
                                                                   1)
                                                                  (("2"
                                                                    (use
                                                                     "length_take[nat]")
                                                                    (("2"
                                                                      (replaces
                                                                       -1
                                                                       1)
                                                                      (("2"
                                                                        (expand
                                                                         "min"
                                                                         1)
                                                                        (("2"
                                                                          (lift-if
                                                                           1)
                                                                          (("2"
                                                                            (split
                                                                             1)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (replaces
                                                                                 "pownoises"
                                                                                 1)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (use
                                                                                     "cache_powvar_correct_result")
                                                                                    (("2"
                                                                                      (with-labels
                                                                                       (typepred
                                                                                        "cache")
                                                                                       (("correct cache"
                                                                                         "cache idxs bounded"
                                                                                         "UNKNOWN")))
                                                                                      (("2"
                                                                                        (with-labels
                                                                                         (assert)
                                                                                         (("cached correct")))
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "CacheData_correct?"
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (flatten)
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (flatten)
                                                                                                    (("2"
                                                                                                      (replace
                                                                                                       "varac"
                                                                                                       "varac not single value")
                                                                                                      (("2"
                                                                                                        (grind)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "nth_append[nat]")
                                                    (("1"
                                                      (replaces -1 2)
                                                      (("1"
                                                        (case
                                                         "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                   pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ")
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           2)
                                                          (("1"
                                                            (replace
                                                             "newoff"
                                                             2)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (case
                                                           "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             1)
                                                            (("1"
                                                              (replaces
                                                               "newoff"
                                                               1)
                                                              (("1"
                                                                (typepred
                                                                 "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                                                                (("1"
                                                                  (inst?
                                                                   -5)
                                                                  (("1"
                                                                    (replace
                                                                     -5
                                                                     2)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "length_take[nat]")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 "min"
                                                                 1)
                                                                (("1"
                                                                  (lift-if
                                                                   1)
                                                                  (("1"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (replaces
                                                                         "pownoises"
                                                                         1)
                                                                        (("2"
                                                                          (use
                                                                           "cache_powvar_correct_result")
                                                                          (("2"
                                                                            (with-labels
                                                                             (typepred
                                                                              "cache")
                                                                             (("correct cache"
                                                                               "cache idxs bounded"
                                                                               "UNKNOWN")))
                                                                            (("2"
                                                                              (with-labels
                                                                               (assert)
                                                                               (("cached correct")))
                                                                              (("2"
                                                                                (expand
                                                                                 "CacheData_correct?"
                                                                                 "cached correct")
                                                                                (("2"
                                                                                  (typepred
                                                                                   "cached")
                                                                                  (("2"
                                                                                    (assert)
                                                                                    (("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (assert)
                                                                                        (("2"
                                                                                          (flatten)
                                                                                          (("2"
                                                                                            (replace
                                                                                             "cached"
                                                                                             "cached correct"
                                                                                             :dir
                                                                                             RL)
                                                                                            (("2"
                                                                                              (replace
                                                                                               -2
                                                                                               "cached correct")
                                                                                              (("2"
                                                                                                (replace
                                                                                                 "re"
                                                                                                 "cached correct")
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     "varidx_powvar")
                                                                                                    (("2"
                                                                                                      (assert)
                                                                                                      nil
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (case
                                                           "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "length_take[nat]")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 "min"
                                                                 1)
                                                                (("1"
                                                                  (lift-if
                                                                   1)
                                                                  (("1"
                                                                    (split
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (replaces
                                                                         "pownoises"
                                                                         1)
                                                                        (("2"
                                                                          (use
                                                                           "cache_powvar_correct_result")
                                                                          (("2"
                                                                            (with-labels
                                                                             (typepred
                                                                              "cache")
                                                                             (("correct cache"
                                                                               "cache idxs bounded"
                                                                               "UNKNOWN")))
                                                                            (("2"
                                                                              (with-labels
                                                                               (assert)
                                                                               (("cached correct")))
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("4"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("5"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (case
                                                       "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (replaces
                                                           -1
                                                           1)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "length_append[nat]")
                                                          (("1"
                                                            (replaces
                                                             -1
                                                             1)
                                                            (("1"
                                                              (replaces
                                                               -1
                                                               1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (use
                                                           "length_take[nat]")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1)
                                                            (("1"
                                                              (expand
                                                               "min"
                                                               1)
                                                              (("1"
                                                                (lift-if
                                                                 1)
                                                                (("1"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (replaces
                                                                       "pownoises"
                                                                       1)
                                                                      (("2"
                                                                        (use
                                                                         "cache_powvar_correct_result")
                                                                        (("2"
                                                                          (with-labels
                                                                           (typepred
                                                                            "cache")
                                                                           (("correct cache"
                                                                             "cache idxs bounded"
                                                                             "UNKNOWN")))
                                                                          (("2"
                                                                            (with-labels
                                                                             (assert)
                                                                             (("cached correct")))
                                                                            (("2"
                                                                              (expand
                                                                               "CacheData_correct?"
                                                                               "cached correct")
                                                                              (("2"
                                                                                (typepred
                                                                                 "cached")
                                                                                (("2"
                                                                                  (assert)
                                                                                  (("2"
                                                                                    (flatten)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (flatten)
                                                                                        (("2"
                                                                                          (replace
                                                                                           "cached"
                                                                                           "cached correct"
                                                                                           :dir
                                                                                           RL)
                                                                                          (("2"
                                                                                            (replace
                                                                                             -2
                                                                                             "cached correct")
                                                                                            (("2"
                                                                                              (replace
                                                                                               "re"
                                                                                               "cached correct")
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   "varidx_powvar")
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("3"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (replace "newoff" 2)
                                                  (("2"
                                                    (typepred
                                                     "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                                                    (("2"
                                                      (inst? -5)
                                                      (("2"
                                                        (replaces -5 3)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2"
                          (with-labels (typepred "cache")
                           (("correct cache" "cache idxs bounded"
                             "UNKNOWN")))
                          (("2"
                            (expand "idxs_bounded"
                                    "cache idxs bounded")
                            (("2" (expand "nth" 2)
                              (("2"
                                (assert)
                                (("2"
                                  (inst "cache idxs bounded" "i-1")
                                  (("2"
                                    (expand ">=")
                                    (("2"
                                      (case
                                       "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (case
                                           "0 < pow - opn(val(cached)`1)")
                                          (("1"
                                            (hide-all-but
                                             (-1
                                              2
                                              "cache idxs bounded"))
                                            (("1"
                                              (name-replace
                                               "A"
                                               "pow - opn(val(cached)`1)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (idxs_ac const-decl "list[nat]" affine nil)
    (factorial def-decl "posnat" factorial "ints/")
    (C const-decl "posnat" binomial "reals/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (idxs_pd def-decl "list[nat]" affine nil)
    (last_idx_box formula-decl nil affine_box nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil))
   nil)
  (Eval_wCache_TCC63-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil))
   nil))
 (Eval_wCache_TCC64 0
  (Eval_wCache_TCC64-1 nil 3632149132
   (""
    (then (skeep*)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "cached" -6)
             (label "idxs" -7) (label "pownoises" -8)
             (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1)
             (label "pow <= 1" 2) (label "varac not single value" 3)
             (label "cv not 0" 4) (label "not in cache 2" 5)
             (label "not in cache 1" 6)))
     (with-labels (split "not in cache 1") (("pow gt opn cached`1")))
     (spread
      (with-labels (split "not in cache 2") (("pow gt opn cached`1")))
      ((then (expand "/=") (propax))
       (then (replaces "nwidxs" 7)
        (spread (split 7)
         ((then (use "cache_powvar_correct_result")
           (with-labels (assert) (("cached correct")))
           (replace "cached" "cached correct" :dir RL)
           (expand "CacheData_correct?" "cached correct")
           (typepred "cached") (assert)
           (with-labels (flatten)
            (("cached`1 is powvar" "cached`1 varidx" "cached cache idx"
              "UNKNOWN")))
           (assert)
           (with-labels (flatten)
            (("cached idx in box" "cached cond ok"
              "cached`2 is powvarac" "UNKNOWN")))
           (spread (split "cached cond ok")
            ((spread (split "cached correct")
              ((then (flatten)
                (spread
                 (name "nwidxs2"
                       "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))")
                 ((then (typepred "nwidxs2") (expand "append_ol")
                   (assert))
                  (then (hide-all-but 1) (typepred "reals.<") (grind))
                  (then (expand "appendable_ol?") (flatten)
                   (spread
                    (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)")
                    ((then (replaces -1 3)
                      (spread
                       (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx")
                       ((then (replaces -1 3)
                         (with-labels (typepred "cache")
                          (("cache compatible pairs" "cache correct"
                            "UNKNOWN")))
                         (skeep "cached cache idx")
                         (replace "pownoises" 1)
                         (replace "cached cache idx" 1 :dir RL)
                         (replace "cached cache idx"
                                  "cached`2 is powvarac"
                           :dir RL)
                         (use "next_idx_pow_var_ac") (replaces -1)
                         (expand "idxs_bounded")
                         (inst "cache correct" "i")
                         (replace "cached`2 is powvarac"
                                  "cache correct"
                           :hide? t)
                         (replace -1 :hide? t) (grind))
                        (then
                         (hide-all-but
                          (1 3 "cached correct" "pow gt opn cached`1"))
                         (replaces -2 1) (expand "nats" 1) (lift-if 1)
                         (spread (split 1)
                          ((grind)
                           (then (flatten) (expand_ol)
                            (expand "first_ol") (propax))))))))
                     (spread (use "last_take_nth[nat,<]")
                      ((assert) (assert)))
                     (assert)
                     (then (hide-all-but 1) (typepred "reals.<")
                      (grind))
                     (assert))))
                  (spread (use "take_ol[nat,<]")
                   ((assert)
                    (then (hide-all-but 1) (typepred "reals.<")
                     (grind))))
                  (assert))))
               (propax)))
             (then (replace "cached`1 varidx" "cached cond ok")
              (hide-all-but
               ("varac" "varac not single value" "cached cond ok"
                "re"))
              (grind)))))
          (then (lift-if 1)
           (spread (split 1)
            ((then (flatten)
              (spread (split 1)
               ((spread (use "length_append[nat]")
                 ((then (replaces -1)
                   (spread (typepred "nats(nextfreeidx, newoff - 1)")
                    ((then (replaces -4 2)
                      (spread (use "length_take[nat]")
                       ((then (replaces -1 2)
                         (spread
                          (case "length(pownoises) > opn(val(cached)`1) - 2")
                          ((then (expand "min" 2) (lift-if 2)
                            (spread
                             (case "length(pownoises) = opn(val(cached)`1) - 1")
                             ((assert) (assert))))
                           (then (replace "pownoises" 1)
                            (with-labels (typepred "cache")
                             (("cache compatible pairs" "cache correct"
                               "UNKNOWN")))
                            (use "cache_powvar_correct_result")
                            (with-labels (assert) (("cached correct")))
                            (replace "cached" "cached correct" :dir RL)
                            (expand "CacheData_correct?"
                                    "cached correct")
                            (typepred "cached") (assert)
                            (with-labels (flatten)
                             (("cached`1 is powvar" "cached`1 varidx"
                               "cached cache idx" "UNKNOWN")))
                            (assert)
                            (with-labels (flatten)
                             (("cached idx in box" "cached cond ok"
                               "cached`2 is powvarac" "UNKNOWN")))
                            (replace "cached`1 varidx"
                                     "cached cond ok")
                            (hide-all-but
                             ("varac" "varac not single value"
                              "cached cond ok" "re"))
                            (grind)))))
                        (assert))))
                     (assert))))
                  (assert) (assert)))
                (then (flatten) (replace "pownoises" 2)
                 (with-labels (typepred "cache")
                  (("cache compatible pairs" "cache correct"
                    "UNKNOWN")))
                 (use "cache_powvar_correct_result")
                 (with-labels (assert) (("cached correct")))
                 (replace "cached" "cached correct" :dir RL)
                 (expand "CacheData_correct?" "cached correct")
                 (typepred "cached") (assert)
                 (with-labels (flatten)
                  (("cached`1 is powvar" "cached`1 varidx"
                    "cached cache idx" "UNKNOWN")))
                 (assert)
                 (with-labels (flatten)
                  (("cached idx in box" "cached cond ok"
                    "cached`2 is powvarac" "UNKNOWN")))
                 (replace "cached`1 varidx" "cached cond ok")
                 (spread (split "cached cond ok")
                  ((then (flatten) (replaces "varac" 2)
                    (replace "re" "cached cond ok") (assert)
                    (spread
                     (case "car[nat]
                                                                                                                    (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                            nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)")
                     ((then (replaces -1) (assert) (grind))
                      (then (expand "take" 1) (expand "append" 1)
                       (propax))
                      (grind))))
                   (then
                    (hide-all-but
                     ("varac" "varac not single value" "cached cond ok"
                      "re"))
                    (grind))))))))
             (then (flatten)
              (spread (split 2)
               ((spread (typepred "nats(nextfreeidx, newoff - 1)")
                 ((then (replace -4 2) (replace "newoff" 2) (assert))
                  (assert)))
                (then (flatten) (expand "nats" 2) (replace "newoff" 2)
                 (lift-if 2)
                 (spread (split 2)
                  ((then (flatten) (assert) (replace "varac" 1)
                    (typepred "nextfreeidx") (use "last_idx_box")
                    (assert))
                   (then (flatten) (expand_ol) (replace "varac" 2)
                    (typepred "nextfreeidx") (use "last_idx_box")
                    (assert)))))))))))))))))
    nil nil)
   ((last_idx_box formula-decl nil affine_box nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (length_append formula-decl nil list_props nil)
    (newoff skolem-const-decl "int" affine_expr_Eval nil)
    (length_take formula-decl nil more_list_props "structures/")
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (powvar? const-decl "bool" affine_expr nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (appendable_ol? const-decl "bool" ordered_list "structures/")
    (append_ol const-decl "ordered_list" ordered_list "structures/")
    (take def-decl "list[T]" more_list_props "structures/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (<= const-decl "bool" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (strict_total_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (last_take_nth formula-decl nil ordered_list "structures/")
    (pownoises skolem-const-decl
     "ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)]"
     affine_expr_Eval nil)
    (cached skolem-const-decl "{res: Maybe[CacheData] |
         some?(res) IMPLIES
          powvar?(val(res)`1) AND
           varidx_powvar(val(res)`1) = varidx_powvar(re) AND
            (EXISTS (i: below(length(cache))): nth(cache, i) = val(res))}"
     affine_expr_Eval nil)
    (cache skolem-const-decl
     "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (append def-decl "list[T]" list_props nil)
    (idxs_ac const-decl "list[nat]" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (first_ol const-decl "T" ordered_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (take_ol formula-decl nil ordered_list "structures/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (Eval_wCache_TCC65 0
  (Eval_wCache_TCC65-3 nil 3635155612
   (""
    (then (skeep*) (assert)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "cached" -6)
             (label "idxs" -7) (label "pownoises" -8)
             (label "newoff" -9) (label "nwidxs" -10)
             (label "acRes" -11) (label "result" -12) (label "idx" 1)
             (label "pow <= 1" 2) (label "varac not single value" 3)
             (label "cv not 0" 4) (label "pow gt opn" 5)
             (label "opw gt opn" 6)))
     (replaces "result") (assert)
     (spread (split 7)
      ((then (expand "every")
        (spread (split 1)
         ((then (replace "nwidxs" 1)
           (with-labels (typepred "cache")
            (("cache correct" "cache idxs bound" "UNKNOWN")))
           (use "cache_powvar_correct_result")
           (with-labels (assert (-1 "cache correct"))
            (("cached correct")))
           (replace "cached" "cached correct" :dir RL)
           (expand "CacheData_correct?" "cached correct")
           (typepred "cached") (assert)
           (with-labels (flatten)
            (("cached`1 is powvar" "cached`1 varidx" "cached cache idx"
              "UNKNOWN")))
           (assert)
           (with-labels (flatten "cached correct")
            (("cached idx in box" "cached cond ok"
              "cached`2 is powvarac" "UNKNOWN")))
           (spread (split "cached cond ok")
            ((spread (split 1)
              ((then (flatten)
                (spread
                 (name "nwidxs2"
                       "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))")
                 ((then (typepred "nwidxs2") (expand "append_ol")
                   (assert))
                  (then (hide-all-but 1) (typepred "reals.<") (grind))
                  (then (assert) (expand "appendable_ol?") (flatten)
                   (spread
                    (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)")
                    ((then (replaces -1 3)
                      (spread
                       (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx")
                       ((then (replaces -1 3)
                         (skeep "cached cache idx")
                         (replace "pownoises" 1)
                         (replace "cached cache idx" 1 :dir RL)
                         (expand "idxs_bounded" "cache idxs bound")
                         (inst "cache idxs bound" "i")
                         (replace "cached cache idx"
                                  "cached`2 is powvarac"
                           :dir RL)
                         (replace "cached`2 is powvarac"
                                  "cache idxs bound")
                         (use "next_idx_pow_var_ac")
                         (spread
                          (case "NOT length(pd(nth_ac(box, varidx_powvar(nth(cache, i)`1)))) = 0")
                          ((assert)
                           (then
                            (hide-all-but
                             (-1 "cached cache idx" "varac"
                              "varac not single value"
                              "cached`1 varidx" "re"))
                            (replaces "re") (assert)
                            (expand "varidx_powvar") (assert)))))
                        (then
                         (hide-all-but
                          (1 3 5 -1 "pow gt opn" "opw gt opn"))
                         (expand "nats" 1) (lift-if 1)
                         (spread (split 1)
                          ((grind)
                           (then (flatten) (expand_ol)
                            (expand "first_ol") (propax))))))))
                     (then (use "last_take_nth[nat,<]") (assert))
                     (then (hide-all-but 1) (typepred "reals.<")
                      (grind)))))
                  (assert)
                  (spread (use "take_ol[nat,<]")
                   ((assert)
                    (then (hide-all-but 1) (typepred "reals.<")
                     (grind))))
                  (assert))))
               (propax)))
             (then (replace "cached`1 varidx" "cached cond ok")
              (hide-all-but
               ("varac" "varac not single value" "cached cond ok"
                "re"))
              (grind)))))
          (then (hide-all-but 1) (typepred "cache")
           (spread (generalize "cache" "cache")
            ((spread (induct "cache")
              ((grind)
               (then (skolem 1 ("h" "t")) (flatten) (expand "every" 1)
                (spread (split 1)
                 ((then (typepred "h`3") (assert))
                  (then (assert)
                   (spread (split -1)
                    ((then (expand "correct_cache?" -1) (flatten))
                     (then (expand "idxs_bounded") (skeep)
                      (expand "nth" -2)
                      (spread (inst? :subst ("i" "i+1"))
                       ((assert) (then (typepred "i") (grind))
                        (then (typepred "i") (grind)))))
                     (then (expand "correct_cache?" -1) (flatten))
                     (then (expand "idxs_bounded") (skeep)
                      (expand "nth" -2)
                      (spread (inst? :subst ("i" "i+1"))
                       ((assert) (then (typepred "i") (grind))
                        (then (typepred "i") (grind)))))))))))
               (then (hide-all-but 1) (typepred "reals.<") (grind))))
             (then (hide-all-but 1) (typepred "reals.<") (grind))
             (then (hide-all-but 1) (typepred "reals.<") (grind))))))))
       (then (expand "correct_cache?") (expand "CacheData_correct?")
        (expand "powvar?") (replace "re" 1) (assert)
        (expand "varidx_powvar") (lift-if "nwidxs")
        (spread (split "nwidxs")
         ((then
           (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs")))
           (replace "nwidxs" 1)
           (spread (split 1)
            ((spread (use "length_append[nat]")
              ((then (replaces -1 1)
                (spread
                 (with-labels
                  (typepred "nats(nextfreeidx, newoff - 1)")
                  (("nats list[nat]" "nats ol" "nats not null"
                    "nats car" "nats length" "nats i")
                   ("newoff >= 1")))
                 ((then (replaces "nats length" 2)
                   (spread
                    (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                    ((then (replaces -1 2) (replace "newoff" 2)
                      (assert))
                     (spread (use "length_take[nat]")
                      ((then (replaces -1 1) (expand "min") (lift-if 1)
                        (spread (split 1)
                         ((propax)
                          (then (flatten) (replace "pownoises")
                           (with-labels (typepred "cache")
                            (("cache correct" "cache idxs bounded"
                              "UNKNOWN")))
                           (use "cache_powvar_correct_result")
                           (with-labels (assert -1)
                            (("cached correct")))
                           (replace "cached" "cached correct" :dir RL)
                           (expand "CacheData_correct?"
                                   "cached correct")
                           (typepred "cached") (assert) (flatten)
                           (assert) (flatten)
                           (replace -2 "cached correct")
                           (replace "re" "cached correct") (assert)
                           (expand "varidx_powvar") (assert)))))
                       (assert)))
                     (assert))))
                  (assert))))
               (assert) (assert)))
             (then (flatten)
              (spread
               (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                                nats(nextfreeidx, newoff - 1))) = car(pownoises)")
               ((then (replaces -1 2)
                 (with-labels (typepred "cache")
                  (("cache correct" "cache idxs bounded" "UNKNOWN")))
                 (use "cache_powvar_correct_result")
                 (with-labels (assert -1) (("cached correct")))
                 (replace "cached" "cached correct" :dir RL)
                 (expand "CacheData_correct?" "cached correct")
                 (typepred "cached") (assert) (flatten) (assert)
                 (flatten)
                 (spread (split "cached correct")
                  ((then (flatten)
                    (spread (split -2)
                     ((then (replace -4 "cached correct")
                       (replace "re" "cached correct") (assert)
                       (expand "varidx_powvar") (assert))
                      (then (expand "length") (assert)))))
                   (then (replace "varac" "varac not single value")
                    (replace -3 "cached correct")
                    (replace "re" "cached correct") (assert)
                    (expand "varidx_powvar") (assert)))))
                (then (expand "append" 1) (lift-if 1)
                 (spread (split 1)
                  ((then (flatten) (expand "take" -1)
                    (spread
                     (case "length(pownoises) >= opn(val(cached)`1) - 1")
                     ((assert)
                      (then (hide -1) (replace "pownoises" 1)
                       (with-labels (typepred "cache")
                        (("cache correct" "cache idxs bounded"
                          "UNKNOWN")))
                       (use "cache_powvar_correct_result")
                       (with-labels (assert) (("cached correct")))
                       (replace "cached" "cached correct" :dir RL)
                       (expand "CacheData_correct?" "cached correct")
                       (typepred "cached") (assert) (flatten) (assert)
                       (flatten)
                       (replace "varac" "varac not single value")
                       (replace -2 "cached correct")
                       (replace "re" "cached correct") (assert)
                       (expand "varidx_powvar") (assert)))))
                   (then (flatten) (assert) (expand "take" 2)
                    (spread
                     (case "length(pownoises) >= opn(val(cached)`1) - 1")
                     ((assert)
                      (then (replace "pownoises" 1)
                       (with-labels (typepred "cache")
                        (("cache correct" "cache idxs bounded"
                          "UNKNOWN")))
                       (use "cache_powvar_correct_result")
                       (with-labels (assert) (("cached correct")))
                       (replace "cached" "cached correct" :dir RL)
                       (expand "CacheData_correct?" "cached correct")
                       (typepred "cached") (assert) (flatten) (assert)
                       (flatten)
                       (replace "varac" "varac not single value")
                       (replace -2 "cached correct")
                       (replace "re" "cached correct")
                       (expand "varidx_powvar") (assert))))))))
                (then (replace "pownoises" 1)
                 (with-labels (typepred "cache")
                  (("cache correct" "cache idxs bounded" "UNKNOWN")))
                 (use "cache_powvar_correct_result")
                 (with-labels (assert) (("cached correct")))
                 (replace "cached" "cached correct" :dir RL)
                 (expand "CacheData_correct?" "cached correct")
                 (typepred "cached") (assert) (flatten) (assert)
                 (flatten)
                 (spread (split "cached correct")
                  ((then (expand "length") (assert))
                   (then (replace "varac" "varac not single value")
                    (replace -3 "cached correct")
                    (replace "re" "cached correct") (assert)
                    (expand "varidx_powvar") (assert)))))
                (assert) (assert)))))))
          (then (flatten) (replace -1 2)
           (spread (split 2)
            ((spread (typepred "nats(nextfreeidx, newoff - 1)")
              ((then (replace -4 2) (replace "newoff" 2) (assert))
               (assert)))
             (then (flatten)
              (spread (typepred "nats(nextfreeidx, newoff - 1)")
               ((spread (inst -5 "0")
                 ((then (expand "nth") (replace -5 3)
                   (typepred "nextfreeidx") (use "last_idx_box")
                   (assert))
                  (then (replace -4 1) (replace "newoff" 1) (assert))))
                (assert))))))))))
       (then (replaces "newoff")
        (hide-all-but (1 "pow gt opn" "opw gt opn"))
        (spread (case "opn(val(cached)`1) < pow")
         ((then (hide "pow gt opn" "opw gt opn")
           (spread
            (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
            ((then (replaces -1)
              (spread (case "0 <= pow - opn(val(cached)`1)")
               ((then (name-replace "A" "pow - opn(val(cached)`1)")
                 (assert))
                (assert))))
             (assert))))
          (assert)))))))
    nil nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (last_idx_box formula-decl nil affine_box nil)
    (length_take formula-decl nil more_list_props "structures/")
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (newoff skolem-const-decl "int" affine_expr_Eval nil)
    (length_append formula-decl nil list_props nil)
    (append def-decl "list[T]" list_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (i skolem-const-decl "below(length(t))" affine_expr_Eval nil)
    (h skolem-const-decl "CacheData" affine_expr_Eval nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (i skolem-const-decl "below(length(t))" affine_expr_Eval nil)
    (t skolem-const-decl "list[CacheData]" affine_expr_Eval nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (list_induction formula-decl nil list_adt nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (powvar? const-decl "bool" affine_expr nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (appendable_ol? const-decl "bool" ordered_list "structures/")
    (append_ol const-decl "ordered_list" ordered_list "structures/")
    (take def-decl "list[T]" more_list_props "structures/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (<= const-decl "bool" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (strict_total_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (first_ol const-decl "T" ordered_list "structures/")
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (next_idx const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (represents_var? const-decl "bool" affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (last_take_nth formula-decl nil ordered_list "structures/")
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (cache skolem-const-decl
     "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (cached skolem-const-decl "{res: Maybe[CacheData] |
         some?(res) IMPLIES
          powvar?(val(res)`1) AND
           varidx_powvar(val(res)`1) = varidx_powvar(re) AND
            (EXISTS (i: below(length(cache))): nth(cache, i) = val(res))}"
     affine_expr_Eval nil)
    (take_ol formula-decl nil ordered_list "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (Eval_wCache_TCC65-2 nil 3632160666
   ("" (skeep*)
    (("" (assert)
      ((""
        (apply (then (label "re" -1) (label "varac" -2)
                (label "cached" -3) (label "newoff" -4)
                (label "nwidxs" -5) (label "acRes" -6)
                (label "result" -7) (label "idx" 1)
                (label "pow <= 1" 2) (label "varac not single value" 3)
                (label "not in cache 3" 4) (label "not in cache 2" 5)
                (label "not in cache 1" 6)))
        (("" (replaces "re")
          (("" (replaces "result")
            (("" (assert)
              (("" (split 7)
                (("1" (expand "correct_cache?")
                  (("1" (expand "CacheData_correct?")
                    (("1" (flatten)
                      (("1" (typepred "nextfreeidx")
                        (("1" (replaces "nwidxs" 2)
                          (("1" (expand "nats" 2)
                            (("1" (lift-if 2)
                              (("1"
                                (split 2)
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (replaces -1 1 :dir RL)
                                      (("1"
                                        (use "last_idx_box")
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (expand_ol)
                                    (("2"
                                      (use "last_idx_box")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replaces "newoff")
                  (("2" (hide-all-but (1 "pow <= 1"))
                    (("2"
                      (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)")
                      (("1" (replaces -1)
                        (("1" (case "0<=pow - 1")
                          (("1" (name-replace "A" "pow -1 ")
                            (("1" (assert) nil nil)) nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (factorial def-decl "posnat" factorial "ints/")
    (C const-decl "posnat" binomial "reals/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (last_idx_box formula-decl nil affine_box nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC65-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC66 0
  (Eval_wCache_TCC66-3 nil 3635155679
   (""
    (then (skeep*) (assert)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached some" -5) (label "cached" -6)
             (label "idxs" -7) (label "pownoises" -8)
             (label "newoff" -9) (label "nwidxs" -10)
             (label "acRes" -11) (label "result" -12) (label "idx" 1)
             (label "pow <= 1" 2) (label "varac not single value" 3)
             (label "cv not 0" 4) (label "pow gt opn" 5)
             (label "opw gt opn" 6)))
     (hide -13) (replaces "result") (assert)
     (spread (split 7)
      ((spread (inst 1 "(:(re, acRes, nwidxs):)")
        ((then (expand "append" 1) (grind)) (grind)))
       (then (replace "newoff" 1) (expand ">=")
        (spread
         (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
         ((then (replaces -1)
           (spread (case "0 < pow - opn(val(cached)`1)")
            ((then (hide-all-but (1 -1))
              (name-replace "A" "pow - opn(val(cached)`1)") (assert))
             (grind))))
          (assert))))
       (then (replace "newoff" 1) (expand "idxs_bounded" 1) (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (replace "acRes" 1)
           (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1)
           (spread (split 1)
            ((then (flatten) (typepred "nextfreeidx")
              (use "last_idx_box")
              (spread
               (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
               ((then (replaces -1)
                 (spread (case "0 < pow - opn(val(cached)`1)")
                  ((then (hide-all-but (-1 -2 -3 1))
                    (name-replace "A" "pow - opn(val(cached)`1)")
                    (assert))
                   (assert))))
                (assert))))
             (then (assert) (replace "nwidxs" 1) (lift-if 1)
              (spread (split 1)
               ((then (flatten)
                 (spread (case "pow - 1 = opn(val(cached)`1)")
                  ((then (replace -1 1 :dir RL) (assert)
                    (spread
                     (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                  nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                           pow - 2) = nextfreeidx")
                     ((assert)
                      (then (hide 2)
                       (use "more_list_props[nat].nth_append")
                       (use "length_take[nat]") (replaces -1) (assert)
                       (spread (split -1)
                        ((then (assert) (replaces -1 1) (expand "min")
                          (lift-if 1)
                          (spread (split 1)
                           ((then (flatten) (grind))
                            (then (flatten)
                             (spread
                              (case "length(pownoises) = pow - 2")
                              ((then (replaces -1 2) (grind))
                               (spread
                                (case
                                 "length(pownoises) > opn(val(cached)`1) - 2")
                                ((assert)
                                 (then
                                  (replace "pownoises" 1)
                                  (typepred "cached")
                                  (use "cache_powvar_correct_result")
                                  (with-labels
                                   (typepred "cache")
                                   (("correct cache"
                                     "cache idxs bounded"
                                     "UNKNOWN")))
                                  (with-labels
                                   (assert)
                                   (("cached correct")))
                                  (replace
                                   "cached"
                                   "cached correct"
                                   :dir
                                   RL)
                                  (expand
                                   "CacheData_correct?"
                                   "cached correct")
                                  (typepred "cached")
                                  (assert)
                                  (flatten)
                                  (assert)
                                  (flatten)
                                  (replace
                                   "varac"
                                   "varac not single value")
                                  (replace -2 "cached correct")
                                  (replace "re" "cached correct")
                                  (assert)
                                  (expand "varidx_powvar")
                                  (assert))))))))))
                         (then (expand "min" 1) (lift-if 1)
                          (spread (split 1)
                           ((assert)
                            (then (flatten) (replaces "pownoises" 1)
                             (typepred "cached")
                             (use "cache_powvar_correct_result")
                             (with-labels (typepred "cache")
                              (("correct cache"
                                "cache idxs bounded"
                                "UNKNOWN")))
                             (with-labels (assert)
                              (("cached correct")))
                             (replace "cached" "cached correct"
                               :dir RL)
                             (expand "CacheData_correct?"
                                     "cached correct")
                             (flatten) (assert) (flatten)
                             (replace "varac" "varac not single value")
                             (grind)))))))))))
                   (spread
                    (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                             =
                             nth(nats(nextfreeidx, newoff - 1),
                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))")
                    ((then (replaces -1 2)
                      (spread
                       (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                               pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ")
                       ((then (replaces -1 2) (replace "newoff" 2)
                         (assert))
                        (spread
                         (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1")
                         ((then (replaces -1 1) (replaces "newoff" 1)
                           (typepred
                            "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                           (inst? -5) (replace -5 2) (assert))
                          (spread (use "length_take[nat]")
                           ((then (replace -1 1) (expand "min" 1)
                             (lift-if 1)
                             (spread (split 1)
                              ((propax)
                               (then
                                (flatten)
                                (replaces "pownoises" 1)
                                (use "cache_powvar_correct_result")
                                (with-labels
                                 (typepred "cache")
                                 (("correct cache"
                                   "cache idxs bounded"
                                   "UNKNOWN")))
                                (with-labels
                                 (assert)
                                 (("cached correct")))
                                (expand
                                 "CacheData_correct?"
                                 "cached correct")
                                (typepred "cached")
                                (assert)
                                (flatten)
                                (assert)
                                (flatten)
                                (replace
                                 "cached"
                                 "cached correct"
                                 :dir
                                 RL)
                                (replace -2 "cached correct")
                                (replace "re" "cached correct")
                                (assert)
                                (expand "varidx_powvar")
                                (assert)))))
                            (assert)))))
                        (spread
                         (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                         ((then (replace -1 1) (assert))
                          (spread (use "length_take[nat]")
                           ((then (replace -1 1) (expand "min" 1)
                             (lift-if 1)
                             (spread (split 1)
                              ((propax)
                               (then
                                (flatten)
                                (replaces "pownoises" 1)
                                (use "cache_powvar_correct_result")
                                (with-labels
                                 (typepred "cache")
                                 (("correct cache"
                                   "cache idxs bounded"
                                   "UNKNOWN")))
                                (with-labels
                                 (assert)
                                 (("cached correct")))))))
                            (assert))))))))
                     (then (hide 3)
                      (spread (use "more_list_props[nat].nth_append")
                       ((spread (split -1)
                         ((then (replaces -1 1) (lift-if 1)
                           (spread (split 1)
                            ((then (flatten)
                              (spread (use "length_take[nat]")
                               ((assert) (assert))))
                             (propax))))
                          (spread
                           (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                           ((then (replaces -1 1) (assert))
                            (spread (use "length_take[nat]")
                             ((then (replace -1 1) (expand "min" 1)
                               (lift-if 1)
                               (spread
                                (split 1)
                                ((propax)
                                 (then
                                  (flatten)
                                  (replaces "pownoises" 1)
                                  (use "cache_powvar_correct_result")
                                  (with-labels
                                   (typepred "cache")
                                   (("correct cache"
                                     "cache idxs bounded"
                                     "UNKNOWN")))
                                  (with-labels
                                   (assert)
                                   (("cached correct")))
                                  (expand
                                   "CacheData_correct?"
                                   "cached correct")
                                  (typepred "cached")
                                  (assert)
                                  (flatten)
                                  (assert)
                                  (flatten)
                                  (replace
                                   "cached"
                                   "cached correct"
                                   :dir
                                   RL)
                                  (replace -2 "cached correct")
                                  (replace "re" "cached correct")
                                  (assert)
                                  (expand "varidx_powvar")
                                  (assert)))))
                              (assert)))))))
                        (assert) (assert))))
                     (spread
                      (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1")
                      ((spread (split 1)
                        ((then (replaces -1 1) (assert))
                         (spread (use "length_append[nat]")
                          ((then (replaces -1 1) (replaces -1 1)
                            (assert))
                           (assert) (assert)))))
                       (then (hide 2)
                        (spread (use "length_take[nat]")
                         ((then (replace -1 1) (expand "min" 1)
                           (lift-if 1)
                           (spread (split 1)
                            ((propax)
                             (then (flatten) (replaces "pownoises" 1)
                              (use "cache_powvar_correct_result")
                              (with-labels (typepred "cache")
                               (("correct cache"
                                 "cache idxs bounded"
                                 "UNKNOWN")))
                              (with-labels (assert)
                               (("cached correct")))
                              (expand "CacheData_correct?"
                                      "cached correct")
                              (typepred "cached") (assert) (flatten)
                              (assert) (flatten)
                              (replace "cached" "cached correct"
                                :dir RL)
                              (replace -2 "cached correct")
                              (replace "re" "cached correct") (assert)
                              (expand "varidx_powvar") (assert)))))
                          (assert))))
                       (assert)))
                     (assert) (assert))))))
                (then (flatten) (replace "newoff" 2)
                 (typepred
                  "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)")
                 (inst? -5) (replaces -5 3) (assert))))))))
          (then
           (with-labels (typepred "cache")
            (("correct cache" "cache idxs bounded" "UNKNOWN")))
           (expand "idxs_bounded" "cache idxs bounded")
           (expand "nth" 2) (assert) (inst "cache idxs bounded" "i-1")
           (expand ">=")
           (spread
            (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))")
            ((then (replaces -1)
              (spread (case "0 < pow - opn(val(cached)`1)")
               ((then (hide-all-but (-1 2 "cache idxs bounded"))
                 (name-replace "A" "pow - opn(val(cached)`1)")
                 (assert))
                (grind))))
             (grind))))))))))
    nil nil)
   ((append def-decl "list[T]" list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (length def-decl "nat" list_props nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (/= const-decl "boolean" notequal nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cached skolem-const-decl "{res: Maybe[CacheData] |
         some?(res) IMPLIES
          powvar?(val(res)`1) AND
           varidx_powvar(val(res)`1) = varidx_powvar(re) AND
            (EXISTS (i: below(length(cache))): nth(cache, i) = val(res))}"
     affine_expr_Eval nil)
    (cache skolem-const-decl
     "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (newoff skolem-const-decl "int" affine_expr_Eval nil)
    (length_append formula-decl nil list_props nil)
    (take def-decl "list[T]" more_list_props "structures/")
    (<= const-decl "bool" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (nth_append formula-decl nil more_list_props "structures/")
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (idxs_ac const-decl "list[nat]" affine nil)
    (factorial def-decl "posnat" factorial "ints/")
    (C const-decl "posnat" binomial "reals/")
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (idxs_pd def-decl "list[nat]" affine nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (length_take formula-decl nil more_list_props "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (last_idx_box formula-decl nil affine_box nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (Eval_wCache_TCC66-2 nil 3632160751
   ("" (skeep*)
    (("" (assert)
      (("" (hide -8)
        ((""
          (apply (then (label "re" -1) (label "varac" -2)
                  (label "cached" -3) (label "newoff" -4)
                  (label "nwidxs" -5) (label "acRes" -6)
                  (label "result" -7) (label "idx" 1)
                  (label "pow <= 1" 2)
                  (label "varac not single value" 3)
                  (label "not in cache 3" 4) (label "not in cache 2" 5)
                  (label "not in cache 1" 6)))
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (split 7)
                  (("1"
                    (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (replaces "newoff")
                    (("2" (expand ">=")
                      (("2" (hide-all-but (1 "pow <= 1"))
                        (("2"
                          (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)")
                          (("1" (replaces -1)
                            (("1" (case "1<=(pow - 1)")
                              (("1"
                                (name-replace "A" "pow-1")
                                (("1" (assert) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (typepred "cache")
                    (("3" (expand "idxs_bounded")
                      (("3" (skeep)
                        (("3" (case "i=0")
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1"
                                (replaces "acRes")
                                (("1"
                                  (use "next_idx_pow_var_ac")
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (lift-if 1)
                                      (("1"
                                        (split 1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (typepred "nwidxs")
                                            (("1"
                                              (case "length(nwidxs)=0")
                                              (("1" (assert) nil nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (replaces "newoff")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand ">=")
                                                (("2"
                                                  (replaces "nwidxs")
                                                  (("2"
                                                    (typepred
                                                     "nats(nextfreeidx, nextfreeidx - 2 + pow)")
                                                    (("2"
                                                      (inst -5 "pow-2")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "nth" 2)
                            (("2" (assert)
                              (("2"
                                (inst?)
                                (("2"
                                  (replaces "newoff")
                                  (("2"
                                    (hide-all-but (2 -2 "pow <= 1"))
                                    (("2"
                                      (case
                                       "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)")
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (case "1<=(pow - 1)")
                                          (("1"
                                            (name-replace "A" "pow-1")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (car_ol const-decl "T" ordered_list "structures/")
    (null_ol? const-decl "bool" ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC66-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC67 0
  (Eval_wCache_TCC67-3 nil 3637424007 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (Eval_wCache_TCC67-2 nil 3635155703
   ("" (skeep*)
    (("" (assert)
      (("" (hide -8)
        ((""
          (apply (then (label "re" -1) (label "varac" -2)
                  (label "cached" -3) (label "newoff" -4)
                  (label "nwidxs" -5) (label "acRes" -6)
                  (label "result" -7) (label "idx" 1)
                  (label "pow <= 1" 2)
                  (label "varac not single value" 3)
                  (label "not in cache 3" 4) (label "not in cache 2" 5)
                  (label "not in cache 1" 6)))
          (("" (replaces "re")
            (("" (replaces "result")
              (("" (assert)
                (("" (split 7)
                  (("1"
                    (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)")
                    (("1" (grind) nil nil)
                     ("2" (hide-all-but 1)
                      (("2" (typepred "reals.<")
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("3" (hide-all-but 1)
                      (("3" (typepred "reals.<")
                        (("3" (grind) nil nil)) nil))
                      nil)
                     ("4" (hide-all-but 1)
                      (("4" (typepred "reals.<")
                        (("4" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (replaces "newoff")
                    (("2" (expand ">=")
                      (("2" (hide-all-but (1 "pow <= 1"))
                        (("2"
                          (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)")
                          (("1" (replaces -1)
                            (("1" (case "1<=(pow - 1)")
                              (("1"
                                (name-replace "A" "pow-1")
                                (("1" (assert) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (typepred "cache")
                    (("3" (expand "idxs_bounded")
                      (("3" (skeep)
                        (("3" (case "i=0")
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1"
                                (replaces "acRes")
                                (("1"
                                  (use "next_idx_pow_var_ac")
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (lift-if 1)
                                      (("1"
                                        (split 1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (typepred "nwidxs")
                                            (("1"
                                              (case "length(nwidxs)=0")
                                              (("1" (assert) nil nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (replaces "newoff")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand ">=")
                                                (("2"
                                                  (replaces "nwidxs")
                                                  (("2"
                                                    (typepred
                                                     "nats(nextfreeidx, nextfreeidx - 2 + pow)")
                                                    (("2"
                                                      (inst -5 "pow-2")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "nth" 2)
                            (("2" (assert)
                              (("2"
                                (inst?)
                                (("2"
                                  (replaces "newoff")
                                  (("2"
                                    (hide-all-but (2 -2 "pow <= 1"))
                                    (("2"
                                      (case
                                       "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)")
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (case "1<=(pow - 1)")
                                          (("1"
                                            (name-replace "A" "pow-1")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (car_ol const-decl "T" ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (null_ol? const-decl "bool" ordered_list "structures/")
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (represents_var? const-decl "bool" affine nil)
    (nzBaseType type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC67-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/"))
   nil))
 (Eval_wCache_TCC68 0
  (Eval_wCache_TCC68-2 nil 3637424154 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (represents_var? const-decl "bool" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil)
  (Eval_wCache_TCC68-1 nil 3632149132 ("" (tcc) nil nil)
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/"))
   nil))
 (Eval_wCache_TCC69 0
  (Eval_wCache_TCC69-1 nil 3632149132 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (car_ol const-decl "T" ordered_list "structures/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (powvar? const-decl "bool" affine_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (Eval_wCache_TCC70 0
  (Eval_wCache_TCC70-1 nil 3632149132
   (""
    (then (skeep*) (assert)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached" -5) (label "newoff" -6)
             (label "nwidxs" -7) (label "acRes" -8) (label "result" -9)
             (label "idx" 1) (label "pow <= 1" 2)
             (label "varac not single value" 3)
             (label "not in cache 3" 4) (label "not in cache 2" 5)
             (label "not in cache 1" 6)))
     (replaces "re") (replaces "result") (assert)
     (spread (split 7)
      ((then (expand "correct_cache?") (expand "CacheData_correct?")
        (expand "powvar?") (expand "varidx_powvar") (flatten)
        (typepred "nextfreeidx") (replaces "nwidxs" 2)
        (expand "nats" 2) (lift-if 2)
        (spread (split 2)
         ((then (assert) (flatten) (replaces -1 1 :dir RL)
           (use "last_idx_box") (grind))
          (then (flatten) (expand_ol) (use "last_idx_box") (grind)))))
       (then (replaces "newoff") (hide-all-but (1 "pow <= 1"))
        (spread (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)")
         ((then (replaces -1)
           (spread (case "0<=pow - 1")
            ((then (name-replace "A" "pow -1 ") (assert)) (assert))))
          (assert)))))))
    nil nil)
   ((CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Box type-eq-decl nil box "interval_arith/")
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (last_idx_box formula-decl nil affine_box nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt
     "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pow_var_pd def-decl
     "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}"
     affine_pow nil)
    (cdr_ol const-decl "ordered_list" ordered_list "structures/")
    (C const-decl "posnat" binomial "reals/")
    (factorial def-decl "posnat" factorial "ints/")
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (powvar? const-decl "bool" affine_expr nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (Eval_wCache_TCC71 0
  (Eval_wCache_TCC71-1 nil 3632149132
   (""
    (then (skeep*) (assert) (hide -10)
     (apply (then (label "re" -2) (label "varac" -4)
             (label "cached" -5) (label "newoff" -6)
             (label "nwidxs" -7) (label "acRes" -8) (label "result" -9)
             (label "idx" 1) (label "pow <= 1" 2)
             (label "varac not single value" 3)
             (label "not in cache 3" 4) (label "not in cache 2" 5)
             (label "not in cache 1" 6)))
     (replaces "re") (replaces "result") (assert)
     (spread (split 7)
      ((spread (inst 1 "(: (re, acRes, nwidxs) :)")
        ((grind) (then (hide-all-but 1) (typepred "reals.<") (grind))
         (then (hide-all-but 1) (typepred "reals.<") (grind)) (grind)))
       (then (replaces "newoff") (expand ">=")
        (hide-all-but (1 "pow <= 1"))
        (spread
         (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)")
         ((then (replaces -1)
           (spread (case "1<=(pow - 1)")
            ((then (name-replace "A" "pow-1") (assert)) (grind))))
          (grind))))
       (then (typepred "cache") (expand "idxs_bounded") (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (replaces "acRes")
           (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1)
           (spread (split 1)
            ((then (flatten) (typepred "nwidxs")
              (spread (case "length(nwidxs)=0") ((assert) (grind))))
             (then (flatten) (replaces "newoff") (assert) (expand ">=")
              (replaces "nwidxs")
              (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)")
              (inst -5 "pow-2") (assert)))))
          (then (expand "nth" 2) (assert) (inst?) (replaces "newoff")
           (hide-all-but (2 -2 "pow <= 1"))
           (spread
            (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)")
            ((then (replaces -1)
              (spread (case "1<=(pow - 1)")
               ((then (name-replace "A" "pow-1") (assert)) (grind))))
             (grind))))))))))
    nil nil)
   ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nats def-decl
     "{r: ordered_list[nat, restrict[[real, real], [nat, nat], boolean](<)] |
         NOT null_ol?[nat, restrict[[real, real], [nat, nat], boolean](<)]
                 (r)
          AND
          car_ol[nat, restrict[[real, real], [nat, nat], boolean](<)](r) =
           s
           AND
           length(r) = e - s + 1 AND
            (FORALL (i: below(length(r))): nth(r, i) = s + i)}"
     affine_pow nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (next_idx const-decl "nat" affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzBaseType type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (represents_var? const-decl "bool" affine nil)
    (next_idx_pow_var_ac formula-decl nil affine_pow nil)
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (car_ol const-decl "T" ordered_list "structures/")
    (> const-decl "bool" reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (length def-decl "nat" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (strict_total_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (Eval_wCache_TCC72 0
  (Eval_wCache_TCC72-1 nil 3632149132 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC73 0
  (Eval_wCache_TCC73-1 nil 3632149132 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC74 0
  (Eval_wCache_TCC74-2 nil 3637424199 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC74-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/"))
   nil))
 (Eval_wCache_TCC75 0
  (Eval_wCache_TCC75-1 nil 3632149132 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (Eval_wCache_TCC76 0
  (Eval_wCache_TCC76-1 nil 3632149132
   (""
    (then (skeep*) (expand "idxs_bounded") (typepred "res1") (assert)
     (flatten) (replace -7 :dir RL) (replace -8 :dir RL)
     (expand "idxs_bounded") (propax))
    nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   nil))
 (Eval_wCache_TCC77 0
  (Eval_wCache_TCC77-1 nil 3632149132
   (""
    (then (skeep*) (expand "idxs_bounded") (typepred "res1") (assert)
     (flatten) (replace -7 :dir RL) (replace -8 :dir RL)
     (expand "idxs_bounded") (propax))
    nil nil)
   ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_wCache_TCC78 0
  (Eval_wCache_TCC78-1 nil 3632149132 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil))
   nil))
 (Eval_wCache_TCC79 0
  (Eval_wCache_TCC79-2 nil 3632160940 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC79-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC80 0
  (Eval_wCache_TCC80-2 nil 3635156052 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC80-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/"))
   nil))
 (Eval_wCache_TCC81 0
  (Eval_wCache_TCC81-2 nil 3637424234 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC81-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/"))
   nil))
 (Eval_wCache_TCC82 0
  (Eval_wCache_TCC82-1 nil 3632149132
   (""
    (then (skeep*) (assert) (hide -11)
     (apply (then (label "result" -10) (label "ac2" -9)
             (label "cache2" -8) (label "newid2" -7) (label "res2" -6)
             (label "ac1" -5) (label "cache1" -4) (label "newid1" -3)
             (label "res1" -2) (label "re" -1)))
     (deftactic typepred_res2 nil
      (with-labels
       (then (typepred "res2") (replace "cache2" -1 :dir RL)
        (replace "newid2" -1 :dir RL) (assert) (flatten))
       (("cache2 not null" "re2" "cache2-form" "newid2-prop"
         "cache2-idxs_bound" "UNKNOWN"))))
     (deftactic typepred_res1 nil
      (with-labels
       (then (typepred "res1") (replace "cache1" -1 :dir RL)
        (replace "newid1" -1 :dir RL) (assert) (flatten))
       (("cache1 not null" "re1" "cache1-form" "newid1-prop"
         "cache1-idxs_bound" "UNKNOWN"))))
     (spread (split 3)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (typepred_res2) (skolem "cache2-form" "l2")
        (skolem "cache1-form" "l1")
        (replace "cache1-form" "cache2-form") (replace "cache2-form" 3)
        (spread
         (inst 3
          "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))")
         ((then (hide-all-but 3) (expand "append" 1 3)
           (use "append_assoc[CacheData]") (assert))
          (grind))))
       (then (replaces "result") (assert) (typepred_res2)
        (typepred_res1))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1)
           (use "next_idx_sub_ac_ac") (expand ">=") (typepred_res2)
           (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL)
              (spread (inst "cache2-idxs_bound" "0")
               ((then (expand "nth" "cache2-idxs_bound")
                 (replace "ac2" :dir RL)
                 (hide-all-but
                  (3 "cache2-idxs_bound" "newid2-prop"
                   "cache1-idxs_bound" -9))
                 (expand "max") (lift-if -4)
                 (spread (split -4)
                  ((then (flatten) (expand ">=") (assert))
                   (then (flatten) (assert)))))
                (grind))))
             (grind))))
          (then (typepred_res2) (expand "idxs_bounded")
           (spread (inst "cache2-idxs_bound" "i-1")
            ((then (expand "nth" 3) (propax))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/")
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (Eval_wCache_TCC83 0
  (Eval_wCache_TCC83-1 nil 3632149132
   (""
    (then (skeep*) (assert) (hide -11)
     (apply (then (label "result" -10) (label "ac2" -9)
             (label "cache2" -8) (label "newid2" -7) (label "res2" -6)
             (label "ac1" -5) (label "cache1" -4) (label "newid1" -3)
             (label "res1" -2) (label "re" -1)))
     (deftactic typepred_res2 nil
      (with-labels
       (then (typepred "res2") (replace "cache2" -1 :dir RL)
        (replace "newid2" -1 :dir RL) (assert) (flatten))
       (("cache2 not null" "re2" "cache2-form" "newid2-prop"
         "cache2-idxs_bound" "UNKNOWN"))))
     (deftactic typepred_res1 nil
      (with-labels
       (then (typepred "res1") (replace "cache1" -1 :dir RL)
        (replace "newid1" -1 :dir RL) (assert) (flatten))
       (("cache1 not null" "re1" "cache1-form" "newid1-prop"
         "cache1-idxs_bound" "UNKNOWN"))))
     (spread (split 3)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (typepred_res2) (skolem "cache2-form" "l2")
        (skolem "cache1-form" "l1")
        (replace "cache1-form" "cache2-form") (replace "cache2-form" 3)
        (spread
         (inst 3
          "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))")
         ((then (hide-all-but 3) (expand "append" 1 3)
           (use "append_assoc[CacheData]") (assert))
          (grind))))
       (then (replaces "result") (assert) (typepred_res2)
        (typepred_res1))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1)
           (use "next_idx_sub_ac_ac") (expand ">=") (typepred_res2)
           (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL)
              (spread (inst "cache2-idxs_bound" "0")
               ((then (expand "nth" "cache2-idxs_bound")
                 (replace "ac2" :dir RL)
                 (hide-all-but
                  (3 "cache2-idxs_bound" "newid2-prop"
                   "cache1-idxs_bound" -9))
                 (expand "max") (lift-if -4)
                 (spread (split -4)
                  ((then (flatten) (expand ">=") (assert))
                   (then (flatten) (assert)))))
                (grind))))
             (grind))))
          (then (typepred_res2) (expand "idxs_bounded")
           (spread (inst "cache2-idxs_bound" "i-1")
            ((then (expand "nth" 3) (propax))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (sub_pd_pd const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (sub_ac_ac const-decl "AffineCombination" affine nil)
    (powvar? const-decl "bool" affine_expr nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (/= const-decl "boolean" notequal nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (var_ac const-decl "AffineCombination" affine nil)
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (last_ol def-decl "T" ordered_list "structures/")
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (length def-decl "nat" list_props nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (Eval_wCache_TCC84 0
  (Eval_wCache_TCC84-1 nil 3632149132
   (""
    (then (skeep*) (assert) (hide -11)
     (apply (then (label "result" -10) (label "ac2" -9)
             (label "cache2" -8) (label "newid2" -7) (label "res2" -6)
             (label "ac1" -5) (label "cache1" -4) (label "newid1" -3)
             (label "res1" -2) (label "re" -1)))
     (deftactic typepred_res2 nil
      (with-labels
       (then (typepred "res2") (replace "cache2" -1 :dir RL)
        (replace "newid2" -1 :dir RL) (assert) (flatten))
       (("cache2 not null" "re2" "cache2-form" "newid2-prop"
         "cache2-idxs_bound" "UNKNOWN"))))
     (deftactic typepred_res1 nil
      (with-labels
       (then (typepred "res1") (replace "cache1" -1 :dir RL)
        (replace "newid1" -1 :dir RL) (assert) (flatten))
       (("cache1 not null" "re1" "cache1-form" "newid1-prop"
         "cache1-idxs_bound" "UNKNOWN"))))
     (spread (split 3)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (typepred_res2) (skolem "cache2-form" "l2")
        (skolem "cache1-form" "l1")
        (replace "cache1-form" "cache2-form") (replace "cache2-form" 3)
        (spread
         (inst 3
          "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))")
         ((then (hide-all-but 3) (expand "append" 1 3)
           (use "append_assoc[CacheData]") (assert))
          (grind))))
       (then (replaces "result") (assert) (typepred_res2)
        (typepred_res1))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1)
           (use "next_idx_sub_ac_ac") (expand ">=") (typepred_res2)
           (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL)
              (spread (inst "cache2-idxs_bound" "0")
               ((then (expand "nth" "cache2-idxs_bound")
                 (replace "ac2" :dir RL)
                 (hide-all-but
                  (3 "cache2-idxs_bound" "newid2-prop"
                   "cache1-idxs_bound" -9))
                 (expand "max") (lift-if -4)
                 (spread (split -4)
                  ((then (flatten) (expand ">=") (assert))
                   (then (flatten) (assert)))))
                (grind))))
             (grind))))
          (then (typepred_res2) (expand "idxs_bounded")
           (spread (inst "cache2-idxs_bound" "i-1")
            ((then (expand "nth" 3) (propax))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (sub_ac_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (sub_pd_pd const-decl "ErrorTerms" affine nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append_assoc formula-decl nil list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (i skolem-const-decl
     "below(length(cons((re, sub_ac_ac(ac1, ac2), null), cache2)))"
     affine_expr_Eval nil)
    (next_idx_sub_ac_ac formula-decl nil affine nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (Eval_wCache_TCC85 0
  (Eval_wCache_TCC85-1 nil 3632149132 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (restrict const-decl "R" restrict nil))
   nil))
 (Eval_wCache_TCC86 0
  (Eval_wCache_TCC86-2 nil 3632161027 ("" (tcc) nil nil)
   ((last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil)
  (Eval_wCache_TCC86-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil
   shostak))
 (Eval_wCache_TCC87 0
  (Eval_wCache_TCC87-2 nil 3635156100 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC87-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/"))
   nil))
 (Eval_wCache_TCC88 0
  (Eval_wCache_TCC88-2 nil 3637424271 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (Eval_wCache_TCC88-1 nil 3632149132 ("" (tcc))
   ((Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/"))
   nil))
 (Eval_wCache_TCC89 0
  (Eval_wCache_TCC89-1 nil 3635099697
   (""
    (then (skeep*) (assert) (hide -7)
     (apply (then (label "result" -6) (label "ac1" -5)
             (label "cache1" -4) (label "newid1" -3) (label "res1" -2)
             (label "re" -1)))
     (deftactic typepred_res1 nil
      (with-labels
       (then (typepred "res1") (replace "cache1" -1 :dir RL)
        (replace "newid1" -1 :dir RL) (assert) (flatten))
       (("cache1 not null" "re1" "cache1-form" "newid1-prop"
         "cache1-idxs_bound" "UNKNOWN"))))
     (spread (split 2)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (skolem "cache1-form" "l1") (replace "cache1-form" 2)
        (spread (inst 2 "cons((re, neg_ac(ac1), null)::CacheData, l1)")
         ((then (hide-all-but 2) (expand "append" 1 2) (propax))
          (then (expand "ordered_list?") (propax)))))
       (then (replaces "result") (assert) (typepred_res1))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (use "next_idx_neg_ac")
           (expand ">=") (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL) (assert))
             (then (expand "length") (assert)))))
          (then (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "i-1")
            ((then (expand "nth" 3) (propax))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((ordered_list? def-decl "bool" ordered_list "structures/")
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (Eval_wCache_TCC90 0
  (Eval_wCache_TCC90-1 nil 3637404772
   (""
    (then (skeep*) (assert) (hide -7)
     (apply (then (label "result" -6) (label "ac1" -5)
             (label "cache1" -4) (label "newid1" -3) (label "res1" -2)
             (label "re" -1)))
     (deftactic typepred_res1 nil
      (with-labels
       (then (typepred "res1") (replace "cache1" -1 :dir RL)
        (replace "newid1" -1 :dir RL) (assert) (flatten))
       (("cache1 not null" "re1" "cache1-form" "newid1-prop"
         "cache1-idxs_bound" "UNKNOWN"))))
     (spread (split 2)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (skolem "cache1-form" "l1") (replace "cache1-form" 2)
        (spread (inst 2 "cons((re, neg_ac(ac1), null)::CacheData, l1)")
         ((then (hide-all-but 2) (expand "append" 1 2) (propax))
          (then (expand "ordered_list?") (propax)))))
       (then (replaces "result") (assert) (typepred_res1))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (use "next_idx_neg_ac")
           (expand ">=") (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL) (assert))
             (then (expand "length") (assert)))))
          (then (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "i-1")
            ((then (expand "nth" 3) (propax))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)
    (pow_var_ac const-decl "AffineCombination" affine_pow nil)
    (nth def-decl "T" list_props nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (length def-decl "nat" list_props nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_ol def-decl "T" ordered_list "structures/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (var_ac const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (powvar? const-decl "bool" affine_expr nil)
    (neg_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (Eval_wCache_TCC91 0
  (Eval_wCache_TCC91-1 nil 3645889367
   (""
    (then (skeep*) (assert) (hide -7)
     (apply (then (label "result" -6) (label "ac1" -5)
             (label "cache1" -4) (label "newid1" -3) (label "res1" -2)
             (label "re" -1)))
     (deftactic typepred_res1 nil
      (with-labels
       (then (typepred "res1") (replace "cache1" -1 :dir RL)
        (replace "newid1" -1 :dir RL) (assert) (flatten))
       (("cache1 not null" "re1" "cache1-form" "newid1-prop"
         "cache1-idxs_bound" "UNKNOWN"))))
     (spread (split 2)
      ((grind)
       (then (replaces "result") (assert) (typepred_res1)
        (skolem "cache1-form" "l1") (replace "cache1-form" 2)
        (spread (inst 2 "cons((re, neg_ac(ac1), null)::CacheData, l1)")
         ((then (hide-all-but 2) (expand "append" 1 2) (propax))
          (then (expand "ordered_list?") (propax)))))
       (then (replaces "result") (assert) (typepred_res1))
       (then (replaces "result") (assert) (expand "idxs_bounded")
        (skeep)
        (spread (case "i=0")
         ((then (replaces -1) (expand "nth" 1) (use "next_idx_neg_ac")
           (expand ">=") (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "0")
            ((then (expand "nth" "cache1-idxs_bound")
              (replace "ac1" :dir RL) (assert))
             (then (expand "length") (assert)))))
          (then (typepred_res1) (expand "idxs_bounded")
           (spread (inst "cache1-idxs_bound" "i-1")
            ((then (expand "nth" 3) (propax))
             (then (typepred "i") (grind)))))))))))
    nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval
     nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (next_idx_neg_ac formula-decl nil affine nil)
    (i skolem-const-decl
     "below(length(cons((re, neg_ac(ac1), null), cache1)))"
     affine_expr_Eval nil)
    (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    ({\|\|} const-decl "AffineCombination" affine nil)
    (neg_ac const-decl "AffineCombination" affine nil))
   nil))
 (Eval_wCache_TCC92 0
  (Eval_wCache_TCC92-1 nil 3645889367 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IntervalExpr])"
     IntervalExpr_adt "interval_arith/")
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (restrict const-decl "R" restrict nil))
   nil))
 (Eval_wCache_TCC93 0
  (Eval_wCache_TCC93-1 nil 3645889367 ("" (subtype-tcc) nil nil)
   ((next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_TCC1 0
  (Eval_TCC1-1 nil 3632156083 ("" (tcc))
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   nil))
 (Eval_TCC2 0
  (Eval_TCC2-1 nil 3632156083 ("" (tcc))
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (length def-decl "nat" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (next_idx const-decl "nat" affine nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil))
   nil))
 (Eval_TCC3 0
  (Eval_TCC3-1 nil 3632156083 ("" (tcc))
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (next_idx const-decl "nat" affine nil)
    (last_idx const-decl "int" indexed_list "structures/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil))
   nil))
 (RE2AC_EvalwCache_eq 0
  (RE2AC_EvalwCache_eq-1 nil 3632852138
   (""
    (deftactic solve_binary_aff nil
     (then (skolem 1 ("re1" "re2")) (flatten) (skeep) (hide -3)
      (spread (split -1)
       ((spread (split -2)
         ((then (inst -2 "nextfreeidx" "cache")
           (expand "Eval_wCache" 1) (replace -2 1 :hide? t) (lift-if 1)
           (spread (split 1)
            ((then (flatten) (grind))
             (then (flatten)
              (spread
               (inst -1 "val(RE2AC(re1,
                                                                                          box,
                                                                                          vs,
                                                                                          nextfreeidx,
                                                                                          cache))`1"
                "val(RE2AC(re1,
                                                                                          box,
                                                                                          vs,
                                                                                          nextfreeidx,
                                                                                          cache))`2")
               ((then (replace -1 2 :hide? t)
                 (spread (split 2)
                  ((then (flatten) (expand "RE2AC" 1) (assert))
                   (then (flatten) (grind)))))
                (then (hide 3)
                 (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                cache)")
                 (assert) (flatten) (assert)
                 (expand "compatible_pairs?") (propax))
                (then (hide 3)
                 (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                cache)")
                 (assert))
                (then (hide 3)
                 (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                cache)")
                 (assert))))))))
          (then (typepred "re2") (propax))))
        (then (typepred "re1") (propax))))))
    (("" (skolem 1 ("box" "_" "vs" "_" "_"))
      (("" (induct "re")
        (("1" (grind) nil nil)
         ("2" (skeep*)
          (("2" (expand "Eval_wCache")
            (("2" (expand "RE2AC") (("2" (propax) nil nil)) nil)) nil))
          nil)
         ("3" (skeep*)
          (("3" (expand "Eval_wCache")
            (("3" (expand "RE2AC") (("3" (propax) nil nil)) nil)) nil))
          nil)
         ("4" (solve_binary_aff) nil nil)
         ("5" (skeep*)
          (("5" (expand "Eval_wCache")
            (("5" (expand "RE2AC") (("5" (propax) nil nil)) nil)) nil))
          nil)
         ("6" (skolem 1 ("re1"))
          (("6" (flatten)
            (("6" (skeep)
              (("6" (hide -2)
                (("6" (split -1)
                  (("1" (expand "Eval_wCache" 1)
                    (("1" (inst -1 "nextfreeidx" "cache")
                      (("1" (grind) nil nil)) nil))
                    nil)
                   ("2" (typepred "re1") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (solve_binary_aff) nil nil)
         ("8" (skolem 1 ("re1" "re2"))
          (("8" (flatten)
            (("8" (skeep)
              (("8" (hide -3)
                (("8" (split -1)
                  (("1" (split -2)
                    (("1" (inst -2 "nextfreeidx" "cache")
                      (("1" (expand "Eval_wCache" 1)
                        (("1" (replace -2 1 :hide? t)
                          (("1" (lift-if 1)
                            (("1" (split 1)
                              (("1"
                                (flatten)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split 2)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand "RE2AC" 1)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (inst
                                       -1
                                       "val(RE2AC(re1,
                                                                                                   box,
                                                                                                   vs,
                                                                                                   nextfreeidx,
                                                                                                   cache))`1"
                                       "val(RE2AC(re1,
                                                                                                   box,
                                                                                                   vs,
                                                                                                   nextfreeidx,
                                                                                                   cache))`2")
                                      (("1"
                                        (split 2)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (expand "RE2AC" 1)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (replaces -1)
                                            (("2"
                                              (expand "RE2AC" 2 14)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide 3 4)
                                        (("2"
                                          (typepred
                                           "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                           cache)")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand
                                                   "compatible_pairs?")
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (hide 3)
                                        (("3"
                                          (typepred
                                           "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                           cache)")
                                          (("3" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("4"
                                        (hide 3)
                                        (("4"
                                          (typepred
                                           "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                           cache)")
                                          (("4" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "re2") (("2" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (typepred "re1") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("9" (skeep*)
          (("9" (expand "Eval_wCache")
            (("9" (expand "RE2AC") (("9" (propax) nil nil)) nil)) nil))
          nil)
         ("10" (skeep*)
          (("10" (expand "Eval_wCache")
            (("10" (expand "RE2AC") (("10" (propax) nil nil)) nil))
            nil))
          nil)
         ("11" (skeep*)
          (("11" (expand "Eval_wCache")
            (("11" (expand "RE2AC") (("11" (propax) nil nil)) nil))
            nil))
          nil)
         ("12" (skeep*)
          (("12" (expand "Eval_wCache")
            (("12" (expand "RE2AC") (("12" (propax) nil nil)) nil))
            nil))
          nil)
         ("13" (skeep*)
          (("13" (expand "Eval_wCache")
            (("13" (expand "RE2AC") (("13" (propax) nil nil)) nil))
            nil))
          nil)
         ("14" (assert) nil nil) ("15" (assert) nil nil)
         ("16" (assert) nil nil) ("17" (assert) nil nil)
         ("18" (assert) nil nil) ("19" (assert) nil nil)
         ("20" (assert) nil nil) ("21" (assert) nil nil)
         ("22" (assert) nil nil))
        nil))
      nil))
    nil)
   ((cache skolem-const-decl
     "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (re1 skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cache skolem-const-decl
     "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (re1 skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sub_pd_pd const-decl "ErrorTerms" affine nil)
    (sub_ac_ac const-decl "AffineCombination" affine nil)
    (neg_ac const-decl "AffineCombination" affine nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (cache skolem-const-decl
     "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (vs skolem-const-decl "Env" affine_expr_Eval nil)
    (re1 skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (null_ol? const-decl "bool" ordered_list "structures/")
    (add_pd_pd const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (add_ac_ac const-decl "AffineCombination" affine nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IntervalExpr_induction formula-decl nil IntervalExpr_adt
     "interval_arith/")
    (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
          LET res = val(result)`2, newnidx = val(result)`1 IN
                 NOT null?(res) AND car(res)`1 = re
             AND (EXISTS (l: list[CacheData]): res = append(l, cache))
             AND (EXISTS (N: Noise):
                    vars_in_box_compatible?(N)(box)(vs) AND
                     compatible_pairs_on?(box, vs)(N)(res))
             AND newnidx >= nextfreeidx AND idxs_bounded(newnidx)(res)
             AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil)
    (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil)
    (vars_in_box_compatible? const-decl "bool" affine_box nil)
    (Noise type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzEpsilon type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (Epsilon type-eq-decl nil affine nil)
    (<= const-decl "bool" reals nil)
    (Eval_wCache def-decl
     "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
          LET res = val(result)`2, newnidx = val(result)`1 IN
                 NOT null?(res) AND car(res)`1 = re
             AND (EXISTS (l: list[CacheData]): res = append(l, cache))
             AND newnidx >= nextfreeidx AND idxs_bounded(newnidx)(res)}"
     affine_expr_Eval nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil)
    (Env type-eq-decl nil affine_box nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Box type-eq-decl nil box "interval_arith/")
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (EvalwCache_inclusion__TCC1 0
  (EvalwCache_inclusion__TCC1-1 nil 3637955749
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (Env type-eq-decl nil affine_box nil)
    (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (next_idx const-decl "nat" affine nil)
    (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil)
    (pow_var_compatible? const-decl "bool" affine_pow nil)
    (^ const-decl "real" exponentiation nil)
    (length_null formula-decl nil more_list_props "structures/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (nth_ac const-decl "AffineCombination" affine_box nil)
    (varidx_powvar const-decl "nat" affine_expr nil)
    (powvar? const-decl "bool" affine_expr nil)
    (eval_ACExpr_Env const-decl "BaseType" affine_expr nil)
    (vars_in_box_compatible? const-decl "bool" affine_box nil)
    (SingInterval? const-decl "bool" affine nil)
    (eval_ac_noise const-decl "real" affine nil)
    (var_ac const-decl "AffineCombination" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (cons_ol const-decl "ordered_list" ordered_list "structures/")
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    (/= const-decl "boolean" notequal nil)
    (|##| const-decl "bool" interval "interval_arith/"))
   nil))
 (EvalwCache_inclusion_ 0
  (EvalwCache_inclusion_-2 "" 3638005043
   ("" (skeep*)
    (("" (assert)
      (("" (flatten)
        (("" (use "RE2AC_EvalwCache_eq")
          (("" (replaces -1)
            ((""
              (typepred "RE2AC(re,
                                            box,
                                            vs,
                                            nextfreeidx,
                                            cache)")
              (("" (assert)
                (("" (flatten)
                  (("" (skeep -3)
                    (("" (expand "compatible_pairs_on?" -4)
                      (("" (inst -4 "0")
                        (("1" (inst -4 "n")
                          (("1" (flatten)
                            (("1" (expand "nth" -4)
                              (("1"
                                (inst 2 "N")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "length")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RE2AC_EvalwCache_eq formula-decl nil affine_expr_Eval nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (Env type-eq-decl nil affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
          LET res = val(result)`2, newnidx = val(result)`1 IN
                 NOT null?(res) AND car(res)`1 = re
             AND (EXISTS (l: list[CacheData]): res = append(l, cache))
             AND (EXISTS (N: Noise):
                    vars_in_box_compatible?(N)(box)(vs) AND
                     compatible_pairs_on?(box, vs)(N)(res))
             AND newnidx >= nextfreeidx AND idxs_bounded(newnidx)(res)
             AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil)
    (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil)
    (vars_in_box_compatible? const-decl "bool" affine_box nil)
    (Noise type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzEpsilon type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (Epsilon type-eq-decl nil affine nil)
    (<= const-decl "bool" reals nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (vs skolem-const-decl "(vars_in_box?(box))" affine_expr_Eval nil)
    (nextfreeidx skolem-const-decl
     "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}"
     affine_expr_Eval nil)
    (cache skolem-const-decl
     "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}"
     affine_expr_Eval nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak)
  (EvalwCache_inclusion_-1 nil 3637955766
   ("" (skeep*)
    (("" (assert)
      (("" (flatten)
        (("" (use "RE2AC_EvalwCache_eq")
          (("" (replaces -1)
            ((""
              (typepred "RE2AC(re,
                                            box,
                                            vs,
                                            nextfreeidx,
                                            cache)")
              (("" (assert)
                (("" (flatten)
                  (("" (skeep -3)
                    (("" (expand "compatible_pairs_on?" -4)
                      (("" (inst -4 "0")
                        (("1" (flatten)
                          (("1" (expand "nth" -4)
                            (("1" (inst 2 "N") (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "length")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (Env type-eq-decl nil affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
          LET res = val(result)`2, newnidx = val(result)`1 IN
                 NOT null?(res) AND car(res)`1 = re
             AND (EXISTS (l: list[CacheData]): res = append(l, cache))
             AND (EXISTS (N: Noise):
                    vars_in_box_compatible?(N)(box)(vs) AND
                     compatible_pairs_on?(box, vs)(N)(res))
             AND newnidx >= nextfreeidx AND idxs_bounded(newnidx)(res)
             AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil)
    (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil)
    (vars_in_box_compatible? const-decl "bool" affine_box nil)
    (Noise type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzEpsilon type-eq-decl nil affine nil)
    (Epsilon type-eq-decl nil affine nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/"))
   shostak))
 (EvalwCache_inclusion 0
  (EvalwCache_inclusion-1 nil 3632852284
   ("" (skeep*)
    (("" (assert)
      (("" (flatten)
        (("" (use "RE2AC_EvalwCache_eq")
          (("1" (replaces -1)
            (("1"
              (typepred "RE2AC(re,
                                        box,
                                        vs,
                                        1 + last_idx_in_box(box),
                                        null[CacheData])")
              (("1" (assert)
                (("1" (flatten)
                  (("1" (skeep -3)
                    (("1" (expand "compatible_pairs_on?" -4)
                      (("1" (inst -4 "0")
                        (("1" (inst -4 "length(box)")
                          (("1" (flatten)
                            (("1" (expand "nth" -4)
                              (("1"
                                (inst 2 "N")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "length")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "compatible_pairs?")
            (("2" (typepred "vs")
              (("2" (use "vib_vibnoise")
                (("2" (assert)
                  (("2" (hide -2)
                    (("2" (expand "vars_in_box_noise?")
                      (("2" (flatten)
                        (("2" (expand "compatible_pairs_on?")
                          (("2" (skeep -2)
                            (("2" (inst 1 "N")
                              (("2"
                                (assert)
                                (("2"
                                  (skeep :preds? t)
                                  (("2"
                                    (expand "length")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (RE2AC_EvalwCache_eq formula-decl nil affine_expr_Eval nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (BaseType type-eq-decl nil affine nil)
    (Env type-eq-decl nil affine_box nil)
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (AffineCombination type-eq-decl nil affine nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil)
    (box skolem-const-decl "Box" affine_expr_Eval nil)
    (vs skolem-const-decl "(vars_in_box?(box))" affine_expr_Eval nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
          LET res = val(result)`2, newnidx = val(result)`1 IN
                 NOT null?(res) AND car(res)`1 = re
             AND (EXISTS (l: list[CacheData]): res = append(l, cache))
             AND (EXISTS (N: Noise):
                    vars_in_box_compatible?(N)(box)(vs) AND
                     compatible_pairs_on?(box, vs)(N)(res))
             AND newnidx >= nextfreeidx AND idxs_bounded(newnidx)(res)
             AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil)
    (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil)
    (vars_in_box_compatible? const-decl "bool" affine_box nil)
    (Noise type-eq-decl nil affine nil)
    (lt_idx const-decl "bool" indexed_list "structures/")
    (nzEpsilon type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (Epsilon type-eq-decl nil affine nil)
    (<= const-decl "bool" reals nil)
    (append def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (re skolem-const-decl "RealExpr" affine_expr_Eval nil)
    (length def-decl "nat" list_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_in_box_noise? const-decl "bool" affine_box nil)
    (vib_vibnoise formula-decl nil affine_box nil))
   nil)))

