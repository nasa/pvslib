(affine_expr_Eval (Eval_wCache_TCC1 0 (Eval_wCache_TCC1-2 nil 3632143418 ("" (tcc) nil nil) nil nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(affine_expr_Eval.result)`2" "(list_adt[CacheData].cons?)")) (Eval_wCache_TCC1-1 nil 3632143264 ("" (well-founded-tcc) nil nil) nil nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(affine_expr_Eval.result)`2" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC2 0 (Eval_wCache_TCC2-3 "" 3789916905 ("" (lemma "well_founded_restrict[IntervalExpr, RealExpr]") (("" (inst?) (("" (expand "well_founded?") (("" (propax) nil nil)) nil)) nil)) nil) ((<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (strict_well_founded? const-decl "bool" orders nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (well_founded_restrict judgement-tcc nil restrict_order_props nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) shostak (Eval_wCache well-founded "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], bool].restrict(IntervalExpr_adt.<<)" "nil")) (Eval_wCache_TCC2-2 nil 3632156352 ("" (then (lemma "well_founded_restrict[IntervalExpr, RealExpr]") (inst?) (expand "well_founded?") (propax)) nil nil) ((RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith)) nil (Eval_wCache well-founded "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], bool].restrict(IntervalExpr_adt.<<)" "nil")) (Eval_wCache_TCC2-1 nil 3632143264 ("" (tcc)) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache well-founded "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], bool].restrict(IntervalExpr_adt.<<)" "nil"))) (Eval_wCache_TCC3 0 (Eval_wCache_TCC3-1 "" 3789916905 ("" (skeep*) (("" (assert) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC4-2 nil 3632156461 ("" (skeep*) (("" (assert) (("" (replaces -1) (("" (replaces -1) (("" (hide -1) (("" (assert) (("" (split 1) (("1" (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (typepred "opC") (("1" (replaces -1) (("1" (expand "next_idx") (("1" (expand "const_ac") (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC4-1 nil 3632143264 ("" (subtype-tcc) nil nil) nil nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC4 0 (Eval_wCache_TCC5-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Includes? const-decl "bool" interval interval_arith) (Unit type-decl nil Unit_adt structures) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (last_ol def-decl "T" ordered_list structures) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (|##| const-decl "bool" interval interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (const_ac const-decl "AffineCombination" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC5 0 (Eval_wCache_TCC5-1 "" 3789916908 ("" (skeep*) (("" (assert) (("" (replaces -1) (("" (replaces -1) (("" (hide -1) (("" (assert) (("" (split 1) (("1" (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (typepred "opC") (("1" (expand "next_idx") (("1" (expand "const_ac") (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (NOT const-decl "[bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (next_idx const-decl "nat" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (last_idx const-decl "int" indexed_list structures) (|##| const-decl "bool" interval interval_arith) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (Unit type-decl nil Unit_adt structures) (Interval type-eq-decl nil interval interval_arith) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (const_ac const-decl "AffineCombination" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (append def-decl "list[T]" list_props nil) ({\|\|} const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC6-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (replaces -1) (("" (replaces -1) (("" (hide -1) (("" (assert) (("" (split 1) (("1" (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (typepred "opC") (("1" (replaces -1) (("1" (expand "next_idx") (("1" (expand "const_ac") (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (next_idx const-decl "nat" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx const-decl "int" indexed_list structures) (|##| const-decl "bool" interval interval_arith) (ordered_list? def-decl "bool" ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Unit type-decl nil Unit_adt structures) (Interval type-eq-decl nil interval interval_arith) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (const_ac const-decl "AffineCombination" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC6 0 (Eval_wCache_TCC6-1 "" 3789916908 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) shostak (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC7-1 nil 3632143264 ("" (tcc)) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC7 0 (Eval_wCache_TCC7-1 "" 3789916910 ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC8-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (replace -6 :hide? t) (("3" (assert) (("3" (expand "idxs_bounded" 1) (("3" (skeep :preds? t) (("3" (expand "length" -1) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (typepred "cached") (("1" (assert) (("1" (skeep) (("1" (replace -2 :dir rl :hide? t) (("1" (expand "idxs_bounded") (("1" (inst -4 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_bounded" -3) (("2" (inst -3 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC8 0 (Eval_wCache_TCC9-2 nil 3632157019 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (replace -6 :hide? t) (("3" (assert) (("3" (expand "idxs_bounded" 1) (("3" (skeep :preds? t) (("3" (expand "length" -1) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (replaces -1) (("1" (typepred "cached") (("1" (assert) (("1" (skeep) (("1" (replace -2 :dir rl :hide? t) (("1" (expand "idxs_bounded") (("1" (inst -4 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_bounded" -3) (("2" (inst -3 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (cached skolem-const-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval nil) (i skolem-const-decl "below(length(cons((re, val(cached), null), cache)))" affine_expr_Eval nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC9-1 nil 3632143264 ("" (tcc)) nil shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC9 0 (Eval_wCache_TCC3-1 nil 3632143264 ("" (tcc) nil nil) ((last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC10 0 (Eval_wCache_TCC10-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.varidx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval.box))}"))) (Eval_wCache_TCC11 0 (Eval_wCache_TCC11-1 nil 3632143264 ("" (tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (ordered_list? def-decl "bool" ordered_list structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC12 0 (Eval_wCache_TCC12-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (last_ol def-decl "T" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC13 0 (Eval_wCache_TCC13-2 "" 3789916916 ("" (skeep*) (("" (replaces -1) (("" (replaces -3) (("" (assert) (("" (split 3) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide -3) (("2" (typepred "cache") (("2" (expand "idxs_bounded" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (last_idx_box formula-decl nil affine_box nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth_ac const-decl "AffineCombination" affine_box nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC13-1 nil 3632143264 ("" (skeep*) (("" (replaces -1) (("" (replaces -3) (("" (assert) (("" (split 3) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (hide -3) (("2" (typepred "cache") (("2" (expand "idxs_bounded" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (ordered_list? def-decl "bool" ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC14 0 (Eval_wCache_TCC14-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (restrict const-decl "R" restrict nil)) nil (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re1)" "nil"))) (Eval_wCache_TCC15 0 (Eval_wCache_TCC15-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC16 0 (Eval_wCache_TCC15-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) shostak (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC17 0 (Eval_wCache_TCC16-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC18 0 (Eval_wCache_TCC17-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval.box))}"))) (Eval_wCache_TCC19 0 (Eval_wCache_TCC19-1 "" 3789916925 ("" (skeep*) (("" (typepred "cache1") (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.cache1" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval.newid1)(cache)}")) (Eval_wCache_TCC18-1 nil 3632143264 ("" (then (skeep*) (typepred "cache1") (typepred "res1") (assert)) nil nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)) shostak (Eval_wCache subtype "affine_expr_Eval.cache1" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval.newid1)(cache)}"))) (Eval_wCache_TCC20 0 (Eval_wCache_TCC19-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "R" restrict nil)) shostak (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re2)" "nil"))) (Eval_wCache_TCC21 0 (Eval_wCache_TCC21-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC22 0 (Eval_wCache_TCC20-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC23 0 (Eval_wCache_TCC21-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.cache2" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC24 0 (Eval_wCache_TCC22-3 nil 3632158042 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC22-2 nil 3632157213 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil))))))) ("2" (grind) nil))))))))))))))))))) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res2) (("3" (typepred_res1) nil))))))) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_add_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil))))) ("2" (flatten) (("2" (assert) nil))))))))))))))) ("2" (grind) nil))))))) ("2" (grind) nil))))))))))))))))) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil))) ("2" (typepred "i") (("2" (grind) nil)))))))))))))))))))))))))))))))) nil) nil nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC22-1 nil 3632143264 ("" (tcc)) ((BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) shostak (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC25 0 (Eval_wCache_TCC23-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (last_ol def-decl "T" ordered_list structures) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (null_ol? const-decl "bool" ordered_list structures) (add_pd_pd const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC26 0 (Eval_wCache_TCC24-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res2) (("3" (typepred_res1) nil nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_add_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -9)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (next_idx_add_ac_ac formula-decl nil affine nil) (i skolem-const-decl "below(length(cons((re, add_ac_ac(ac1, ac2), null), cache2)))" affine_expr_Eval nil) (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_assoc formula-decl nil list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (add_pd_pd const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC27 0 (Eval_wCache_TCC27-1 "" 3789916940 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (ordered_list? def-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC25-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res2) (("3" (typepred_res1) nil nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_add_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -9)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC28 0 (Eval_wCache_TCC26-2 nil 3632158301 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC26-1 nil 3632143264 ("" (subtype-tcc) nil nil) ((BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (idxs_ac const-decl "list[nat]" affine nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC29 0 (Eval_wCache_TCC27-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5) (("3" (replace -4) (("3" (assert) (("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (cache_get def-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC30 0 (Eval_wCache_TCC28-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (restrict const-decl "R" restrict nil)) shostak (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re1)" "nil"))) (Eval_wCache_TCC31 0 (Eval_wCache_TCC31-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC32 0 (Eval_wCache_TCC32-1 "" 3789916946 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)")) (Eval_wCache_TCC29-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5) (("3" (replace -4) (("3" (assert) (("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC33 0 (Eval_wCache_TCC30-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) shostak (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC34 0 (Eval_wCache_TCC31-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval.box))}"))) (Eval_wCache_TCC35 0 (Eval_wCache_TCC32-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.cache1" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval.newid1)(cache)}"))) (Eval_wCache_TCC36 0 (Eval_wCache_TCC33-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (restrict const-decl "R" restrict nil)) shostak (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re2)" "nil"))) (Eval_wCache_TCC37 0 (Eval_wCache_TCC37-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC38 0 (Eval_wCache_TCC34-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) shostak (Eval_wCache subtype "affine_expr_Eval.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC39 0 (Eval_wCache_TCC39-1 "" 3789917098 ("" (skeep* :preds? t) (("" (assert) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.cache2" "(list_adt[CacheData].cons?)")) (Eval_wCache_TCC35-1 nil 3632143264 ("" (then (skeep* :preds? t) (assert)) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.cache2" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC40 0 (Eval_wCache_TCC36-1 nil 3632143264 ("" (skeep*) (("" (expand "next_idx_2") (("" (typepred "res2") (("" (assert) (("" (flatten) (("" (replace -13 :dir RL) (("" (typepred "res1") (("" (assert) (("" (flatten) (("" (replaces -16) (("" (hide-all-but (6 -8 -4 -9 -16)) (("" (expand "idxs_bounded") (("" (inst -1 "0") (("1" (inst? :subst ("i" "0")) (("1" (expand "nth") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (reveal 1) (("3" (grind) nil nil)) nil)) nil) ("2" (reveal 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx_2 const-decl "nat" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (below type-eq-decl nil naturalnumbers nil) (res1 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = re1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "affine_expr_Eval.newid2" "{newidx: naturalnumbers.nat | reals.>=(newidx, affine.next_idx_2(pd(affine_expr_Eval.ac1), pd(affine_expr_Eval.ac2)))}"))) (Eval_wCache_TCC41 0 (Eval_wCache_TCC37-2 nil 3632158377 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC37-1 nil 3632143264 ("" (tcc)) ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil)) shostak (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC42 0 (Eval_wCache_TCC38-2 "" 3743920758 ("" (skeep*) (("" (assert) (("" (hide 1) (("" (hide -6) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (length def-decl "nat" list_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (mult_ac_ac const-decl "AffineCombination" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC38-1 nil 3632143264 ("" (tcc) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) (mult_ac_ac const-decl "AffineCombination" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC43 0 (Eval_wCache_TCC39-2 nil 3632158836 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound"))))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound"))))) (("" (split 4) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "next_idx_2") (("3" (expand ">=") (("3" (expand "idxs_bounded") (("3" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res2) (("3" (typepred_res1) (("3" (hide-all-but (3 "newid2-prop" "newid1-prop")) (("3" (expand ">=") (("3" (case "nextfreeidx <= newid2") (("1" (hide-all-but (-1 1)) (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "nextfreeidx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (typepred "reals.<=") (("2" (expand "total_order?") (("2" (expand "partial_order?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (expand "transitive?") (("2" (flatten) (("2" (inst - "nextfreeidx" "newid1" "newid2") (("2" (split -) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_mult_ac_ac") (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (hide-all-but (3 "cache2-idxs_bound")) (("1" (expand ">=") (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (next_idx_mult_ac_ac formula-decl nil affine nil) (below type-eq-decl nil nat_types nil) (i skolem-const-decl "below(length(cons((re, mult_ac_ac(ac1, ac2, newid2), null), cache2)))" affine_expr_Eval nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (lt_plus_lt2 formula-decl nil real_props nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (realorder? const-decl "bool" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (newid2 skolem-const-decl "nat" affine_expr_Eval nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx_2 const-decl "nat" affine nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_assoc formula-decl nil list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (length def-decl "nat" list_props nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (below type-eq-decl nil naturalnumbers nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (nth def-decl "T" list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (mult_ac_ac const-decl "AffineCombination" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC39-1 nil 3632143264 ("" (tcc)) ((ordered_list? def-decl "bool" ordered_list structures)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC44 0 (Eval_wCache_TCC44-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC45 0 (Eval_wCache_TCC40-3 "" 3743921091 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) shostak (Eval_wCache subtype "affine_expr_Eval.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval.box))}")) (Eval_wCache_TCC40-2 nil 3632158947 ("" (skeep*) (("" (expand "next_idx_2") (("" (typepred "res2") (("" (assert) (("" (flatten) (("" (replace -13 :dir RL) (("" (typepred "res1") (("" (assert) (("" (flatten) (("" (replaces -16) (("" (hide-all-but (6 -8 -4 -9 -16)) (("" (expand "idxs_bounded") (("" (inst -1 "0") (("1" (inst? :subst ("i" "0")) (("1" (expand "nth") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (reveal 1) (("3" (grind) nil nil)) nil)) nil) ("2" (reveal 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval.box))}")) (Eval_wCache_TCC40-1 nil 3632143264 ("" (tcc)) nil shostak (Eval_wCache subtype "affine_expr_Eval.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval.box))}"))) (Eval_wCache_TCC46 0 (Eval_wCache_TCC41-1 nil 3632143264 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (idx!1 skolem-const-decl "nat" affine_expr_Eval nil) (length def-decl "nat" list_props nil) (box!1 skolem-const-decl "Box" affine_expr_Eval nil) (nextfreeidx!1 skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box!1)}" affine_expr_Eval nil) (cache!1 skolem-const-decl "{cache: (correct_cache?(box!1)) | idxs_bounded(nextfreeidx!1)(cache)}" affine_expr_Eval nil) (below type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)"))) (Eval_wCache_TCC47 0 (Eval_wCache_TCC47-1 nil 3789916209 ("" (assuming-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (next_idx const-decl "nat" affine nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (restrict const-decl "R" restrict nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil)) nil (Eval_wCache assuming "structures@ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (Eval_wCache_TCC48 0 (Eval_wCache_TCC48-1 "" 3789917114 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound"))))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound"))))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (= const-decl "[T, T -> boolean]" equalities nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_ol const-decl "ordered_list" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC43-1 nil 3632143264 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound"))))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound"))))) (("" (split 4) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "next_idx_2") (("3" (expand ">=") (("3" (expand "idxs_bounded") (("3" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res2) (("3" (typepred_res1) (("3" (hide-all-but (3 "newid2-prop" "newid1-prop")) (("3" (expand ">=") (("3" (case "nextfreeidx <= newid2") (("1" (hide-all-but (-1 1)) (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "nextfreeidx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (typepred "reals.<=") (("2" (expand "total_order?") (("2" (expand "partial_order?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (expand "transitive?") (("2" (flatten) (("2" (inst - "nextfreeidx" "newid1" "newid2") (("2" (split -) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_mult_ac_ac") (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (hide-all-but (3 "cache2-idxs_bound")) (("1" (expand ">=") (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_ol const-decl "ordered_list" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (Eval_wCache subtype "ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}"))) (Eval_wCache_TCC49 0 (Eval_wCache_TCC44-1 nil 3632143264 ("" (tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (ordered_list? def-decl "bool" ordered_list structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC50 0 (Eval_wCache_TCC45-1 nil 3632149132 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (below type-eq-decl nil naturalnumbers nil) (cache!1 skolem-const-decl "{cache: (correct_cache?(box!1)) | idxs_bounded(nextfreeidx!1)(cache)}" affine_expr_Eval nil) (nextfreeidx!1 skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box!1)}" affine_expr_Eval nil) (box!1 skolem-const-decl "Box" affine_expr_Eval nil) (idx!1 skolem-const-decl "nat" affine_expr_Eval nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nat_expt application-judgement "nat" exponentiation nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (last_ol def-decl "T" ordered_list structures) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC51 0 (Eval_wCache_TCC46-2 nil 3632159098 ("" (skeep* :preds? t) (("" (assert) (("" (replace -14 2) (("" (split 2) (("1" (grind) nil nil) ("2" (assert) (("2" (inst 1 "cons[CacheData]( (re, acRes, null)::CacheData, null[CacheData])") (("1" (expand "append") (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (replace -14 1) (("1" (expand "null_ol") (("1" (expand "pow_var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand "next_idx") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "next_idx") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (replace -1 :hide? t) (("1" (replace -10 :hide? t) (("1" (expand "next_idx" 1) (("1" (expand "last_idx") (("1" (assert) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "last_idx_box") (("1" (expand "next_idx" -1) (("1" (expand "last_idx" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (assert) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "pow=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "next_idx" 2) (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (expand "empty_ErrorTerms") (("1" (replace -9 :hide? t) (("1" (use "last_idx_box") (("1" (expand "next_idx" -1) (("1" (expand "last_idx" -1) (("1" (expand "nth") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_bounded" -5) (("2" (inst -5 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (ac_proj_pd formula-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_idx_box formula-decl nil affine_box nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (cons_ol const-decl "ordered_list" ordered_list structures) (real_times_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (last_ol def-decl "T" ordered_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (olidx_car_last formula-decl nil indexed_list structures) (lt_idx const-decl "bool" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (car_ol const-decl "T" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (acRes skolem-const-decl "AffineCombination" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (i skolem-const-decl "below(length(cons((re, acRes, null), cache)))" affine_expr_Eval nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC46-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC52 0 (Eval_wCache_TCC47-2 nil 3637405210 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil (Eval_wCache subtype "affine_expr_Eval.re" "(affine_expr.powvar?)")) (Eval_wCache_TCC47-1 nil 3632149132 ("" (skeep* :preds? t) (("" (assert) (("" (replace -11 2) (("" (split 2) (("1" (grind) nil nil) ("2" (assert) (("2" (inst 1 "(: (re, acRes, null) :)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("3" (assert) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (replace -11 1) (("1" (expand "null_ol") (("1" (expand "pow_var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (split 2) (("1" (grind) nil nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (replace -1 :hide? t) (("1" (replace -10 :hide? t) (("1" (expand "next_idx" 1) (("1" (expand "last_idx") (("1" (assert) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "last_idx_box") (("1" (expand "next_idx" -1) (("1" (expand "last_idx" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (assert) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "pow=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "next_idx" 2) (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (expand "empty_ErrorTerms") (("1" (replace -9 :hide? t) (("1" (use "last_idx_box") (("1" (expand "next_idx" -1) (("1" (expand "last_idx" -1) (("1" (expand "nth") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_bounded" -4) (("2" (inst -4 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (ac_proj_pd formula-decl nil affine nil) (last_idx_box formula-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (cons_ol const-decl "ordered_list" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (olidx_car_last formula-decl nil indexed_list structures) (lt_idx const-decl "bool" indexed_list structures) (car_ol const-decl "T" ordered_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.re" "(affine_expr.powvar?)"))) (Eval_wCache_TCC53 0 (Eval_wCache_TCC48-2 nil 3637417843 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil (Eval_wCache subtype "Maybe[CacheData].val(affine_expr_Eval.cached)`1" "(IntervalExpr_adt.pow?)")) (Eval_wCache_TCC48-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (Eval_wCache subtype "Maybe[CacheData].val(affine_expr_Eval.cached)`1" "(IntervalExpr_adt.pow?)"))) (Eval_wCache_TCC54 0 (Eval_wCache_TCC54-1 "" 3789917200 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (typepred "cache") (("" (expand "correct_cache?" 4) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace "cached" -1 :dir RL) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal "re") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "re") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (pow skolem-const-decl "nat" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (last_ol def-decl "T" ordered_list structures) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (varidx_powvar const-decl "nat" affine_expr nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC49-2 nil 3632159201 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (typepred "cache") (("" (expand "correct_cache?" 4) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace "cached" -1 :dir RL) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal "re") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "re") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_ol def-decl "T" ordered_list structures) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC49-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC55 0 (Eval_wCache_TCC50-3 "" 3635153604 ("" (skeep*) (("" (assert) (("" (hide -9) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (NOT const-decl "[bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (powvar? const-decl "bool" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (varidx_powvar const-decl "nat" affine_expr nil) (length def-decl "nat" list_props nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC50-2 nil 3632159278 ("" (skeep*) (("" (assert) (("" (hide -7) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (last_ol def-decl "T" ordered_list structures) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC50-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC56 0 (Eval_wCache_TCC56-1 "" 3789917203 ("" (skeep* :preds? t) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (represents_var? const-decl "bool" affine nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (Eval_wCache_TCC51-3 nil 3637420984 ("" (skeep* :preds? t) (("" (assert) (("" (replace -14 2) (("" (split 2) (("1" (grind) nil nil) ("2" (assert) (("2" (inst 1 "cons[CacheData]( (re, acRes, null)::CacheData, null[CacheData])") (("1" (expand "append") (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (replace -14 1) (("1" (expand "null_ol") (("1" (expand "pow_var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand "next_idx") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "next_idx") (("1" (expand "empty_ErrorTerms") (("1" (expand "last_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (replace -1 :hide? t) (("1" (replace -10 :hide? t) (("1" (expand "next_idx" 1) (("1" (expand "last_idx") (("1" (assert) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "last_idx_box") (("1" (expand "next_idx" -1) (("1" (expand "last_idx" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (assert) (("1" (expand "cons_ol") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "pow=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "next_idx" 2) (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (expand "empty_ErrorTerms") (("1" (replace -9 :hide? t) (("1" (use "last_idx_box") (("1" (expand "next_idx" -1) (("1" (expand "last_idx" -1) (("1" (expand "nth") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_bounded" -5) (("2" (inst -5 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (represents_var? const-decl "bool" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith)) nil (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (Eval_wCache_TCC51-2 nil 3635153659 ("" (skeep*) (("" (assert) (("" (hide -7) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (Eval_wCache_TCC51-1 nil 3632149132 ("" (skeep*) (("" (assert) (("" (replace -6 4 :hide? t) (("" (assert) (("" (split 4) (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (expand "nth" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (inst -2 "i-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (represents_var? const-decl "bool" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)"))) (Eval_wCache_TCC57 0 (Eval_wCache_TCC52-4 "" 3743922768 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace -8 -1 :dir RL) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (assert) (("" (flatten) (("" (assert) (("" (replaces -8) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (idxs_pd def-decl "list[nat]" affine nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC52-3 nil 3637421193 ("" (then (skeep*) (replaces -2) (expand "powvar?") (propax)) nil nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures) (idxs_pd def-decl "list[nat]" affine nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC52-2 nil 3632159338 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace -6 -1 :dir RL) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (assert) (("" (flatten) (("" (split -5) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -8) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (car_ol const-decl "T" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (represents_var? const-decl "bool" affine nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC52-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}"))) (Eval_wCache_TCC58 0 (Eval_wCache_TCC58-2 "" 3803760920 ("" (skeep*) (("" (apply (then (label "re" -2) (label "varac" -1) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -6) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (idxs_pd def-decl "list[nat]" affine nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (last_ol def-decl "T" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (pow skolem-const-decl "nat" affine_expr_Eval nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC58-1 "" 3789917285 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_pd def-decl "list[nat]" affine nil) (last_ol def-decl "T" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC53-3 nil 3635153725 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_pd def-decl "list[nat]" affine nil) (last_ol def-decl "T" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC53-2 nil 3632159420 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow < cached pow" -4) (label "cached" -5) (label "idxs" -6) (label "pownoises" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (hide 5) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (expand "correct_cache?" 5) (("" (expand "CacheData_correct?") (("" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("" (typepred "cached") (("" (assert) (("" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("" (skeep "cached cache idx") (("" (use "cache_powvar_correct_result") (("" (with-labels (assert) ("cached is correct" "UNKNOWN")) (("" (replace "cached" "cached is correct" :dir RL) (("" (expand "CacheData_correct?") (("" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("" (split "cached cond ok") (("1" (replace "pownoises" "cached cond ok" :dir RL) (("1" (replace "cached`1 varidx" "cached cond ok") (("1" (reveal "re") (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (flatten "cached cond ok") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC53-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC59 0 (Eval_wCache_TCC54-5 "" 3743922889 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "pow < cached pow" -7) (label "cached" -5) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 5))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (re, acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (assert ("cached is correct" "cached`1 is powvar")) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (lemma "nth_ol[nat,<]") (("1" (inst -1 "pownoises" "opn(nth(cache, i!1)`1)-2" "pow-2") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (append def-decl "list[T]" list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (realorder? const-decl "bool" real_orders reals) (strict_total_order? const-decl "bool" orders nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (trichotomous? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (irreflexive? const-decl "bool" relations nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (strict_order? const-decl "bool" orders nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (nth_ol formula-decl nil ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (below type-eq-decl nil nat_types nil) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (below type-eq-decl nil naturalnumbers nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC54-4 nil 3637421292 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (typepred "cache") (("" (expand "correct_cache?" 4) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace "cached" -1 :dir RL) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal "re") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "re") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth_ol formula-decl nil ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (realorder? const-decl "bool" real_orders reals) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC54-3 nil 3635153793 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow < cached pow" -4) (label "cached" -5) (label "idxs" -6) (label "pownoises" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (hide 5) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (expand "correct_cache?" 5) (("" (expand "CacheData_correct?") (("" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("" (typepred "cached") (("" (assert) (("" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("" (skeep "cached cache idx") (("" (use "cache_powvar_correct_result") (("" (with-labels (assert) ("cached is correct" "UNKNOWN")) (("" (replace "cached" "cached is correct" :dir RL) (("" (expand "CacheData_correct?") (("" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("" (split "cached cond ok") (("1" (replace "pownoises" "cached cond ok" :dir RL) (("1" (replace "cached`1 varidx" "cached cond ok") (("1" (reveal "re") (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (flatten "cached cond ok") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC54-2 nil 3632159702 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow < cached pow" -4) (label "cached" -5) (label "idxs" -6) (label "pownoises" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (assert ("cached is correct" "cached`1 is powvar")) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (lemma "nth_ol[nat,<]") (("2" (inst -1 "pownoises" "opn(nth(cache, i!1)`1)-2" "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (nth_ol formula-decl nil ordered_list structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Interval type-eq-decl nil interval interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC54-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC60 0 (Eval_wCache_TCC60-1 "" 3789917289 ("" (skeep*) (("" (assert) nil nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval.cached)`1), 2), 1)" "nat")) (Eval_wCache_TCC55-3 nil 3637421557 ("" (skeep*) (("" (assert) (("" (hide -9) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval.cached)`1), 2), 1)" "nat")) (Eval_wCache_TCC55-2 nil 3635153830 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow < cached pow" -4) (label "cached" -5) (label "idxs" -6) (label "pownoises" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (assert ("cached is correct" "cached`1 is powvar")) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (lemma "nth_ol[nat,<]") (("1" (inst -1 "pownoises" "opn(nth(cache, i!1)`1)-2" "pow-2") (("1" (assert) nil nil)) nil) ("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (nth_ol formula-decl nil ordered_list structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval.cached)`1), 2), 1)" "nat")) (Eval_wCache_TCC55-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil)) nil (Eval_wCache subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval.cached)`1), 2), 1)" "nat"))) (Eval_wCache_TCC61 0 (Eval_wCache_TCC61-1 "" 3789917289 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) nil nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}")) (Eval_wCache_TCC56-2 nil 3637421797 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (assert) (("" (flatten) (("" (split -5) (("1" (flatten) (("1" (assert) (("1" (replaces -8) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}")) (Eval_wCache_TCC56-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil)) nil (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}"))) (Eval_wCache_TCC62 0 (Eval_wCache_TCC62-1 "" 3789917290 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) nil nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}")) (Eval_wCache_TCC57-1 nil 3632149132 ("" (then (skeep*) (use "cache_powvar_correct_result") (assert) (replace -8 -1 :dir RL) (expand "CacheData_correct?") (typepred "cached") (assert) (flatten) (assert) (flatten) (assert) (replaces -8) (grind)) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}"))) (Eval_wCache_TCC63 0 (Eval_wCache_TCC58-2 "" 3743922958 ("" (skeep*) (("" (replaces -4) (("" (expand "represents_var?") (("" (expand "nth_ac") (("" (expand "var_ac") (("" (assert) (("" (lift-if 7) (("" (expand_ol) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_ac const-decl "AffineCombination" affine_box nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (/= const-decl "boolean" notequal nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (length_singleton formula-decl nil more_list_props structures) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (var_ac const-decl "AffineCombination" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (represents_var? const-decl "bool" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (Eval_wCache_TCC58-1 nil 3632149132 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow < cached pow" -6) (label "cached" -7) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (hide 5) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (expand "correct_cache?" 5) (("" (expand "CacheData_correct?") (("" (expand "powvar?") (("" (expand "varidx_powvar") (("" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("" (typepred "cached") (("" (assert) (("" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("" (skeep "cached cache idx") (("" (use "cache_powvar_correct_result") (("" (with-labels (assert) ("cached is correct" "UNKNOWN")) (("" (replace "cached" "cached is correct" :dir RL) (("" (expand "CacheData_correct?") (("" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("" (split "cached cond ok") (("1" (replace "pownoises" "cached cond ok" :dir RL) (("1" (replace "cached`1 varidx" "cached cond ok") (("1" (reveal "re") (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (flatten "cached cond ok") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "varidx_powvar") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((represents_var? const-decl "bool" affine nil) (var_ac const-decl "AffineCombination" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (length_singleton formula-decl nil more_list_props structures) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (ac_proj_cv formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)"))) (Eval_wCache_TCC64 0 (Eval_wCache_TCC64-1 "" 3803762046 ("" (skeep*) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "cached" -5) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 6) (label "not in cache 2" 5) (label "not in cache 1" 4))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil) ("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (use "next_idx_pow_var_ac") (("1" (expand "idxs_bounded") (("1" (inst "cache correct" "i") (("1" (replace "cached`2 is powvarac" "cache correct" :hide? t) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (hide-all-but 1) (("4" (assuming-tcc) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("4" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                                                                                                                                                      (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                                                              nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (nil application-judgement "above(n)" exp2 nil) (append def-decl "list[T]" list_props nil) (idxs_ac const-decl "list[nat]" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (last_idx const-decl "int" indexed_list structures) (real_minus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval nil) (pownoises skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine_expr_Eval nil) (last_take_nth formula-decl nil ordered_list structures) (transitive? const-decl "bool" relations nil) (irreflexive? const-decl "bool" relations nil) (pred type-eq-decl nil defined_types nil) (strict_order? const-decl "bool" orders nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (length_take formula-decl nil more_list_props structures) (newoff skolem-const-decl "int" affine_expr_Eval nil) (length_append formula-decl nil list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (last_idx_box formula-decl nil affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_wCache subtype "affine_expr_Eval.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC59-3 "" 3743922999 ("" (skeep*) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil) ("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (use "next_idx_pow_var_ac") (("1" (expand "idxs_bounded") (("1" (inst "cache correct" "i") (("1" (replace "cached`2 is powvarac" "cache correct" :hide? t) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (hide-all-but 1) (("4" (assuming-tcc) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("4" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                                                                                                                                     (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                                             nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (last_take_nth formula-decl nil ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (length_take formula-decl nil more_list_props structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (last_idx_box formula-decl nil affine_box nil)) shostak (Eval_wCache subtype "affine_expr_Eval.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC59-2 nil 3632159972 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow < cached pow" -6) (label "cached" -7) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (re, acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (assert ("cached is correct" "cached`1 is powvar")) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (lemma "nth_ol[nat,<]") (("1" (inst -1 "pownoises" "opn(nth(cache, i!1)`1)-2" "pow-2") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_box formula-decl nil affine_box nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (length_take formula-decl nil more_list_props structures) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (take def-decl "list[T]" more_list_props structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (realorder? const-decl "bool" real_orders reals) (last_take_nth formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (take_ol formula-decl nil ordered_list structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC59-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}"))) (Eval_wCache_TCC65 0 (Eval_wCache_TCC65-1 "" 3803763006 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "cached" -5) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 6) (label "pow gt opn" 5) (label "opw gt opn" 4))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil) ("3" (assert) (("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (case "NOT length(pd(nth_ac(box, varidx_powvar(nth(cache, i)`1)))) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-1 "cached cache idx" "varac" "varac not single value" "cached`1 varidx" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil) ("5" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("1" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (split -1) (("1" (expand "correct_cache?" -1) (("1" (flatten) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (expand "nth" -2) (("2" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "correct_cache?" -1) (("3" (flatten) nil nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -2) (("4" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (expand "powvar?") (("2" (replace "re" 1) (("2" (assert) (("2" (expand "varidx_powvar") (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                                                          nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (last_take_nth formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (transitive? const-decl "bool" relations nil) (irreflexive? const-decl "bool" relations nil) (pred type-eq-decl nil defined_types nil) (strict_order? const-decl "bool" orders nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (list_induction formula-decl nil list_adt nil) (last_idx const-decl "int" indexed_list structures) (t skolem-const-decl "list[CacheData]" affine_expr_Eval nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (h skolem-const-decl "CacheData" affine_expr_Eval nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval nil) (every adt-def-decl "boolean" list_adt nil) (append def-decl "list[T]" list_props nil) (length_append formula-decl nil list_props nil) (newoff skolem-const-decl "int" affine_expr_Eval nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (length_take formula-decl nil more_list_props structures) (last_idx_box formula-decl nil affine_box nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC60-4 nil 3635154099 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil) ("3" (assert) (("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (case "NOT length(pd(nth_ac(box, varidx_powvar(nth(cache, i)`1)))) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-1 "cached cache idx" "varac" "varac not single value" "cached`1 varidx" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil) ("5" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("1" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (split -1) (("1" (expand "correct_cache?" -1) (("1" (flatten) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (expand "nth" -2) (("2" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "correct_cache?" -1) (("3" (flatten) nil nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -2) (("4" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assuming-tcc) nil nil)) nil) ("3" (hide-all-but 1) (("3" (assuming-tcc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (expand "powvar?") (("2" (replace "re" 1) (("2" (assert) (("2" (expand "varidx_powvar") (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                                             nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (last_take_nth formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (var_ac const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (length_take formula-decl nil more_list_props structures) (last_idx_box formula-decl nil affine_box nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC60-3 nil 3635153975 ("" (skeep*) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil))) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil))))) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (grind) nil))))))))))))))))) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil))))))))))))))))))))) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil) ("2" (assert) nil))) ("3" (assert) nil) ("4" (assert) nil))))))) ("3" (use "take_ol[nat,<]") (("3" (assert) nil))) ("4" (assert) nil))))) ("2" (propax) nil))) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil))))))))))))))))))))))))) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil))))))))))))))))))))))))))))))) ("2" (assert) nil))))) ("2" (assert) nil))))) ("2" (assert) nil) ("3" (assert) nil))) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                                                                            (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                    nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil))))) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil))))) ("3" (grind) nil))))))))))) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil))))) ("2" (assert) nil))) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil))))))))))) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))))) nil) nil nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC60-2 nil 3632160081 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (case "NOT length(pd(nth_ac(box, varidx(nth(cache, i)`1)))) = 0") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lift-if "cache idxs bound") (("1" (split "cache idxs bound") (("1" (flatten) (("1" (hide-all-but (-1 -3 "cached cond ok" "cached cache idx" 2)) (("1" (replaces "cached cache idx") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand ">=") (("2" (hide-all-but ("cache idxs bound" 4)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 "cached cache idx" "varac" "varac not single value" "cached`1 varidx" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (use "take_ol[nat,<]") (("4" (assert) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("2" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (split -1) (("1" (expand "correct_cache?" -1) (("1" (flatten) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (expand "nth" -2) (("2" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "correct_cache?" -1) (("3" (flatten) nil nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -2) (("4" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (replace "re" 1) (("2" (assert) (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                     nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (last_take_nth formula-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (var_ac const-decl "AffineCombination" affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (last_idx_box formula-decl nil affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC60-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC66 0 (Eval_wCache_TCC66-2 "" 3803763986 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "cached" -5) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 6) (label "pow gt opn" 5) (label "opw gt opn" 4))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                    pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "more_list_props[nat].nth_append") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (assert) (("2" (split -1) (("1" (assert) (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                                     =
                                                                     nth(nats(nextfreeidx, newoff - 1),
                                                                         pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                            pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length_take formula-decl nil more_list_props structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (idxs_pd def-decl "list[nat]" affine nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nil application-judgement "above(n)" exp2 nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (nth_append formula-decl nil more_list_props structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (take def-decl "list[T]" more_list_props structures) (length_append formula-decl nil list_props nil) (newoff skolem-const-decl "int" affine_expr_Eval nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (cache skolem-const-decl "{cache: (correct_cache?(box)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval nil) (real_minus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (> const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC66-1 "" 3789917313 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                          nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                   pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "more_list_props[nat].nth_append") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (assert) (("2" (split -1) (("1" (assert) (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                    =
                                                    nth(nats(nextfreeidx, newoff - 1),
                                                        pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                         pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (length_take formula-decl nil more_list_props structures) (idxs_pd def-decl "list[nat]" affine nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (nth_append formula-decl nil more_list_props structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (take def-decl "list[T]" more_list_props structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC61-4 nil 3637421951 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                          nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                   pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "more_list_props[nat].nth_append") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (assert) (("2" (split -1) (("1" (assert) (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                    =
                                                    nth(nats(nextfreeidx, newoff - 1),
                                                        pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                         pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (length_take formula-decl nil more_list_props structures) (idxs_pd def-decl "list[nat]" affine nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (nth_append formula-decl nil more_list_props structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (take def-decl "list[T]" more_list_props structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC61-3 nil 3635154882 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil) ("3" (assert) (("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (case "NOT length(pd(nth_ac(box, varidx(nth(cache, i)`1)))) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-1 "cached cache idx" "varac" "varac not single value" "cached`1 varidx" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("1" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (split -1) (("1" (expand "correct_cache?" -1) (("1" (flatten) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (expand "nth" -2) (("2" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "correct_cache?" -1) (("3" (flatten) nil nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -2) (("4" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (replace "re" 1) (("2" (assert) (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                  nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (last_take_nth formula-decl nil ordered_list structures) (cons_ol const-decl "ordered_list" ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (var_ac const-decl "AffineCombination" affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (last_idx_box formula-decl nil affine_box nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC61-2 nil 3632160598 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -11) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                         nats(nextfreeidx, newoff - 1)),
                                                                                                                  pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1 1) (("2" (use "length_take[nat]") (("2" (replaces -1 1) (("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                             pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_box formula-decl nil affine_box nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (idxs_ac const-decl "list[nat]" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Interval type-eq-decl nil interval interval_arith) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC61-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC67 0 (Eval_wCache_TCC67-1 "" 3789917314 ("" (skeep*) (("" (grind) nil nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}")) (Eval_wCache_TCC62-3 nil 3637422043 ("" (then (skeep*) (grind)) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}")) (Eval_wCache_TCC62-2 nil 3635155516 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -11) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                          nats(nextfreeidx, newoff - 1)),
                                                                                                                                   pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1 1) (("2" (use "length_take[nat]") (("2" (replaces -1 1) (("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_box formula-decl nil affine_box nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (idxs_ac const-decl "list[nat]" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}")) (Eval_wCache_TCC62-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (Eval_wCache subtype "(number_fields.-)(affine_expr_Eval.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval.nextfreeidx, e)}"))) (Eval_wCache_TCC68 0 (Eval_wCache_TCC63-3 "" 3743923245 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length def-decl "nat" list_props nil)) shostak (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (more_list_props "" 3644773828 ("" (then (skeep*) (replaces -4) (expand "represents_var?") (expand "nth_ac") (expand "var_ac") (assert) (lift-if 7) (expand_ol) (assert)) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil)) shostak (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (Eval_wCache_TCC63-2 nil 3637423816 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                           nats(nextfreeidx, newoff - 1)),
                                                                                                                                                    pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replaces -1 1) (("2" (use "length_take[nat]") (("2" (replaces -1 1) (("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                   pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (idxs_ac const-decl "list[nat]" affine nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (idxs_pd def-decl "list[nat]" affine nil) (last_idx_box formula-decl nil affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)")) (Eval_wCache_TCC63-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.varac" "(affine.represents_var?)"))) (Eval_wCache_TCC69 0 (Eval_wCache_TCC64-2 "" 3743923392 ("" (auto-rewrite-defs :always? t) (("" (assert :let-reduce? t :cases-rewrite? nil :ignore-typepreds? nil) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (lift-if :updates? t) (("" (replace*) (("" (assert :let-reduce? t :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil :cases-rewrite? nil) (("" (bddsimp) (("1" (inst? :if-match t :polarity? nil) (("1" (skolem-typepred) (("1" (lift-if :updates? t) (("1" (replace*) (("1" (assert :let-reduce? t :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil :cases-rewrite? nil) nil nil)) nil)) nil)) nil)) nil) ("2" (inst? :if-match t :polarity? nil) (("2" (skolem-typepred) (("2" (lift-if :updates? t) (("2" (replace*) (("2" (assert :let-reduce? t :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil :cases-rewrite? nil) nil nil)) nil)) nil)) nil)) nil) ("3" (inst? :if-match t :polarity? nil) (("3" (lift-if :updates? t) (("3" (replace*) (("3" (assert :let-reduce? t :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil :cases-rewrite? nil) nil nil)) nil)) nil)) nil) ("4" (inst? :if-match t :polarity? nil) (("4" (lift-if :updates? t) (("4" (replace*) (("4" (assert :let-reduce? t :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil :cases-rewrite? nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_plus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_ol def-decl "T" ordered_list structures) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (varidx_powvar const-decl "nat" affine_expr nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}")) (Eval_wCache_TCC64-1 nil 3632149132 ("" (skeep*) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil) ("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (expand "idxs_bounded") (("1" (inst "cache correct" "i") (("1" (replace "cached`2 is powvarac" "cache correct" :hide? t) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (hide-all-but 1) (("4" (typepred "reals.<") (("4" (grind) nil nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("4" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                                                                                                                    (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                            nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (last_ol def-decl "T" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith)) nil (Eval_wCache subtype "affine_expr_Eval.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval.varac)) = 0)}"))) (Eval_wCache_TCC70 0 (Eval_wCache_TCC70-1 "" 3803764352 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 6) (label "not in cache 2" 5) (label "not in cache 1" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "correct_cache?") (("1" (expand "CacheData_correct?") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (replaces "nwidxs" 2) (("1" (expand "nats" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (replaces -1) (("1" (case "0<=pow - 1") (("1" (name-replace "A" "pow -1 ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (int_times_even_is_even application-judgement "even_int" integers nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (last_idx_box formula-decl nil affine_box nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC65-4 "" 3743923422 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "correct_cache?") (("1" (expand "CacheData_correct?") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (replaces "nwidxs" 2) (("1" (expand "nats" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (replaces -1) (("1" (case "0<=pow - 1") (("1" (name-replace "A" "pow -1 ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (last_idx_box formula-decl nil affine_box nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC65-3 nil 3635155612 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil) ("3" (assert) (("3" (expand "appendable_ol?") (("3" (flatten) (("3" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (case "NOT length(pd(nth_ac(box, varidx_powvar(nth(cache, i)`1)))) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-1 "cached cache idx" "varac" "varac not single value" "cached`1 varidx" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (use "take_ol[nat,<]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("1" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (split -1) (("1" (expand "correct_cache?" -1) (("1" (flatten) nil nil)) nil) ("2" (expand "idxs_bounded") (("2" (skeep) (("2" (expand "nth" -2) (("2" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "correct_cache?" -1) (("3" (flatten) nil nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -2) (("4" (inst? :subst ("i" "i+1")) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (expand "powvar?") (("2" (replace "re" 1) (("2" (assert) (("2" (expand "varidx_powvar") (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                                nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (varidx_powvar const-decl "nat" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (last_idx_box formula-decl nil affine_box nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (powvar? const-decl "bool" affine_expr nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC65-2 nil 3632160666 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "correct_cache?") (("1" (expand "CacheData_correct?") (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (replaces "nwidxs" 2) (("1" (expand "nats" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (replaces -1) (("1" (case "0<=pow - 1") (("1" (name-replace "A" "pow -1 ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (last_idx_box formula-decl nil affine_box nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC65-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC71 0 (Eval_wCache_TCC66-4 "" 3743923457 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (re, acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (replaces "newoff") (("2" (expand ">=") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -2 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (<= const-decl "bool" reals nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (car_ol const-decl "T" ordered_list structures) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC66-3 nil 3635155679 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (replace "newoff" 1) (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace "nwidxs" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                  nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                           pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "more_list_props[nat].nth_append") (("2" (use "length_take[nat]") (("2" (replaces -1) (("2" (assert) (("2" (split -1) (("1" (assert) (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                             =
                             nth(nats(nextfreeidx, newoff - 1),
                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                               pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC66-2 nil 3632160751 ("" (skeep*) (("" (assert) (("" (hide -8) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (replaces "newoff") (("2" (expand ">=") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -2 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Interval type-eq-decl nil interval interval_arith) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}")) (Eval_wCache_TCC66-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC72 0 (Eval_wCache_TCC72-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC73 0 (Eval_wCache_TCC67-3 nil 3637424007 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (restrict const-decl "R" restrict nil)) nil (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re1)" "nil")) (Eval_wCache_TCC67-2 nil 3635155703 ("" (skeep*) (("" (assert) (("" (hide -8) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (typepred "reals.<") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "reals.<") (("3" (grind) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (typepred "reals.<") (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (expand ">=") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -2 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (car_ol const-decl "T" ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re1)" "nil")) (Eval_wCache_TCC67-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re1)" "nil"))) (Eval_wCache_TCC74 0 (Eval_wCache_TCC74-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC75 0 (Eval_wCache_TCC68-2 nil 3637424154 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)")) (Eval_wCache_TCC68-1 nil 3632149132 ("" (tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC76 0 (Eval_wCache_TCC69-3 "" 3743923504 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) shostak (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)")) (Eval_wCache_TCC69-2 "" 3691952957 ("" (skeep*) (("" (postpone) nil nil)) nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) shostak (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)")) (Eval_wCache_TCC69-1 nil 3632149132 ("" (tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (last_ol def-decl "T" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) nil (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC77 0 (Eval_wCache_TCC70-2 "" 3743923533 ("" (skeep*) (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval.box))}")) (Eval_wCache_TCC70-1 nil 3632149132 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (replaces "re") (replaces "result") (assert) (spread (split 7) ((then (expand "correct_cache?") (expand "CacheData_correct?") (expand "powvar?") (expand "varidx_powvar") (flatten) (typepred "nextfreeidx") (replaces "nwidxs" 2) (expand "nats" 2) (lift-if 2) (spread (split 2) ((then (assert) (flatten) (replaces -1 1 :dir RL) (use "last_idx_box") (grind)) (then (flatten) (expand_ol) (use "last_idx_box") (grind))))) (then (replaces "newoff") (hide-all-but (1 "pow <= 1")) (spread (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") ((then (replaces -1) (spread (case "0<=pow - 1") ((then (name-replace "A" "pow -1 ") (assert)) (assert)))) (assert))))))) nil nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval_wCache subtype "affine_expr_Eval.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval.box))}"))) (Eval_wCache_TCC78 0 (Eval_wCache_TCC71-2 "" 3743923563 ("" (skeep*) (("" (expand "idxs_bounded") (("" (typepred "res1") (("" (assert) (("" (flatten) (("" (replace -7 :dir RL) (("" (replace -8 :dir RL) (("" (expand "idxs_bounded") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.cache1" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval.newid1)(cache)}")) (Eval_wCache_TCC71-1 nil 3632149132 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (re, acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (replaces "newoff") (("2" (expand ">=") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -2 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "affine_expr_Eval.cache1" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval.newid1)(cache)}"))) (Eval_wCache_TCC79 0 (Eval_wCache_TCC72-1 nil 3632149132 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "R" restrict nil)) nil (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re2)" "nil"))) (Eval_wCache_TCC80 0 (Eval_wCache_TCC80-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC81 0 (Eval_wCache_TCC73-1 nil 3632149132 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC82 0 (Eval_wCache_TCC74-2 nil 3637424199 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.cache2" "(list_adt[CacheData].cons?)")) (Eval_wCache_TCC74-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (Eval_wCache subtype "affine_expr_Eval.cache2" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC83 0 (Eval_wCache_TCC75-1 nil 3632149132 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC84 0 (Eval_wCache_TCC76-2 "" 3743923648 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (length def-decl "nat" list_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (sub_ac_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (sub_pd_pd const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC76-1 nil 3632149132 ("" (then (skeep*) (expand "idxs_bounded") (typepred "res1") (assert) (flatten) (replace -7 :dir RL) (replace -8 :dir RL) (expand "idxs_bounded") (propax)) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (sub_pd_pd const-decl "ErrorTerms" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC85 0 (Eval_wCache_TCC77-1 nil 3632149132 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res2) (("3" (typepred_res1) nil nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_sub_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -9)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (box skolem-const-decl "Box" affine_expr_Eval nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (next_idx_sub_ac_ac formula-decl nil affine nil) (i skolem-const-decl "below(length(cons((re, sub_ac_ac(ac1, ac2), null), cache2)))" affine_expr_Eval nil) (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_assoc formula-decl nil list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (sub_pd_pd const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC86 0 (Eval_wCache_TCC78-1 nil 3632149132 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (restrict const-decl "R" restrict nil)) nil (Eval_wCache termination "affine_expr_Eval.Eval_wCache(affine_expr_Eval.re1)" "nil"))) (Eval_wCache_TCC87 0 (Eval_wCache_TCC87-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC88 0 (Eval_wCache_TCC79-2 nil 3632160940 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)")) (Eval_wCache_TCC79-1 nil 3632149132 ("" (subtype-tcc) nil nil) nil shostak (Eval_wCache subtype "affine_expr_Eval.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?)"))) (Eval_wCache_TCC89 0 (Eval_wCache_TCC80-2 nil 3635156052 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)")) (Eval_wCache_TCC80-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "affine_expr_Eval.cache1" "(list_adt[CacheData].cons?)"))) (Eval_wCache_TCC90 0 (Eval_wCache_TCC81-2 nil 3637424234 ("" (tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (Eval_wCache_TCC81-1 nil 3632149132 ("" (tcc)) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures)) nil (Eval_wCache subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (Eval_wCache_TCC91 0 (Eval_wCache_TCC91-1 "" 3789917360 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (minus_real_is_real application-judgement "real" reals nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (length def-decl "nat" list_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (neg_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]")) (Eval_wCache_TCC82-1 nil 3632149132 ("" (then (skeep*) (assert) (hide -11) (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (spread (split 3) ((grind) (then (replaces "result") (assert) (typepred_res1) (typepred_res2) (skolem "cache2-form" "l2") (skolem "cache1-form" "l1") (replace "cache1-form" "cache2-form") (replace "cache2-form" 3) (spread (inst 3 "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") ((then (hide-all-but 3) (expand "append" 1 3) (use "append_assoc[CacheData]") (assert)) (grind)))) (then (replaces "result") (assert) (typepred_res2) (typepred_res1)) (then (replaces "result") (assert) (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (use "next_idx_sub_ac_ac") (expand ">=") (typepred_res2) (typepred_res1) (expand "idxs_bounded") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (replace "ac1" :dir RL) (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (replace "ac2" :dir RL) (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -9)) (expand "max") (lift-if -4) (spread (split -4) ((then (flatten) (expand ">=") (assert)) (then (flatten) (assert))))) (grind)))) (grind)))) (then (typepred_res2) (expand "idxs_bounded") (spread (inst "cache2-idxs_bound" "i-1") ((then (expand "nth" 3) (propax)) (then (typepred "i") (grind))))))))))) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (neg_ac const-decl "AffineCombination" affine nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (Eval_wCache subtype "affine_expr_Eval.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]"))) (Eval_wCache_TCC92 0 (Eval_wCache_TCC83-1 nil 3632149132 ("" (skeep*) (("" (assert) (("" (hide -7) (("" (apply (then (label "result" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 2) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" 2) (("2" (inst 2 "cons((re, neg_ac(ac1), null)::CacheData, l1)") (("1" (hide-all-but 2) (("1" (expand "append" 1 2) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "result") (("3" (assert) (("3" (typepred_res1) nil nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_neg_ac") (("1" (expand ">=") (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res1) (("2" (expand "idxs_bounded") (("2" (inst "cache1-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((neg_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (minus_real_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval nil) (i skolem-const-decl "below(length(cons((re, neg_ac(ac1), null), cache1)))" affine_expr_Eval nil) (next_idx_neg_ac formula-decl nil affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Some(affine_expr_Eval.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_wCache_TCC93 0 (Eval_wCache_TCC93-1 nil 3789916209 ("" (subtype-tcc) nil nil) ((next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval_wCache subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2)`1 = affine_expr_Eval.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval.cache)) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1, affine_expr_Eval.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(result)`2))}"))) (Eval_TCC1 0 (Eval_TCC1-2 "" 3789917363 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) shostak (Eval subtype "(number_fields.+)(affine_box.last_idx_in_box(affine_expr_Eval.box), 1)" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval.box))}")) (Eval_TCC1-1 nil 3632156083 ("" (tcc)) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval subtype "(number_fields.+)(affine_box.last_idx_in_box(affine_expr_Eval.box), 1)" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval.box))}"))) (Eval_TCC2 0 (Eval_TCC2-2 "" 3789917364 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) shostak (Eval subtype "list_adt[CacheData].null" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded((number_fields.+)(1, affine_box.last_idx_in_box(affine_expr_Eval.box)))(cache)}")) (Eval_TCC2-1 nil 3632156083 ("" (tcc)) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)) nil (Eval subtype "list_adt[CacheData].null" "{cache: (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box)) | affine_expr_Eval_fnd.idxs_bounded((number_fields.+)(1, affine_box.last_idx_in_box(affine_expr_Eval.box)))(cache)}"))) (Eval_TCC3 0 (Eval_TCC3-2 "" 3789917365 ("" (tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) shostak (Eval subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(affine_expr_Eval.result)`2" "(list_adt[CacheData].cons?)")) (Eval_TCC3-1 nil 3632156083 ("" (tcc)) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (Eval subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(affine_expr_Eval.result)`2" "(list_adt[CacheData].cons?)"))) (RE2AC_EvalwCache_eq 0 (RE2AC_EvalwCache_eq-1 nil 3632852138 ("" (deftactic solve_binary_aff nil (then (skolem 1 ("re1" "re2")) (flatten) (skeep) (hide -3) (spread (split -1) ((spread (split -2) ((then (inst -2 "nextfreeidx" "cache") (expand "Eval_wCache" 1) (replace -2 1 :hide? t) (lift-if 1) (spread (split 1) ((then (flatten) (grind)) (then (flatten) (spread (inst -1 "val(RE2AC(re1,
                                                                                          box,
                                                                                          vs,
                                                                                          nextfreeidx,
                                                                                          cache))`1" "val(RE2AC(re1,
                                                                                          box,
                                                                                          vs,
                                                                                          nextfreeidx,
                                                                                          cache))`2") ((then (replace -1 2 :hide? t) (spread (split 2) ((then (flatten) (expand "RE2AC" 1) (assert)) (then (flatten) (grind))))) (then (hide 3) (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                cache)") (assert) (flatten) (assert) (expand "compatible_pairs?") (propax)) (then (hide 3) (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                cache)") (assert)) (then (hide 3) (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                cache)") (assert)))))))) (then (typepred "re2") (propax)))) (then (typepred "re1") (propax)))))) (("" (skolem 1 ("box" "_" "vs" "_" "_")) (("" (induct "re") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "Eval_wCache") (("2" (expand "RE2AC") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (expand "Eval_wCache") (("3" (expand "RE2AC") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (solve_binary_aff) nil nil) ("5" (skeep*) (("5" (expand "Eval_wCache") (("5" (expand "RE2AC") (("5" (propax) nil nil)) nil)) nil)) nil) ("6" (skolem 1 ("re1")) (("6" (flatten) (("6" (skeep) (("6" (hide -2) (("6" (split -1) (("1" (expand "Eval_wCache" 1) (("1" (inst -1 "nextfreeidx" "cache") (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (solve_binary_aff) nil nil) ("8" (skolem 1 ("re1" "re2")) (("8" (flatten) (("8" (skeep) (("8" (hide -3) (("8" (split -1) (("1" (split -2) (("1" (inst -2 "nextfreeidx" "cache") (("1" (expand "Eval_wCache" 1) (("1" (replace -2 1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "RE2AC" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "val(RE2AC(re1,
                                                                                                   box,
                                                                                                   vs,
                                                                                                   nextfreeidx,
                                                                                                   cache))`1" "val(RE2AC(re1,
                                                                                                   box,
                                                                                                   vs,
                                                                                                   nextfreeidx,
                                                                                                   cache))`2") (("1" (split 2) (("1" (flatten) (("1" (expand "RE2AC" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (replaces -1) (("2" (expand "RE2AC" 2 14) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                           cache)") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "compatible_pairs?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                           cache)") (("3" (assert) nil nil)) nil)) nil) ("4" (hide 3) (("4" (typepred "RE2AC(re1, box, vs, nextfreeidx,
                                                                                                           cache)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep*) (("9" (expand "Eval_wCache") (("9" (expand "RE2AC") (("9" (propax) nil nil)) nil)) nil)) nil) ("10" (skeep*) (("10" (expand "Eval_wCache") (("10" (expand "RE2AC") (("10" (propax) nil nil)) nil)) nil)) nil) ("11" (skeep*) (("11" (expand "Eval_wCache") (("11" (expand "RE2AC") (("11" (propax) nil nil)) nil)) nil)) nil) ("12" (skeep*) (("12" (expand "Eval_wCache") (("12" (expand "RE2AC") (("12" (propax) nil nil)) nil)) nil)) nil) ("13" (skeep*) (("13" (expand "Eval_wCache") (("13" (expand "RE2AC") (("13" (propax) nil nil)) nil)) nil)) nil) ("14" (skeep*) (("14" (expand "Eval_wCache") (("14" (expand "RE2AC") (("14" (propax) nil nil)) nil)) nil)) nil) ("15" (assert) nil nil) ("16" (assert) nil nil) ("17" (assert) nil nil) ("18" (assert) nil nil) ("19" (assert) nil nil) ("20" (assert) nil nil) ("21" (assert) nil nil) ("22" (assert) nil nil) ("23" (assert) nil nil) ("24" (skeep*) (("24" (expand "Eval_wCache") (("24" (expand "RE2AC") (("24" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sub_pd_pd const-decl "ErrorTerms" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil) (neg_ac const-decl "AffineCombination" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (add_pd_pd const-decl "ErrorTerms" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr_induction formula-decl nil IntervalExpr_adt interval_arith) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith)) nil)) (EvalwCache_inclusion__TCC1 0 (EvalwCache_inclusion__TCC1-1 nil 3637955749 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Env type-eq-decl nil box interval_arith) (vars_in_box? const-decl "bool" box interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (> const-decl "bool" reals nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (|##| const-decl "bool" interval interval_arith)) nil (EvalwCache_inclusion_ subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval.box))]].val(affine_expr_Eval.E)`2" "(list_adt[CacheData].cons?)"))) (EvalwCache_inclusion_ 0 (EvalwCache_inclusion_-2 "" 3638005043 ("" (skeep*) (("" (assert) (("" (flatten) (("" (use "RE2AC_EvalwCache_eq") (("" (replaces -1) (("" (typepred "RE2AC(re,
                                            box,
                                            vs,
                                            nextfreeidx,
                                            cache)") (("" (assert) (("" (flatten) (("" (skeep -3) (("" (expand "compatible_pairs_on?" -4) (("" (inst -4 "0") (("1" (inst -4 "n") (("1" (flatten) (("1" (expand "nth" -4) (("1" (inst 2 "N") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RE2AC_EvalwCache_eq formula-decl nil affine_expr_Eval nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (vars_in_box? const-decl "bool" box interval_arith) (Env type-eq-decl nil box interval_arith) (Env type-eq-decl nil affine_box nil) (BaseType type-eq-decl nil affine nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (below type-eq-decl nil naturalnumbers nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval nil) (vs skolem-const-decl "(vars_in_box?(box))" affine_expr_Eval nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak) (EvalwCache_inclusion_-1 nil 3637955766 ("" (skeep*) (("" (assert) (("" (flatten) (("" (use "RE2AC_EvalwCache_eq") (("" (replaces -1) (("" (typepred "RE2AC(re,
                                            box,
                                            vs,
                                            nextfreeidx,
                                            cache)") (("" (assert) (("" (flatten) (("" (skeep -3) (("" (expand "compatible_pairs_on?" -4) (("" (inst -4 "0") (("1" (flatten) (("1" (expand "nth" -4) (("1" (inst 2 "N") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (vars_in_box? const-decl "bool" box interval_arith) (Env type-eq-decl nil box interval_arith) (Env type-eq-decl nil affine_box nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals)) shostak)) (EvalwCache_inclusion 0 (EvalwCache_inclusion-1 nil 3632852284 ("" (skeep*) (("" (assert) (("" (flatten) (("" (use "RE2AC_EvalwCache_eq") (("1" (replaces -1) (("1" (typepred "RE2AC(re,
                                        box,
                                        vs,
                                        1 + last_idx_in_box(box),
                                        null[CacheData])") (("1" (assert) (("1" (flatten) (("1" (skeep -3) (("1" (expand "compatible_pairs_on?" -4) (("1" (inst -4 "0") (("1" (inst -4 "length(box)") (("1" (flatten) (("1" (expand "nth" -4) (("1" (inst 2 "N") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs?") (("2" (typepred "vs") (("2" (use "vib_vibnoise") (("2" (assert) (("2" (hide -2) (("2" (expand "vars_in_box_noise?") (("2" (flatten) (("2" (expand "compatible_pairs_on?") (("2" (skeep -2) (("2" (inst 1 "N") (("2" (assert) (("2" (skeep :preds? t) (("2" (expand "length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (RE2AC_EvalwCache_eq formula-decl nil affine_expr_Eval nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (Env type-eq-decl nil box interval_arith) (vars_in_box? const-decl "bool" box interval_arith) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval nil) (vs skolem-const-decl "(vars_in_box?(box))" affine_expr_Eval nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (re skolem-const-decl "RealExpr" affine_expr_Eval nil) (length def-decl "nat" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (vars_in_box_noise? const-decl "bool" affine_box nil) (vib_vibnoise formula-decl nil affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)))
