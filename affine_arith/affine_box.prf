(affine_box (last_idx_in_box_TCC1 0 (last_idx_in_box_TCC1-1 nil 3628272615 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (last_idx_in_box subtype "(number_fields.-)(list_props[Interval].length(affine_box.box), 1)" "upfrom(-1)"))) (last_idx_box 0 (last_idx_box-1 nil 3631475493 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak)) (uptol_TCC1 0 (uptol_TCC1-1 nil 3628272615 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (uptol subtype "(number_fields.-)(affine_box.i, 1)" "nat"))) (uptol_TCC2 0 (uptol_TCC2-1 nil 3628272615 ("" (subtype-tcc) nil nil) nil nil (uptol termination "affine_box.uptol((number_fields.-)(affine_box.i, 1))" "nil"))) (uptol_decl_def 0 (uptol_decl_def-1 nil 3628514396 ("" (induct "i") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (uptol def-decl "list[nat]" affine_box nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (uptol_decl_def_rl 0 (uptol_decl_def_rl-1 nil 3628857126 ("" (induct "i") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "uptol" -2) (("2" (expand "member" -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (uptol def-decl "list[nat]" affine_box nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (idxs_box_membership 0 (idxs_box_membership-1 nil 3628856761 ("" (skeep) (("" (split 1) (("1" (flatten) (("1" (expand "last_idx_in_box") (("1" (expand "idxs_box") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "uptol_decl_def_rl") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_box") (("2" (flatten) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (use "uptol_decl_def") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (box skolem-const-decl "{b: Box | NOT null?(b)}" affine_box nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (Box type-eq-decl nil box interval_arith) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (uptol_decl_def_rl formula-decl nil affine_box nil) (idxs_box const-decl "list[nat]" affine_box nil) (uptol_decl_def formula-decl nil affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil)) shostak)) (idxs_box_nth 0 (idxs_box_nth-1 nil 3628513863 ("" (skeep) (("" (expand "appin") (("" (expand "idxs_box") (("" (typepred "i") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (expand "nth_ac") (("1" (use "idxs_ac_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (use "uptol_decl_def") (("1" (assert) (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((appin const-decl "bool" more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (Box type-eq-decl nil box interval_arith) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nth_ac const-decl "AffineCombination" affine_box nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (uptol_decl_def formula-decl nil affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (idxs_ac_var_ac formula-decl nil affine nil) (idxs_box const-decl "list[nat]" affine_box nil)) shostak)) (restrict_box_preserves_eval 0 (restrict_box_preserves_eval-2 "" 3789918213 ("" (skeep) (("" (use "eval_ac_partial_ext") (("" (assert) (("" (hide 2) (("" (expand "restrict_box") (("" (skeep) (("" (generalize "N" "N") (("" (induct "N") (("1" (typepred "N!1") (("1" (propax) nil nil)) nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (split -1) (("1" (expand "get_noise_by_idx" 1 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "restrict_by_idxs" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1 -1)) (("2" (use "member_append_r[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "restrict_by_idxs" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "cdr_ol") (("2" (replaces -2 :dir RL) (("2" (expand "get_noise_by_idx") (("2" (expand "null_ol?") (("2" (lift-if 2) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (case "car(tN)`1 > i") (("1" (grind) nil nil) ("2" (expand "ordered_list?") (("2" (expand "lt_idx") (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "restrict_by_idxs" 2) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (expand "cons_ol") (("2" (expand "cdr_ol") (("2" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (expand "get_noise_by_idx" 2 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (expand "ordered_list?" -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_ac_partial_ext formula-decl nil affine nil) (restrict_box const-decl "Noise" affine_box nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (list_induction formula-decl nil list_adt nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (member_append_r formula-decl nil more_list_props structures) (cons_ol const-decl "ordered_list" ordered_list structures) (TRUE const-decl "bool" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (member def-decl "bool" list_props nil) (idxs_ac const-decl "list[nat]" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (restrict_by_idxs def-decl "{N_: Noise |
   null_ol?(N_) OR (NOT null_ol?(N) AND car_ol(N)`1 <= car_ol(N_)`1)}" affine nil) (append def-decl "list[T]" list_props nil) (idxs_box const-decl "list[nat]" affine_box nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (restrict_box_preserves_eval-1 nil 3628358032 ("" (skeep) (("" (use "eval_ac_partial_ext") (("" (assert) (("" (hide 2) (("" (expand "restrict_box") (("" (skeep) (("" (generalize "N" "N") (("" (induct "N") (("1" (typepred "N!1") (("1" (propax) nil nil)) nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (split -1) (("1" (expand "get_noise_by_idx" 1 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "restrict_by_idxs" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1 -1)) (("2" (use "member_append_r[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "restrict_by_idxs" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "cdr_ol") (("2" (replaces -2 :dir RL) (("2" (expand "get_noise_by_idx") (("2" (expand "null_ol?") (("2" (lift-if 2) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (case "car(tN)`1 > i") (("1" (grind) nil nil) ("2" (expand "ordered_list?") (("2" (expand "lt_idx") (("2" (assert) (("2" (flatten) (("2" (expand ">") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "restrict_by_idxs" 2) (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (expand "cons_ol") (("2" (expand "cdr_ol") (("2" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (expand "get_noise_by_idx" 2 2) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cdr_ol") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (expand "ordered_list?" -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_ac_partial_ext formula-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (null_ol const-decl "ordered_list" ordered_list structures) (cdr_Noise_jdg application-judgement "Noise" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (member_append_r formula-decl nil more_list_props structures) (cons_ol const-decl "ordered_list" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (restrict_by_idxs def-decl "{N_: Noise |
   null_ol?(N_) OR (NOT null_ol?(N) AND car_ol(N)`1 <= car_ol(N_)`1)}" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (restrict_box_alt_def 0 (restrict_box_alt_def-1 nil 3628510096 ("" (skeep) (("" (split 1) (("1" (generalize "N" "N") (("1" (induct "N") (("1" (typepred "N!1") (("1" (propax) nil nil)) nil) ("2" (typepred "N!1") (("2" (propax) nil nil)) nil) ("3" (grind) nil nil) ("4" (skolem 1 ("hN" "tN")) (("4" (flatten) (("4" (expand "get_noise_by_idx" 1 2) (("4" (expand "null_ol?") (("4" (expand "car_ol") (("4" (lift-if 1) (("4" (split 1) (("1" (flatten) (("1" (expand "restrict_box" 1) (("1" (expand "restrict_by_idxs") (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (expand "cons_ol") (("1" (replaces -1 :dir RL) (("1" (case "member(hN`1, append(idxs_box(box), idxs_ac(Xa)))") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1 -3)) (("2" (split -1) (("1" (use "member_append_r[nat]") (("1" (assert) nil nil)) nil) ("2" (use "member_append_l[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (hide -2) (("1" (expand "restrict_box" 1) (("1" (expand "restrict_by_idxs" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "get_noise_by_idx" 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (case "get_noise_by_idx(i, restrict_box(tN, box, Xa)) =
          get_noise_by_idx(i, tN)") (("1" (expand "restrict_box") (("1" (replaces -1) (("1" (expand ">") (("1" (expand "ordered_list?") (("1" (expand "lt_idx") (("1" (expand "get_noise_by_idx") (("1" (expand "null_ol?") (("1" (case "null?(tN)") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "car_ol") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (hide 3) (("2" (expand "ordered_list?" -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "restrict_box" 2) (("2" (expand "restrict_by_idxs") (("2" (expand "null_ol?") (("2" (expand "car_ol") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "cdr_ol") (("1" (expand "get_noise_by_idx" 1 1) (("1" (expand "null_ol?") (("1" (expand "car_ol") (("1" (assert) (("1" (expand "cdr_ol") (("1" (expand "restrict_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "cdr_ol") (("2" (expand "restrict_box" -1) (("2" (expand "ordered_list?" -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (generalize "N" "N") (("2" (induct "N") (("1" (typepred " N!1") (("1" (propax) nil nil)) nil) ("2" (grind) nil nil) ("3" (skolem 1 ("hN" "tN")) (("3" (flatten) (("3" (expand "restrict_box" 3) (("3" (expand "restrict_by_idxs" 3) (("3" (expand "null_ol?") (("3" (expand "car_ol") (("3" (lift-if 3) (("3" (split 3) (("1" (use "member_append_fi[nat]") (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_idx_strict_order formula-decl nil indexed_list structures) (list_induction formula-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (restrict_by_idxs def-decl "{N_: Noise |
   null_ol?(N_) OR (NOT null_ol?(N) AND car_ol(N)`1 <= car_ol(N_)`1)}" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr_Noise_jdg application-judgement "Noise" affine nil) (TRUE const-decl "bool" booleans nil) (member_append_l formula-decl nil more_list_props structures) (member_append_r formula-decl nil more_list_props structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (append def-decl "list[T]" list_props nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (restrict_box const-decl "Noise" affine_box nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (idxs_box const-decl "list[nat]" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (idxs_ac const-decl "list[nat]" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (member def-decl "bool" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (list type-decl nil list_adt nil) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (member_append_fi formula-decl nil more_list_props structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (restrict_box_preserves_compbox 0 (restrict_box_preserves_compbox-1 nil 3628506928 ("" (skeep) (("" (expand "vars_in_box_compatible?") (("" (skeep) (("" (insteep) (("" (flatten) (("" (split 1) (("1" (replaces -1 :dir RL) (("1" (use "eval_ac_partial_ext") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "restrict_box_alt_def") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (hide 2) (("1" (flatten) (("1" (hide 1) (("1" (use "idxs_box_nth") (("1" (expand "appin") (("1" (expand "nth_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "restrict_box_alt_def") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vars_in_box_compatible? const-decl "bool" affine_box nil) (below type-eq-decl nil naturalnumbers nil) (Box type-eq-decl nil box interval_arith) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_ac_partial_ext formula-decl nil affine nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (var_ac const-decl "AffineCombination" affine nil) (restrict_box const-decl "Noise" affine_box nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (idxs_box_nth formula-decl nil affine_box nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nth_ac const-decl "AffineCombination" affine_box nil) (appin const-decl "bool" more_list_props structures) (restrict_box_alt_def formula-decl nil affine_box nil) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (idxs_box const-decl "list[nat]" affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (compatibles_box_noises 0 (compatibles_box_noises-2 "" 3789918218 ("" (skeep) (("" (skeep) (("" (expand "vars_in_box_compatible?") (("" (inst -1 "j") (("1" (flatten) (("1" (split -2) (("1" (inst -3 "j") (("1" (assert) (("1" (flatten) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "j") (("2" (assert) (("2" (use "eval_var_ac") (("2" (replaces -1) (("2" (use "eval_var_ac") (("2" (replaces -1) (("2" (replaces -1 :dir RL) (("2" (grind) (("2" (use "both_sides_times1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "appin") (("2" (use "idxs_box_membership") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (j skolem-const-decl "(appin(idxs_box(box)))" affine_box nil) (box skolem-const-decl "Box" affine_box nil) (idxs_box const-decl "list[nat]" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (appin const-decl "bool" more_list_props structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (eval_var_ac formula-decl nil affine nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (SingInterval? const-decl "bool" affine nil) (TRUE const-decl "bool" booleans nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (member def-decl "bool" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (idxs_box_membership formula-decl nil affine_box nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak) (compatibles_box_noises-1 nil 3628506897 ("" (skeep) (("" (skeep) (("" (expand "vars_in_box_compatible?") (("" (inst -1 "j") (("1" (flatten) (("1" (split -2) (("1" (inst -3 "j") (("1" (assert) (("1" (flatten) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (replaces -1 :dir RL) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "j") (("2" (assert) (("2" (use "eval_var_ac") (("2" (replaces -1) (("2" (use "eval_var_ac") (("2" (replaces -1) (("2" (replaces -1 :dir RL) (("2" (grind) (("2" (use "both_sides_times1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "appin") (("2" (use "idxs_box_membership") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (appin const-decl "bool" more_list_props structures) (eval_var_ac formula-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (SingInterval? const-decl "bool" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) shostak)) (vars_in_box_noise_rec_TCC1 0 (vars_in_box_noise_rec_TCC1-1 nil 3636271732 ("" (subtype-tcc) nil nil) nil nil (vars_in_box_noise_rec subtype "affine_box.k" "nat"))) (vars_in_box_noise_rec_TCC2 0 (vars_in_box_noise_rec_TCC2-1 nil 3636271732 ("" (subtype-tcc) nil nil) nil nil (vars_in_box_noise_rec subtype "(number_fields.-)(affine_box.k, affine_box.i)" "below[length[Interval](box)]"))) (vars_in_box_noise_rec_TCC3 0 (vars_in_box_noise_rec_TCC3-1 nil 3636271732 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (vars_in_box_noise_rec subtype "affine_box.box" "(list_adt[Interval].cons?)"))) (vars_in_box_noise_rec_TCC4 0 (vars_in_box_noise_rec_TCC4-1 nil 3636271732 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (|##| const-decl "bool" interval interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (vars_in_box_noise_rec subtype "(number_fields.+)(affine_box.i, 1)" "{i: naturalnumbers.nat | (number_fields.+)(i, list_props[Interval].length(list_adt[Interval].cdr(affine_box.box))) = affine_box.n}"))) (vars_in_box_noise_rec_TCC5 0 (vars_in_box_noise_rec_TCC5-1 nil 3636271732 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (|##| const-decl "bool" interval interval_arith)) nil (vars_in_box_noise_rec termination "affine_box.vars_in_box_noise_rec(list_adt[Interval].cdr(affine_box.box), affine_box.n, (number_fields.+)(affine_box.i, 1))" "nil"))) (vars_in_box_noise_rec_TCC6 0 (vars_in_box_noise_rec_TCC6-3 "" 3789918227 ("" (skeep* :preds? t) (("" (iff) (("" (split) (("1" (flatten) (("1" (case "null?[Interval](box)") (("1" (hide -2) (("1" (case "box=null") (("1" (replaces -1) (("1" (hide -1) (("1" (inst 1 "empty_noise") (("1" (skeep :preds? t) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (typepred "v(cdr[Interval](box), n, i + 1)(vs)") (("1" (replaces -1) (("1" (skeep) (("1" (case "SingInterval?(car(box))") (("1" (inst 2 "upd_noise(N, i, 0)") (("1" (skeep) (("1" (case "k=i") (("1" (replaces -1) (("1" (assert) (("1" (split 2) (("1" (grind) nil nil) ("2" (expand "nth" 1) (("2" (expand "var_ac" 1) (("2" (expand "eval_ac_noise" 1) (("2" (assert) (("2" (expand "SingInterval?") (("2" (assert) (("2" (case "eval_pd_noise(null, upd_noise(N, i, 0)) = 0") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (use "gnbi_upd") nil nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "k") (("1" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "nth(cdr(box), k - 1 - i) = nth(box, k  - i)") (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (replaces -4 :dir RL) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("3" (flatten) (("3" (split -6) (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil) ("2" (expand "nth" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "containment_var") (("2" (assert) (("2" (skeep) (("2" (inst 3 "upd_noise(N, i, e)") (("2" (skeep) (("2" (case "k=i") (("1" (replaces -1) (("1" (hide -3) (("1" (split 3) (("1" (grind) nil nil) ("2" (assert) (("2" (expand "nth" 1) (("2" (use "updated_noise_on_varac2") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "k") (("1" (flatten) (("1" (split 4) (("1" (grind) nil nil) ("2" (case "nth(cdr(box), k - 1 - i) = nth(box, k  - i)") (("1" (replaces -1) (("1" (use "updated_noise_on_varac1") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("3" (flatten) (("3" (split -6) (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<<") (("2" (propax) nil nil)) nil) ("3" (hide 3) (("3" (expand "length" -4) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (split 2) (("1" (inst -1 "i") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (typepred "v(cdr(box), n, i + 1)(vs)") (("1" (replaces -1) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (SingInterval? const-decl "bool" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (BaseType type-eq-decl nil affine nil) (|##| const-decl "bool" interval interval_arith) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Env type-eq-decl nil affine_box nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (containment_var formula-decl nil affine nil) (k skolem-const-decl "subrange(i, n - 1)" affine_box nil) (updated_noise_on_varac1 formula-decl nil affine nil) (add_N const-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (updated_noise_on_varac2 formula-decl nil affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (gnbi_upd formula-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (i skolem-const-decl "{i: nat | i + length(box) = n}" affine_box nil) (n skolem-const-decl "nat" affine_box nil) (box skolem-const-decl "Box" affine_box nil) (real_times_real_is_real application-judgement "real" reals nil) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil) (real_plus_real_is_real application-judgement "real" reals nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (eval_var_ac formula-decl nil affine nil) (gnbi_upd_2 formula-decl nil affine nil) (k skolem-const-decl "subrange(i, n - 1)" affine_box nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (empty_noise const-decl "Noise" affine nil) (length def-decl "nat" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Box type-eq-decl nil box interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (vars_in_box_noise_rec subtype "booleans.OR(list_adt[Interval].null?(affine_box.box), (booleans.AND(interval.##(affine_box.vs(affine_box.i), list_adt[Interval].car(affine_box.box)), affine_box.vars_in_box_noise_rec(list_adt[Interval].cdr(affine_box.box), affine_box.n, (number_fields.+)(affine_box.i, 1))(affine_box.vs))))" "{b: booleans.bool | b = (EXISTS (N: affine.Noise): FORALL (k: integers.subrange(affine_box.i, (number_fields.-)(affine_box.n, 1))): booleans.AND(interval.##(affine_box.vs(k), list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i))), booleans.AND(affine.eval_ac_noise(affine.var_ac(list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i)), k), N) = affine_box.vs(k), (booleans.IMPLIES(affine.SingInterval?(list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i))), affine.get_noise_by_idx(k, N) = 0)))))}")) (vars_in_box_noise_rec_TCC6-2 nil 3636271877 ("" (skeep* :preds? t) (("" (iff) (("" (split) (("1" (flatten) (("1" (case "null?[Interval](box)") (("1" (hide -2) (("1" (case "box=null") (("1" (replaces -1) (("1" (hide -1) (("1" (inst 1 "empty_noise") (("1" (skeep :preds? t) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (typepred "v(cdr[Interval](box), n, i + 1)(vs)") (("1" (replaces -1) (("1" (skeep) (("1" (case "SingInterval?(car(box))") (("1" (inst 2 "upd_noise(N, i, 0)") (("1" (skeep) (("1" (case "k=i") (("1" (replaces -1) (("1" (assert) (("1" (split 2) (("1" (grind) nil nil) ("2" (expand "nth" 1) (("2" (expand "var_ac" 1) (("2" (expand "eval_ac_noise" 1) (("2" (assert) (("2" (expand "SingInterval?") (("2" (assert) (("2" (case "eval_pd_noise(null, upd_noise(N, i, 0)) = 0") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_pd_noise") (("2" (expand_ol) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (use "gnbi_upd") nil nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "k") (("1" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "nth(cdr(box), k - 1 - i) = nth(box, k  - i)") (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (replaces -4 :dir RL) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (assert) (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("3" (flatten) (("3" (split -6) (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil) ("2" (expand "nth" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "containment_var") (("2" (assert) (("2" (skeep) (("2" (inst 3 "upd_noise(N, i, e)") (("2" (skeep) (("2" (case "k=i") (("1" (replaces -1) (("1" (hide -3) (("1" (split 3) (("1" (grind) nil nil) ("2" (assert) (("2" (expand "nth" 1) (("2" (use "updated_noise_on_varac2") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "k") (("1" (flatten) (("1" (split 4) (("1" (grind) nil nil) ("2" (case "nth(cdr(box), k - 1 - i) = nth(box, k  - i)") (("1" (replaces -1) (("1" (use "updated_noise_on_varac1") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("3" (flatten) (("3" (split -6) (("1" (use "gnbi_upd_2") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<<") (("2" (propax) nil nil)) nil) ("3" (hide 3) (("3" (expand "length" -4) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (split 2) (("1" (inst -1 "i") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (typepred "v(cdr(box), n, i + 1)(vs)") (("1" (replaces -1) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get_noise_by_idx def-decl "Epsilon" affine nil) (SingInterval? const-decl "bool" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (|##| const-decl "bool" interval interval_arith) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (containment_var formula-decl nil affine nil) (updated_noise_on_varac1 formula-decl nil affine nil) (add_N const-decl "Noise" affine nil) (extend_N const-decl "Noise" affine nil) (updated_noise_on_varac2 formula-decl nil affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (gnbi_upd formula-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (eval_pd_noise def-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (eval_var_ac formula-decl nil affine nil) (gnbi_upd_2 formula-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (empty_noise const-decl "Noise" affine nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith)) nil (vars_in_box_noise_rec subtype "booleans.OR(list_adt[Interval].null?(affine_box.box), (booleans.AND(interval.##(affine_box.vs(affine_box.i), list_adt[Interval].car(affine_box.box)), affine_box.vars_in_box_noise_rec(list_adt[Interval].cdr(affine_box.box), affine_box.n, (number_fields.+)(affine_box.i, 1))(affine_box.vs))))" "{b: booleans.bool | b = (EXISTS (N: affine.Noise): FORALL (k: integers.subrange(affine_box.i, (number_fields.-)(affine_box.n, 1))): booleans.AND(interval.##(affine_box.vs(k), list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i))), booleans.AND(affine.eval_ac_noise(affine.var_ac(list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i)), k), N) = affine_box.vs(k), (booleans.IMPLIES(affine.SingInterval?(list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i))), affine.get_noise_by_idx(k, N) = 0)))))}")) (vars_in_box_noise_rec_TCC6-1 nil 3636271732 ("" (subtype-tcc) nil nil) nil nil (vars_in_box_noise_rec subtype "booleans.OR(list_adt[Interval].null?(affine_box.box), (booleans.AND(interval.##(affine_box.vs(affine_box.i), list_adt[Interval].car(affine_box.box)), affine_box.vars_in_box_noise_rec(list_adt[Interval].cdr(affine_box.box), affine_box.n, (number_fields.+)(affine_box.i, 1))(affine_box.vs))))" "{b: booleans.bool | b = (EXISTS (N: affine.Noise): FORALL (k: integers.subrange(affine_box.i, (number_fields.-)(affine_box.n, 1))): booleans.AND(interval.##(affine_box.vs(k), list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i))), booleans.AND(affine.eval_ac_noise(affine.var_ac(list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i)), k), N) = affine_box.vs(k), (booleans.IMPLIES(affine.SingInterval?(list_props[Interval].nth(affine_box.box, (number_fields.-)(k, affine_box.i))), affine.get_noise_by_idx(k, N) = 0)))))}"))) (vars_in_box_noise 0 (vars_in_box_noise-1 nil 3636271924 ("" (skeep) (("" (expand "vars_in_box_noise?") (("" (split 1) (("1" (skeep) (("1" (typepred "vars_in_box_noise_rec(box, length(box), 0)(vs)") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "vars_in_box_noise_rec(box, length(box), 0)(vs)") (("2" (replaces -1) (("2" (skeep) (("2" (inst?) (("2" (expand "vars_in_box_compatible?") (("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vars_in_box_noise? const-decl "bool" affine_box nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (TRUE const-decl "bool" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (null_ol? const-decl "bool" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (Proper? const-decl "bool" interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Box type-eq-decl nil box interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Env type-eq-decl nil affine_box nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (|##| const-decl "bool" interval interval_arith) (BaseType type-eq-decl nil affine nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (SingInterval? const-decl "bool" affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (vars_in_box_noise_rec def-decl "{b: bool |
   b =
    (EXISTS (N: Noise):
       FORALL (k: subrange(i, n - 1)):
         vs(k) ## nth(box, k - i) AND
          eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
           (SingInterval?(nth(box, k - i)) IMPLIES
             get_noise_by_idx(k, N) = 0))}" affine_box nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (vib_vibnoise 0 (vib_vibnoise-3 "" 3789918234 ("" (expand "vars_in_box?") (("" (expand "vars_in_box_noise?") (("" (skeep) (("" (split 1) (("1" (grind) nil nil) ("2" (name "l" "length(box)") (("2" (generalize-skolem-constants) (("2" (skolem 1 ("_" "_" "vs_")) (("2" (induct "l") (("1" (skeep) (("1" (inst -1 "l_1") (("1" (inst -1 "box_1") (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "box_1 = null") (("1" (replaces -1) (("1" (expand "vars_in_box_compatible?") (("1" (inst 1 "empty_noise") (("1" (skeep :preds? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst -1 "take(box_1, length(box_1)-1)") (("1" (split -1) (("1" (skeep) (("1" (case "SingInterval?(nth(box_1, length(box_1)-1))") (("1" (inst 1 "upd_noise(N,j,0)") (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i=j") (("1" (hide -3) (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (inst -3 "j") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i") (("1" (use "nth_take2[Interval]") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (flatten) (("1" (assert) (("1" (split 2) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "length_take[Interval]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (case "-1 <= (vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) AND (vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) <= 1") "typeP") (("1" (hide "typeP") (("1" (inst 2 "upd_noise(N,j,
           (vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) )") (("1" (name-replace "B" "(vs_(j)
                                         -
                                         (lb(nth(box_1, j))
                                          +
                                          ub(nth(box_1, j)))
                                         /
                                         2)
                                        /
                                        ((ub(nth(box_1, j))
                                          -
                                          lb(nth(box_1, j)))
                                         /
                                         2)") (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i=j") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (expand "B") (("1" (name-replace "A" "((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i") (("1" (use "nth_take2[Interval]") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (flatten) (("1" (assert) (("1" (split 3) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "typeP") (("2" (expand "B") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "length_take[Interval]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "typeP") (("2" (propax) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("2" (inst -3 "j") (("1" (hide-all-but (-3 "typeP")) (("1" (expand "##") (("1" (flatten) (("1" (split 1) (("1" (use "div_mult_pos_le2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (reveal 2) (("2" (expand "SingInterval?") (("2" (reveal -4) (("2" (inst -1 "j") (("2" (expand "##") (("2" (reveal -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "div_mult_pos_le1") (("1" (assert) nil nil) ("2" (reveal -4 -3 1) (("2" (inst -2 "j") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (use "length_take[Interval]") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (inst -2 "i") (("1" (typepred "i") (("1" (use "nth_take2[Interval]") (("1" (grind) nil nil) ("2" (use "length_take[Interval]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_take[Interval]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vars_in_box_noise? const-decl "bool" affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Proper? const-decl "bool" interval interval_arith) (|##| const-decl "bool" interval interval_arith) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (Env type-eq-decl nil affine_box nil) (BaseType type-eq-decl nil affine nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (empty_noise const-decl "Noise" affine nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (SingInterval? const-decl "bool" affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (eval_var_ac formula-decl nil affine nil) (gnbi_upd formula-decl nil affine nil) (length_take formula-decl nil more_list_props structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth_take2 formula-decl nil more_list_props structures) (gnbi_upd_2 formula-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (i skolem-const-decl "below(length(box_1))" affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (car_ol const-decl "T" ordered_list structures) (> const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (nil application-judgement "above(n)" exp2 nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_le2 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (i skolem-const-decl "below(length(box_1))" affine_box nil) (B skolem-const-decl "real" affine_box nil) (vs_ skolem-const-decl "Env" affine_box nil) (j skolem-const-decl "nat" affine_box nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (i skolem-const-decl "below(length(take(box_1, length(box_1) - 1)))" affine_box nil) (int_plus_int_is_int application-judgement "int" integers nil) (take def-decl "list[T]" more_list_props structures) (box_1 skolem-const-decl "Box" affine_box nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (vars_in_box? const-decl "bool" box interval_arith)) shostak) (vib_vibnoise-2 nil 3636284045 ("" (expand "vars_in_box?") (("" (expand "vars_in_box_noise?") (("" (skeep) (("" (split 1) (("1" (grind) nil nil) ("2" (name "l" "length(box)") (("2" (generalize-skolem-constants) (("2" (skolem 1 ("_" "_" "vs_")) (("2" (induct "l") (("1" (skeep) (("1" (inst -1 "l_1") (("1" (inst -1 "box_1") (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "box_1 = null") (("1" (replaces -1) (("1" (expand "vars_in_box_compatible?") (("1" (inst 1 "empty_noise") (("1" (skeep :preds? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst -1 "take(box_1, length(box_1)-1)") (("1" (split -1) (("1" (skeep) (("1" (case "SingInterval?(nth(box_1, length(box_1)-1))") (("1" (inst 1 "upd_noise(N,j,0)") (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i=j") (("1" (hide -3) (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (inst -3 "j") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i") (("1" (use "nth_take2[Interval]") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (flatten) (("1" (assert) (("1" (split 2) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "length_take[Interval]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (case "-1 <= (vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) AND (vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) <= 1") "typeP") (("1" (hide "typeP") (("1" (inst 2 "upd_noise(N,j,
           (vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) )") (("1" (name-replace "B" "(vs_(j)
                                         -
                                         (lb(nth(box_1, j))
                                          +
                                          ub(nth(box_1, j)))
                                         /
                                         2)
                                        /
                                        ((ub(nth(box_1, j))
                                          -
                                          lb(nth(box_1, j)))
                                         /
                                         2)") (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i=j") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (expand "B") (("1" (name-replace "A" "((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i") (("1" (use "nth_take2[Interval]") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (flatten) (("1" (assert) (("1" (split 3) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "eval_var_ac") (("1" (replaces -1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "typeP") (("2" (expand "B") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "length_take[Interval]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "typeP") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("2" (inst -3 "j") (("1" (hide-all-but (-3 "typeP")) (("1" (expand "##") (("1" (flatten) (("1" (split 1) (("1" (use "div_mult_pos_le2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (reveal 2) (("2" (expand "SingInterval?") (("2" (reveal -4) (("2" (inst -1 "j") (("2" (expand "##") (("2" (reveal -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "div_mult_pos_le1") (("1" (assert) nil nil) ("2" (reveal -4 -3 1) (("2" (inst -2 "j") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (use "length_take[Interval]") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (inst -2 "i") (("1" (typepred "i") (("1" (use "nth_take2[Interval]") (("1" (grind) nil nil) ("2" (use "length_take[Interval]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_take[Interval]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Proper? const-decl "bool" interval interval_arith) (|##| const-decl "bool" interval interval_arith) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (empty_noise const-decl "Noise" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_var_ac formula-decl nil affine nil) (gnbi_upd formula-decl nil affine nil) (length_take formula-decl nil more_list_props structures) (nth_take2 formula-decl nil more_list_props structures) (gnbi_upd_2 formula-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (take def-decl "list[T]" more_list_props structures) (vars_in_box? const-decl "bool" box interval_arith)) nil) (vib_vibnoise-1 nil 3636273734 ("" (expand "vars_in_box?") (("" (expand "vars_in_box_noise?") (("" (skeep) (("" (split 1) (("1" (grind) nil nil) ("2" (name "l" "length(box)") (("2" (generalize-skolem-constants) (("2" (skolem 1 ("_" "_" "vs_")) (("2" (induct "l") (("1" (skeep) (("1" (inst -1 "l_1") (("1" (inst -1 "box_1") (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (skeep) (("3" (inst -1 "take(box_1, length(box_1)-1)") (("1" (split -1) (("1" (skeep) (("1" (inst 1 "upd_noise(N,j,IF SingInterval?(nth(box_1, length(box_1)-1)) THEN 0 ELSE
(vs_(j) - (lb(nth(box_1, j)) + ub(nth(box_1, j))) / 2) / ((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2) ENDIF)") (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i=j") (("1" (hide -2) (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (split 1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "SingInterval?") (("1" (inst -3 "j") (("1" (expand "##") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name-replace "A" "((ub(nth(box_1, j)) - lb(nth(box_1, j))) / 2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst -2 "j") (("1" (expand "##") (("1" (flatten) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (postpone) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (postpone) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i") (("1" (use "nth_take2[Interval]") (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (flatten) (("1" (assert) (("1" (split 2) (("1" (use "eval_var_ac") (("1" (postpone) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (- 1)) (("2" (postpone) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide 3) (("2" (use "length_take[Interval]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ("2" (use "length_take[Interval]") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (inst -2 "i") (("1" (typepred "i") (("1" (use "nth_take2[Interval]") (("1" (grind) nil nil) ("2" (use "length_take[Interval]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_take[Interval]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (Inclusion?_TCC1 0 (Inclusion?_TCC1-1 nil 3633434131 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (Box type-eq-decl nil box interval_arith) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (Inclusion? subtype "affine_box.i" "below[length[Interval](box2)]"))) (Inclusion_trans 0 (Inclusion_trans-1 nil 3635259628 ("" (skeep) (("" (expand "Inclusion?") (("" (flatten) (("" (assert) (("" (skeep) (("" (inst? -2) (("" (inst? -4) (("" (lemma "Incl_trans") (("" (inst -1 "nth(box1,i)" "nth(box2,i)" "nth(box,i)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Inclusion? const-decl "bool" affine_box nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (Box type-eq-decl nil box interval_arith) (below type-eq-decl nil naturalnumbers nil) (Incl_trans formula-decl nil interval interval_arith) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)) nil)) (Lbbox_Inclusion 0 (Lbbox_Inclusion-1 nil 3635257773 ("" (skeep :preds? t) (("" (typepred "Lbbox(pox)") (("" (expand "Inclusion?") (("" (assert) (("" (skeep 1 :preds? t) (("" (expand "Lbbox") (("" (lemma "map_nth_rw[Interval,Interval]") (("" (inst -1 "LAMBDA (X: Interval): [| lb(X) |]" "pox" "i") (("" (replaces -1) (("" (expand "ProperBox?") (("" (hide -3) (("" (lemma "every_nth[Interval]") (("" (inst?) (("" (assert) (("" (inst? -1) (("" (hide-all-but (-1 1)) (("" (rewrite "lb_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ProperBox type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (Lbbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (Box type-eq-decl nil box interval_arith) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Lbbox_Proper application-judgement "ProperBox" box interval_arith) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) ([\|\|] const-decl "Interval" interval interval_arith) (every_nth formula-decl nil list_props nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Incl_r2i formula-decl nil interval interval_arith) (lb_inclusion formula-decl nil interval interval_arith) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (PRED type-eq-decl nil defined_types nil) (Proper? const-decl "bool" interval interval_arith) (TRUE const-decl "bool" booleans nil) (map_nth_rw formula-decl nil more_map_props nil) (Inclusion? const-decl "bool" affine_box nil)) nil)) (Ubbox_Inclusion 0 (Ubbox_Inclusion-1 nil 3635258541 ("" (skeep :preds? t) (("" (typepred "Ubbox(pox)") (("" (expand "Inclusion?") (("" (assert) (("" (skeep 1 :preds? t) (("" (expand "Ubbox") (("" (lemma "map_nth_rw[Interval,Interval]") (("" (inst -1 "LAMBDA (X: Interval): [| ub(X) |]" "pox" "i") (("" (replaces -1) (("" (expand "ProperBox?") (("" (hide -3) (("" (lemma "every_nth[Interval]") (("" (inst?) (("" (assert) (("" (inst? -1) (("" (hide-all-but (-1 1)) (("" (rewrite "ub_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ProperBox type-eq-decl nil box interval_arith) (ProperBox? const-decl "bool" box interval_arith) (Ubbox const-decl "listn[Interval](length(box))" box interval_arith) (listn type-eq-decl nil listn structures) (Box type-eq-decl nil box interval_arith) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Ubbox_Proper application-judgement "ProperBox" box interval_arith) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) ([\|\|] const-decl "Interval" interval interval_arith) (every_nth formula-decl nil list_props nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Incl_r2i formula-decl nil interval interval_arith) (ub_inclusion formula-decl nil interval interval_arith) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (PRED type-eq-decl nil defined_types nil) (Proper? const-decl "bool" interval interval_arith) (TRUE const-decl "bool" booleans nil) (map_nth_rw formula-decl nil more_map_props nil) (Inclusion? const-decl "bool" affine_box nil)) nil)))
