(ring_general_results
 (IMP_ring_with_one_basic_properties_TCC1 0
  (IMP_ring_with_one_basic_properties_TCC1-1 nil 3793899776
   ("" (rewrite "fullset_is_ring_with_one") nil nil)
   ((fullset_is_ring_with_one formula-decl nil ring_general_results
     nil))
   nil
   (IMP_ring_with_one_basic_properties assuming
    "ring_with_one_basic_properties[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero, ring_general_results.one].ring_with_one_basic_properties"
    "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_basic_properties.T, ring_with_one_basic_properties.+, ring_with_one_basic_properties.*, ring_with_one_basic_properties.zero, ring_with_one_basic_properties.one].ring_with_one?(sets[ring_with_one_basic_properties.T].fullset)")))
 (IMP_ring_characteristic_def_TCC1 0
  (IMP_ring_characteristic_def_TCC1-1 nil 3793899776
   ("" (lemma "fullset_is_ring_with_one")
    (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (fullset_is_ring_with_one formula-decl nil ring_general_results
     nil))
   nil
   (IMP_ring_characteristic_def assuming
    "ring_characteristic_def[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero].ring_characteristic_def"
    "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))
 (homomorphism_Z_to_R_TCC1 0
  (homomorphism_Z_to_R_TCC1-1 nil 3725305783
   ("" (skosimp*)
    (("" (lemma "times_member")
      (("" (inst -1 "R!1" "x1!1" "one")
        (("1" (assert) nil nil)
         ("2" (typepred "R!1")
          (("2" (expand "ring_with_one?")
            (("2" (flatten)
              (("2" (expand "monoid?")
                (("2" (expand "monad?")
                  (("2" (flatten)
                    (("2" (expand "member") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_general_results nil)
    (* formal-const-decl "[T, T -> T]" ring_general_results nil)
    (+ formal-const-decl "[T, T -> T]" ring_general_results nil)
    (T formal-nonempty-type-decl nil ring_general_results nil)
    (times_member formula-decl nil ring_basic_properties nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (monad? const-decl "bool" monad_def algebra)
    (monoid? const-decl "bool" monoid_def algebra)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fullset const-decl "set" sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ring? const-decl "bool" ring_def algebra)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (one formal-const-decl "T" ring_general_results nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra))
   nil
   (homomorphism_Z_to_R subtype
    "(restrict[int, (sets[int].fullset), ring_general_results.T].restrict((LAMBDA (m: integers.int): ring_basic_properties[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero].times(ring_general_results.one, m))))"
    "[(sets[int].fullset) -> (ring_general_results.R)]")))
 (homomorphism_Z_to_R 0
  (homomorphism_Z_to_R-2 nil 3725308776
   ("" (skosimp)
    (("" (expand "restrict")
      (("" (split)
        (("1" (expand "R_homomorphism?")
          (("1" (split)
            (("1" (expand "star_closed?")
              (("1" (skosimp)
                (("1" (expand "member")
                  (("1" (expand "fullset") (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "star_closed?")
              (("2" (skosimp)
                (("2" (expand "member")
                  (("2" (expand "fullset") (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (expand "star_closed?")
              (("3" (skosimp)
                (("3" (rewrite "R_sum_star_closed[T,+,*,zero]") nil
                  nil))
                nil))
              nil)
             ("4" (expand "star_closed?")
              (("4" (skosimp)
                (("4" (rewrite "R_prod_star_closed[T,+,*,zero]") nil
                  nil))
                nil))
              nil)
             ("5" (expand "homomorphism?")
              (("5" (skosimp)
                (("5" (rewrite "times_sum" :dir rl) nil nil)) nil))
              nil)
             ("6" (expand "homomorphism?")
              (("6" (skosimp)
                (("6" (lemma "times_product[T,+,*,zero]")
                  (("6" (inst -1 "a!1" "one" "one" "b!1")
                    (("6" (rewrite "times_one")
                      (("6" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "R_kernel")
          (("2" (decompose-equality)
            (("2" (iff)
              (("2" (prop)
                (("1" (lemma "multiple_char")
                  (("1" (inst -1 "R!1" "x!1")
                    (("1" (prop)
                      (("1" (skosimp)
                        (("1" (lemma "gen_times_int_one")
                          (("1" (inst -1 "x!1" "x!2")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "fullset") (("2" (propax) nil nil)) nil)
                 ("3" (hide -)
                  (("3" (lemma "zero_is_member_R[T,+,*,zero]")
                    (("3" (inst -1 "R!1")
                      (("3" (expand "member") (("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (lemma "multiple_char")
                  (("4" (inst -1 "R!1" "x!1")
                    (("4" (skosimp -2)
                      (("4" (hide -2)
                        (("4" (prop)
                          (("1" (inst -1 "one")
                            (("1" (lemma "one_in[T,*,one]")
                              (("1" (inst -1 "R!1") nil nil)) nil))
                            nil)
                           ("2" (inst 1 "k!1") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil)
    (one_in formula-decl nil monad algebra)
    (monad? const-decl "bool" monad_def algebra)
    (monad nonempty-type-eq-decl nil monad algebra) nil
    (zero_is_member_R formula-decl nil ring_basic_properties nil)
    (multiple_char formula-decl nil ring_characteristic_def nil)
    (gen_times_int_one formula-decl nil ring_with_one_basic_properties
     nil)
    (charac const-decl "nat" ring_characteristic_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (times const-decl "T" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (times_product formula-decl nil ring_basic_properties nil)
    (times_one formula-decl nil ring_with_one algebra)
    (homomorphism? const-decl "bool" homomorphisms_def nil)
    (times_sum formula-decl nil ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (R_prod_star_closed formula-decl nil ring_basic_properties nil)
    (R_sum_star_closed formula-decl nil ring_basic_properties nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (one formal-const-decl "T" ring_general_results nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (T formal-nonempty-type-decl nil ring_general_results nil)
    (+ formal-const-decl "[T, T -> T]" ring_general_results nil)
    (* formal-const-decl "[T, T -> T]" ring_general_results nil)
    (zero formal-const-decl "T" ring_general_results nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (star_closed? const-decl "bool" groupoid_def algebra)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil))
   nil)
  (homomorphism_Z_to_R-1 nil 3725305784 ("" (postpone) nil nil) nil
   shostak))
 (field_zero_maximal_ideal 0
  (field_zero_maximal_ideal-1 nil 3782203978
   ("" (skeep)
    (("" (prop)
      (("1"
        (lemma "zero_natural_isomorphism[T,+,*,zero,
                    coset[T,+](R,singleton(zero)),add[T,+,*](R,singleton(zero)),product[T,+,*](R,singleton(zero)),singleton(zero)]")
        (("1" (inst -1 "R")
          (("1"
            (lemma "isomorphic_fields[T,+,*,zero,one,
                      coset[T,+](R,singleton(zero)),add[T,+,*](R,singleton(zero)),product[T,+,*](R,singleton(zero)),singleton(zero),+[T,+](one,singleton(zero))]")
            (("1" (inst -1 "R" "R/singleton(zero)")
              (("1" (assert)
                (("1" (lemma "quot_div_ring_maximal_ideal")
                  (("1" (inst -1 "R" "singleton(zero)")
                    (("1" (expand "field?") (("1" (assert) nil nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (rewrite "zero_ideal") nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (rewrite "quotient_ring_with_one")
                  (("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (expand "ring_with_one?")
                (("2" (rewrite "fullset_quot_group_is_ring")
                  (("1" (expand "monoid?")
                    (("1" (expand "monad?")
                      (("1" (lemma "fullset_quot_group_is_ring")
                        (("1" (inst -1 "R" "singleton(zero)")
                          (("1" (expand "ring?")
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split)
                                  (("1"
                                    (expand "fullset" 1)
                                    (("1" (propax) nil nil))
                                    nil)
                                   ("2"
                                    (hide -)
                                    (("2"
                                      (expand "identity?")
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (expand "restrict")
                                          (("2"
                                            (typepred "x")
                                            (("2"
                                              (rewrite
                                               "lcoset_iff_coset"
                                               :dir
                                               rl)
                                              (("2"
                                                (expand "left_coset?")
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (replaces -1)
                                                    (("2"
                                                      (rewrite
                                                       "product_charac")
                                                      (("1"
                                                        (rewrite
                                                         "product_charac")
                                                        (("1"
                                                          (hide -1 2)
                                                          (("1"
                                                            (typepred
                                                             "R")
                                                            (("1"
                                                              (expand
                                                               "ring_with_one?")
                                                              (("1"
                                                                (expand
                                                                 "monoid?")
                                                                (("1"
                                                                  (expand
                                                                   "monad?")
                                                                  (("1"
                                                                    (expand
                                                                     "member")
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (hide -1 2)
                                                          (("2"
                                                            (rewrite
                                                             "zero_ideal")
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide -1 2)
                                                        (("2"
                                                          (typepred
                                                           "R")
                                                          (("2"
                                                            (expand
                                                             "ring_with_one?")
                                                            (("2"
                                                              (expand
                                                               "monoid?")
                                                              (("2"
                                                                (expand
                                                                 "monad?")
                                                                (("2"
                                                                  (expand
                                                                   "member")
                                                                  (("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (hide -1 2)
                                                        (("3"
                                                          (rewrite
                                                           "zero_ideal")
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 2)
                            (("2" (rewrite "zero_ideal") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (rewrite "fullset_is_ring_with_one") nil nil)
             ("4" (hide-all-but 1)
              (("4" (rewrite "lcoset_iff_coset" :dir rl)
                (("4" (expand "left_coset?")
                  (("4" (inst 1 "one")
                    (("4" (typepred "R")
                      (("4" (expand "ring_with_one?")
                        (("4" (expand "monoid?")
                          (("4" (expand "monad?")
                            (("4" (expand "member")
                              (("4" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (rewrite "fullset_quot_group_is_ring")
            (("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil))
            nil))
          nil)
         ("3" (hide-all-but 1)
          (("3" (rewrite "fullset_is_ring") nil nil)) nil)
         ("4" (hide-all-but 1)
          (("4" (rewrite "ideal_is_coset")
            (("4" (hide 2) (("4" (rewrite "zero_ideal") nil nil)) nil))
            nil))
          nil)
         ("5" (hide-all-but 1)
          (("5" (skeep)
            (("5" (lemma "coset_product")
              (("5" (inst -1 "R" "singleton(zero)" "x1`1" "x1`2")
                (("1" (assert) nil nil)
                 ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (hide-all-but 1)
          (("6" (skeep)
            (("6" (lemma "coset_add")
              (("6" (inst -1 "R" "singleton(zero)" "x1`1" "x1`2")
                (("1" (assert) nil nil)
                 ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (hide - 2)
          (("7" (inst 1 "singleton(zero)")
            (("7" (rewrite "ideal_is_coset")
              (("7" (hide 2) (("7" (rewrite "zero_ideal") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2"
        (lemma
         "zero_natural_isomorphism[T,+,*,zero,coset[T,+](R,singleton(zero)),add[T,+,*](R,singleton(zero)),product[T,+,*](R,singleton(zero)),singleton(zero)]")
        (("1" (inst -1 "R")
          (("1"
            (lemma
             "isomorphic_fields_charac[T, +, *, zero,one, coset[T, +](R, singleton(zero)),
                 add(R, singleton(zero)), product(R, singleton(zero)),
                 singleton(zero),+[T,+](one,singleton(zero))]")
            (("1" (inst -1 "R" "R/singleton(zero)")
              (("1" (assert)
                (("1" (hide -1 2)
                  (("1" (rewrite "maximal_ideal_quot_field") nil nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (rewrite "quotient_ring_with_one")
                  (("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (expand "ring_with_one?")
                (("2" (rewrite "fullset_quot_group_is_ring")
                  (("1" (lemma "fullset_quot_group_is_ring")
                    (("1" (inst -1 "R" "singleton(zero)")
                      (("1" (expand "monoid?")
                        (("1" (expand "monad?")
                          (("1" (expand "ring?")
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split)
                                  (("1"
                                    (expand "fullset")
                                    (("1" (propax) nil nil))
                                    nil)
                                   ("2"
                                    (hide -)
                                    (("2"
                                      (expand "identity?")
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (expand "restrict")
                                          (("2"
                                            (typepred "x")
                                            (("2"
                                              (rewrite
                                               "lcoset_iff_coset"
                                               :dir
                                               rl)
                                              (("2"
                                                (expand "left_coset?")
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (replaces -1)
                                                    (("2"
                                                      (rewrite
                                                       "product_charac")
                                                      (("1"
                                                        (rewrite
                                                         "product_charac")
                                                        (("1"
                                                          (hide -1 2)
                                                          (("1"
                                                            (typepred
                                                             "R")
                                                            (("1"
                                                              (expand
                                                               "ring_with_one?")
                                                              (("1"
                                                                (expand
                                                                 "monoid?")
                                                                (("1"
                                                                  (expand
                                                                   "monad?")
                                                                  (("1"
                                                                    (expand
                                                                     "member")
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (hide -1 2)
                                                          (("2"
                                                            (rewrite
                                                             "zero_ideal")
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide -1 2)
                                                        (("2"
                                                          (typepred
                                                           "R ")
                                                          (("2"
                                                            (expand
                                                             "ring_with_one?")
                                                            (("2"
                                                              (expand
                                                               "monoid?")
                                                              (("2"
                                                                (expand
                                                                 "monad?")
                                                                (("2"
                                                                  (expand
                                                                   "member")
                                                                  (("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (hide -1 2)
                                                        (("3"
                                                          (rewrite
                                                           "zero_ideal")
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (rewrite "zero_ideal") nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (hide-all-but 1)
              (("3" (rewrite "fullset_is_ring_with_one") nil nil)) nil)
             ("4" (hide-all-but 1)
              (("4" (rewrite "lcoset_iff_coset" :dir rl)
                (("4" (expand "left_coset?")
                  (("4" (inst 1 "one")
                    (("4" (typepred "R")
                      (("4" (expand "ring_with_one?")
                        (("4" (expand "monoid?")
                          (("4" (expand "monad?")
                            (("4" (expand "member")
                              (("4" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (rewrite "fullset_quot_group_is_ring")
            (("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil))
            nil))
          nil)
         ("3" (hide-all-but 1)
          (("3" (lemma "fullset_is_ring_with_one")
            (("3" (expand "ring_with_one?") (("3" (assert) nil nil))
              nil))
            nil))
          nil)
         ("4" (hide-all-but 1)
          (("4" (rewrite "ideal_is_coset")
            (("4" (hide 2) (("4" (rewrite "zero_ideal") nil nil)) nil))
            nil))
          nil)
         ("5" (hide-all-but 1)
          (("5" (skeep)
            (("5" (lemma "coset_product")
              (("5" (inst -1 "R" "singleton(zero)" "x1`1" "x1`2")
                (("1" (assert) nil nil)
                 ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (hide-all-but 1)
          (("6" (skeep)
            (("6" (lemma "coset_add")
              (("6" (inst -1 "R" "singleton(zero)" "x1`1" "x1`2")
                (("1" (assert) nil nil)
                 ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (hide-all-but 1)
          (("7" (inst 1 "singleton(zero)")
            (("7" (rewrite "ideal_is_coset")
              (("7" (hide 2) (("7" (rewrite "zero_ideal") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((coset_add formula-decl nil quotient_rings nil)
    (coset_product formula-decl nil quotient_rings nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (fullset_is_ring formula-decl nil ring_basic_properties nil)
    (ring nonempty-type-eq-decl nil ring algebra)
    (fullset_is_ring_with_one formula-decl nil ring_general_results
     nil)
    (fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (monad? const-decl "bool" monad_def algebra)
    (identity? const-decl "bool" operator_defs nil)
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (product_charac formula-decl nil quotient_rings nil)
    (times_one formula-decl nil ring_with_one algebra)
    (one_times formula-decl nil ring_with_one algebra)
    (left_coset? const-decl "bool" cosets_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (monoid? const-decl "bool" monoid_def algebra)
    (R skolem-const-decl "ring_with_one[T, +, *, zero, one]"
     ring_general_results nil)
    (restrict const-decl "R" restrict nil)
    (setof type-eq-decl nil defined_types nil)
    (/ const-decl "setof[set[T]]" quotient_ring_def nil)
    (quot_div_ring_maximal_ideal formula-decl nil
     ring_with_one_maximal_ideal nil)
    (zero_ideal formula-decl nil ring_ideal nil)
    (field? const-decl "bool" field_def algebra)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (quotient_ring_with_one formula-decl nil quotient_rings_with_one
     nil)
    (+ const-decl "set[T]" cosets_def nil)
    (isomorphic_fields formula-decl nil ring_with_one_homomorphism nil)
    (ring? const-decl "bool" ring_def algebra)
    (fullset const-decl "set" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" ring_general_results nil)
    (zero_natural_isomorphism formula-decl nil
     ring_homomorphism_lemmas_extras nil)
    (T formal-nonempty-type-decl nil ring_general_results nil)
    (+ formal-const-decl "[T, T -> T]" ring_general_results nil)
    (* formal-const-decl "[T, T -> T]" ring_general_results nil)
    (zero formal-const-decl "T" ring_general_results nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (coset? const-decl "bool" cosets_def nil)
    (one formal-const-decl "T" ring_general_results nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (coset type-eq-decl nil cosets_def nil)
    (add const-decl "set[T]" quotient_ring_def nil)
    (product const-decl "set[T]" quotient_ring_def nil)
    (maximal_ideal_quot_field formula-decl nil
     ring_with_one_maximal_ideal nil)
    (maximal_ideal? const-decl "bool" ring_maximal_ideal_def nil)
    (maximal_ideal type-eq-decl nil ring_maximal_ideal_def nil)
    (isomorphic_fields_charac formula-decl nil
     ring_with_one_homomorphism_extras nil))
   shostak))
 (maximal_ideal_iff_proper_id 0
  (maximal_ideal_iff_proper_id-1 nil 3782568229
   ("" (skeep)
    (("" (prop)
      (("1" (skeep)
        (("1" (expand "maximal_ideal?")
          (("1" (flatten)
            (("1" (inst -2 "I!1")
              (("1"
                (case "subset?(singleton(zero), I!1) AND subset?(I!1, R)")
                (("1" (assert) nil nil)
                 ("2" (hide-all-but 1)
                  (("2" (typepred "I!1")
                    (("2" (expand "ideal?")
                      (("2" (expand "left_ideal?")
                        (("2" (expand "subring?")
                          (("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (expand "subset?")
                                (("2"
                                  (hide-all-but (-2 1))
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (expand "member")
                                      (("2"
                                        (expand "singleton")
                                        (("2"
                                          (lemma "zero_is_member_R")
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (expand "member")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "maximal_ideal?")
        (("2" (split)
          (("1" (rewrite "zero_ideal") nil nil)
           ("2" (lemma "one_diff_zero_monad")
            (("2" (inst -1 "R")
              (("2" (assert)
                (("2" (decompose-equality 1)
                  (("2" (inst -1 "one")
                    (("2" (iff)
                      (("2" (prop)
                        (("1" (hide -3 -4)
                          (("1" (expand "singleton")
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (typepred "R")
                          (("2" (hide-all-but (-1 1))
                            (("2" (expand "ring_with_one?")
                              (("2"
                                (expand "monoid?")
                                (("2"
                                  (expand "monad?")
                                  (("2"
                                    (expand "member")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (inst -3 "N") (("3" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((maximal_ideal? const-decl "bool" ring_maximal_ideal_def nil)
    (T formal-nonempty-type-decl nil ring_general_results nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_general_results nil)
    (* formal-const-decl "[T, T -> T]" ring_general_results nil)
    (zero formal-const-decl "T" ring_general_results nil)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (one formal-const-decl "T" ring_general_results nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (subring? const-decl "bool" ring_def algebra)
    (member const-decl "bool" sets nil)
    (zero_is_member_R formula-decl nil ring_basic_properties nil)
    (left_ideal? const-decl "bool" ring_ideal_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" ring_general_results nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (ring nonempty-type-eq-decl nil ring algebra)
    (zero_ideal formula-decl nil ring_ideal nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (monad? const-decl "bool" monad_def algebra)
    (monoid? const-decl "bool" monoid_def algebra)
    (one_diff_zero_monad formula-decl nil
     ring_with_one_basic_properties nil))
   shostak))
 (proper_id_zero_maximal_ideal 0
  (proper_id_zero_maximal_ideal-1 nil 3782217799
   ("" (skeep)
    (("" (prop)
      (("1" (hide -4)
        (("1" (skeep)
          (("1" (expand "strict_subset?")
            (("1" (expand "maximal_ideal?")
              (("1" (prop)
                (("1" (inst -2 "I!1")
                  (("1" (prop)
                    (("1" (hide-all-but 1)
                      (("1" (typepred "I!1")
                        (("1" (expand "subset?")
                          (("1" (skeep)
                            (("1" (expand "member")
                              (("1"
                                (expand "singleton")
                                (("1"
                                  (replaces -2)
                                  (("1"
                                    (case "ring?(I!1)")
                                    (("1"
                                      (hide -2)
                                      (("1"
                                        (lemma "zero_is_member_R")
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (expand "member")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2)
                                      (("2"
                                        (expand "ideal?")
                                        (("2"
                                          (expand "left_ideal?")
                                          (("2"
                                            (expand "subring?")
                                            (("2" (flatten) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "maximal_ideal?")
        (("2" (prop)
          (("1" (rewrite "zero_ideal") nil nil)
           ("2" (hide -2 1)
            (("2" (lemma "one_diff_zero_monad")
              (("2" (inst?)
                (("2" (assert)
                  (("2" (hide -3)
                    (("2" (decompose-equality -2)
                      (("2" (inst -1 "one")
                        (("2" (iff)
                          (("2" (prop)
                            (("1" (expand "singleton")
                              (("1" (propax) nil nil)) nil)
                             ("2" (hide 2 3)
                              (("2"
                                (typepred "R")
                                (("2"
                                  (expand "ring_with_one?")
                                  (("2"
                                    (expand "monoid?")
                                    (("2"
                                      (expand "monad?")
                                      (("2"
                                        (expand "member")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (inst 3 "N")
              (("3" (expand "strict_subset?")
                (("3" (hide -1 -3 -4) (("3" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((maximal_ideal? const-decl "bool" ring_maximal_ideal_def nil)
    (T formal-nonempty-type-decl nil ring_general_results nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_general_results nil)
    (* formal-const-decl "[T, T -> T]" ring_general_results nil)
    (zero formal-const-decl "T" ring_general_results nil)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (one formal-const-decl "T" ring_general_results nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (left_ideal? const-decl "bool" ring_ideal_def nil)
    (subring? const-decl "bool" ring_def algebra)
    (zero_is_member_R formula-decl nil ring_basic_properties nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_subset? const-decl "bool" sets nil)
    (ring nonempty-type-eq-decl nil ring algebra)
    (zero_ideal formula-decl nil ring_ideal nil)
    (one_diff_zero_monad formula-decl nil
     ring_with_one_basic_properties nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" ring_general_results nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (singleton? const-decl "bool" sets nil)
    (monad? const-decl "bool" monad_def algebra)
    (monoid? const-decl "bool" monoid_def algebra)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   shostak)))
(ring_general_results_extras
 (IMP_ring_homomorphism_lemmas_TCC1 0
  (IMP_ring_homomorphism_lemmas_TCC1-1 nil 3782568211
   ("" (lemma "R1_is_ring_with_one")
    (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (R1_is_ring_with_one formula-decl nil ring_general_results_extras
     nil))
   nil
   (IMP_ring_homomorphism_lemmas assuming
    "ring_homomorphism_lemmas[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1, ring_general_results_extras.zero1, ring_general_results_extras.T2, ring_general_results_extras.s2, ring_general_results_extras.p2, ring_general_results_extras.zero2].ring_homomorphism_lemmas"
    "R1_is_ring: ASSUMPTION ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring?(sets[ring_homomorphism_lemmas.T1].fullset)")))
 (IMP_ring_homomorphism_lemmas_TCC2 0
  (IMP_ring_homomorphism_lemmas_TCC2-1 nil 3782568211
   ("" (rewrite "R2_is_ring") nil nil)
   ((R2_is_ring formula-decl nil ring_general_results_extras nil)) nil
   (IMP_ring_homomorphism_lemmas assuming
    "ring_homomorphism_lemmas[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1, ring_general_results_extras.zero1, ring_general_results_extras.T2, ring_general_results_extras.s2, ring_general_results_extras.p2, ring_general_results_extras.zero2].ring_homomorphism_lemmas"
    "R2_is_ring: ASSUMPTION ring_def[ring_homomorphism_lemmas.T2, ring_homomorphism_lemmas.s2, ring_homomorphism_lemmas.p2, ring_homomorphism_lemmas.zero2].ring?(sets[ring_homomorphism_lemmas.T2].fullset)")))
 (IMP_ring_general_results_TCC1 0
  (IMP_ring_general_results_TCC1-1 nil 3782568211
   ("" (rewrite "R1_is_ring_with_one") nil nil)
   ((R1_is_ring_with_one formula-decl nil ring_general_results_extras
     nil))
   nil
   (IMP_ring_general_results assuming
    "ring_general_results[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1, ring_general_results_extras.zero1, ring_general_results_extras.one1].ring_general_results"
    "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero, ring_general_results.one].ring_with_one?(sets[ring_general_results.T].fullset)")))
 (no_prop_id_mono_TCC1 0
  (no_prop_id_mono_TCC1-1 nil 3782476569
   ("" (skeep)
    (("" (skeep)
      (("" (lemma "coset_add")
        (("" (inst -1 "R" "I!1" "x1`1" "x1`2") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (ring nonempty-type-eq-decl nil ring algebra)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset_add formula-decl nil quotient_rings nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil))
   nil
   (no_prop_id_mono existence ""
    "cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)")))
 (no_prop_id_mono_TCC2 0
  (no_prop_id_mono_TCC2-1 nil 3782476569
   ("" (skeep)
    (("" (skeep)
      (("" (lemma "coset_product")
        (("" (inst -1 "R" "I!1" "x1`1" "x1`2") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (ring nonempty-type-eq-decl nil ring algebra)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset_product formula-decl nil quotient_rings nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil))
   nil
   (no_prop_id_mono subtype
    "quotient_ring_def[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1].add(ring_general_results_extras.R, ring_general_results_extras.I)"
    "[[cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I), cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)] -> cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)]")))
 (no_prop_id_mono_TCC3 0
  (no_prop_id_mono_TCC3-1 nil 3782476569
   ("" (skeep) (("" (rewrite "ideal_is_coset") nil nil)) nil)
   ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (ring nonempty-type-eq-decl nil ring algebra)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil))
   nil
   (no_prop_id_mono subtype
    "quotient_ring_def[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1].product(ring_general_results_extras.R, ring_general_results_extras.I)"
    "[[cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I), cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)] -> cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)]")))
 (no_prop_id_mono_TCC4 0
  (no_prop_id_mono_TCC4-1 nil 3782476569
   ("" (skeep) (("" (rewrite "fullset_quot_group_is_ring") nil nil))
    nil)
   ((fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (ring nonempty-type-eq-decl nil ring algebra)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil))
   nil
   (no_prop_id_mono subtype "ring_general_results_extras.I"
    "cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)")))
 (no_prop_id_mono_TCC5 0
  (no_prop_id_mono_TCC5-1 nil 3782476569
   ("" (skeep)
    (("" (inst 1 "I!1") (("" (rewrite "ideal_is_coset") nil nil)) nil))
    nil)
   ((T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (coset? const-decl "bool" cosets_def nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (ring nonempty-type-eq-decl nil ring algebra))
   nil
   (no_prop_id_mono assuming
    "algebra@ring[cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I), quotient_ring_def[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1].add(ring_general_results_extras.R, ring_general_results_extras.I), quotient_ring_def[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1].product(ring_general_results_extras.R, ring_general_results_extras.I), ring_general_results_extras.I].ring"
    "fullset_is_ring: ASSUMPTION ring_def[ring.T, ring.+, ring.*, ring.zero].ring?(sets[ring.T].fullset)")))
 (no_prop_id_mono 0
  (no_prop_id_mono-1 nil 3782476585
   ("" (skeep)
    (("" (inst -1 "R/I!1" "LAMBDA (r:(R)): +[T1,s1](r,I!1)")
      (("1" (prop)
        (("1" (lemma "ring_natural_homo")
          (("1" (inst -1 "R" "I!1")
            (("1" (assert)
              (("1" (flatten)
                (("1"
                  (lemma
                   "monomorphism_charac[T1,s1,p1,zero1,coset[T1,s1](R,I!1),add(R,I!1),product(R,I!1),I!1]")
                  (("1"
                    (inst -1 "R" "R/I!1"
                     "LAMBDA (r: (R)): (+[T1, s1])(r, I!1)")
                    (("1" (assert) nil nil)
                     ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil))
                      nil)
                     ("3" (skeep)
                      (("3" (expand "restrict")
                        (("3" (expand "/")
                          (("3" (hide-all-but 1)
                            (("3"
                              (case "coset?[T1, s1](R, I!1)(((+[T1, s1])(r, I!1)))")
                              (("1" (assert) nil nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (rewrite "lcoset_iff_coset" :dir rl)
                                  (("2"
                                    (expand "left_coset?")
                                    (("2" (inst 1 "r") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (hide-all-but 1)
                      (("4" (rewrite "quotient_group_is_ring") nil
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (inst 1 "I!1")
                      (("2" (rewrite "ideal_is_coset") nil nil)) nil))
                    nil)
                   ("3" (hide-all-but 1)
                    (("3" (rewrite "fullset_quot_group_is_ring") nil
                      nil))
                    nil)
                   ("4" (hide-all-but 1)
                    (("4" (rewrite "R1_is_ring") nil nil)) nil)
                   ("5" (hide-all-but 1)
                    (("5" (rewrite "ideal_is_coset") nil nil)) nil)
                   ("6" (skeep)
                    (("6" (hide-all-but 1)
                      (("6" (lemma "coset_product")
                        (("6" (inst -1 "R" "I!1" "x1`1" "x1`2 ")
                          (("6" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("7" (skeep)
                    (("7" (hide-all-but 1)
                      (("7" (lemma "coset_add")
                        (("7" (inst -1 "R" "I!1" "x1`1" "x1`2")
                          (("7" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "zero_homomorphism?")
          (("2" (inst -1 "one1")
            (("1" (lemma "one_diff_zero_coset")
              (("1" (inst -1 "R" "I!1") (("1" (assert) nil nil)) nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (typepred "R")
                (("2" (expand "ring_with_one?")
                  (("2" (expand "monoid?")
                    (("2" (expand "monad?")
                      (("2" (expand "member") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "ring_natural_homo")
        (("2" (inst -1 "R" "I!1")
          (("2" (assert)
            (("2" (flatten)
              (("2" (hide-all-but (-1 1))
                (("2" (expand "R_epimorphism?")
                  (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (hide-all-but 1)
        (("3" (skeep)
          (("3" (expand "restrict")
            (("3" (expand "/")
              (("3"
                (case "coset?[T1, s1](R, I!1)(((+[T1, s1])(r, I!1)))")
                (("1" (assert) nil nil)
                 ("2" (hide 2)
                  (("2" (rewrite "lcoset_iff_coset" :dir rl)
                    (("2" (expand "left_coset?")
                      (("2" (inst 1 "r") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (hide-all-but 1)
        (("4" (rewrite "quotient_group_is_ring") nil nil)) nil))
      nil))
    nil)
   ((R_epimorphism? const-decl "bool" ring_homomorphisms_def nil)
    (coset_add formula-decl nil quotient_rings nil)
    (coset_product formula-decl nil quotient_rings nil)
    (R1_is_ring formula-decl nil ring_homomorphism_lemmas nil)
    (fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (member const-decl "bool" sets nil)
    (star_closed? const-decl "bool" groupoid_def algebra)
    (lc_gen const-decl "T" cosets_def nil)
    (left_coset? const-decl "bool" cosets_def nil)
    (right_coset? const-decl "bool" cosets_def nil)
    (lproduct const-decl "set[T]" quotient_ring_def nil)
    (homomorphism? const-decl "bool" homomorphisms_def nil)
    (injective? const-decl "bool" functions nil)
    (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (quotient_group_is_ring formula-decl nil quotient_rings nil)
    (TRUE const-decl "bool" booleans nil)
    (fullset const-decl "set" sets nil)
    (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil)
    nil (zero2 formal-const-decl "T2" ring_general_results_extras nil)
    (p2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (s2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (T2 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (ring_natural_homo formula-decl nil ring_homomorphism_lemmas nil)
    (one_diff_zero_coset formula-decl nil quotient_rings_with_one nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (monoid? const-decl "bool" monoid_def algebra)
    (monad? const-decl "bool" monad_def algebra)
    (zero_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)
    (ring nonempty-type-eq-decl nil ring algebra)
    (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (coset? const-decl "bool" cosets_def nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (add const-decl "set[T]" quotient_ring_def nil)
    (product const-decl "set[T]" quotient_ring_def nil)
    (restrict const-decl "R" restrict nil)
    (setof type-eq-decl nil defined_types nil)
    (/ const-decl "setof[set[T]]" quotient_ring_def nil))
   shostak))
 (mono_no_prop_id 0
  (mono_no_prop_id-1 nil 3782564950
   ("" (skeep)
    (("" (inst -1 "R_kernel(R,S)(phi)")
      (("1" (split)
        (("1" (hide 2)
          (("1" (expand "zero_homomorphism?")
            (("1" (skeep)
              (("1" (decompose-equality)
                (("1" (inst -1 "r")
                  (("1" (iff)
                    (("1" (prop)
                      (("1" (expand "R_kernel")
                        (("1" (assert) nil nil)) nil)
                       ("2" (typepred "r") (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 1) (("2" (rewrite "monomorphism_charac") nil nil))
          nil))
        nil)
       ("2" (hide 2 3) (("2" (rewrite "R_kernel_is_ideal") nil nil))
        nil))
      nil))
    nil)
   ((R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil)
    (zero_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil
    (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (T2 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (p2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (zero2 formal-const-decl "T2" ring_general_results_extras nil)
    (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)
    (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil)
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one algebra)
    (ring nonempty-type-eq-decl nil ring algebra))
   shostak))
 (no_prop_id_iff_mono 0
  (no_prop_id_iff_mono-1 nil 3782222733
   ("" (skeep)
    (("" (prop)
      (("1" (skeep) (("1" (postpone) nil nil)) nil)
       ("2" (skeep)
        (("2" (inst 1 "R_kernel(R,S)(phi)")
          (("1" (split)
            (("1" (expand "strict_subset?")
              (("1" (split)
                (("1" (expand "subset?")
                  (("1" (skeep)
                    (("1" (expand "member")
                      (("1" (expand "R_kernel")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "zero_homomorphism?")
                  (("2" (skeep)
                    (("2" (decompose-equality -1)
                      (("2" (inst -1 "r")
                        (("2" (iff)
                          (("2" (prop)
                            (("1" (expand "R_kernel")
                              (("1" (assert) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite "monomorphism_charac")
              (("2" (assert) nil nil)) nil))
            nil)
           ("2" (rewrite "R_kernel_is_ideal") nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))

