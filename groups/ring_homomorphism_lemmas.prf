(ring_homomorphism_lemmas (IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3793737446 ("" (rewrite "R1_is_ring") nil nil) ((R1_is_ring formula-decl nil ring_homomorphism_lemmas nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)"))) (IMP_ring_basic_properties_TCC2 0 (IMP_ring_basic_properties_TCC2-1 nil 3793737446 ("" (rewrite "R2_is_ring") nil nil) ((R2_is_ring formula-decl nil ring_homomorphism_lemmas nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_homomorphism_lemmas.T2, ring_homomorphism_lemmas.s2, ring_homomorphism_lemmas.p2, ring_homomorphism_lemmas.zero2].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)"))) (R_homo_plus_TCC1 0 (R_homo_plus_TCC1-1 nil 3755373064 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def algebra) (plus_zero formula-decl nil ring algebra) (restrict const-decl "R" restrict nil) (zero_plus formula-decl nil ring algebra) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def algebra) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def algebra) (inv_exists? const-decl "bool" group_def algebra) (group? const-decl "bool" group_def algebra) (commutative? const-decl "bool" operator_defs nil) (abelian_group? const-decl "bool" group_def algebra) (left_distributive? const-decl "bool" operator_defs_more algebra) (right_distributive? const-decl "bool" operator_defs_more algebra) (homomorphism? const-decl "bool" homomorphisms_def nil)) nil (R_homo_plus subtype "ring_homomorphism_lemmas.s1(ring_homomorphism_lemmas.x, ring_homomorphism_lemmas.y)" "(ring_homomorphism_lemmas.R1)"))) (R_homo_plus 0 (R_homo_plus-1 nil 3755373070 ("" (skosimp) (("" (skosimp) (("" (typepred "phi!1") (("" (expand "R_homomorphism?") (("" (flatten) (("" (hide-all-but (-5 1)) (("" (expand "homomorphism?") (("" (inst -1 "x!1" "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((homomorphism? const-decl "bool" homomorphisms_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)) shostak)) (R_homo_mult_TCC1 0 (R_homo_mult_TCC1-1 nil 3755373064 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def algebra) (plus_zero formula-decl nil ring algebra) (restrict const-decl "R" restrict nil) (zero_plus formula-decl nil ring algebra) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def algebra) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def algebra) (inv_exists? const-decl "bool" group_def algebra) (group? const-decl "bool" group_def algebra) (commutative? const-decl "bool" operator_defs nil) (abelian_group? const-decl "bool" group_def algebra) (left_distributive? const-decl "bool" operator_defs_more algebra) (right_distributive? const-decl "bool" operator_defs_more algebra) (homomorphism? const-decl "bool" homomorphisms_def nil)) nil (R_homo_mult subtype "ring_homomorphism_lemmas.p1(ring_homomorphism_lemmas.x, ring_homomorphism_lemmas.y)" "(ring_homomorphism_lemmas.R1)"))) (R_homo_mult 0 (R_homo_mult-1 nil 3755373186 ("" (skosimp*) (("" (typepred "phi!1") (("" (expand "R_homomorphism?") (("" (flatten) (("" (hide-all-but (-6 1)) (("" (expand "homomorphism?") (("" (inst -1 "x!1" "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil)) shostak)) (R_homo_equiv_TCC1 0 (R_homo_equiv_TCC1-1 nil 3755373064 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def algebra) (plus_zero formula-decl nil ring algebra) (restrict const-decl "R" restrict nil) (zero_plus formula-decl nil ring algebra) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def algebra) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def algebra) (inv_exists? const-decl "bool" group_def algebra) (group? const-decl "bool" group_def algebra) (commutative? const-decl "bool" operator_defs nil) (abelian_group? const-decl "bool" group_def algebra) (left_distributive? const-decl "bool" operator_defs_more algebra) (right_distributive? const-decl "bool" operator_defs_more algebra)) nil (R_homo_equiv subtype "ring_homomorphism_lemmas.s1(ring_homomorphism_lemmas.x, ring_homomorphism_lemmas.y)" "(ring_homomorphism_lemmas.R1)"))) (R_homo_equiv_TCC2 0 (R_homo_equiv_TCC2-1 nil 3755373064 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (right_distributive? const-decl "bool" operator_defs_more algebra) (left_distributive? const-decl "bool" operator_defs_more algebra) (abelian_group? const-decl "bool" group_def algebra) (commutative? const-decl "bool" operator_defs nil) (group? const-decl "bool" group_def algebra) (inv_exists? const-decl "bool" group_def algebra) (monoid? const-decl "bool" monoid_def algebra) (associative? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def algebra) (identity? const-decl "bool" operator_defs nil) (zero_plus formula-decl nil ring algebra) (restrict const-decl "R" restrict nil) (plus_zero formula-decl nil ring algebra) (star_closed? const-decl "bool" groupoid_def algebra) (member const-decl "bool" sets nil)) nil (R_homo_equiv subtype "ring_homomorphism_lemmas.p1(ring_homomorphism_lemmas.x, ring_homomorphism_lemmas.y)" "(ring_homomorphism_lemmas.R1)"))) (R_homo_equiv 0 (R_homo_equiv-1 nil 3755373252 ("" (skosimp) (("" (prop) (("1" (skosimp) (("1" (lemma "R_homo_plus") (("1" (lemma "R_homo_mult") (("1" (inst -2 "R1!1" "R2!1" "phi!1" "x!1" "y!1") (("1" (inst -1 "R1!1" "R2!1" "phi!1" "x!1" "y!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (expand "homomorphism?") (("2" (expand "star_closed?") (("2" (split) (("1" (skosimp) (("1" (hide -) (("1" (rewrite "R_sum_star_closed") nil nil)) nil)) nil) ("2" (hide -) (("2" (skosimp) (("2" (rewrite "R_prod_star_closed") nil nil)) nil)) nil) ("3" (hide -) (("3" (skosimp) (("3" (rewrite "R_sum_star_closed") nil nil)) nil)) nil) ("4" (hide -) (("4" (skosimp) (("4" (rewrite "R_prod_star_closed") nil nil)) nil)) nil) ("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (assert) nil nil)) nil)) nil) ("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_homo_plus formula-decl nil ring_homomorphism_lemmas nil) (phi!1 skolem-const-decl "[(R1!1) -> (R2!1)]" ring_homomorphism_lemmas nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homo_mult formula-decl nil ring_homomorphism_lemmas nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (star_closed? const-decl "bool" groupoid_def algebra)) shostak)) (zero_to_zero_TCC1 0 (zero_to_zero_TCC1-1 nil 3745322746 ("" (skosimp) (("" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("" (inst -1 "R1!1") (("" (assert) nil nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (zero_to_zero subtype "ring_homomorphism_lemmas.zero1" "(ring_homomorphism_lemmas.R1)"))) (zero_to_zero 0 (zero_to_zero-1 nil 3745322747 ("" (skosimp) (("" (typepred "phi!1") (("" (expand "R_homomorphism?") (("" (expand "homomorphism?") (("" (flatten) (("" (hide -1 -2 -3 -4 -6) (("" (inst -1 "zero1" "zero1") (("" (assert) (("" (lemma "cancel_right_plus[T2,s2,p2,zero2]") (("" (inst -1 "phi!1(zero1)" "s2(phi!1(zero1), phi!1(zero1))" "inv(phi!1(zero1))") (("" (assert) (("" (rewrite "plus_associative") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (plus_zero formula-decl nil ring algebra) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (plus_associative formula-decl nil ring algebra) (negate_is_right_inv formula-decl nil ring algebra) (cancel_right_plus formula-decl nil ring algebra)) shostak)) (inv_to_inv_TCC1 0 (inv_to_inv_TCC1-1 nil 3746439212 ("" (skosimp) (("" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("" (inst -1 "R1!1" "x!1") (("" (assert) nil nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (inv_is_member_R formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (inv_to_inv subtype "group[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.zero1].inv(ring_homomorphism_lemmas.x)" "(ring_homomorphism_lemmas.R1)"))) (inv_to_inv 0 (inv_to_inv-1 nil 3746439230 ("" (skosimp*) (("" (typepred "phi!1") (("" (expand "R_homomorphism?") (("" (flatten) (("" (hide -1 -2 -3 -4 -6) (("" (expand "homomorphism?") (("" (inst -1 "x!1" "inv(x!1)") (("" (rewrite "negate_is_right_inv") (("" (rewrite "zero_to_zero") (("" (name-replace "y" "phi!1(x!1)") (("" (name-replace "z" "phi!1(inv(x!1))") (("" (lemma "negate_is_right_inv[T2,s2,p2,zero2]") (("" (lemma "cancel_left_plus[T2,s2,p2,zero2]") (("" (inst -2 "y") (("" (replaces -3) (("" (inst -1 "inv(y)" "z" "y") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (negate_is_right_inv formula-decl nil ring algebra) (TRUE const-decl "bool" booleans nil) (cancel_left_plus formula-decl nil ring algebra) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra)) shostak)) (epi_commutative 0 (epi_commutative-1 nil 3782062401 ("" (skeep) (("" (typepred "phi") (("" (expand "R_epimorphism?") (("" (flatten) (("" (rewrite "R_homo_equiv") (("" (expand "commutative_ring?") (("" (expand "commutative?") (("" (skeep) (("" (expand "restrict") (("" (expand "surjective?") (("" (copy -1) (("" (inst -1 "x") (("" (inst -2 "y") (("" (skeep*) (("" (copy -3) (("" (inst -1 "x_1" "x!1") (("" (inst -4 "x!1" "x_1") (("" (flatten) (("" (hide -1 -5) (("" (replaces -2) (("" (replaces -2) (("" (inst -3 "x_1" "x!1") (("" (replaces -3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_epimorphism type-eq-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (commutative_ring? const-decl "bool" ring_def algebra) (surjective? const-decl "bool" functions nil) (TRUE const-decl "bool" booleans nil) (restrict const-decl "R" restrict nil) (commutative? const-decl "bool" operator_defs nil) (R_homo_equiv formula-decl nil ring_homomorphism_lemmas nil)) shostak)) (image_homo_is_subring 0 (image_homo_is_subring-1 nil 3746440620 ("" (skosimp) (("" (lemma "subring_equiv[T2,s2,p2,zero2]") (("" (inst -1 "R2!1" "image(phi!1)(R1!1)") (("" (assert) (("" (hide 2) (("" (name-replace "Im" "image(phi!1)(restrict[T1, (R1!1), boolean](R1!1))" :hide? nil) (("" (split) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -1 "zero2") (("1" (expand "member") (("1" (expand "extend") (("1" (prop) (("1" (lemma "zero_to_zero") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (hide -3) (("1" (expand* "Im" "image" "image") (("1" (inst 1 "zero1") (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "extend") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (split) (("1" (expand "extend") (("1" (prop) (("1" (hide -2) (("1" (expand* "Im" "image" "image") (("1" (typepred "x!1") (("1" (expand "extend") (("1" (typepred "y!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (skosimp*) (("1" (inst 1 "s1(x!2,inv(x!3))") (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -6) (("1" (expand "homomorphism?") (("1" (inst -1 "x!2" "inv(x!3)") (("1" (replaces -1) (("1" (lemma "inv_to_inv") (("1" (inst -1 "R1!1" "R2!1" "phi!1" "x!3") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "x!2") (("2" (typepred "x!3") (("2" (hide-all-but (-1 -3 1)) (("2" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!3") (("2" (assert) (("2" (inst -2 "R1!1" "x!2" "inv(x!3)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1" "y!1") (("2" (expand "extend") (("2" (prop) (("2" (hide -2 -4) (("2" (lemma "inv_is_member_R[T2,s2,p2,zero2]") (("2" (lemma "R_sum_star_closed[T2,s2,p2,zero2]") (("2" (inst -2 "R2!1" "y!1") (("2" (inst -1 "R2!1" "x!1" "inv(y!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (prop) (("1" (hide -2) (("1" (expand* "Im" "image" "image") (("1" (typepred "x!1" "y!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (skosimp*) (("1" (inst 1 "p1(x!3,x!2)") (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -5) (("1" (expand "homomorphism?") (("1" (inst -1 "x!3" "x!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide -) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!3" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "R_prod_star_closed[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1" "x!1" "y!1") (("2" (assert) (("2" (hide 2) (("2" (typepred "x!1" "y!1") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (subring_equiv formula-decl nil ring_basic_properties nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (x!3 skolem-const-decl "(restrict[T1, (R1!1), bool](R1!1))" ring_homomorphism_lemmas nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](R1!1))" ring_homomorphism_lemmas nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](R1!1))" ring_homomorphism_lemmas nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (x!3 skolem-const-decl "(restrict[T1, (R1!1), bool](R1!1))" ring_homomorphism_lemmas nil) (inv_to_inv formula-decl nil ring_homomorphism_lemmas nil) (TRUE const-decl "bool" booleans nil) (inv_is_member_R formula-decl nil ring_basic_properties nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (subset? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (Im skolem-const-decl "set[(R2!1)]" ring_homomorphism_lemmas nil) (image const-decl "set[R]" function_image nil) (empty? const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (image const-decl "set[R]" function_image nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (R_homo_image_subring 0 (R_homo_image_subring-1 nil 3751275241 ("" (skosimp) (("" (rewrite "subring_equiv" 1) (("" (split) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -1 "zero2") (("1" (expand "member") (("1" (expand "extend") (("1" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (inst 1 "zero1") (("1" (lemma "zero_to_zero") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "R1!1") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst-cp -1 "R1!1") (("2" (inst -1 "S1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "R2!1") (("2" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "extend") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (split) (("1" (expand "extend") (("1" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (typepred "x!1" "y!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (skosimp*) (("1" (hide -1 -3) (("1" (inst 1 "s1(x!3,inv(x!2))") (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -6) (("1" (expand "homomorphism?") (("1" (inst -1 "x!3" "inv(x!2)") (("1" (replaces -1) (("1" (case-replace "inv(y!1) = phi!1(inv(x!2))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "inv_to_inv") (("2" (inst -1 "R1!1" "R2!1" "phi!1" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "x!3" "x!2") (("2" (expand "restrict") (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst-cp -1 "R1!1" "x!2") (("2" (inst -1 "S1!1" "x!2") (("1" (assert) (("1" (hide -7 -8 -9) (("1" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("1" (inst-cp -1 "R1!1" "x!3" "inv(x!2)") (("1" (inst -1 "S1!1" "x!3" "inv(x!2)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inv_is_member_R[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1" "y!1") (("2" (typepred "y!1") (("2" (expand "extend") (("2" (prop) (("1" (assert) (("1" (lemma "R_sum_star_closed[T2,s2,p2,zero2]") (("1" (inst -1 "R2!1" "x!1" "inv(y!1)") (("1" (assert) (("1" (hide 2) (("1" (typepred "x!1") (("1" (expand "extend") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (typepred "x!1" "y!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (skosimp*) (("1" (inst 1 "p1(x!3,x!2)") (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -5) (("1" (expand "homomorphism?") (("1" (inst -1 "x!3" "x!2") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x!3" "x!2") (("2" (expand "restrict") (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst-cp -1 "R1!1" "x!3" "x!2") (("2" (inst -1 "S1!1" "x!3" "x!2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1" "y!1") (("2" (expand "extend") (("2" (prop) (("2" (hide -2 -4) (("2" (lemma "R_prod_star_closed[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1" "x!1" "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subring_equiv formula-decl nil ring_basic_properties nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (image const-decl "set[R]" function_image nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (restrict const-decl "R" restrict nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (x!3 skolem-const-decl "(restrict[T1, (R1!1), bool](S1!1))" ring_homomorphism_lemmas nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](S1!1))" ring_homomorphism_lemmas nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (inv_is_member_R formula-decl nil ring_basic_properties nil) (TRUE const-decl "bool" booleans nil) (inv_to_inv formula-decl nil ring_homomorphism_lemmas nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](S1!1))" ring_homomorphism_lemmas nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (= const-decl "[T, T -> boolean]" equalities nil) (x!3 skolem-const-decl "(restrict[T1, (R1!1), bool](S1!1))" ring_homomorphism_lemmas nil) (subset? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (S1!1 skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (subring? const-decl "bool" ring_def algebra) (image const-decl "set[R]" function_image nil) (empty? const-decl "bool" sets nil)) shostak)) (R_homo_inv_image_subring 0 (R_homo_inv_image_subring-1 nil 3753983711 ("" (skosimp) (("" (rewrite "subring_equiv" 1) (("" (split) (("1" (expand "subring?") (("1" (flatten) (("1" (hide -1) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -1 "zero1") (("1" (expand "member") (("1" (expand "extend") (("1" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (rewrite "zero_to_zero") (("1" (hide -1) (("1" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("1" (inst -1 "S2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (typepred "R1!1") (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "extend") (("3" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (typepred "phi!1" "x!1" "y!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -5 -6 -7 -8 -10) (("1" (expand "homomorphism?") (("1" (inst -5 "x!1" "inv[T1, s1, zero1](y!1)") (("1" (replaces -5) (("1" (lemma "inv_to_inv") (("1" (inst -1 "R1!1" "R2!1" "phi!1" "y!1") (("1" (replaces -1) (("1" (lemma "inv_is_member_R[T2,s2,p2,zero2]") (("1" (inst -1 "S2!1" "phi!1(y!1)") (("1" (assert) (("1" (expand "subring?") (("1" (flatten) (("1" (lemma "R_sum_star_closed[T2,s2,p2,zero2]") (("1" (inst -1 "S2!1" "phi!1(x!1)" "inv(phi!1(y!1))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (typepred "x!1" "y!1") (("2" (expand "extend") (("2" (prop) (("2" (hide -2 -4) (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "y!1") (("2" (assert) (("2" (hide -2) (("2" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!1" "inv(y!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "inverse_image") (("3" (expand "member") (("3" (typepred "x!1" "y!1") (("3" (expand "extend") (("3" (prop) (("3" (expand "inverse_image") (("3" (expand "member") (("3" (typepred "phi!1") (("3" (expand "R_homomorphism?") (("3" (flatten) (("3" (hide -1 -2 -3 -4 -5) (("3" (expand "homomorphism?") (("3" (inst -1 "x!1" "y!1") (("3" (replaces -1) (("3" (hide -1 -3 -5) (("3" (expand "subring?") (("3" (flatten) (("3" (hide -3) (("3" (lemma "R_prod_star_closed[T2,s2,p2,zero2]") (("3" (inst -1 "S2!1" "phi!1(x!1)" "phi!1(y!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -) (("4" (typepred "x!1" "y!1") (("4" (expand "extend") (("4" (prop) (("4" (hide -2 -4) (("4" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("4" (inst -1 "R1!1" "x!1" "y!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subring_equiv formula-decl nil ring_basic_properties nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (inverse_image const-decl "set[D]" function_image nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (y!1 skolem-const-decl "(extend[T1, (R1!1), bool, FALSE](inverse_image(phi!1, S2!1)))" ring_homomorphism_lemmas nil) (phi!1 skolem-const-decl "R_homomorphism[T1, s1, p1, zero1, T2, s2, p2, zero2](R1!1, R2!1)" ring_homomorphism_lemmas nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphism_lemmas nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (inv_to_inv formula-decl nil ring_homomorphism_lemmas nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (inv_is_member_R formula-decl nil ring_basic_properties nil) (TRUE const-decl "bool" booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (subset? const-decl "bool" sets nil) (subring? const-decl "bool" ring_def algebra) (empty? const-decl "bool" sets nil) (S2!1 skolem-const-decl "set[T2]" ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil)) shostak)) (R_kernel_is_subring 0 (R_kernel_is_subring-1 nil 3746875614 ("" (skosimp) (("" (lemma "subring_equiv[T1,s1,p1,zero1]") (("" (inst -1 "R1!1" "R_kernel(R1!1, R2!1)(phi!1)") (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -1 "zero1") (("1" (expand "member") (("1" (expand "R_kernel") (("1" (lemma "zero_to_zero") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("1" (inst -1 "R1!1") (("1" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("1" (inst -1 "R2!1") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "R_kernel") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (split) (("1" (expand "R_kernel") (("1" (typepred "x!1" "y!1") (("1" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("1" (inst -1 "R1!1" "y!1") (("1" (expand "R_kernel") (("1" (flatten) (("1" (assert) (("1" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("1" (inst -1 "R1!1" "x!1" "inv(y!1)") (("1" (assert) (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -6) (("1" (expand "homomorphism?") (("1" (inst -1 "x!1" "inv(y!1)") (("1" (replaces -1) (("1" (replaces -5) (("1" (lemma "inv_to_inv") (("1" (inst -1 "R1!1" "R2!1" "phi!1" "y!1") (("1" (replaces -1) (("1" (replaces -7) (("1" (rewrite "negate_zero") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "R_kernel") (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!1" "y!1") (("2" (expand "member") (("2" (typepred "x!1" "y!1") (("2" (expand "R_kernel") (("2" (flatten) (("2" (assert) (("2" (typepred "phi!1") (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (hide -1 -2 -3 -4 -5) (("2" (expand "homomorphism?") (("2" (inst -1 "x!1" "y!1") (("2" (replaces -1) (("2" (replaces -3) (("2" (replaces -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (subring_equiv formula-decl nil ring_basic_properties nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (nonempty? const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (plus_zero formula-decl nil ring algebra) (negate_zero formula-decl nil ring algebra) (inv_to_inv formula-decl nil ring_homomorphism_lemmas nil) (TRUE const-decl "bool" booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (inv_is_member_R formula-decl nil ring_basic_properties nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (times_zero formula-decl nil ring algebra) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (R_kernel_is_subgroup 0 (R_kernel_is_subgroup-1 nil 3746881823 ("" (skosimp) (("" (expand "subgroup?") (("" (lemma "R_kernel_is_subring") (("" (inst -1 "R1!1" "R2!1" "phi!1") (("" (expand "subring?") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (flatten) (("" (hide-all-but (-1 -2 1)) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subgroup? const-decl "bool" group_def algebra) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (abelian_group? const-decl "bool" group_def algebra) (subring? const-decl "bool" ring_def algebra) (R_kernel_is_subring formula-decl nil ring_homomorphism_lemmas nil)) shostak)) (monomorphism_charac 0 (monomorphism_charac-1 nil 3746881896 ("" (skosimp) (("" (prop) (("1" (expand "R_monomorphism?") (("1" (expand "injective?") (("1" (expand "R_kernel") (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "singleton") (("1" (inst -4 "x!1" "zero1") (("1" (lemma "zero_to_zero") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "singleton") (("2" (replaces -1) (("2" (hide -) (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -) (("3" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("3" (inst -1 "R2!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "singleton") (("4" (replaces -1) (("4" (hide -) (("4" (lemma "zero_to_zero") (("4" (inst -1 "R1!1" "R2!1" "phi!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "R_monomorphism?") (("2" (expand "injective?") (("2" (skosimp) (("2" (expand "R_kernel") (("2" (decompose-equality) (("2" (inst -1 "x1!1 - x2!1") (("2" (iff) (("2" (typepred "x1!1" "x2!1") (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x2!1") (("2" (assert) (("2" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x1!1" "inv(x2!1)") (("2" (assert) (("2" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1") (("2" (assert) (("2" (typepred "phi!1") (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (hide -1 -2 -3 -4 -6) (("2" (expand "homomorphism?") (("2" (inst -1 "x1!1" "inv(x2!1)") (("2" (lemma "cancel_right_minus[T2,s2,p2,zero2]") (("2" (inst -1 "phi!1(x1!1)" "phi!1(x2!1)" "phi!1(x2!1)") (("2" (assert) (("2" (lemma "inv_to_inv") (("2" (inst -1 "R1!1" "R2!1" "phi!1" "x2!1") (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) (("2" (hide-all-but (-7 1)) (("2" (expand "singleton") (("2" (lemma "cancel_right_minus[T1,s1,p1,zero1]") (("2" (inst -1 "x1!1" "x2!1" "x2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (TRUE const-decl "bool" booleans nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (NOT const-decl "[bool -> bool]" booleans nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (cancel_right_minus formula-decl nil ring algebra) (negate_is_right_inv formula-decl nil ring algebra) (inv_to_inv formula-decl nil ring_homomorphism_lemmas nil) (inv_is_member_R formula-decl nil ring_basic_properties nil)) shostak)) (inv_iso_is_iso_TCC1 0 (inv_iso_is_iso_TCC1-1 nil 3782125198 ("" (existence-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphism type-eq-decl nil ring_homomorphisms_def nil) (zero_times formula-decl nil ring algebra) (times_zero formula-decl nil ring algebra) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def algebra) (plus_zero formula-decl nil ring algebra) (restrict const-decl "R" restrict nil) (zero_plus formula-decl nil ring algebra) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def algebra) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def algebra) (inv_exists? const-decl "bool" group_def algebra) (group? const-decl "bool" group_def algebra) (commutative? const-decl "bool" operator_defs nil) (abelian_group? const-decl "bool" group_def algebra) (left_distributive? const-decl "bool" operator_defs_more algebra) (right_distributive? const-decl "bool" operator_defs_more algebra) (injective? const-decl "bool" functions nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil)) nil (inv_iso_is_iso existence "" "(ring_homomorphism_lemmas.R1)"))) (inv_iso_is_iso 0 (inv_iso_is_iso-1 nil 3782123694 ("" (skosimp) (("" (typepred "phi!1") (("" (expand "R_isomorphism?") (("" (expand "R_monomorphism?") (("" (expand "R_epimorphism?") (("" (flatten) (("" (hide -4) (("" (case "R_homomorphism?[T2,s2,p2,zero2,T1,s1,p1,zero1](R2!1, R1!1)(inverse(phi!1))") (("1" (assert) (("1" (hide -1 -3) (("1" (lemma "bij_inv_is_bij[(R1!1),(R2!1)]") (("1" (inst -1 "phi!1") (("1" (expand "bijective?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "R_homomorphism?" 1) (("2" (split) (("1" (expand "star_closed?") (("1" (hide -) (("1" (typepred "R2!1") (("1" (skosimp) (("1" (rewrite "R_sum_star_closed") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "star_closed?") (("2" (hide -) (("2" (skosimp) (("2" (rewrite "R_prod_star_closed") nil nil)) nil)) nil)) nil) ("3" (expand "star_closed?") (("3" (hide -) (("3" (skosimp) (("3" (rewrite "R_sum_star_closed") nil nil)) nil)) nil)) nil) ("4" (expand "star_closed?") (("4" (hide -) (("4" (skosimp) (("4" (rewrite "R_prod_star_closed") nil nil)) nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (skosimp) (("5" (rewrite "R_homo_equiv") (("5" (expand "surjective?") (("5" (copy -3) (("5" (inst -1 "a!1") (("5" (inst -4 "b!1") (("5" (skosimp*) (("5" (replace -1 1 rl) (("5" (replace -4 1 rl) (("5" (inst -3 "x!1" "x!2") (("5" (flatten) (("5" (rewrite "inverse_injective") (("5" (rewrite "inverse_injective") (("5" (lemma "congruence[(R2!1),(R1!1)]") (("5" (inst -1 "inverse(phi!1)" "inverse(phi!1)" "phi!1(s1(x!1, x!2))" "s2(phi!1(x!1), phi!1(x!2))") (("1" (prop) (("1" (hide-all-but (-1 -3 1)) (("1" (rewrite "inverse_injective") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (typepred "R1!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (rewrite "R_homo_equiv") (("6" (expand "surjective?") (("6" (copy -3) (("6" (inst -1 "a!1") (("6" (inst -4 "b!1") (("6" (skosimp*) (("6" (replace -1 1 rl) (("6" (replace -4 1 rl) (("6" (hide -1 -4) (("6" (rewrite "inverse_injective") (("6" (rewrite "inverse_injective") (("6" (inst -2 "x!1" "x!2") (("6" (flatten) (("6" (hide -2) (("6" (lemma "congruence[(R2!1),(R1!1)]") (("6" (inst -1 "inverse(phi!1)" "inverse(phi!1)" "phi!1(p1(x!1, x!2))" "p2(phi!1(x!1), phi!1(x!2))") (("1" (prop) (("1" (hide -3) (("1" (rewrite "inverse_injective") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (typepred "R1!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide - 2) (("3" (typepred "R1!1") (("3" (expand "ring?") (("3" (expand "abelian_group?") (("3" (expand "group?") (("3" (expand "monoid?") (("3" (expand "monad?") (("3" (expand "member") (("3" (flatten) (("3" (hide-all-but (-2 1)) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_isomorphism type-eq-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (inverse const-decl "D" function_inverse nil) (TRUE const-decl "bool" booleans nil) (bijective? const-decl "bool" functions nil) (bij_inv_is_bij formula-decl nil function_inverse nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_homo_equiv formula-decl nil ring_homomorphism_lemmas nil) (injective? const-decl "bool" functions nil) (inverse_injective formula-decl nil function_inverse nil) (congruence formula-decl nil functions nil) (group? const-decl "bool" group_def algebra) (monad? const-decl "bool" monad_def algebra) (monoid? const-decl "bool" monoid_def algebra) (abelian_group? const-decl "bool" group_def algebra) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (surjective? const-decl "bool" functions nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (star_closed? const-decl "bool" groupoid_def algebra) (member const-decl "bool" sets nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil)) shostak)) (R_kernel_is_ideal 0 (R_kernel_is_ideal-1 nil 3747065280 ("" (skosimp) (("" (lemma "ideal_equiv[T1,s1,p1,zero1]") (("" (inst -1 "R_kernel(R1!1, R2!1)(phi!1)" "R1!1") (("" (assert) (("" (hide 2) (("" (split) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (lemma "R_kernel_is_subring") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (expand "subring?") (("1" (flatten) (("1" (hide -1) (("1" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("1" (inst -1 "R_kernel(R1!1, R2!1)(phi!1)") (("1" (inst -3 "zero1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "R_kernel_is_subring") (("2" (inst -1 "R1!1" "R2!1" "phi!1") (("2" (expand "subring?") (("2" (flatten) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (name-replace "K" "R_kernel(R1!1, R2!1)(phi!1)" :hide? nil) (("3" (split) (("1" (lemma "subring_equiv[T1,s1,p1,zero1]") (("1" (lemma "R_kernel_is_subring") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (inst -2 "R1!1" "K") (("1" (assert) (("1" (flatten) (("1" (hide-all-but (-4 1)) (("1" (inst -1 "x!1" "y!1") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1" "r!1") (("2" (expand "R_kernel" -1) (("2" (flatten) (("2" (typepred "phi!1") (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (hide -1 -2 -3 -4 -5) (("2" (expand "homomorphism?") (("2" (inst -1 "x!1" "r!1") (("2" (expand "K" 1) (("2" (expand "R_kernel" 1) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!1" "r!1") (("2" (assert) (("2" (replaces -2) (("2" (replaces -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1" "r!1") (("3" (expand "R_kernel" -1) (("3" (flatten) (("3" (typepred "phi!1") (("3" (expand "R_homomorphism?") (("3" (flatten) (("3" (hide -1 -2 -3 -4 -5) (("3" (expand "homomorphism?") (("3" (inst -1 "r!1" "x!1") (("3" (expand "K" 1) (("3" (expand "R_kernel" 1) (("3" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("3" (inst -1 "R1!1" "r!1" "x!1") (("3" (assert) (("3" (replaces -2) (("3" (replaces -4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ideal_equiv formula-decl nil ring_ideal nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (phi!1 skolem-const-decl "R_homomorphism[T1, s1, p1, zero1, T2, s2, p2, zero2](R1!1, R2!1)" ring_homomorphism_lemmas nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (subring? const-decl "bool" ring_def algebra) (R_kernel_is_subring formula-decl nil ring_homomorphism_lemmas nil) (nonempty? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (times_zero formula-decl nil ring algebra) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (zero_times formula-decl nil ring algebra) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (K skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (subring_equiv formula-decl nil ring_basic_properties nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (R_epimorphism_image_ideal 0 (R_epimorphism_image_ideal-1 nil 3753977192 ("" (skosimp) (("" (expand "ideal?") (("" (expand "left_ideal?") (("" (expand "right_ideal?") (("" (typepred "I!1") (("" (expand "ideal?") (("" (expand "left_ideal?") (("" (flatten) (("" (rewrite "R_homo_image_subring") (("1" (split) (("1" (expand "left_swallow?") (("1" (skosimp) (("1" (hide -2 -3) (("1" (typepred "r!1" "x!1") (("1" (expand "image") (("1" (expand "image") (("1" (expand "member") (("1" (expand "extend") (("1" (prop) (("1" (skosimp) (("1" (typepred "phi!1") (("1" (expand "R_epimorphism?") (("1" (flatten) (("1" (expand "surjective?") (("1" (inst -1 "r!1") (("1" (skosimp) (("1" (inst 1 "p1(x!3,x!2)") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -2 -3 -4 -5 -6) (("1" (expand "homomorphism?") (("1" (inst -2 "x!3" "x!2") (("1" (replaces -2) (("1" (replaces -1) (("1" (replaces -3 1 rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide-all-but (-7 1)) (("2" (typepred "x!3" "x!2") (("2" (expand "restrict") (("2" (typepred "I!1") (("2" (hide -5) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "left_swallow?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "x!3" "x!2") (("2" (expand "member") (("2" (assert) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!3" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4) (("2" (lemma "R_prod_star_closed[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1" "r!1" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "right_swallow?") (("2" (skosimp) (("2" (typepred "x!1" "r!1") (("2" (expand "extend") (("2" (expand "member") (("2" (prop) (("1" (expand "image") (("1" (expand "image") (("1" (skosimp) (("1" (typepred "phi!1") (("1" (expand "R_epimorphism?") (("1" (flatten) (("1" (expand "surjective?") (("1" (inst -1 "r!1") (("1" (skosimp) (("1" (inst 1 "p1(x!2,x!3)") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -2 -3 -4 -5 -6) (("1" (expand "homomorphism?") (("1" (inst -2 "x!2" "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide-all-but (-9 1)) (("2" (typepred "x!2" "x!3") (("2" (expand "restrict") (("2" (expand "right_ideal?") (("2" (expand "right_swallow?") (("2" (flatten) (("2" (hide -4) (("2" (inst -4 "x!3" "x!2") (("2" (assert) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!2" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4 -5 -6) (("2" (lemma "R_prod_star_closed[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1" "x!1" "r!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (typepred "phi!1") (("2" (expand "R_epimorphism?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ideal? const-decl "bool" ring_ideal_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (image const-decl "set[R]" function_image nil) (restrict const-decl "R" restrict nil) (image const-decl "set[R]" function_image nil) (surjective? const-decl "bool" functions nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (TRUE const-decl "bool" booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](I!1))" ring_homomorphism_lemmas nil) (I!1 skolem-const-decl "ideal[T1, s1, p1, zero1](R1!1)" ring_homomorphism_lemmas nil) (x!3 skolem-const-decl "(R1!1)" ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](I!1))" ring_homomorphism_lemmas nil) (x!3 skolem-const-decl "(R1!1)" ring_homomorphism_lemmas nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (R_epimorphism type-eq-decl nil ring_homomorphisms_def nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (R_homo_image_subring formula-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (ideal type-eq-decl nil ring_ideal_def nil) (left_ideal? const-decl "bool" ring_ideal_def nil)) shostak)) (R_homo_inv_image_ideal 0 (R_homo_inv_image_ideal-1 nil 3753986983 ("" (skosimp) (("" (expand "ideal?") (("" (expand "left_ideal?") (("" (expand "right_ideal?") (("" (rewrite "R_homo_inv_image_subring") (("1" (split) (("1" (expand "left_swallow?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "extend") (("1" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (typepred "r!1" "x!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -5) (("1" (expand "homomorphism?") (("1" (inst -1 "r!1" "x!1") (("1" (replaces -1) (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (flatten) (("1" (hide -2) (("1" (expand "left_ideal?") (("1" (flatten) (("1" (hide -1) (("1" (expand "left_swallow?") (("1" (inst -1 "phi!1(r!1)" "phi!1(x!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "r!1" "x!1") (("2" (expand "extend") (("2" (prop) (("2" (hide -2) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "r!1" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "right_swallow?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "extend") (("2" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -5) (("1" (expand "homomorphism?") (("1" (inst -1 "x!1" "r!1") (("1" (replaces -1) (("1" (typepred "x!1" "r!1" "I!1") (("1" (expand "extend") (("1" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (expand "ideal?") (("1" (flatten) (("1" (hide -4) (("1" (expand "right_ideal?") (("1" (flatten) (("1" (hide -4) (("1" (expand "right_swallow?") (("1" (inst -4 "phi!1(r!1)" "phi!1(x!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1" "r!1") (("2" (expand "extend") (("2" (prop) (("2" (hide -2) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!1" "r!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ideal? const-decl "bool" ring_ideal_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (extend const-decl "R" extend nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (inverse_image const-decl "set[D]" function_image nil) (NOT const-decl "[bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphism_lemmas nil) (I!1 skolem-const-decl "ideal[T2, s2, p2, zero2](R2!1)" ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (phi!1 skolem-const-decl "R_homomorphism[T1, s1, p1, zero1, T2, s2, p2, zero2](R1!1, R2!1)" ring_homomorphism_lemmas nil) (x!1 skolem-const-decl "(extend[T1, (R1!1), bool, FALSE](inverse_image(phi!1, I!1)))" ring_homomorphism_lemmas nil) (TRUE const-decl "bool" booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (member const-decl "bool" sets nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (x!1 skolem-const-decl "(extend[T1, (R1!1), bool, FALSE](inverse_image(phi!1, I!1)))" ring_homomorphism_lemmas nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (R_homo_inv_image_subring formula-decl nil ring_homomorphism_lemmas nil) (left_ideal? const-decl "bool" ring_ideal_def nil)) shostak)) (R_kernel_in_inverse_image 0 (R_kernel_in_inverse_image-1 nil 3755008608 ("" (skosimp) (("" (name-replace "K" "R_kernel(R1!1, R2!1)(phi!1)" :hide? nil) (("" (assert) (("" (expand "subset?") (("" (skosimp) (("" (expand "member") (("" (expand "extend") (("" (expand "K" -3) (("" (expand " R_kernel" -3) (("" (flatten) (("" (assert) (("" (expand "inverse_image") (("" (replaces -5) (("" (rewrite "zero_is_member_R") (("" (hide -1 -3 -4 2) (("" (expand "subring?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (K skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (inverse_image const-decl "set[D]" function_image nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (subring? const-decl "bool" ring_def algebra) (TRUE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil)) shostak)) (inv_image_image_sum 0 (inv_image_image_sum-1 nil 3755015154 ("" (skosimp) (("" (name-replace "K" "R_kernel(R1!1, R2!1)(phi!1)" :hide? nil) (("" (assert) (("" (decompose-equality 1) (("" (iff) (("" (prop) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (expand "restrict" 1) (("1" (expand "image") (("1" (skosimp) (("1" (typepred "x!2") (("1" (expand "restrict") (("1" (typepred "x!1") (("1" (expand "sum") (("1" (inst 1 "x!2" "s1(-x!2,x!1)") (("1" (rewrite "plus_associative" :dir rl) nil nil) ("2" (expand "K" 1) (("2" (expand "R_kernel" 1) (("2" (split) (("1" (hide -3 -4 -5 -6) (("1" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("1" (inst -1 "R1!1" "x!2") (("1" (expand "member") (("1" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("1" (inst -1 "R1!1" "inv(x!2)" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (typepred "R2!1") (("2" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "phi!1") (("3" (expand "R_homomorphism?") (("3" (flatten) (("3" (hide -1 -2 -3 -4 -6) (("3" (expand "homomorphism?") (("3" (inst -1 "-x!2" "x!1") (("1" (replaces -1) (("1" (lemma "inv_to_inv") (("1" (inst -1 "R1!1" "R2!1" "phi!1" "x!2") (("1" (replaces -1) (("1" (replaces -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "inv_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "R1!1" "x!2") (("2" (assert) (("2" (expand "-") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict" -1) (("2" (expand "sum") (("2" (skosimp) (("2" (typepred "x!1" "h!1" "k!1") (("2" (expand "inverse_image") (("2" (expand "member") (("2" (expand "image") (("2" (inst 1 "h!1") (("1" (replaces -4) (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -6) (("1" (expand "homomorphism?") (("1" (expand "K" -4) (("1" (expand "R_kernel" -4) (("1" (flatten) (("1" (inst -1 "h!1" "k!1") (("1" (replaces -1) (("1" (replaces -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-2 -6 1)) (("2" (expand "subset?") (("2" (inst -2 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (inverse_image const-decl "set[D]" function_image nil) (image const-decl "set[R]" function_image nil) (restrict const-decl "R" restrict nil) (sum const-decl "set[T]" cosets_def nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (S1!1 skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (x!2 skolem-const-decl "(restrict[T1, (R1!1), bool](S1!1))" ring_homomorphism_lemmas nil) (K skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (inv const-decl "{y | x * y = one AND y * x = one}" group algebra) (x!1 skolem-const-decl "(R1!1)" ring_homomorphism_lemmas nil) (plus_associative formula-decl nil ring algebra) (zero_plus formula-decl nil ring algebra) (negate_is_right_inv formula-decl nil ring algebra) (homomorphism? const-decl "bool" homomorphisms_def nil) (TRUE const-decl "bool" booleans nil) (negate_is_left_inv formula-decl nil ring algebra) (inv_to_inv formula-decl nil ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (inv_is_member_R formula-decl nil ring_basic_properties nil) (h!1 skolem-const-decl "(S1!1)" ring_homomorphism_lemmas nil) (plus_zero formula-decl nil ring algebra) (subring? const-decl "bool" ring_def algebra) (subset? const-decl "bool" sets nil)) nil)) (inv_image_image_subring_TCC1 0 (inv_image_image_subring_TCC1-1 nil 3755015181 ("" (subtype-tcc) nil nil) ((R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ring nonempty-type-eq-decl nil ring algebra) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def algebra) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (plus_zero formula-decl nil ring algebra) (restrict const-decl "R" restrict nil) (zero_plus formula-decl nil ring algebra) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def algebra) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def algebra) (inv_exists? const-decl "bool" group_def algebra) (group? const-decl "bool" group_def algebra) (commutative? const-decl "bool" operator_defs nil) (abelian_group? const-decl "bool" group_def algebra) (left_distributive? const-decl "bool" operator_defs_more algebra) (right_distributive? const-decl "bool" operator_defs_more algebra) (ring? const-decl "bool" ring_def algebra) (subring? const-decl "bool" ring_def algebra)) nil (inv_image_image_subring subtype "ring_homomorphism_lemmas.S1" "(ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring?)"))) (inv_image_image_subring 0 (inv_image_image_subring-1 nil 3755015188 ("" (skosimp) (("" (name-replace "K" "R_kernel(R1!1, R2!1)(phi!1)" :hide? nil) (("" (assert) (("" (prop) (("1" (expand "subring?" 1) (("1" (lemma "R_kernel_is_subring") (("1" (inst -1 "R1!1" "R2!1" "phi!1") (("1" (expand "subring?" -1) (("1" (flatten) (("1" (assert) (("1" (hide -1 -2) (("1" (lemma "inv_image_image_sum") (("1" (inst -1 "R1!1" "R2!1" "S1!1" "phi!1") (("1" (assert) (("1" (replaces -1) (("1" (decompose-equality -1) (("1" (expand "subset?") (("1" (skosimp) (("1" (inst -1 "x!1") (("1" (expand "restrict") (("1" (expand "sum") (("1" (iff) (("1" (expand "member") (("1" (assert) (("1" (inst 1 "zero1" "x!1") (("1" (assert) nil nil) ("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-4 1)) (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "S1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "K" -1) (("2" (expand "R_kernel" -1) (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inv_image_image_sum") (("2" (inst -1 "R1!1" "R2!1" "S1!1" "phi!1") (("2" (assert) (("2" (replaces -1) (("2" (decompose-equality 1) (("2" (expand "restrict") (("2" (expand "sum") (("2" (iff 1) (("2" (expand "subring?" -1) (("2" (flatten) (("2" (expand "subset?") (("2" (prop) (("1" (skosimp) (("1" (typepred "h!1" "k!1") (("1" (inst -4 "k!1") (("1" (assert) (("1" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("1" (inst -1 "S1!1" "h!1" "k!1") (("1" (assert) nil nil) ("2" (hide-all-but (-7 1)) (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1" "zero1") (("1" (assert) nil nil) ("2" (hide -) (("2" (expand "R_kernel") (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (lemma "zero_is_member_R[T2,s2,p2,zero2]") (("2" (inst -1 "R2!1") (("2" (inst -2 "R1!1") (("2" (assert) (("2" (rewrite "zero_to_zero") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (T2 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphism_lemmas nil) (zero2 formal-const-decl "T2" ring_homomorphism_lemmas nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (R_kernel_is_subring formula-decl nil ring_homomorphism_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (inv_image_image_sum formula-decl nil ring_homomorphism_lemmas nil) (sum const-decl "set[T]" cosets_def nil) (restrict const-decl "R" restrict nil) (K skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (zero_plus formula-decl nil ring algebra) (S1!1 skolem-const-decl "set[T1]" ring_homomorphism_lemmas nil) (member const-decl "bool" sets nil) (x!1 skolem-const-decl "T1" ring_homomorphism_lemmas nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (subset? const-decl "bool" sets nil) (TRUE const-decl "bool" booleans nil) (subring? const-decl "bool" ring_def algebra) (NOT const-decl "[bool -> bool]" booleans nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (plus_zero formula-decl nil ring algebra) (phi!1 skolem-const-decl "R_homomorphism[T1, s1, p1, zero1, T2, s2, p2, zero2](R1!1, R2!1)" ring_homomorphism_lemmas nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphism_lemmas nil) (x!1 skolem-const-decl "(R1!1)" ring_homomorphism_lemmas nil)) shostak)) (ring_natural_homo_TCC1 0 (ring_natural_homo_TCC1-1 nil 3724689249 ("" (skosimp) (("" (expand "/") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (inst 1 "r!1") nil nil)) nil)) nil)) nil)) nil) ((/ const-decl "setof[set[T]]" quotient_ring_def nil) (left_coset? const-decl "bool" cosets_def nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (+ const-decl "set[T]" cosets_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)) nil (ring_natural_homo subtype "(cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].+)(ring_homomorphism_lemmas.r, ring_homomorphism_lemmas.I)" "(quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1]./(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I))"))) (ring_natural_homo_TCC2 0 (ring_natural_homo_TCC2-1 nil 3724689249 ("" (skosimp*) (("" (expand* "restrict" "/") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (decompose-equality -1) (("" (inst -1 "x1!1") (("" (inst 1 "x1!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (left_coset? const-decl "bool" cosets_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "set[T]" cosets_def nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (/ const-decl "setof[set[T]]" quotient_ring_def nil) (setof type-eq-decl nil defined_types nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)) nil (ring_natural_homo subtype "ring_homomorphism_lemmas.phi" "[(ring_homomorphism_lemmas.S) -> (restrict[set[T1], cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), booleans.bool].restrict(quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1]./(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)))]"))) (ring_natural_homo_TCC3 0 (ring_natural_homo_TCC3-1 nil 3724689249 ("" (skosimp) (("" (inst 1 "I!1") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (inst 1 "zero1") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "S!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (coset? const-decl "bool" cosets_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (coset type-eq-decl nil cosets_def nil) (I!1 skolem-const-decl "ideal[T1, s1, p1, zero1](S!1)" ring_homomorphism_lemmas nil) (S!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)) nil (ring_natural_homo existence "" "cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)"))) (ring_natural_homo_TCC4 0 (ring_natural_homo_TCC4-1 nil 3724689249 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst -1 "S!1" "I!1" "x1!1`1" "x1!1`2") (("" (expand "add") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (coset_add formula-decl nil quotient_rings nil) (add const-decl "set[T]" quotient_ring_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (ring_natural_homo subtype "quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1].add(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)" "[[cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)] -> cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)]"))) (ring_natural_homo_TCC5 0 (ring_natural_homo_TCC5-1 nil 3724689249 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst -1 "S!1" "I!1" "x1!1`1" "x1!1`2") (("" (expand "product") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (coset_product formula-decl nil quotient_rings nil) (product const-decl "set[T]" quotient_ring_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (ring_natural_homo subtype "quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1].product(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)" "[[cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)] -> cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)]"))) (ring_natural_homo_TCC6 0 (ring_natural_homo_TCC6-1 nil 3748698239 ("" (skosimp) (("" (inst 1 "I!1") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (inst 1 "zero1") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "S!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ideal type-eq-decl nil ring_ideal_def nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (S!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (member const-decl "bool" sets nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_coset? const-decl "bool" cosets_def nil)) nil (ring_natural_homo subtype "ring_homomorphism_lemmas.I" "cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)"))) (ring_natural_homo_TCC7 0 (ring_natural_homo_TCC7-2 "" 3804567705 ("" (skosimp*) (("" (expand "R_epimorphism?") (("" (flatten) (("" (assert) (("" (skosimp) (("" (expand* "restrict" "/") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (decompose-equality -1) (("" (inst -1 "x1!1") (("" (inst 1 "x1!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (ring_natural_homo subtype "ring_homomorphism_lemmas.phi" "ring_homomorphisms_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1, cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1].add(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1].product(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), ring_homomorphism_lemmas.I].R_homomorphism(ring_homomorphism_lemmas.S, restrict[set[T1], cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), booleans.bool].restrict(quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1]./(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)))")) (ring_natural_homo_TCC7-1 nil 3748698239 ("" (skosimp*) (("" (expand "R_epimorphism?") (("" (flatten) (("" (assert) (("" (hide -1 -2) (("" (skosimp) (("" (expand* "restrict" "/") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (decompose-equality -1) (("" (inst -1 "x1!1") (("" (inst 1 "x1!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (/ const-decl "setof[set[T]]" quotient_ring_def nil) (restrict const-decl "R" restrict nil) (left_coset? const-decl "bool" cosets_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "set[T]" cosets_def nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)) nil (ring_natural_homo subtype "ring_homomorphism_lemmas.phi" "ring_homomorphisms_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1, cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1].add(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1].product(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), ring_homomorphism_lemmas.I].R_homomorphism(ring_homomorphism_lemmas.S, restrict[set[T1], cosets_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1].coset(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I), booleans.bool].restrict(quotient_ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1]./(ring_homomorphism_lemmas.S, ring_homomorphism_lemmas.I)))"))) (ring_natural_homo 0 (ring_natural_homo-1 nil 3724689252 ("" (skosimp) (("" (assert) (("" (expand "R_epimorphism?") (("" (split) (("1" (expand "surjective?") (("1" (skosimp) (("1" (typepred "y!1") (("1" (hide -2) (("1" (expand "coset?") (("1" (expand "left_coset?") (("1" (flatten) (("1" (hide -2) (("1" (skosimp) (("1" (inst 1 "a!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (split) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (lemma "R_sum_star_closed[T1,s1,p1,zero1]") (("1" (inst -1 "S!1" "x!1" "y!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "star_closed?") (("2" (skosimp) (("2" (lemma "R_prod_star_closed[T1,s1,p1,zero1]") (("2" (inst -1 "S!1" "x!1" "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (expand "restrict") (("3" (expand "/") (("3" (rewrite "coset_add") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand* "member" "restrict" "/") (("4" (rewrite "coset_product") nil nil)) nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (skosimp) (("5" (rewrite "add_charac") nil nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (rewrite "product_charac") nil nil)) nil)) nil)) nil)) nil) ("3" (expand "R_kernel") (("3" (decompose-equality) (("1" (expand "restrict") (("1" (iff) (("1" (prop) (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "subset?") (("1" (inst -1 "x!1") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/") (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "zero1") (("1" (rewrite "left_zero") nil nil) ("2" (hide -) (("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "S!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "self_coset") (("3" (typepred "I!1") (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (flatten) (("3" (hide -2 -3) (("3" (inst -2 "I!1" "S!1" "x!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "self_coset") (("4" (typepred "I!1") (("4" (expand "ideal?") (("4" (expand "left_ideal?") (("4" (flatten) (("4" (hide -2 -3) (("4" (inst -2 "I!1" "S!1" "x!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (rewrite "lcoset_iff_coset" 1 :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "zero1") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T1,s1,p1,zero1]") (("2" (inst -1 "S!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((left_coset? const-decl "bool" cosets_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (coset? const-decl "bool" cosets_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (coset type-eq-decl nil cosets_def nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" quotient_ring_def nil) (surjective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (star_closed? const-decl "bool" groupoid_def algebra) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (coset_add formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (add_charac formula-decl nil quotient_rings nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (product_charac formula-decl nil quotient_rings nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (I!1 skolem-const-decl "ideal[T1, s1, p1, zero1](S!1)" ring_homomorphism_lemmas nil) (S!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "set[T]" cosets_def nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (subset? const-decl "bool" sets nil) (subring? const-decl "bool" ring_def algebra) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil)) shostak)))(ring_homomorphism_lemmas_extras (IMP_quotient_rings_TCC1 0 (IMP_quotient_rings_TCC1-1 nil 3782147281 ("" (rewrite "R1_is_ring") nil nil) ((R1_is_ring formula-decl nil ring_homomorphism_lemmas_extras nil)) nil (IMP_quotient_rings assuming "quotient_rings[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1, ring_homomorphism_lemmas_extras.p1, ring_homomorphism_lemmas_extras.zero1].quotient_rings" "fullset_is_ring: ASSUMPTION ring_def[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring?(sets[quotient_rings.T].fullset)"))) (zero_natural_isomorphism_TCC1 0 (zero_natural_isomorphism_TCC1-1 nil 3782147281 ("" (skeep) (("" (inst 1 "singleton(zero1)") (("" (rewrite "ideal_is_coset") (("" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil) ((nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (coset? const-decl "bool" cosets_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (coset type-eq-decl nil cosets_def nil) (S skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas_extras nil) (zero_ideal formula-decl nil ring_ideal nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil)) nil (zero_natural_isomorphism existence "" "cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))"))) (zero_natural_isomorphism_TCC2 0 (zero_natural_isomorphism_TCC2-1 nil 3782147281 ("" (skeep) (("" (lemma "coset_add") (("" (inst -1 "S" "singleton[T1](zero1)" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras nil) (coset_add formula-decl nil quotient_rings nil) (zero_ideal formula-decl nil ring_ideal nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ideal? const-decl "bool" ring_ideal_def nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (ring nonempty-type-eq-decl nil ring algebra) (S skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas_extras nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil)) nil (zero_natural_isomorphism subtype "quotient_ring_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1, ring_homomorphism_lemmas_extras.p1].add(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))" "[[cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1)), cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))] -> cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))]"))) (zero_natural_isomorphism_TCC3 0 (zero_natural_isomorphism_TCC3-1 nil 3782147281 ("" (skeep) (("" (lemma "coset_product") (("" (inst -1 "S" "singleton[T1](zero1)" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil) ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras nil) (coset_product formula-decl nil quotient_rings nil) (zero_ideal formula-decl nil ring_ideal nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ideal? const-decl "bool" ring_ideal_def nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (ring nonempty-type-eq-decl nil ring algebra) (S skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas_extras nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil)) nil (zero_natural_isomorphism subtype "quotient_ring_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1, ring_homomorphism_lemmas_extras.p1].product(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))" "[[cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1)), cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))] -> cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))]"))) (zero_natural_isomorphism_TCC4 0 (zero_natural_isomorphism_TCC4-1 nil 3782147281 ("" (skeep) (("" (inst 1 "singleton[T1](zero1)") (("" (rewrite "ideal_is_coset") (("" (hide 2) (("" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil) ((nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil) (zero_ideal formula-decl nil ring_ideal nil)) nil (zero_natural_isomorphism subtype "sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1)" "cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))"))) (zero_natural_isomorphism 0 (zero_natural_isomorphism-1 nil 3782147356 ("" (skeep) (("" (expand "R_isomorphic?") (("" (inst 1 "(LAMBDA (r:(S)): r + singleton(zero1))") (("1" (lemma "ring_natural_homo[T1,s1,p1,zero1,coset(S,singleton(zero1)),add(S,singleton(zero1)),product(S,singleton(zero1)),singleton(zero1)]") (("1" (inst -1 "S" "singleton(zero1)") (("1" (assert) (("1" (flatten) (("1" (expand "R_isomorphism?") (("1" (assert) (("1" (lemma "monomorphism_charac[T1,s1,p1,zero1,
                        coset(S,singleton(zero1)),add(S,singleton(zero1)),product(S,singleton(zero1)),singleton(zero1)]") (("1" (inst -1 "S" "S/singleton(zero1)" "(LAMBDA (r: (S)): r + singleton(zero1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "R_epimorphism?") (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (expand "restrict") (("3" (expand "/") (("3" (hide-all-but 1) (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (case "left_coset?(S, singleton[T1](zero1))
                                ((+[T1, s1])(r, singleton[T1](zero1)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "left_coset?") (("2" (inst 1 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "quotient_group_is_ring") (("4" (hide 2) (("4" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "zero_ideal") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "fullset_quot_group_is_ring") (("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite " R1_is_ring") nil nil)) nil) ("4" (hide 2) (("4" (rewrite "ideal_is_coset") (("4" (rewrite "zero_ideal") nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (lemma "coset_product") (("5" (inst -1 "S" "singleton(zero1)" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (lemma "coset_add") (("6" (inst -1 "S" "singleton(zero1)" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (inst 1 "singleton(zero1)") (("7" (rewrite "ideal_is_coset") (("7" (rewrite "zero_ideal") nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "restrict") (("2" (expand "/") (("2" (case " coset?[T1, s1]
                   (S, singleton[T1](zero1))((+[T1, s1])(r, singleton[T1](zero1)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (ring_natural_homo formula-decl nil ring_homomorphism_lemmas nil) (add const-decl "set[T]" quotient_ring_def nil) (product const-decl "set[T]" quotient_ring_def nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil) (zero_ideal formula-decl nil ring_ideal nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (R1_is_ring formula-decl nil ring_homomorphism_lemmas_extras nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (coset_product formula-decl nil quotient_rings nil) (coset_add formula-decl nil quotient_rings nil) (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphism_lemmas_extras nil) (zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (S skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphism_lemmas_extras nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (coset? const-decl "bool" cosets_def nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (+ const-decl "set[T]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" quotient_ring_def nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil)) shostak)))
