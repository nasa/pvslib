(ring_prime_ideal (IMP_ring_one_generator_TCC1 0 (IMP_ring_one_generator_TCC1-1 nil 3793905401 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_prime_ideal nil)) nil (IMP_ring_one_generator assuming "ring_one_generator[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring_one_generator" "fullset_is_ring: ASSUMPTION ring_def[ring_one_generator.T, ring_one_generator.+, ring_one_generator.*, ring_one_generator.zero].ring?(sets[ring_one_generator.T].fullset)"))) (prime_ideal_prop1 0 (prime_ideal_prop1-2 nil 3776615613 ("" (skosimp) (("" (expand "prime_ideal?") (("" (assert) (("" (skosimp) (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (inst -3 "x!1*x!2") (("" (expand "sum") (("" (split) (("1" (inst -3 "x!1" "x!2") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (typepred "B!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3 -4) (("2" (expand "subset?") (("2" (inst -1 "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (typepred "A!1") (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (flatten) (("3" (hide -2 -3 -4) (("3" (expand "subset?") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1" "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (subring? const-decl "bool" ring_def algebra) (left_ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (x!2 skolem-const-decl "T" ring_prime_ideal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (zero formal-const-decl "T" ring_prime_ideal nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (x!1 skolem-const-decl "T" ring_prime_ideal nil) (A!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_prime_ideal nil) (B!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_prime_ideal nil) (sum const-decl "set[T]" cosets_def nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil) (prime_ideal_prop1-1 nil 3776596215 ("" (skosimp) (("" (expand "prime_ideal?") (("" (assert) (("" (skosimp) (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (inst -3 "x!1*x!2") (("" (expand "sum") (("" (split) (("1" (inst -3 "x!1" "x!2") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (typepred "B!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3 -4) (("2" (expand "subset?") (("2" (inst -1 "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (typepred "A!1") (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (flatten) (("3" (hide -2 -3 -4) (("3" (expand "subset?") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1" "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (subring? const-decl "bool" ring_def algebra) (left_ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (zero formal-const-decl "T" ring_prime_ideal nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (sum const-decl "set[T]" cosets_def nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak)) (prime_ideal_prop2 0 (prime_ideal_prop2-2 nil 3793981445 ("" (skosimp*) (("" (case "subset?(sum[T,*](commutative_one_gen(R!1)(a!1), commutative_one_gen(R!1)(b!1)), P!1)") (("1" (expand "prime_ideal?") (("1" (flatten) (("1" (inst -4 "commutative_one_gen(R!1)(a!1)" "commutative_one_gen(R!1)(b!1)") (("1" (assert) (("1" (split) (("1" (hide -2) (("1" (case "commutative_one_gen(R!1)(a!1)(a!1)") (("1" (expand "subset?") (("1" (inst -2 "a!1") (("1" (assert) (("1" (expand "extend") (("1" (propax) nil))))))))) ("2" (hide -1 -4 2 3 4) (("2" (expand "commutative_one_gen") (("2" (inst 1 "zero" "1") (("1" (assert) (("1" (rewrite "times_int_one") nil))) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil))))))))))))))))) ("2" (hide -2 -3 -4 -5 1 2) (("2" (case "commutative_one_gen(R!1)(b!1)(b!1)") (("1" (expand "subset?") (("1" (inst -2 "b!1") (("1" (assert) (("1" (expand "extend") (("1" (propax) nil))))))))) ("2" (hide -1) (("2" (expand "commutative_one_gen") (("2" (inst 1 "zero" "1") (("1" (assert) (("1" (rewrite "times_int_one") nil))) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil))))))))))))))))))))) ("2" (hide-all-but (-2 1)) (("2" (rewrite "commutative_one_gen_is_ideal") nil))) ("3" (hide-all-but (-2 1)) (("3" (rewrite "commutative_one_gen_is_ideal") nil))))))))) ("2" (hide 2 3) (("2" (expand "subset?") (("2" (skosimp) (("2" (lemma "subset_product_one_gen") (("2" (inst -1 "R!1" "a!1" "b!1") (("2" (expand "subset?") (("2" (inst -1 "x!1") (("2" (assert) (("2" (hide -2) (("2" (expand "extend") (("2" (prop) (("2" (expand "commutative_one_gen") (("2" (skosimp) (("2" (replace -2 1) (("2" (case "P!1(r!1 * (a!1 * b!1)) AND P!1(times(a!1 * b!1, n!1))") (("1" (flatten) (("1" (expand "prime_ideal?") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -7 1)) (("1" (lemma "R_sum_star_closed") (("1" (inst -1 "P!1" "r!1 * (a!1 * b!1)" "times(a!1 * b!1, n!1)") (("1" (assert) nil))))))))))))))))))) ("2" (hide 2) (("2" (split) (("1" (typepred "r!1") (("1" (expand "prime_ideal?") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (flatten) (("1" (hide-all-but (-1 -6 -9 1)) (("1" (inst -2 "r!1" "a!1*b!1") (("1" (assert) nil))))))))))))))))) ("2" (expand "prime_ideal?") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 -9 1)) (("2" (lemma "times_member") (("2" (inst -1 "P!1" "n!1" "a!1*b!1") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))))))))))))))))))) nil) ((commutative_one_gen const-decl "set[(R)]" ring_one_generator nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (zero formal-const-decl "T" ring_prime_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (sum const-decl "set[T]" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (commutative_one_gen_is_ideal formula-decl nil ring_one_generator nil) (commutative_ring? const-decl "bool" ring_def algebra) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (times_int_one formula-decl nil ring_basic_properties nil) (left_identity formula-decl nil monad algebra) (zero_times formula-decl nil ring algebra) (zero_is_member_R formula-decl nil ring_basic_properties nil) (ideal type-eq-decl nil ring_ideal_def nil) (b!1 skolem-const-decl "(R!1)" ring_prime_ideal nil) (ideal? const-decl "bool" ring_ideal_def nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (a!1 skolem-const-decl "(R!1)" ring_prime_ideal nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (subset_product_one_gen formula-decl nil ring_one_generator nil) (times_member formula-decl nil ring_basic_properties nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (subring? const-decl "bool" ring_def algebra) (P!1 skolem-const-decl "set[T]" ring_prime_ideal nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (times const-decl "T" ring_basic_properties nil)) nil) (prime_ideal_prop2-1 nil 3776605044 ("" (skosimp*) (("" (case "subset?(sum[T,*](commutative_one_gen(R!1)(a!1), commutative_one_gen(R!1)(b!1)), P!1)") (("1" (expand "prime_ideal?") (("1" (flatten) (("1" (inst -4 "commutative_one_gen(R!1)(a!1)" "commutative_one_gen(R!1)(b!1)") (("1" (assert) (("1" (split) (("1" (hide -2) (("1" (case "commutative_one_gen(R!1)(a!1)(a!1)") (("1" (expand "subset?") (("1" (inst -2 "a!1") (("1" (assert) (("1" (expand "extend") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 2 3 4) (("2" (expand "commutative_one_gen") (("2" (inst 1 "zero" "1") (("1" (assert) (("1" (rewrite "times_int_one") nil nil)) nil) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 1 2) (("2" (case "commutative_one_gen(R!1)(b!1)(b!1)") (("1" (expand "subset?") (("1" (inst -2 "b!1") (("1" (assert) (("1" (expand "extend") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "commutative_one_gen") (("2" (inst 1 "zero" "1") (("1" (assert) (("1" (rewrite "times_int_one") nil nil)) nil) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (rewrite "commutative_one_gen_is_ideal") nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (rewrite "commutative_one_gen_is_ideal") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "subset?") (("2" (skosimp) (("2" (lemma "subset_product_one_gen") (("2" (inst -1 "R!1" "a!1" "b!1") (("2" (expand "subset?") (("2" (inst -1 "x!1") (("2" (assert) (("2" (hide -2) (("2" (expand "extend") (("2" (prop) (("2" (expand "commutative_one_gen") (("2" (skosimp) (("2" (replace -2 1) (("2" (case "P!1(r!1 * (a!1 * b!1)) AND P!1(times(a!1 * b!1, n!1))") (("1" (flatten) (("1" (expand "prime_ideal?") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -7 1)) (("1" (lemma "R_sum_star_closed") (("1" (inst -1 "P!1" "r!1 * (a!1 * b!1)" "times(a!1 * b!1, n!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (typepred "r!1") (("1" (expand "prime_ideal?") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (flatten) (("1" (hide-all-but (-1 -6 -9 1)) (("1" (inst -2 "r!1" "a!1*b!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prime_ideal?") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 -9 1)) (("2" (lemma "times_member") (("2" (inst -1 "P!1" "n!1" "a!1*b!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((commutative_one_gen const-decl "set[(R)]" ring_one_generator nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (zero formal-const-decl "T" ring_prime_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (sum const-decl "set[T]" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (commutative_one_gen_is_ideal formula-decl nil ring_one_generator nil) (commutative_ring? const-decl "bool" ring_def algebra) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (times_int_one formula-decl nil ring_basic_properties nil) (left_identity formula-decl nil monad algebra) (zero_times formula-decl nil ring algebra) (zero_is_member_R formula-decl nil ring_basic_properties nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (subset_product_one_gen formula-decl nil ring_one_generator nil) (times_member formula-decl nil ring_basic_properties nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (subring? const-decl "bool" ring_def algebra) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (times const-decl "T" ring_basic_properties nil)) shostak)) (prime_ideal_prod_closed 0 (prime_ideal_prod_closed-1 nil 3777111936 ("" (skosimp*) (("" (expand "member") (("" (expand "remove") (("" (flatten) (("" (split) (("1" (expand "member") (("1" (expand "/") (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (expand "left_coset?") (("1" (skosimp*) (("1" (replaces -2) (("1" (replaces -2) (("1" (rewrite "product_charac") (("1" (lemma "self_coset") (("1" (inst -1 "P!1" "R!1" "a!1*a!2") (("1" (typepred "P!1") (("1" (expand "prime_ideal?") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (hide -2 -3 -4) (("1" (assert) (("1" (lemma "prime_ideal_prop2") (("1" (inst -1 "P!1" "R!1") (("1" (assert) (("1" (inst -1 "a!1" "a!2") (("1" (assert) (("1" (split) (("1" (lemma "self_coset") (("1" (inst -1 "P!1" "R!1" "a!1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "self_coset") (("2" (inst -1 "P!1" "R!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "R!1") (("2" (expand "commutative_ring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "P!1") (("2" (expand "prime_ideal?") (("2" (propax) nil nil)) nil)) nil) ("3" (typepred "R!1") (("3" (expand "commutative_ring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "/") (("2" (rewrite "coset_product") (("1" (typepred "P!1") (("1" (expand "prime_ideal?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "R!1") (("2" (expand "commutative_ring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (coset_product formula-decl nil quotient_rings nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (coset? const-decl "bool" cosets_def nil) (commutative_ring? const-decl "bool" ring_def algebra) (ring? const-decl "bool" ring_def algebra) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (prime_ideal type-eq-decl nil ring_prime_ideal_def nil) (coset type-eq-decl nil cosets_def nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (zero formal-const-decl "T" ring_prime_ideal nil) (left_coset? const-decl "bool" cosets_def nil) (TRUE const-decl "bool" booleans nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring algebra) (product_charac formula-decl nil quotient_rings nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (prime_ideal_prop2 formula-decl nil ring_prime_ideal nil) (NOT const-decl "[bool -> bool]" booleans nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (/ const-decl "setof[set[T]]" quotient_ring_def nil) (remove const-decl "set" sets nil)) shostak)) (prime_ideal_nz_closed_TCC1 0 (prime_ideal_nz_closed_TCC1-1 nil 3780320789 ("" (skeep) (("" (inst 1 "P") (("" (rewrite "ideal_is_coset") (("" (expand "prime_ideal?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_prime_ideal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (zero formal-const-decl "T" ring_prime_ideal nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (coset type-eq-decl nil cosets_def nil) (P skolem-const-decl "set[T]" ring_prime_ideal nil) (R skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil)) nil (prime_ideal_nz_closed existence "" "cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)"))) (prime_ideal_nz_closed_TCC2 0 (prime_ideal_nz_closed_TCC2-2 "" 3804567608 ("" (skeep) (("" (skeep) (("" (lemma "coset_add") (("" (inst -1 "R" "P" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (hide -2 2) (("2" (expand "prime_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (prime_ideal_nz_closed subtype "quotient_ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*].add(ring_prime_ideal.R, ring_prime_ideal.P)" "[[cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P), cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)] -> cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)]")) (prime_ideal_nz_closed_TCC2-1 nil 3780320789 ("" (skeep) (("" (skeep) (("" (lemma "coset_add") (("" (inst -1 "R" "P" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "prime_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (ring nonempty-type-eq-decl nil ring algebra) (P skolem-const-decl "set[T]" ring_prime_ideal nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ideal type-eq-decl nil ring_ideal_def nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (coset_add formula-decl nil quotient_rings nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (zero formal-const-decl "T" ring_prime_ideal nil)) nil (prime_ideal_nz_closed subtype "quotient_ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*].add(ring_prime_ideal.R, ring_prime_ideal.P)" "[[cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P), cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)] -> cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)]"))) (prime_ideal_nz_closed_TCC3 0 (prime_ideal_nz_closed_TCC3-2 "" 3804567628 ("" (skeep*) (("" (lemma "coset_product") (("" (inst -1 "R" "P" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (hide -2 2) (("2" (expand "prime_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (prime_ideal_nz_closed subtype "quotient_ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*].product(ring_prime_ideal.R, ring_prime_ideal.P)" "[[cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P), cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)] -> cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)]")) (prime_ideal_nz_closed_TCC3-1 nil 3780320789 ("" (skeep*) (("" (lemma "coset_product") (("" (inst -1 "R" "P" "x1`1" "x1`2") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "prime_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_prime_ideal nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (coset_product formula-decl nil quotient_rings nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def algebra) (ideal? const-decl "bool" ring_ideal_def nil) (P skolem-const-decl "set[T]" ring_prime_ideal nil) (ring nonempty-type-eq-decl nil ring algebra) (R skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (prime_ideal_nz_closed subtype "quotient_ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*].product(ring_prime_ideal.R, ring_prime_ideal.P)" "[[cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P), cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)] -> cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)]"))) (prime_ideal_nz_closed_TCC4 0 (prime_ideal_nz_closed_TCC4-1 nil 3780320789 ("" (skeep) (("" (lemma "ideal_is_coset") (("" (inst -1 "R" "P") (("" (expand "prime_ideal?") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_prime_ideal nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (P skolem-const-decl "set[T]" ring_prime_ideal nil) (R skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring algebra) (ring? const-decl "bool" ring_def algebra) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (prime_ideal_nz_closed subtype "ring_prime_ideal.P" "cosets_def[ring_prime_ideal.T, ring_prime_ideal.+].coset(ring_prime_ideal.R, ring_prime_ideal.P)"))) (prime_ideal_nz_closed 0 (prime_ideal_nz_closed-1 nil 3780320806 ("" (skosimp) (("" (expand "nz_closed?") (("" (expand "star_closed?") (("" (skosimp) (("" (expand "member") (("" (expand "remove") (("" (expand "member") (("" (expand "restrict") (("" (typepred "x!1" "y!1") (("" (expand "remove") (("" (expand "member") (("" (expand "restrict") (("" (flatten) (("" (hide -2 -4) (("" (split) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (expand "left_coset?") (("1" (skosimp*) (("1" (replaces -2) (("1" (replaces -2) (("1" (rewrite "product_charac") (("1" (lemma "prime_ideal_prop2") (("1" (inst?) (("1" (assert) (("1" (inst -1 "a!1" "a!2") (("1" (expand "prime_ideal?") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (hide -3 -5 -6 -7) (("1" (lemma "self_coset") (("1" (inst?) (("1" (inst -1 "R!1") (("1" (assert) (("1" (lemma "self_coset") (("1" (prop) (("1" (inst -2 "P!1" "R!1" "a!1") (("1" (assert) nil nil)) nil) ("2" (inst -2 "P!1" "R!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prime_ideal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -1) (("2" (replaces -1) (("2" (expand "/") (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "a!1*a!2") (("1" (rewrite "product_charac") (("1" (expand "prime_ideal?") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "commutative_ring?") (("2" (hide -2 -3 2 3) (("2" (typepred "a!1" "a!2") (("2" (lemma "R_prod_star_closed") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nz_closed? const-decl "bool" ring_nz_closed_def algebra) (remove const-decl "set" sets nil) (restrict const-decl "R" restrict nil) (commutative_ring? const-decl "bool" ring_def algebra) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (a!2 skolem-const-decl "(R!1)" ring_prime_ideal nil) (a!1 skolem-const-decl "(R!1)" ring_prime_ideal nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_prime_ideal nil) (product const-decl "set[T]" quotient_ring_def nil) (+ const-decl "set[T]" cosets_def nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (TRUE const-decl "bool" booleans nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (product_charac formula-decl nil quotient_rings nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (prime_ideal? const-decl "bool" ring_prime_ideal_def nil) (prime_ideal_prop2 formula-decl nil ring_prime_ideal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-nonempty-type-decl nil ring_prime_ideal nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_prime_ideal nil) (zero formal-const-decl "T" ring_prime_ideal nil) (ring? const-decl "bool" ring_def algebra) (ring nonempty-type-eq-decl nil ring algebra) (coset type-eq-decl nil cosets_def nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" quotient_ring_def nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def algebra)) nil)))
