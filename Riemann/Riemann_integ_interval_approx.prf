(Riemann_integ_interval_approx (IMP_integral_def_TCC1 0 (IMP_integral_def_TCC1-1 nil 3782293256 ("" (assuming-tcc) nil nil) ((connected? const-decl "bool" deriv_domain_def analysis)) nil (IMP_integral_def assuming "analysis@integral_def[real].integral_def" "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))) (IMP_integral_def_TCC2 0 (IMP_integral_def_TCC2-1 nil 3782293256 ("" (expand "not_one_element?") (("" (skeep) (("" (inst 1 "x+1") (("" (assert) nil nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (not_one_element? const-decl "bool" deriv_domain_def analysis)) nil (IMP_integral_def assuming "analysis@integral_def[real].integral_def" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (R_TCC1 0 (R_TCC1-1 nil 3657241451 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (R subtype "(number_fields.+)(exponentiation.^(2, Riemann_integ_interval_approx.m), 1)" "above(1)"))) (R_TCC2 0 (R_TCC2-1 nil 3657241451 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (R subtype "(number_fields.-)(Riemann_integ_interval_approx.i, 1)" "below[length(P)]"))) (R_TCC3 0 (R_TCC3-1 nil 3657241451 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (R subtype "Riemann_integ_interval_approx.i" "below[length(P)]"))) (RiemannSum_R2I_TCC1 0 (RiemannSum_R2I_TCC1-1 nil 3657241451 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil)) nil (RiemannSum_R2I subtype "1" "subrange[1, 2 ^ m]"))) (RiemannSum_R2I_TCC2 0 (RiemannSum_R2I_TCC2-1 nil 3657241451 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (RiemannSum_R2I subtype "(number_fields.-)(Riemann_integ_interval_approx.i, 1)" "subrange[1, 2 ^ m]"))) (RiemannSum_R2I_TCC3 0 (RiemannSum_R2I_TCC3-1 nil 3657241451 ("" (termination-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (RiemannSum_R2I termination "Riemann_integ_interval_approx.RiemannSum_R2I(Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b, Riemann_integ_interval_approx.m, (number_fields.-)(Riemann_integ_interval_approx.i, 1), Riemann_integ_interval_approx.n, Riemann_integ_interval_approx.F, Riemann_integ_interval_approx.R)" "nil"))) (riemann_sum_r2i_alternative_definition_TCC1 0 (riemann_sum_r2i_alternative_definition_TCC1-1 nil 3782064295 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (subrange? const-decl "bool" Riemann_integ_interval_approx nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil)) nil (riemann_sum_r2i_alternative_definition subtype "Riemann_integ_interval_approx.k" "subrange[1, 2 ^ m]"))) (riemann_sum_r2i_alternative_definition_TCC2 0 (riemann_sum_r2i_alternative_definition_TCC2-1 nil 3782064295 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (subrange? const-decl "bool" Riemann_integ_interval_approx nil) (restrict const-decl "R" restrict nil)) nil (riemann_sum_r2i_alternative_definition subtype "LAMBDA (k: (Riemann_integ_interval_approx.subrange?(1, exponentiation.^(2, Riemann_integ_interval_approx.m)))): Riemann_integ_interval_approx.R(Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b, Riemann_integ_interval_approx.m, k, Riemann_integ_interval_approx.n, Riemann_integ_interval_approx.F)" "[(restrict[int, nat, bool].restrict(Riemann_integ_interval_approx.subrange?(1, exponentiation.^(2, Riemann_integ_interval_approx.m)))) -> Interval]"))) (riemann_sum_r2i_alternative_definition 0 (riemann_sum_r2i_alternative_definition-1 nil 3782067785 ("" (skeep :but "i") (("" (expand "restrict") (("" (expand "subrange?") (("" (induct "i") (("1" (expand "SigmaSub") (("1" (expand "Sigma") (("1" (expand "Sigma") (("1" (expand "RiemannSum_R2I") (("1" (use "pos_expt_gt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "SigmaSub") (("2" (expand "RiemannSum_R2I" 1) (("2" (expand "Sigma" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (name-replace "bla" "2^m") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subrange?") (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (m skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil subrange_type nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (Interval type-eq-decl nil interval interval_arith) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil) (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx nil) (SigmaSub const-decl "Interval" Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real nonempty-type-from-decl nil reals nil) (subrange_induction formula-decl nil subrange_inductions nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Sigma def-decl "Interval" interval interval_arith) (Add_0_r formula-decl nil interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (r2i_Nneg application-judgement "(NonNeg?)" interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (above nonempty-type-eq-decl nil integers nil) (pos_expt_gt formula-decl nil exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (subrange? const-decl "bool" Riemann_integ_interval_approx nil)) SHOSTAK)) (F_integrable_cos 0 (F_integrable_cos-1 nil 3653179516 ("" (lemma "fundamental_indef[real]") (("1" (skosimp*) (("1" (inst -1 "lb(X!1)" "ub(X!1)" "cos") (("1" (assert) (("1" (lemma "cos_cont_fun") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand (quote connected?) (quote 1)) (("2" (propax) nil nil)) nil)) nil)) nil) ((cos_cont_fun formula-decl nil sincos trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (not_one_element? const-decl "bool" deriv_domain_def analysis) (connected? const-decl "bool" deriv_domain_def analysis) (fundamental_indef formula-decl nil indefinite_integral analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) SHOSTAK)) (F_integrable_cos2_TCC1 0 (F_integrable_cos2_TCC1-1 nil 3660688109 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (F_integrable_cos2 subtype "ub(Riemann_integ_interval_approx.X)" "{x: real | reals.<(lb(Riemann_integ_interval_approx.X), x)}"))) (F_integrable_cos2 0 (F_integrable_cos2-1 nil 3660689017 ("" (lemma "F_integrable_cos") (("" (skosimp*) (("" (inst?) (("" (ground) (("" (expand "Integrable?") (("" (typepred "X!1") (("" (expand "StrictInterval?") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (Integrable? const-decl "bool" integral_def analysis) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (F_integrable_cos formula-decl nil Riemann_integ_interval_approx nil)) SHOSTAK)) (eq_part_width_TCC1 0 (eq_part_width_TCC1-1 nil 3653179014 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (eq_part_width subtype "(number_fields.+)(exponentiation.^(2, Riemann_integ_interval_approx.m), 1)" "above(1)"))) (eq_part_width_TCC2 0 (eq_part_width_TCC2-1 nil 3653179014 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (eq_part_width subtype "(number_fields.-)(Riemann_integ_interval_approx.i, 1)" "below[length(P)]"))) (eq_part_width_TCC3 0 (eq_part_width_TCC3-1 nil 3653179014 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (eq_part_width subtype "Riemann_integ_interval_approx.i" "below[length(P)]"))) (eq_part_width 0 (eq_part_width-1 nil 3653179619 ("" (lemma "width_eq_part") (("" (skosimp*) (("" (assert) (("" (skosimp*) (("" (name-replace "P_1" " eq_partition(lb(X!1), ub(X!1), 2 ^ m!1 + 1)") (("" (inst? -1) (("" (assert) (("" (typepred "width(lb(X!1), ub(X!1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))") (("" (expand "width") (("" (typepred "max({l: real |
               EXISTS (ii: below(length(eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)) - 1)):
                 l = seq(eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(1 + ii) - seq(eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(ii)})
        ") (("1" (skosimp*) (("1" (replace -1) (("1" (reveal -1) (("1" (expand "P_1") (("1" (expand "eq_partition") (("1" (field) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "P_1") (("2" (field) (("2" (lemma "analysis@integral_def.width_TCC3") (("2" (name-replace "PP" "eq_partition[real](lb(X!1), ub(X!1), 1 + (2 ^ m!1))") (("2" (inst -1 "lb(X!1)" "ub(X!1)" "PP" "seq(PP)") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (split) (("1" (propax) nil nil) ("2" (expand "PP") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "X!1") (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "X!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "X!1") (("3" (assert) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (width const-decl "posreal" integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}" finite_sets_minmax finite_sets) (P_1 skolem-const-decl "partition[real](lb(X!1), ub(X!1))" Riemann_integ_interval_approx nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (width_TCC3 subtype-tcc nil integral_def analysis) (PP skolem-const-decl "partition[real](lb(X!1), ub(X!1))" Riemann_integ_interval_approx nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (fdx_73 skolem-const-decl "posint" Riemann_integ_interval_approx nil) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (div_cancel2 formula-decl nil real_props nil) (posint nonempty-type-eq-decl nil integers nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_minus_real_is_real application-judgement "real" reals nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (width_eq_part formula-decl nil integral_def analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) SHOSTAK)) (Mult_r2i_dist 0 (Mult_r2i_dist-1 nil 3653179816 ("" (grind) nil nil) ((> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) ([\|\|] const-decl "Interval" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Ge const-decl "bool" interval interval_arith) (pXp const-decl "Interval" interval interval_arith) (Le const-decl "bool" interval interval_arith) (pXm const-decl "Interval" interval interval_arith) (Neg const-decl "Interval" interval interval_arith) (nXp const-decl "Interval" interval interval_arith) (nXm const-decl "Interval" interval interval_arith) (mXp const-decl "Interval" interval interval_arith) (Mult const-decl "Interval" interval interval_arith)) SHOSTAK)) (integ_r2i_bound 0 (integ_r2i_bound-1 nil 3653179896 ("" (skosimp*) (("" (lemma "integral_bound[real]") (("1" (inst?) (("1" (expand "##") (("1" (musimp) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand (quote connected?) (quote 1)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (integral_bound formula-decl nil integral_prep analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis) (bool nonempty-type-eq-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (|##| const-decl "bool" interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil)) SHOSTAK)) (simple_one 0 (simple_one-1 nil 3656535644 ("" (skosimp*) (("" (expand "##") (("" (typepred "x!1") (("" (ground) nil nil)) nil)) nil)) nil) ((|##| const-decl "bool" interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (AND const-decl "[bool, bool -> bool]" booleans nil) (closed_interval type-eq-decl nil intervals_real reals)) SHOSTAK)) (integ_r2i_bound₂ 0 (integ_r2i_bound₂-1 nil 3885346357 ("" (lemma "integ_r2i_bound") (("" (skosimp*) (("" (inst? -1) (("" (inst -1 " M₀!1" "m₀!1") (("" (lemma "Mult_r2i_dist") (("" (inst -1 "[|m₀!1, M₀!1|]" "ub(X!1) - lb(X!1)") (("1" (case "[|m₀!1 * (ub(X!1) - lb(X!1)), M₀!1 * (ub(X!1) - lb(X!1))|]= Mult([|lb([|m₀!1, M₀!1|]), ub([|m₀!1, M₀!1|])|], [|ub(X!1) - lb(X!1)|])") (("1" (assert) (("1" (expand "##") (("1" (assert) (("1" (typepred "X!1") (("1" (hide-all-but (-1 1 -5)) (("1" (split) (("1" (assert) (("1" (case "lb([|m₀!1, M₀!1|])=m₀!1") (("1" (case "ub([|m₀!1, M₀!1|])=M₀!1") (("1" (rewrite -1) (("1" (expand (quote StrictInterval?) (quote -2)) (("1" (propax) nil nil)) nil)) nil) ("2" (expand (quote StrictInterval?) (quote -2)) (("2" (propax) nil nil)) nil)) nil) ("2" (expand (quote StrictInterval?) (quote -1)) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "X!1") (("2" (expand (quote StrictInterval?) (quote -1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) ([\|\|] const-decl "Interval" interval interval_arith) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (NOT const-decl "[bool -> bool]" booleans nil) (|##| const-decl "bool" interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (Mult const-decl "Interval" interval interval_arith) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (Mult_r2i_dist formula-decl nil Riemann_integ_interval_approx nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (integ_r2i_bound formula-decl nil Riemann_integ_interval_approx nil)) shostak)) (Integ_Inclusion_fun_TCC1 0 (Integ_Inclusion_fun_TCC1-1 nil 3656262906 ("" (inst 1 "cos") (("" (skosimp*) (("" (expand (quote integ_inclus_fun?) (quote 1)) (("" (lemma "F_integrable_cos") (("" (inst? -1) (("" (split) (("1" (expand "Integrable?") (("1" (typepred "X!1") (("1" (assert) (("1" (expand "StrictInterval?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "Cos_inclusion") (("2" (inst? -1) (("2" (lemma "Cos_inclusion") (("2" (inst?) (("2" (inst 1 "Cos") (("2" (inst?) (("2" (ground) (("2" (skosimp*) (("2" (inst -1 "x!1") (("2" (ground) (("2" (typepred "x!1") (("2" (ground) (("2" (expand "##") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((F_integrable_cos formula-decl nil Riemann_integ_interval_approx nil) (NOT const-decl "[bool -> bool]" booleans nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Integrable? const-decl "bool" integral_def analysis) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (Proper_Cos application-judgement "ProperInterval" interval_trig interval_arith) (Cos_Fundamental application-judgement "(Fundamental?(PreTrue))" interval_expr_trig interval_arith) (Cos_Inclusion application-judgement "(Inclusion?(PreTrue, cos))" interval_expr_trig interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (|##| const-decl "bool" interval interval_arith) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (Cos const-decl "Interval" interval_trig interval_arith) (Cos_inclusion formula-decl nil interval_trig interval_arith) (cos const-decl "real" sincos_def trig_fnd) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (Integ_Inclusion_fun existence "" "{f: [reals.real -> reals.real] | FORALL (X: interval.StrictInterval, n: naturalnumbers.nat): Riemann_integ_interval_approx.integ_inclus_fun?(X, f, n)}"))) (Integ_inclus_f 0 (Integ_inclus_f-1 nil 3656413011 ("" (skosimp*) (("" (expand "F_Bound?") (("" (lemma "integ_r2i_bound₂") (("" (inst? -1) (("" (musimp) (("" (hide-all-but (-2 1)) (("" (skosimp*) (("" (case "[|lb(F!1(n!1)(X!1)), ub(F!1(n!1)(X!1))|]= F!1(n!1)(X!1)") (("1" (assert) (("1" (rewrite -1) (("1" (inst -1 "x!1") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) (("2" (expand "[||]") (("2" (ground) (("2" (musimp) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((F_Bound? const-decl "bool" Riemann_integ_interval_approx nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (integ_r2i_bound₂ formula-decl nil Riemann_integ_interval_approx nil)) SHOSTAK)) (Integ_inclusion_f 0 (Integ_inclusion_f-1 nil 3656544923 ("" (lemma "Integ_inclus_f") (("" (skosimp*) (("" (inst? -1) (("" (assert) (("" (case "F!1(n!1)(X!1)= [|lb(F!1(n!1)(X!1)), ub(F!1(n!1)(X!1))|]") (("1" (rewrite -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "[||]") (("2" (musimp) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) ([\|\|] const-decl "Interval" interval interval_arith) (= const-decl "[T, T -> boolean]" equalities nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Integ_inclus_f formula-decl nil Riemann_integ_interval_approx nil)) SHOSTAK)) (Integ_inclusion₂_f_TCC1 0 (Integ_inclusion₂_f_TCC1-1 nil 3881820517 ("" (skosimp*) (("" (expand (quote strictinterval?) (quote 1)) (("" (ground) (("" (musimp) (("" (ground) (("" (case "P!1`length > 1") (("1" (use "parts_order") (("1" (musimp) (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((StrictInterval? const-decl "bool" interval interval_arith) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (StrictInterval type-eq-decl nil interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (subrange type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (parts_order formula-decl nil integral_def analysis) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Integ_inclusion₂_f subtype "[|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]" "StrictInterval"))) (Integ_inclusion₂_f 0 (Integ_inclusion₂_f-1 nil 3881821232 ("" (lemma "Mult_inclusion") (("" (skosimp*) (("" (ground) (("" (skosimp*) (("" (case "g!1(x!1) * (ub(X!1) - lb(X!1)) / 2 ^ m!1 = (ub(X!1) * g!1(x!1) - lb(X!1) * g!1(x!1)) / 2 ^ m!1") (("1" (case-replace "  (ub(X!1) * g!1(x!1) - lb(X!1) * g!1(x!1)) / 2 ^ m!1 = g!1(x!1) * (ub(X!1) - lb(X!1)) / 2 ^ m!1 ") (("1" (inst -2 "Eval!1(n!1)([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|]) " " [|(ub(X!1) - lb(X!1)) / 2 ^ m!1|]" "g!1(x!1)" "(ub(X!1) - lb(X!1)) / 2 ^ m!1") (("1" (case "g!1(x!1) ## Eval!1(n!1)([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|]) AND (ub(X!1) - lb(X!1)) / 2 ^ m!1 ## [|(ub(X!1) - lb(X!1)) / 2 ^ m!1|]") (("1" (assert) nil nil) ("2" (typepred "Eval!1") (("2" (expand "F_Bound?") (("2" (inst -1 "x!1") (("1" (assert) (("1" (ground) (("1" (expand "##" 1) (("1" (musimp) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (hide-all-but (1 -4)) (("2" (expand "##") (("2" (case "eq_partition[real](lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1)=lb([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|])") (("1" (rewrite -1) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field) nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (|##| const-decl "bool" interval interval_arith) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (lb_r2i formula-decl nil interval interval_arith) (ub_r2i formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (x!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) ([\|\|] const-decl "Interval" interval interval_arith) (subrange type-eq-decl nil integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (finite_sequence type-eq-decl nil finite_sequences nil) (above nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) ([\|\|] const-decl "Interval" interval interval_arith) (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint nonempty-type-eq-decl nil integers nil) (div_cancel2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (Mult_inclusion formula-decl nil interval interval_arith)) SHOSTAK)) (Integ_inclusion₃_f_TCC1 0 (Integ_inclusion₃_f_TCC1-1 nil 3881820517 ("" (lemma "parts_order") (("" (skosimp*) (("" (inst -1 "lb(X!1)" "ub(X!1)" "eq_partition(lb(X!1),ub(X!1), 2^m!1+1)" "i!1-1" "i!1") (("1" (ground) nil nil) ("2" (expand "eq_partition" 1) (("2" (typepred "i!1") (("2" (field 1) nil nil)) nil)) nil) ("3" (expand "eq_partition" 1) (("3" (typepred "i!1") (("3" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil integers nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (eq_partition const-decl "partition(a, b)" integral_def analysis) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (parts_order formula-decl nil integral_def analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (Integ_inclusion₃_f subtype "ub([|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|])" "{x: real | reals.<(lb([|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]), x)}"))) (Integ_inclusion₃_f_TCC2 0 (Integ_inclusion₃_f_TCC2-1 nil 3881820517 ("" (skosimp*) (("" (typepred "g!1") (("" (inst -1 "             ([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                      (P!1)(i!1 - 1),
                  finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                      (P!1)(i!1)|])" "1") (("1" (expand "integ_inclus_fun?") (("1" (assert) nil nil)) nil) ("2" (expand "StrictInterval?") (("2" (ground) (("2" (lemma "parts_order") (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (parts_order formula-decl nil integral_def analysis) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) ([\|\|] const-decl "Interval" interval interval_arith) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (P!1 skolem-const-decl "partition[real](lb(X!1), ub(X!1))" Riemann_integ_interval_approx nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil integers nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Integ_inclusion₃_f subtype "Riemann_integ_interval_approx.g" "{f | integral_def[real].integrable?(lb([|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]), ub([|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]), Riemann_integ_interval_approx.f)}"))) (Integ_inclusion₃_f 0 (Integ_inclusion₃_f-1 nil 3881821295 ("" (skosimp*) (("" (ground) (("" (lemma "Integ_inclusion_f") (("" (skosimp*) (("" (ground) (("" (inst? -1) (("1" (inst -1 "g!1") (("1" (case " integrable?(lb([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|]),
                                  ub([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|]), g!1)
                       AND F_Bound?([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|], g!1, n!1, Eval!1)") (("1" (ground) (("1" (assert) (("1" (case " [|(ub(X!1) - lb(X!1)) / 2 ^ m!1|]=[|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1) - eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1)|] ") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (lemma " eq_part_width") (("2" (inst? -1) (("2" (ground) (("2" (inst -1 "i!1") (("2" (case "StrictInterval?([|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|])") (("1" (ground) nil nil) ("2" (typepred "X!1") (("2" (hide-all-but -2 2) (("2" (lemma "parts_order") (("2" (expand "StrictInterval?") (("2" (ground) (("2" (inst? -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (musimp) (("1" (typepred "Eval!1") (("1" (ground) nil nil)) nil) ("2" (typepred "g!1") (("2" (inst -1 "[|eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1 - 1), eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(i!1)|]" "1") (("1" (expand (quote integ_inclus_fun?) (quote -1)) (("1" (musimp) nil nil)) nil) ("2" (lemma "parts_order") (("2" (expand "StrictInterval?") (("2" (inst? -1) (("2" (inst -1 "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (ground) (("3" (lemma "parts_order") (("3" (expand "StrictInterval?") (("3" (ground) (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1) (("4" (lemma "parts_order") (("4" (ground) (("4" (inst?) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "StrictInterval?") (("2" (lemma "parts_order") (("2" (inst?) (("2" (inst -1 "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_minus_real_is_real application-judgement "real" reals nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (StrictInterval type-eq-decl nil interval interval_arith) (eq_partition const-decl "partition(a, b)" integral_def analysis) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) ([\|\|] const-decl "Interval" interval interval_arith) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (StrictInterval? const-decl "bool" interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil) (finseq type-eq-decl nil finite_sequences nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integrable? const-decl "bool" integral_def analysis) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (parts_order formula-decl nil integral_def analysis) (eq_part_width formula-decl nil Riemann_integ_interval_approx nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) ([\|\|] const-decl "Interval" interval interval_arith) (real_div_nzreal_is_real application-judgement "real" reals nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (int_minus_int_is_int application-judgement "int" integers nil) (Integ_inclusion_f formula-decl nil Riemann_integ_interval_approx nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) SHOSTAK)) (simple_two_TCC1 0 (simple_two_TCC1-1 nil 3657133213 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (simple_two subtype "0" "below[length(P)]"))) (simple_two_TCC2 0 (simple_two_TCC2-1 nil 3657133213 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (simple_two subtype "exponentiation.^(2, Riemann_integ_interval_approx.m)" "below[length(P)]"))) (simple_two 0 (simple_two-1 nil 3657133213 ("" (skosimp*) (("" (assert) (("" (expand "eq_partition" 1) (("" (field) nil nil)) nil)) nil)) nil) ((posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) SHOSTAK)) (sub_integ_TCC1 0 (sub_integ_TCC1-1 nil 3657147024 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sub_integ subtype "(number_fields.+)(exponentiation.^(2, Riemann_integ_interval_approx.m), 1)" "above(1)"))) (sub_integ_TCC2 0 (sub_integ_TCC2-1 nil 3657147024 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sub_integ subtype "(number_fields.-)(Riemann_integ_interval_approx.i, 1)" "below[length(P)]"))) (sub_integ_TCC3 0 (sub_integ_TCC3-1 nil 3657147024 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil subrange_type nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sub_integ subtype "Riemann_integ_interval_approx.i" "below[length(P)]"))) (sub_integ_TCC4 0 (sub_integ_TCC4-1 nil 3657147024 ("" (skosimp*) (("" (lemma "parts_order") (("" (inst -1 " a!1" "b!1" "eq_partition(a!1,b!1,2^m!1+1)" "i!1-1" "i!1") (("1" (ground) nil nil) ("2" (expand "eq_partition") (("2" (field 1) nil nil)) nil) ("3" (expand "eq_partition") (("3" (field 1) nil nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (parts_order formula-decl nil integral_def analysis) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m!1 skolem-const-decl "nat" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil subrange_type nil) (i!1 skolem-const-decl "subrange[1, 2 ^ m!1]" Riemann_integ_interval_approx nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (eq_partition const-decl "partition(a, b)" integral_def analysis) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (b!1 skolem-const-decl "{x: real | a!1 < x}" Riemann_integ_interval_approx nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sub_integ subtype "ub([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|])" "{x: real | reals.<(lb([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]), x)}"))) (sub_integ_TCC5 0 (sub_integ_TCC5-1 nil 3657147024 ("" (skosimp*) (("" (typepred "g!1") (("" (inst -1 "([|finseq_appl[closed_interval[real](a!1, b!1)](P!1)(i!1 - 1),
                finseq_appl[closed_interval[real](a!1, b!1)](P!1)(i!1)|])" "1") (("1" (expand "integ_inclus_fun?") (("1" (ground) nil nil)) nil) ("2" (expand "StrictInterval?") (("2" (lemma "parts_order") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,2^m!1+1)" "i!1-1" "i!1") (("1" (ground) nil nil) ("2" (expand "eq_partition") (("2" (typepred "i!1") (("2" (field 1) nil nil)) nil)) nil) ("3" (expand "eq_partition") (("3" (typepred "i!1") (("3" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (above nonempty-type-eq-decl nil integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (parts_order formula-decl nil integral_def analysis) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) ([\|\|] const-decl "Interval" interval interval_arith) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (< const-decl "bool" reals nil) (b!1 skolem-const-decl "{x: real | a!1 < x}" Riemann_integ_interval_approx nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (P!1 skolem-const-decl "partition[real](a!1, b!1)" Riemann_integ_interval_approx nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (m!1 skolem-const-decl "nat" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil subrange_type nil) (i!1 skolem-const-decl "subrange[1, 2 ^ m!1]" Riemann_integ_interval_approx nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sub_integ subtype "Riemann_integ_interval_approx.g" "{f | integral_def[real].integrable?(lb([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]), ub([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]), Riemann_integ_interval_approx.f)}"))) (sum_n_split_TCC1 0 (sum_n_split_TCC1-1 nil 3657147024 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sum_n_split subtype "0" "below[length(P)]"))) (sum_n_split_TCC2 0 (sum_n_split_TCC2-1 nil 3657147024 ("" (termination-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sum_n_split subtype "1" "below[length(P)]"))) (sum_n_split_TCC3 0 (sum_n_split_TCC3-1 nil 3657164589 ("" (lemma "parts_order") (("" (skosimp*) (("" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,2^m!1+1)" "0" "1") (("1" (ground) nil nil) ("2" (expand "eq_partition") (("2" (field 1) nil nil)) nil) ("3" (ground) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (eq_partition const-decl "partition(a, b)" integral_def analysis) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (b!1 skolem-const-decl "{x: real | a!1 < x}" Riemann_integ_interval_approx nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (m!1 skolem-const-decl "nat" Riemann_integ_interval_approx nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (parts_order formula-decl nil integral_def analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (sum_n_split subtype "ub([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(0), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(1)|])" "{x: real | reals.<(lb([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(0), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(1)|]), x)}"))) (sum_n_split_TCC4 0 (sum_n_split_TCC4-1 nil 3657164589 ("" (skosimp*) (("" (typepred "g!1") (("" (inst -1 "[|finseq_appl[closed_interval[real](a!1, b!1)](P!1)(0),
                finseq_appl[closed_interval[real](a!1, b!1)](P!1)(1)|]" "1") (("1" (expand "integ_inclus_fun?") (("1" (ground) nil nil)) nil) ("2" (ground) (("2" (expand "StrictInterval?") (("2" (ground) (("2" (lemma "parts_order") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,2^m!1+1)" "0" "1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (above nonempty-type-eq-decl nil integers nil) (parts_order formula-decl nil integral_def analysis) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) ([\|\|] const-decl "Interval" interval interval_arith) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (< const-decl "bool" reals nil) (b!1 skolem-const-decl "{x: real | a!1 < x}" Riemann_integ_interval_approx nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (P!1 skolem-const-decl "partition[real](a!1, b!1)" Riemann_integ_interval_approx nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sum_n_split subtype "Riemann_integ_interval_approx.g" "{f | integral_def[real].integrable?(lb([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(0), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(1)|]), ub([|finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(0), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(1)|]), Riemann_integ_interval_approx.f)}"))) (sum_n_split_TCC5 0 (sum_n_split_TCC5-1 nil 3657164589 ("" (skosimp*) (("" (typepred "i!1") (("" (field 1) nil nil)) nil)) nil) ((subrange type-eq-decl nil subrange_type nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sum_n_split subtype "(number_fields.-)(Riemann_integ_interval_approx.i, 1)" "subrange[1, 2 ^ m]"))) (sum_n_split_TCC6 0 (sum_n_split_TCC6-1 nil 3657164589 ("" (termination-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sum_n_split termination "Riemann_integ_interval_approx.sum_n_split(Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b, Riemann_integ_interval_approx.m, (number_fields.-)(Riemann_integ_interval_approx.i, 1), Riemann_integ_interval_approx.g)" "nil"))) (general_integ_split_TCC1 0 (general_integ_split_TCC1-1 nil 3657179198 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (general_integ_split subtype "0" "below[length(P)]"))) (general_integ_split_TCC2 0 (general_integ_split_TCC2-1 nil 3657179198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (subrange type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (general_integ_split subtype "Riemann_integ_interval_approx.i" "below[length(P)]"))) (general_integ_split_TCC3 0 (general_integ_split_TCC3-1 nil 3657179198 ("" (skosimp*) (("" (lemma "parts_order") (("" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,2^m!1+1)" "0" "i!1") (("1" (ground) nil nil) ("2" (typepred "i!1") (("2" (expand "eq_partition") (("2" (field 1) nil nil)) nil)) nil) ("3" (field 1) nil nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (parts_order formula-decl nil integral_def analysis) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (subrange type-eq-decl nil integers nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (eq_partition const-decl "partition(a, b)" integral_def analysis) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (b!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (general_integ_split subtype "finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)" "{x: real | reals.<(finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(0), x)}"))) (general_integ_split_TCC4 0 (general_integ_split_TCC4-1 nil 3657179198 ("" (skosimp*) (("" (typepred "g!1") (("" (ground) (("" (inst -1 "[|P!1`seq(0), P!1`seq(i!1)|]" "1") (("1" (expand "integ_inclus_fun?") (("1" (ground) nil nil)) nil) ("2" (expand "StrictInterval?") (("2" (lemma "parts_order") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,2^m!1+1)" "0" "i!1") (("1" (ground) nil nil) ("2" (typepred "i!1") (("2" (expand "eq_partition") (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (P!1 skolem-const-decl "partition[real](a!1, b!1)" Riemann_integ_interval_approx nil) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (b!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) ([\|\|] const-decl "Interval" interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (parts_order formula-decl nil integral_def analysis) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (above nonempty-type-eq-decl nil integers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (general_integ_split subtype "Riemann_integ_interval_approx.g" "{f | integral_def[real].integrable?(finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(0), finite_sequences[closed_interval[real](Riemann_integ_interval_approx.a, Riemann_integ_interval_approx.b)].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i), Riemann_integ_interval_approx.f)}"))) (general_integ_split 0 (general_integ_split-1 nil 3657179198 ("" (assert) (("" (skolem!) (("" (flatten) (("" (induct "i") (("1" (expand "sum_n_split") (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (name-replace "P_1" "eq_partition") (("2" (case " integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0),
                                 P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1), g!1)= integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0), P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1), g!1)+ integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1), P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1), g!1) ") (("1" (rewrite -3) (("1" (case "sum_n_split(a!1, b!1, m!1, k!1 + 1, g!1)= sum_n_split(a!1, b!1, m!1, k!1, g!1) +integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1), P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1), g!1)") (("1" (assert) nil nil) ("2" (case " integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0),
                                         P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1), g!1)=sum_n_split(a!1, b!1, m!1, k!1 + 1, g!1)") (("1" (propax) nil nil) ("2" (hide 1) (("2" (both-sides - "integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1),P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1), g!1)" -1) (("1" (field -1) (("1" (hide 2) (("1" (case-replace " sum_n_split(a!1, b!1, m!1, k!1, g!1)=integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0), P_1(a!1,b!1, 1 + 2 ^ m!1)`seq(1 + k!1), g!1) -integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1),P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(1 + k!1), g!1) ") (("1" (field 1) (("1" (expand (quote sum_n_split) (quote 1)) (("1" (case-replace " sum_n_split(a!1, b!1, m!1, k!1, g!1)=integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0), P_1(a!1,b!1, 1 + 2 ^ m!1)`seq(1 + k!1), g!1) -integral(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1),P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(1 + k!1), g!1) ") (("1" (field 1) (("1" (field 1) (("1" (assert) (("1" (expand (quote p_1) (quote 1)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (iff 1) (("2" (split 1) (("1" (flatten) (("1" (field 1) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "integral_split[real]") (("1" (inst -1 "P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0)" "P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1)" "P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1)" "g!1") (("1" (case "P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0) <
                                 P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1)
                                 AND
                                 P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1) <
                                  P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1)
                                  AND
                                  integrable?(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(0),
                                              P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1), g!1)
                                   AND
                                   integrable?(P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1),
                                               P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1 + 1), g!1)") (("1" (assert) nil nil) ("2" (lemma "parts_order") (("2" (inst?) (("2" (assert) (("2" (lemma "parts_order") (("2" (expand "P_1") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1, b!1, 1 + 2 ^ m!1)" "k!1" "k!1+1") (("1" (assert) (("1" (hide-all-but 1) (("1" (typepred "g!1") (("1" (inst -1 "[|eq_partition(a!1,b!1,1+2^m!1)`seq(0),eq_partition(a!1,b!1,1+2^m!1)`seq(k!1)|]" "1") (("1" (expand (quote integ_inclus_fun?) (quote -1)) (("1" (assert) (("1" (ground) (("1" (hide -2) (("1" (typepred "g!1") (("1" (inst -1 "[|eq_partition(a!1,b!1,1+2^m!1)`seq(k!1),eq_partition(a!1,b!1,1+2^m!1)`seq(1+k!1)|]" "1") (("1" (expand (quote integ_inclus_fun?) (quote -1)) (("1" (assert) nil nil)) nil) ("2" (expand (quote strictinterval?) (quote 1)) (("2" (lemma "parts_order") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,1+2^m!1)" "k!1" "k!1+1") (("1" (assert) nil nil) ("2" (expand (quote eq_partition) (quote 1)) (("2" (typepred "k!1") (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand (quote eq_partition) (quote 1)) (("3" (field 1) nil nil)) nil) ("4" (expand (quote eq_partition) (quote 1)) (("4" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand (quote strictinterval?) (quote 1)) (("2" (lemma "parts_order") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,1+2^m!1)" "0" "k!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand (quote eq_partition) (quote 1)) (("3" (typepred "k!1") (("3" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand (quote eq_partition) (quote 1)) (("2" (field 1) nil nil)) nil) ("3" (expand (quote eq_partition) (quote 1)) (("3" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil) ("3" (typepred "g!1") (("3" (inst -1 "[|P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(k!1),P_1(a!1, b!1, 1 + 2 ^ m!1)`seq(1+k!1) |]" "1") (("1" (expand "integ_inclus_fun?") (("1" (assert) nil nil)) nil) ("2" (lemma "parts_order") (("2" (expand (quote strictinterval?) (quote 1)) (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,1+2^m!1)" "k!1" "1+k!1") (("1" (assert) (("1" (ground) (("1" (expand "P_1") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand (quote eq_partition) (quote 1)) (("2" (field 1) nil nil)) nil) ("3" (expand (quote eq_partition) (quote 1)) (("3" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "parts_order") (("4" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,1+2^m!1)" "k!1" "1+k!1") (("1" (expand "P_1") (("1" (assert) nil nil)) nil) ("2" (expand (quote eq_partition) (quote 1)) (("2" (field 1) nil nil)) nil) ("3" (expand (quote eq_partition) (quote 1)) (("3" (field 1) nil nil)) nil)) nil)) nil) ("5" (expand (quote p_1) (quote 1)) (("5" (expand (quote eq_partition) (quote 1)) (("5" (field 1) nil nil)) nil)) nil) ("6" (expand (quote p_1) (quote 1)) (("6" (expand (quote eq_partition) (quote 1)) (("6" (field 1) nil nil)) nil)) nil) ("7" (expand (quote p_1) (quote 1)) (("7" (expand (quote eq_partition) (quote 1)) (("7" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "g!1") (("3" (skosimp*) (("3" (inst -1 "[|eq_partition[real](a!1, b!1, 1 + 2 ^ m!1)`seq(0),eq_partition[real](a!1, b!1, 1 + 2 ^ m!1)`seq(i!2)|]" "1") (("1" (expand "integ_inclus_fun?") (("1" (assert) nil nil)) nil) ("2" (expand "StrictInterval?") (("2" (lemma "parts_order") (("2" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,1+2^m!1)" "0" "i!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (lemma "parts_order") (("4" (inst -1 "a!1" "b!1" "eq_partition(a!1,b!1,1+2^m!1)" "0" "i!2") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (typepred "i!2") (("5" (expand "eq_partition") (("5" (field 1) nil nil)) nil)) nil)) nil) ("6" (assert) nil nil) ("7" (expand (quote eq_partition) (quote 1)) (("7" (propax) nil nil)) nil) ("8" (field 1) nil nil)) nil)) nil)) nil)) nil) ((b!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (a!1 skolem-const-decl "real" Riemann_integ_interval_approx nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (g!1 skolem-const-decl "Integ_Inclusion_fun" Riemann_integ_interval_approx nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (integrable? const-decl "bool" integral_def analysis) (pred type-eq-decl nil defined_types nil) (integral? const-decl "bool" integral_def analysis) (integral const-decl "{S: real | integral?(a, b, ff, S)}" integral_def analysis) (subrange type-eq-decl nil subrange_type nil) (sum_n_split def-decl "real" Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real nonempty-type-from-decl nil reals nil) (subrange_induction formula-decl nil subrange_inductions nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (both_sides_plus_lt2 formula-decl nil real_props nil) (integral_split formula-decl nil integral_split analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis) (k!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) ([\|\|] const-decl "Interval" interval interval_arith) (real_times_real_is_real application-judgement "real" reals nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_plus_lt1 formula-decl nil real_props nil) (parts_order formula-decl nil integral_def analysis) (real_minus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (P_1 skolem-const-decl "[d: [a: real, {x: real | a < x}, above(1)] -> partition[real](d`1, d`2)]" Riemann_integ_interval_approx nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_plus_real_is_real application-judgement "real" reals nil) (i!2 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) SHOSTAK)) (general_integ_split₁_TCC1 0 (general_integ_split₁_TCC1-1 nil 3881820517 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (|##| const-decl "bool" interval interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (width const-decl "posreal" integral_def analysis) (integral? const-decl "bool" integral_def analysis) (integrable? const-decl "bool" integral_def analysis) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (general_integ_split₁ subtype "Riemann_integ_interval_approx.g" "{f | integral_def[real].integrable?(lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X), Riemann_integ_interval_approx.f)}"))) (general_integ_split₁_TCC2 0 (general_integ_split₁_TCC2-1 nil 3881820517 ("" (induct "m") (("1" (typepred "m!1") (("1" (propax) nil nil)) nil) ("2" (typepred "m!1") (("2" (propax) nil nil)) nil) ("3" (ground) nil nil) ("4" (skosimp*) (("4" (ground) (("1" (field 1) (("1" (typepred "j!1") (("1" (field 1) (("1" (case " 2^(1+j!1)= 2*2^(j!1)") (("1" (rewrite -1) (("1" (lazy-grind) nil nil)) nil) ("2" (lazy-grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lazy-grind) nil nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (expt_x0 formula-decl nil exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (general_integ_split₁ subtype "exponentiation.^(2, Riemann_integ_interval_approx.m)" "subrange[1, 2 ^ m]"))) (general_integ_split₁ 0 (general_integ_split₁-1 nil 3885354789 ("" (lemma "general_integ_split") (("" (skolem!) (("" (inst -1 "lb(X!1)" "ub(X!1)" "g!1" " m!1") (("" (assert) (("" (musimp) (("1" (inst -1 "2^m!1") (("1" (lemma "simple_two") (("1" (inst?) (("1" (case "eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(0)= lb(X!1)") (("1" (case "eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(2^m!1)= ub(X!1)") (("1" (case " ub(X!1)=eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(2^m!1)") (("1" (case " lb(X!1)=eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)`seq(0)") (("1" (hide -3) (("1" (hide -3) (("1" (rewrite -1) (("1" (rewrite -2) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (typepred "X!1") (("2" (expand "StrictInterval?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (posint_exp application-judgement "posint" exponentiation nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (eq_partition const-decl "partition(a, b)" integral_def analysis) (simple_two formula-decl nil Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (general_integ_split formula-decl nil Riemann_integ_interval_approx nil)) shostak)) (trivial 0 (trivial-1 nil 3657256210 ("" (skosimp*) (("" (lazy-grind) nil nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) SHOSTAK)) (Fundamental_Riemann_inclusion₁_TCC1 0 (Fundamental_Riemann_inclusion₁_TCC1-1 nil 3881820517 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Fundamental_Riemann_inclusion₁ subtype "(number_fields.-)(Riemann_integ_interval_approx.i, 1)" "below[length(P)]"))) (Fundamental_Riemann_inclusion₁_TCC2 0 (Fundamental_Riemann_inclusion₁_TCC2-1 nil 3881820517 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (subrange type-eq-decl nil integers nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Fundamental_Riemann_inclusion₁ subtype "Riemann_integ_interval_approx.i" "below[length(P)]"))) (Fundamental_Riemann_inclusion₁_TCC3 0 (Fundamental_Riemann_inclusion₁_TCC3-1 nil 3881820517 ("" (skosimp*) (("" (expand "StrictInterval?") (("" (lemma "parts_order") (("" (inst -1 "lb(X!1)" "ub(X!1)" "eq_partition(lb(X!1),ub(X!1),2^m!1+1)" "i!1-1" "i!1") (("1" (ground) (("1" (ground) (("1" (rewrite -2) (("1" (lazy-grind) nil nil)) nil)) nil)) nil) ("2" (expand "eq_partition") (("2" (typepred "i!1") (("2" (field 1) nil nil)) nil)) nil) ("3" (expand "eq_partition") (("3" (typepred "i!1") (("3" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((StrictInterval? const-decl "bool" interval interval_arith) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (StrictInterval type-eq-decl nil interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (eq_partition const-decl "partition(a, b)" integral_def analysis) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (i!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil integers nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (parts_order formula-decl nil integral_def analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Fundamental_Riemann_inclusion₁ subtype "[|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]" "StrictInterval"))) (Fundamental_Riemann_inclusion₁ 0 (Fundamental_Riemann_inclusion₁-1 nil 3885354496 ("" (skosimp*) (("" (assert) (("" (induct "i") (("1" (lemma "Integ_inclusion₃_f") (("1" (skosimp*) (("1" (expand "sum_n_split") (("1" (expand "RiemannSum_R2I") (("1" (expand "R") (("1" (simplify) (("1" (assert) (("1" (assert) (("1" (inst?) (("1" (hide-all-but 1) (("1" (use "expt_ge1") (("1" (assert) (("1" (lemma "Integ_inclusion₃_f") (("1" (simplify) (("1" (inst?) (("1" (inst -1 "g!1" "n!1" "lb(X!1)") (("1" (assert) (("1" (inst -1 "1") (("1" (musimp) (("1" (inst?) (("1" (ground) nil nil) ("2" (typepred "Eval!1") (("2" (inst -1 "1") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "##") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "sum_n_split" 1) (("2" (expand "RiemannSum_R2I" 1) (("2" (case "integral(lb([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))](eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(k!1),finseq_appl[closed_interval[real](lb(X!1), ub(X!1))](eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1)) (1 + k!1)|]), ub([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))](eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(k!1),finseq_appl[closed_interval[real](lb(X!1), ub(X!1))](eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(1 + k!1)|]),g!1) ## R(lb(X!1), ub(X!1), m!1, 1 + k!1, n!1, Eval!1)") (("1" (lemma "Add_inclusion") (("1" (inst -1 "R(lb(X!1), ub(X!1), m!1, 1 + k!1, n!1, Eval!1)" "RiemannSum_R2I(lb(X!1), ub(X!1), m!1, k!1, n!1, Eval!1, R)" "integral(lb
                             ([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(k!1),
                                finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))
                                    (1 + k!1)|]),
                           ub
                             ([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(k!1),
                                finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))
                                    (1 + k!1)|]),
                           g!1)" "sum_n_split(lb(X!1), ub(X!1), m!1, k!1, g!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "R") (("2" (lemma "Integ_inclusion₃_f") (("2" (inst?) (("2" (inst -1 "g!1" "n!1" "lb([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                                     (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))
                                     (k!1),
                                 finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                                     (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))
                                     (1 + k!1)|])") (("2" (assert) (("2" (inst -1 "k!1+1") (("1" (ground) (("1" (inst?) (("1" (typepred "Eval!1") (("1" (inst -1 "k!1+1") (("1" (ground) nil nil) ("2" (lemma "trivial") (("2" (inst? -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "##") (("2" (ground) (("2" (lemma "parts_order") (("2" (lemma "parts_order") (("2" (inst -1 "lb(X!1)" "ub(X!1)" "eq_partition(lb(X!1),ub(X!1),2^m!1+1)" "k!1" "k!1+1") (("1" (ground) nil nil) ("2" (typepred "k!1") (("2" (expand "eq_partition") (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) (("2" (ground) (("2" (hide 2) (("2" (hide -2) (("2" (field) (("2" (lemma "trivial") (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "X!1") (("3" (expand "StrictInterval?") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (expand "StrictInterval?") (("4" (lemma "parts_order") (("4" (inst? -1) (("4" (expand "[||]") (("4" (inst? -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep :preds? t) (("5" (expand "eq_partition") (("5" (field) nil nil)) nil)) nil)) nil) ("6" (typepred "X!1") (("6" (skosimp*) (("6" (expand "StrictInterval?") (("6" (propax) nil nil)) nil)) nil)) nil) ("7" (skeep :preds? t) (("7" (expand "eq_partition") (("7" (field) nil nil)) nil)) nil) ("8" (use "expt_ge1") nil nil)) nil)) nil)) nil) ((posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (integrable? const-decl "bool" integral_def analysis) (integral? const-decl "bool" integral_def analysis) (integral const-decl "{S: real | integral?(a, b, ff, S)}" integral_def analysis) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (Add_inclusion formula-decl nil interval interval_arith) (trivial formula-decl nil Riemann_integ_interval_approx nil) (int_plus_int_is_int application-judgement "int" integers nil) (Eval!1 skolem-const-decl "{F: [nat -> [Interval -> Interval]] |
   FORALL (i: subrange(1, 2 ^ m!1)):
     F_Bound?([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(i - 1),
                finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(i)|],
              g!1, n!1, F)}" Riemann_integ_interval_approx nil) (parts_order formula-decl nil integral_def analysis) (real_times_real_is_real application-judgement "real" reals nil) (lt_plus_lt1 formula-decl nil real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (k!1 skolem-const-decl "subrange(1, 2 ^ m!1)" Riemann_integ_interval_approx nil) (Integ_inclusion₃_f formula-decl nil Riemann_integ_interval_approx nil) (lb_interval formula-decl nil interval interval_arith) (ub_interval formula-decl nil interval interval_arith) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (expt_ge1 formula-decl nil exponentiation nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (Eval!1 skolem-const-decl "{F: [nat -> [Interval -> Interval]] |
   FORALL (i: subrange(1, 2 ^ m!1)):
     F_Bound?([|finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(i - 1),
                finseq_appl[closed_interval[real](lb(X!1), ub(X!1))]
                    (eq_partition(lb(X!1), ub(X!1), 1 + 2 ^ m!1))(i)|],
              g!1, n!1, F)}" Riemann_integ_interval_approx nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (r2i_Proper application-judgement "ProperInterval" interval interval_arith) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (subrange_induction formula-decl nil subrange_inductions nil) (real nonempty-type-from-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (R const-decl "Interval" Riemann_integ_interval_approx nil) (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx nil) (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil) (sum_n_split def-decl "real" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil subrange_type nil) (|##| const-decl "bool" interval interval_arith) (pred type-eq-decl nil defined_types nil) (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil) (finseq type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (g!1 skolem-const-decl "Integ_Inclusion_fun" Riemann_integ_interval_approx nil) (n!1 skolem-const-decl "nat" Riemann_integ_interval_approx nil) ([\|\|] const-decl "Interval" interval interval_arith) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (m!1 skolem-const-decl "posnat" Riemann_integ_interval_approx nil) (subrange type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (eq_partition const-decl "partition(a, b)" integral_def analysis) (Interval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (X!1 skolem-const-decl "StrictInterval" Riemann_integ_interval_approx nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (Simple_Riemann_Soundness_TCC1 0 (Simple_Riemann_Soundness_TCC1-1 nil 3657509351 ("" (skosimp*) (("" (lemma "parts_order") (("" (ground) (("" (inst?) (("" (ground) (("" (typepred "X!1") (("" (hide-all-but (-1 1)) (("" (expand "StrictInterval?" -1) (("" (lemma "parts_order") (("" (ground) (("" (inst?) (("" (typepred "X!1") (("" (hide-all-but (-1 1)) (("" (expand "StrictInterval?" -1) (("" (lemma "parts_order") (("" (inst?) (("" (inst?) (("" (expand "StrictInterval?") (("" (assert) (("" (lemma "parts_order") (("" (ground) (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (parts_order formula-decl nil integral_def analysis) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (Interval type-eq-decl nil interval interval_arith) (bool nonempty-type-eq-decl nil booleans nil) (StrictInterval? const-decl "bool" interval interval_arith) (StrictInterval type-eq-decl nil interval interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (closed_interval type-eq-decl nil intervals_real reals) (finite_sequence type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (partition type-eq-decl nil integral_def analysis) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (subrange type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ub_interval formula-decl nil interval interval_arith) (lb_interval formula-decl nil interval interval_arith) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Simple_Riemann_Soundness subtype "[|finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)((number_fields.-)(Riemann_integ_interval_approx.i, 1)), finite_sequences[closed_interval[real](lb(Riemann_integ_interval_approx.X), ub(Riemann_integ_interval_approx.X))].finseq_appl(Riemann_integ_interval_approx.P)(Riemann_integ_interval_approx.i)|]" "StrictInterval"))) (Simple_Riemann_Soundness 0 (Simple_Riemann_Soundness-1 nil 3657268800 ("" (skosimp*) (("" (assert) (("" (skosimp*) (("" (lemma "Fundamental_Riemann_inclusion₁") (("" (inst?) (("" (inst -1 "X!1" "g!1" "n!1") (("" (assert) (("" (inst -1 "2^m!1") (("" (inst -1 "Eval!1") (("" (case "integral(lb(X!1), ub(X!1), g!1) = sum_n_split(lb(X!1), ub(X!1), m!1, 2 ^ m!1, g!1)") (("1" (rewrite -1) nil nil) ("2" (lemma "general_integ_split₁") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Fundamental_Riemann_inclusion₁ formula-decl nil Riemann_integ_interval_approx nil) (Integ_Inclusion_fun nonempty-type-eq-decl nil Riemann_integ_interval_approx nil) (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (StrictInterval type-eq-decl nil interval interval_arith) (StrictInterval? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (subrange type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integrable? const-decl "bool" integral_def analysis) (integral? const-decl "bool" integral_def analysis) (integral const-decl "{S: real | integral?(a, b, ff, S)}" integral_def analysis) (subrange type-eq-decl nil subrange_type nil) (sum_n_split def-decl "real" Riemann_integ_interval_approx nil) (general_integ_split₁ formula-decl nil Riemann_integ_interval_approx nil) (eq_partition const-decl "partition(a, b)" integral_def analysis) (partition type-eq-decl nil integral_def analysis) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (above nonempty-type-eq-decl nil integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (closed_interval type-eq-decl nil intervals_real reals) ([\|\|] const-decl "Interval" interval interval_arith) (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) SHOSTAK)))
