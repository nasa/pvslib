(polynomial_pseudo_divide (pseudo_div_TCC1 0 (pseudo_div_TCC1-1 nil 3582634590 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (pseudo_div subtype "real_defs.max((number_fields.+)((number_fields.-)((number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m), polynomial_pseudo_divide.i), 1), 0)" "naturalnumber"))) (pseudo_div_TCC2 0 (pseudo_div_TCC2-1 nil 3582634590 ("" (subtype-tcc) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "polynomial_pseudo_divide.make_divlisttype((: :), 0, array2list[int].array2list((number_fields.+)(polynomial_pseudo_divide.n, 1))(polynomial_pseudo_divide.g), polynomial_pseudo_divide.n)" "{DT: polynomial_pseudo_divide.DivListType | booleans.OR((booleans.OR(reals.>(polynomial_pseudo_divide.m, polynomial_pseudo_divide.n), booleans.AND(reals.>(polynomial_pseudo_divide.i, (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(1, polynomial_pseudo_divide.n), DT`rdegl = polynomial_pseudo_divide.n)))), booleans.OR((booleans.AND(polynomial_pseudo_divide.m = 0, booleans.AND(list_props[int].length(DT`reml) = 0, DT`rdegl = 0))), (booleans.AND(reals.>(polynomial_pseudo_divide.m, 0), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(polynomial_pseudo_divide.i, polynomial_pseudo_divide.m), list_props[int].length(DT`reml) = (number_fields.+)(1, DT`rdegl))))))}"))) (pseudo_div_TCC3 0 (pseudo_div_TCC3-1 nil 3582634590 ("" (skeep) (("" (assert) (("" (hide 4) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (length def-decl "nat" list_props nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "polynomial_pseudo_divide.make_divlisttype(array2list[int].array2list((number_fields.+)(polynomial_pseudo_divide.n, 1))(polynomial_pseudo_divide.g), polynomial_pseudo_divide.n, (: :), 0)" "{DT: polynomial_pseudo_divide.DivListType | booleans.OR((booleans.OR(reals.>(polynomial_pseudo_divide.m, polynomial_pseudo_divide.n), booleans.AND(reals.>(polynomial_pseudo_divide.i, (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(1, polynomial_pseudo_divide.n), DT`rdegl = polynomial_pseudo_divide.n)))), booleans.OR((booleans.AND(polynomial_pseudo_divide.m = 0, booleans.AND(list_props[int].length(DT`reml) = 0, DT`rdegl = 0))), (booleans.AND(reals.>(polynomial_pseudo_divide.m, 0), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(polynomial_pseudo_divide.i, polynomial_pseudo_divide.m), list_props[int].length(DT`reml) = (number_fields.+)(1, DT`rdegl))))))}"))) (pseudo_div_TCC4 0 (pseudo_div_TCC6-1 nil 3582651046 ("" (skosimp*) (("" (assert) (("" (lift-if) (("" (split -) (("1" (flatten) (("1" (replace -2) (("1" (expand "make_divlisttype") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "v!1(g!1, n!1)(h!1, m!1)(1 + i!1)") (("2" (replaces -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (TRUE const-decl "bool" booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "polynomial_pseudo_divide.ldt`rdegl" "below[length[int](ldt`reml)]"))) (pseudo_div_TCC5 0 (pseudo_div_TCC8-1 nil 3582881577 ("" (subtype-tcc) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "(number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)" "nat"))) (pseudo_div_TCC6 0 (pseudo_div_TCC9-1 nil 3582881577 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (lift-if) (("" (ground) (("1" (expand "make_divlisttype") (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "v(g, n)(h, m)(1 + i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (pseudo_div subtype "polynomial_pseudo_divide.j" "below[length[int](ldt`reml)]"))) (pseudo_div_TCC7 0 (pseudo_div_TCC10-1 nil 3591348813 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (lift-if) (("" (ground) (("1" (expand "make_divlisttype") (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "v(g, n)(h, m)(1 + i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DivListType type-eq-decl nil polynomial_pseudo_divide nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (pseudo_div subtype "polynomial_pseudo_divide.j" "below[length[int](ldt`reml)]"))) (pseudo_div_TCC8 0 (pseudo_div_TCC11-1 nil 3591348813 ("" (subtype-tcc) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "(number_fields.-)(polynomial_pseudo_divide.j, polynomial_pseudo_divide.i)" "nat"))) (pseudo_div_TCC9 0 (pseudo_div_TCC13-1 nil 3755251664 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "(number_fields.-)((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i), 1)" "nat"))) (pseudo_div_TCC10 0 (pseudo_div_TCC10-1 "" 3884449738 ("" (subtype-tcc) nil nil) nil shostak (pseudo_div subtype "polynomial_pseudo_divide.make_divlisttype(list_adt[int].cons(polynomial_pseudo_divide.thisterm, polynomial_pseudo_divide.ldt`quotl), (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m), array2list[int].array2list((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i))(LAMBDA (j: naturalnumbers.nat): IF reals.>(j, (number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i)) THEN 0 ELSIF reals.<(j, polynomial_pseudo_divide.i) THEN number_fields.*(polynomial_pseudo_divide.h(polynomial_pseudo_divide.m), list_props[int].nth(polynomial_pseudo_divide.ldt`reml, j)) ELSE (number_fields.-)(number_fields.*(polynomial_pseudo_divide.h(polynomial_pseudo_divide.m), list_props[int].nth(polynomial_pseudo_divide.ldt`reml, j)), number_fields.*(polynomial_pseudo_divide.thisterm, polynomial_pseudo_divide.h((number_fields.-)(j, polynomial_pseudo_divide.i)))) ENDIF), (number_fields.-)((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i), 1))" "{DT: polynomial_pseudo_divide.DivListType | booleans.OR((booleans.OR(reals.>(polynomial_pseudo_divide.m, polynomial_pseudo_divide.n), booleans.AND(reals.>(polynomial_pseudo_divide.i, (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(1, polynomial_pseudo_divide.n), DT`rdegl = polynomial_pseudo_divide.n)))), booleans.OR((booleans.AND(polynomial_pseudo_divide.m = 0, booleans.AND(list_props[int].length(DT`reml) = 0, DT`rdegl = 0))), (booleans.AND(reals.>(polynomial_pseudo_divide.m, 0), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(polynomial_pseudo_divide.i, polynomial_pseudo_divide.m), list_props[int].length(DT`reml) = (number_fields.+)(1, DT`rdegl))))))}")) (pseudo_div_TCC7-2 "" 3755369808 ("" (skosimp*) (("" (assert) (("" (lift-if) (("" (split -) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (expand "every") (("1" (expand "every") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "v!1(g!1, n!1)(h!1, m!1)(1 + i!1)") (("2" (replaces -2 :dir rl) (("2" (assert) (("2" (flatten) (("2" (expand "every") (("2" (typepred "ldt!1`quotl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (pseudo_div subtype "polynomial_pseudo_divide.make_divlisttype(list_adt[int].cons(polynomial_pseudo_divide.thisterm, polynomial_pseudo_divide.ldt`quotl), (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m), array2list[int].array2list((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i))(LAMBDA (j: naturalnumbers.nat): IF reals.>(j, (number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i)) THEN 0 ELSIF reals.<(j, polynomial_pseudo_divide.i) THEN number_fields.*(polynomial_pseudo_divide.h(polynomial_pseudo_divide.m), list_props[int].nth(polynomial_pseudo_divide.ldt`reml, j)) ELSE (number_fields.-)(number_fields.*(polynomial_pseudo_divide.h(polynomial_pseudo_divide.m), list_props[int].nth(polynomial_pseudo_divide.ldt`reml, j)), number_fields.*(polynomial_pseudo_divide.thisterm, polynomial_pseudo_divide.h((number_fields.-)(j, polynomial_pseudo_divide.i)))) ENDIF), (number_fields.-)((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i), 1))" "{DT: polynomial_pseudo_divide.DivListType | booleans.OR((booleans.OR(reals.>(polynomial_pseudo_divide.m, polynomial_pseudo_divide.n), booleans.AND(reals.>(polynomial_pseudo_divide.i, (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(1, polynomial_pseudo_divide.n), DT`rdegl = polynomial_pseudo_divide.n)))), booleans.OR((booleans.AND(polynomial_pseudo_divide.m = 0, booleans.AND(list_props[int].length(DT`reml) = 0, DT`rdegl = 0))), (booleans.AND(reals.>(polynomial_pseudo_divide.m, 0), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(polynomial_pseudo_divide.i, polynomial_pseudo_divide.m), list_props[int].length(DT`reml) = (number_fields.+)(1, DT`rdegl))))))}")) (pseudo_div_TCC7-1 nil 3582881577 ("" (skosimp*) (("" (assert) (("" (lift-if) (("" (split -) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "v!1(g!1, n!1)(h!1, m!1)(1 + i!1)") (("2" (replaces -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil)) nil (pseudo_div subtype "polynomial_pseudo_divide.make_divlisttype(list_adt[int].cons(polynomial_pseudo_divide.thisterm, polynomial_pseudo_divide.ldt`quotl), (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m), array2list[int].array2list((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i))(LAMBDA (j: naturalnumbers.nat): IF reals.>(j, (number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i)) THEN 0 ELSIF reals.<(j, polynomial_pseudo_divide.i) THEN number_fields.*(polynomial_pseudo_divide.h(polynomial_pseudo_divide.m), list_props[int].nth(polynomial_pseudo_divide.ldt`reml, j)) ELSE (number_fields.-)(number_fields.*(polynomial_pseudo_divide.h(polynomial_pseudo_divide.m), list_props[int].nth(polynomial_pseudo_divide.ldt`reml, j)), number_fields.*(polynomial_pseudo_divide.thisterm, polynomial_pseudo_divide.h((number_fields.-)(j, polynomial_pseudo_divide.i)))) ENDIF), (number_fields.-)((number_fields.+)(polynomial_pseudo_divide.m, polynomial_pseudo_divide.i), 1))" "{DT: polynomial_pseudo_divide.DivListType | booleans.OR((booleans.OR(reals.>(polynomial_pseudo_divide.m, polynomial_pseudo_divide.n), booleans.AND(reals.>(polynomial_pseudo_divide.i, (number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(1, polynomial_pseudo_divide.n), DT`rdegl = polynomial_pseudo_divide.n)))), booleans.OR((booleans.AND(polynomial_pseudo_divide.m = 0, booleans.AND(list_props[int].length(DT`reml) = 0, DT`rdegl = 0))), (booleans.AND(reals.>(polynomial_pseudo_divide.m, 0), booleans.AND(list_props[int].length(DT`reml) = (number_fields.+)(polynomial_pseudo_divide.i, polynomial_pseudo_divide.m), list_props[int].length(DT`reml) = (number_fields.+)(1, DT`rdegl))))))}"))) (pseudo_div_TCC11 0 (pseudo_div_TCC15-1 nil 3755251664 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div subtype "(number_fields.-)(polynomial_pseudo_divide.n, polynomial_pseudo_divide.m)" "nat"))) (pseudo_div_TCC12 0 (pseudo_div_TCC17-1 nil 3755251664 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (pseudo_div termination "polynomial_pseudo_divide.pseudo_div(polynomial_pseudo_divide.g, polynomial_pseudo_divide.n)(polynomial_pseudo_divide.h, polynomial_pseudo_divide.m)((number_fields.+)(polynomial_pseudo_divide.i, 1))" "nil"))) (pseudo_div_lengths 0 (pseudo_div_lengths-2 "" 3790098574 ("" (case "FORALL (g, h: [nat -> int], i, m, n: nat):
                                    h(m) /= 0 AND i <= n - m IMPLIES
                                     LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                         pd = poly_divide(g, n)(h, m)(n-m-i),
                                         qlength = length(psd`quotl),
                                         rlength = length(psd`reml)
                                       IN
                                       psd`qdegl = pd`qdeg AND
                                        psd`rdegl = pd`rdeg AND psd`rdegl = max(rlength - 1, 0) and qlength = (IF m = 0 THEN n - m + 1 ELSE i + 1 ENDIF)") (("1" (skeep) (("1" (case "i > n-m") (("1" (hide -2) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (expand "poly_divide") (("1" (expand "make_divtype") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (expand "pseudo_div") (("2" (expand "poly_divide") (("2" (lift-if) (("2" (expand "make_divtype") (("2" (expand "make_divlisttype") (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "max") (("3" (assert) (("3" (skeep) (("3" (skeep) (("3" (inst - "g" "h" "m" "n") (("3" (assert) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (case "NOT -1 * j - m + n = ii+1") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (replace -1) (("2" (assert) (("2" (split +) (("1" (hide (-3 -4 -5)) (("1" (expand "pseudo_div" +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (expand "poly_divide" +) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "make_divtype") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "make_divlisttype") (("2" (expand "poly_divide" +) (("2" (assert) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4 -5)) (("2" (assert) (("2" (expand "pseudo_div" +) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (expand "poly_divide" +) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "make_divtype") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "make_divlisttype") (("2" (expand "poly_divide" +) (("2" (assert) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "pseudo_div" +) (("3" (lift-if) (("3" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "make_divlisttype") (("2" (invoke (name "AA" "%1") (! 2 2 1 1 1 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (replace -2) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (replace -3) (("3" (hide 5) (("3" (ground) (("3" (replace -2) (("3" (expand "pseudo_div" +) (("3" (expand "make_divlisttype") (("3" (expand "length" 3) (("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (skosimp*) (("4" (assert) (("4" (ground) (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1 1 :dir rl) (("2" (replace -4) (("2" (expand "pseudo_div" 4) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (assert) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lift-if) (("4" (ground) (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "pseudo_div" +) (("3" (expand "make_divlisttype") (("3" (expand "length" +) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "pseudo_div" 4) (("4" (expand "make_divlisttype") (("4" (expand "length" 4) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (NOT const-decl "[bool -> bool]" booleans nil) (length_singleton formula-decl nil more_list_props structures) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (nil application-judgement "above(n)" exp2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_divtype const-decl "DivType" polynomial_division nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivType type-eq-decl nil polynomial_division nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (poly_divide def-decl "DivType" polynomial_division nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil)) shostak) (pseudo_div_lengths-1 nil 3582908268 ("" (case "FORALL (g, h: [nat -> int], i, m, n: nat):
                                    h(m) /= 0 AND i <= n - m IMPLIES
                                     LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                         pd = poly_divide(g, n)(h, m)(n-m-i),
                                         qlength = length(psd`quotl),
                                         rlength = length(psd`reml)
                                       IN
                                       psd`qdegl = pd`qdeg AND
                                        psd`rdegl = pd`rdeg AND psd`rdegl = max(rlength - 1, 0) and qlength = (IF m = 0 THEN n - m + 1 ELSE i + 1 ENDIF)") (("1" (skeep) (("1" (case "i > n-m") (("1" (hide -2) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (expand "poly_divide") (("1" (expand "make_divtype") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (expand "pseudo_div") (("2" (expand "poly_divide") (("2" (lift-if) (("2" (expand "make_divtype") (("2" (expand "make_divlisttype") (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (expand "max") (("2" (assert) nil nil)) nil) ("3" (expand "length") (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "max") (("3" (assert) (("3" (skeep) (("3" (skeep) (("3" (inst - "g" "h" "m" "n") (("3" (assert) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (case "NOT -1 * j - m + n = ii+1") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (replace -1) (("2" (assert) (("2" (split +) (("1" (hide (-3 -4 -5)) (("1" (expand "pseudo_div" +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (expand "poly_divide" +) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "make_divtype") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "make_divlisttype") (("2" (expand "poly_divide" +) (("2" (assert) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4 -5)) (("2" (assert) (("2" (expand "pseudo_div" +) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (expand "poly_divide" +) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "make_divtype") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "make_divlisttype") (("2" (expand "poly_divide" +) (("2" (assert) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "pseudo_div" +) (("3" (lift-if) (("3" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "make_divlisttype") (("2" (invoke (name "AA" "%1") (! 2 2 1 1 1 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (replace -2) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (replace -3) (("3" (hide 5) (("3" (ground) (("3" (replace -2) (("3" (expand "pseudo_div" +) (("3" (expand "make_divlisttype") (("3" (expand "length" 3) (("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (skosimp*) (("4" (assert) (("4" (ground) (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1 1 :dir rl) (("2" (replace -4) (("2" (expand "pseudo_div" 4) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (assert) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lift-if) (("4" (ground) (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "pseudo_div" +) (("3" (expand "make_divlisttype") (("3" (expand "length" +) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "pseudo_div" 4) (("4" (expand "make_divlisttype") (("4" (expand "length" 4) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ((array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (length_singleton formula-decl nil more_list_props structures) (make_divtype const-decl "DivType" polynomial_division nil) (list type-decl nil list_adt nil) (DivType type-eq-decl nil polynomial_division nil) (poly_divide def-decl "DivType" polynomial_division nil)) nil)) (HHGGLEM 0 (HHGGLEM-1 nil 3583580204 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (GG const-decl "int" polynomial_pseudo_divide nil) (HH const-decl "int" polynomial_pseudo_divide nil) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (pseudo_div_def_TCC1 0 (pseudo_div_def_TCC1-1 nil 3583595096 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div_def subtype "(number_fields.-)(polynomial_pseudo_divide.k, ((number_fields.+)((number_fields.-)(polynomial_pseudo_divide.pd`qdeg, polynomial_pseudo_divide.qlength), 1)))" "below[length[int](psd`quotl)]"))) (pseudo_div_def_TCC2 0 (pseudo_div_def_TCC2-1 nil 3583595096 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (lemma "pseudo_div_lengths") (("" (inst?) (("" (assert) (("" (flatten) (("" (case "length(pseudo_div(g, n)(h, m)(i)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (expand "pseudo_div" 1) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pseudo_div_def subtype "polynomial_pseudo_divide.k" "below[length[int](psd`reml)]"))) (pseudo_div_def 0 (pseudo_div_def-8 "" 3790098711 ("" (case "FORALL (R, T: nat, g, h: [nat -> int], i, m, n: nat):
                                                                                                          (h(m) /= 0 AND
                                                                                                            i <= n - m AND
                                                                                                             (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                                                                              (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                                                                           IMPLIES
                                                                                                           LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                                                                               pd = poly_divide(g, n)(h, m)(n-m-i),
                                                                                                               qlength = length(psd`quotl),
                                                                                                               rlength = length(psd`reml)
                                                                                                             IN
                                                                                                             (pd`quot =
                                                                                                               (LAMBDA (k: nat): (1 / h(m)) ^ GG(k, n, m, n-m-i, R, T)) *
                                                                                                                (LAMBDA (k: nat):
                                                                                                                   IF k <= pd`qdeg AND k >= pd`qdeg - qlength + 1
                                                                                                                     THEN nth(psd`quotl, k - (pd`qdeg - qlength + 1))
                                                                                                                   ELSE 0
                                                                                                                   ENDIF))
                                                                                                              AND
                                                                                                              pd`rem =
                                                                                                               (LAMBDA (k: nat): (1 / h(m)) ^ HH(k, n, m, n-m-i, R, T)) *
                                                                                                                (LAMBDA (k: nat):
                                                                                                                   IF k <= pd`rdeg AND m > 0 THEN nth(psd`reml, k)
                                                                                                                   ELSE 0
                                                                                                                   ENDIF)") (("1" (skeep) (("1" (case "i>n-m") (("1" (hide -2) (("1" (assert) (("1" (expand "poly_divide") (("1" (expand "pseudo_div") (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (expand "length") (("1" (split) (("1" (decompose-equality) (("1" (expand "*") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (expand "*") (("1" (expand "HH") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "array2list(1 + n)(g)") (("1" (hide -1) (("1" (inst - "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "*") (("2" (expand "HH") (("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "R" "T" "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "GG") (("1" (lift-if) (("1" (ground) (("1" (inst - "m+x!1") (("1" (replaces -2 :dir rl) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -4 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (decompose-equality 2) (("1" (lift-if) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) (("1" (expand "*") (("1" (expand "GG") (("1" (rewrite "expt_x1") (("1" (hide -1) (("1" (replaces -2 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (expand "every") (("3" (expand "every") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality +) (("1" (expand "*") (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (name "AA" "array2list(n)
                      (LAMBDA (j: nat):
                         IF j > n THEN 0
                         ELSIF j < n - m
                           THEN h(m) * nth(array2list(1 + n)(g), j)
                         ELSE h(m) * nth(array2list(1 + n)(g), j) -
                               nth(array2list(1 + n)(g), n) * h(j - n + m)
                         ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "HH" +) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (ground) (("2" (name "AA" "array2list(n)
                      (LAMBDA (j: nat):
                         IF j > n THEN 0
                         ELSIF j < n - m
                           THEN h(m) * nth(array2list(1 + n)(g), j)
                         ELSE h(m) * nth(array2list(1 + n)(g), j) -
                               nth(array2list(1 + n)(g), n) * h(j - n + m)
                         ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (expand "HH" +) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst - "R" "T" "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (replace -1) (("3" (case "NOT n-m-j = ii+1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (expand "GG" +) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (inst - "x!1") (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (expand "*") (("1" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (expand "HH") (("1" (expand "GG") (("1" (hide -) (("1" (grind :exclude ("nth" "pseudo_div")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "GG") (("2" (assert) (("2" (expand "pseudo_div" + 2) (("2" (assert) (("2" (expand "make_divlisttype") (("2" (expand "nth" + 2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide (-1 -2 -3 -4)) (("2" (replace -2) (("2" (assert) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (replaces -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -4) (("2" (hide (-1 -2 -3)) (("2" (assert) (("2" (expand "*") (("2" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "1+ii" "m" "n") (("3" (assert) (("3" (flatten) (("3" (replace -3 +) (("3" (expand "max" +) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (hide-all-but (-1 +)) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (hide (-6 -7)) (("4" (skosimp*) (("4" (assert) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide (-7 -8)) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div" + 3) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (hide -1) (("1" (hide -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2) (("1" (replace -3) (("1" (case "length(pseudo_div(g, n)(h, m)(1 + ii)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) (("1" (expand "pseudo_div" + 5) (("1" (expand "make_divlisttype") (("1" (name "AB" "array2list[int](1 + ii + m)
                                                                                                         (LAMBDA (j: nat):
                                                                                                            IF j > 1 + ii + m THEN 0
                                                                                                            ELSIF j < 1 + ii
                                                                                                              THEN h(m)
                                                                                                                   *
                                                                                                                   nth
                                                                                                                   (IF 1 + ii = n - m
                                                                                                                    THEN array2list[int](1 + n)(g)
                                                                                                                    ELSE pseudo_div
                                                                                                                         (g, n)(h, m)(2 + ii)`reml
                                                                                                                    ENDIF,
                                                                                                                    j)
                                                                                                            ELSE h(m)
                                                                                                                 *
                                                                                                                 nth
                                                                                                                 (IF 1 + ii = n - m
                                                                                                                  THEN array2list[int](1 + n)(g)
                                                                                                                  ELSE pseudo_div
                                                                                                                       (g, n)(h, m)(2 + ii)`reml
                                                                                                                  ENDIF,
                                                                                                                  j)
                                                                                                                 -
                                                                                                                 nth
                                                                                                                 (IF 1 + ii = n - m
                                                                                                                  THEN array2list[int](1 + n)(g)
                                                                                                                  ELSE pseudo_div
                                                                                                                       (g, n)(h, m)(2 + ii)`reml
                                                                                                                  ENDIF,
                                                                                                                  IF 1 + ii = n - m
                                                                                                                  THEN n
                                                                                                                  ELSE pseudo_div
                                                                                                                       (g, n)(h, m)(2 + ii)`rdegl
                                                                                                                  ENDIF)
                                                                                                                 *
                                                                                                                 h(j - 1 - ii)
                                                                                                            ENDIF)") (("1" (replaces -1) (("1" (typepred "AB") (("1" (replaces -2) (("1" (hide -3) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (expand "HH") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt" + 3) (("1" (expand "expt" + 4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" + 3) (("2" (expand "expt" + 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (hide -) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lift-if) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) (("6" (lift-if) (("6" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (hide -) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (hide -) (("3" (assert) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (case "NOT x!1=ii+m") (("1" (assert) (("1" (case "FORALL (kn:nat): kn>ii-1+m AND kn<=ii+m IMPLIES kn = ii+m") (("1" (inst - "x!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "kn>=ii+m") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (case "FORALL (a1,a2:nat): a1>a2-1 IMPLIES a1>=a2") (("1" (inst - "kn" "ii+m") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but (-1 +)) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "pseudo_div_lengths") (("4" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skosimp*) (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil) ((n skolem-const-decl "nat" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (i skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (i skolem-const-decl "nat" polynomial_pseudo_divide nil) (x!1 skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (g skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (h skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (ii skolem-const-decl "int" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (poly_divide_lengths formula-decl nil polynomial_division nil) (max_npreal_0 formula-decl nil min_max reals) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (h skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (real_minus_real_is_real application-judgement "real" reals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (x!1 skolem-const-decl "nat" polynomial_pseudo_divide nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[T -> real]" real_fun_ops reals) (g skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (rat_expt application-judgement "rat" exponentiation nil) (TRUE const-decl "bool" booleans nil) (length_singleton formula-decl nil more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (expt_x1 formula-decl nil exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (nil application-judgement "above(n)" exp2 nil) (make_divtype const-decl "DivType" polynomial_division nil) (g skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (below type-eq-decl nil naturalnumbers nil) (listn type-eq-decl nil listn structures) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (expt def-decl "real" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (int_times_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivType type-eq-decl nil polynomial_division nil) (* const-decl "[T -> real]" real_fun_ops reals) (^ const-decl "real" exponentiation nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (GG const-decl "int" polynomial_pseudo_divide nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (HH const-decl "int" polynomial_pseudo_divide nil) (poly_divide def-decl "DivType" polynomial_division nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil)) shostak) (pseudo_div_def-7 "" 3755369000 ("" (case "FORALL (R, T: nat, g, h: [nat -> int], i, m, n: nat):
                                                                                                          (h(m) /= 0 AND
                                                                                                            i <= n - m AND
                                                                                                             (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                                                                              (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                                                                           IMPLIES
                                                                                                           LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                                                                               pd = poly_divide(g, n)(h, m)(n-m-i),
                                                                                                               qlength = length(psd`quotl),
                                                                                                               rlength = length(psd`reml)
                                                                                                             IN
                                                                                                             (pd`quot =
                                                                                                               (LAMBDA (k: nat): (1 / h(m)) ^ GG(k, n, m, n-m-i, R, T)) *
                                                                                                                (LAMBDA (k: nat):
                                                                                                                   IF k <= pd`qdeg AND k >= pd`qdeg - qlength + 1
                                                                                                                     THEN nth(psd`quotl, k - (pd`qdeg - qlength + 1))
                                                                                                                   ELSE 0
                                                                                                                   ENDIF))
                                                                                                              AND
                                                                                                              pd`rem =
                                                                                                               (LAMBDA (k: nat): (1 / h(m)) ^ HH(k, n, m, n-m-i, R, T)) *
                                                                                                                (LAMBDA (k: nat):
                                                                                                                   IF k <= pd`rdeg AND m > 0 THEN nth(psd`reml, k)
                                                                                                                   ELSE 0
                                                                                                                   ENDIF)") (("1" (skeep) (("1" (case "i>n-m") (("1" (hide -2) (("1" (assert) (("1" (expand "poly_divide") (("1" (expand "pseudo_div") (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (expand "length") (("1" (split) (("1" (decompose-equality) (("1" (expand "*") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (expand "*") (("1" (expand "HH") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "array2list(1 + n)(g)") (("1" (hide -1) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -2 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "*") (("2" (expand "HH") (("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) (("4" (rewrite "every_nth") (("4" (skeep) (("4" (typepred "array2list[real](1 + n)(g)") (("4" (inst -3 "i!1") (("4" (replace -3 :dir rl) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "R" "T" "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "GG") (("1" (lift-if) (("1" (ground) (("1" (inst - "m+x!1") (("1" (replaces -2 :dir rl) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -4 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (rewrite "every_nth") (("3" (skeep) (("3" (typepred "array2list[real](1 + n)(g)") (("3" (inst -3 "i") (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "every_nth") (("4" (assert) (("4" (skeep) (("4" (assert) (("4" (typepred "array2list[real](1 + n)(g)") (("4" (inst -3 "i") (("4" (replace -3 :dir rl) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (decompose-equality 2) (("1" (lift-if) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) (("1" (expand "*") (("1" (expand "GG") (("1" (rewrite "expt_x1") (("1" (hide -1) (("1" (replaces -2 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (expand "every") (("3" (expand "every") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (rewrite "every_nth") (("5" (skeep) (("5" (typepred "array2list(1+n)(g)") (("5" (inst -3 "i") (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality +) (("1" (expand "*") (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (name "AA" "array2list(n)
                      (LAMBDA (j: nat):
                         IF j > n THEN 0
                         ELSIF j < n - m
                           THEN h(m) * nth(array2list(1 + n)(g), j)
                         ELSE h(m) * nth(array2list(1 + n)(g), j) -
                               nth(array2list(1 + n)(g), n) * h(j - n + m)
                         ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "HH" +) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (ground) (("2" (name "AA" "array2list(n)
                      (LAMBDA (j: nat):
                         IF j > n THEN 0
                         ELSIF j < n - m
                           THEN h(m) * nth(array2list(1 + n)(g), j)
                         ELSE h(m) * nth(array2list(1 + n)(g), j) -
                               nth(array2list(1 + n)(g), n) * h(j - n + m)
                         ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (expand "HH" +) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst - "R" "T" "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (replace -1) (("3" (case "NOT n-m-j = ii+1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (expand "GG" +) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (inst - "x!1") (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil) ("3" (skeep) (("3" (rewrite "every_nth") (("3" (skeep) (("3" (typepred "array2list[real](1 + n)(g)") (("3" (inst -3 "i") (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "every_nth") (("4" (skeep) (("4" (typepred "array2list[real](1 + n)(g)") (("4" (inst -3 "i") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (expand "*") (("1" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (expand "HH") (("1" (expand "GG") (("1" (hide -) (("1" (grind :exclude ("nth" "pseudo_div")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "GG") (("2" (assert) (("2" (expand "pseudo_div" + 2) (("2" (assert) (("2" (expand "make_divlisttype") (("2" (expand "nth" + 2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide (-1 -2 -3 -4)) (("2" (replace -2) (("2" (assert) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (replaces -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -4) (("2" (hide (-1 -2 -3)) (("2" (assert) (("2" (expand "*") (("2" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "1+ii" "m" "n") (("3" (assert) (("3" (flatten) (("3" (replace -3 +) (("3" (expand "max" +) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (hide-all-but (-1 +)) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (hide (-6 -7)) (("4" (skosimp*) (("4" (assert) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide (-7 -8)) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div" + 3) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (hide -1) (("1" (hide -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2) (("1" (replace -3) (("1" (case "length(pseudo_div(g, n)(h, m)(1 + ii)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) (("1" (expand "pseudo_div" + 5) (("1" (expand "make_divlisttype") (("1" (replaces -1) (("1" (name "AB" "array2list[int](1 + ii + m)
                                                                                                         (LAMBDA (j: nat):
                                                                                                            IF j > 1 + ii + m THEN 0
                                                                                                            ELSIF j < 1 + ii
                                                                                                              THEN h(m)
                                                                                                                   *
                                                                                                                   nth
                                                                                                                   (IF 1 + ii = n - m
                                                                                                                    THEN array2list[int](1 + n)(g)
                                                                                                                    ELSE pseudo_div
                                                                                                                         (g, n)(h, m)(2 + ii)`reml
                                                                                                                    ENDIF,
                                                                                                                    j)
                                                                                                            ELSE h(m)
                                                                                                                 *
                                                                                                                 nth
                                                                                                                 (IF 1 + ii = n - m
                                                                                                                  THEN array2list[int](1 + n)(g)
                                                                                                                  ELSE pseudo_div
                                                                                                                       (g, n)(h, m)(2 + ii)`reml
                                                                                                                  ENDIF,
                                                                                                                  j)
                                                                                                                 -
                                                                                                                 nth
                                                                                                                 (IF 1 + ii = n - m
                                                                                                                  THEN array2list[int](1 + n)(g)
                                                                                                                  ELSE pseudo_div
                                                                                                                       (g, n)(h, m)(2 + ii)`reml
                                                                                                                  ENDIF,
                                                                                                                  IF 1 + ii = n - m
                                                                                                                  THEN n
                                                                                                                  ELSE pseudo_div
                                                                                                                       (g, n)(h, m)(2 + ii)`rdegl
                                                                                                                  ENDIF)
                                                                                                                 *
                                                                                                                 h(j - 1 - ii)
                                                                                                            ENDIF)") (("1" (replaces -1) (("1" (typepred "AB") (("1" (replaces -2) (("1" (hide -3) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (expand "HH") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt" + 3) (("1" (expand "expt" + 4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" + 3) (("2" (expand "expt" + 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (hide -) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lift-if) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) (("6" (lift-if) (("6" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (hide -) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (hide -) (("3" (assert) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (case "NOT x!1=ii+m") (("1" (assert) (("1" (case "FORALL (kn:nat): kn>ii-1+m AND kn<=ii+m IMPLIES kn = ii+m") (("1" (inst - "x!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "kn>=ii+m") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (case "FORALL (a1,a2:nat): a1>a2-1 IMPLIES a1>=a2") (("1" (inst - "kn" "ii+m") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but (-1 +)) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "pseudo_div_lengths") (("4" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skosimp*) (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (max_npreal_0 formula-decl nil min_max reals) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (length_singleton formula-decl nil more_list_props structures) (make_divtype const-decl "DivType" polynomial_division nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list type-decl nil list_adt nil) (DivType type-eq-decl nil polynomial_division nil) (poly_divide def-decl "DivType" polynomial_division nil)) shostak) (pseudo_div_def-6 nil 3601033952 ("" (case "FORALL (R, T: nat, g, h: [nat -> int], i, m, n: nat):
                                                                                                   (h(m) /= 0 AND
                                                                                                     i <= n - m AND
                                                                                                      (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                                                                       (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                                                                    IMPLIES
                                                                                                    LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                                                                        pd = poly_divide(g, n)(h, m)(n-m-i),
                                                                                                        qlength = length(psd`quotl),
                                                                                                        rlength = length(psd`reml)
                                                                                                      IN
                                                                                                      (pd`quot =
                                                                                                        (LAMBDA (k: nat): (1 / h(m)) ^ GG(k, n, m, n-m-i, R, T)) *
                                                                                                         (LAMBDA (k: nat):
                                                                                                            IF k <= pd`qdeg AND k >= pd`qdeg - qlength + 1
                                                                                                              THEN nth(psd`quotl, k - (pd`qdeg - qlength + 1))
                                                                                                            ELSE 0
                                                                                                            ENDIF))
                                                                                                       AND
                                                                                                       pd`rem =
                                                                                                        (LAMBDA (k: nat): (1 / h(m)) ^ HH(k, n, m, n-m-i, R, T)) *
                                                                                                         (LAMBDA (k: nat):
                                                                                                            IF k <= pd`rdeg AND m > 0 THEN nth(psd`reml, k)
                                                                                                            ELSE 0
                                                                                                            ENDIF)") (("1" (skeep) (("1" (case "i>n-m") (("1" (hide -2) (("1" (assert) (("1" (expand "poly_divide") (("1" (expand "pseudo_div") (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (expand "length") (("1" (split) (("1" (decompose-equality) (("1" (expand "*") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (expand "*") (("1" (expand "HH") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "array2list(1 + n)(g)") (("1" (hide -1) (("1" (inst - "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "*") (("2" (expand "HH") (("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "R" "T" "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "GG") (("1" (lift-if) (("1" (ground) (("1" (inst - "m+x!1") (("1" (replaces -2 :dir rl) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -4 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (decompose-equality 2) (("1" (lift-if) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) (("1" (expand "*") (("1" (expand "GG") (("1" (rewrite "expt_x1") (("1" (hide -1) (("1" (replaces -2 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality +) (("1" (expand "*") (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (name "AA" "array2list[int](n)
                                                                (LAMBDA (j: nat):
                                                                   IF j > n THEN 0
                                                                   ELSIF j < n - m
                                                                     THEN h(m) * nth(array2list[int](1 + n)(g), j)
                                                                   ELSE h(m) * nth(array2list[int](1 + n)(g), j) -
                                                                         nth(array2list[int](1 + n)(g), n) * h(j - n + m)
                                                                   ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "HH" +) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (ground) (("2" (name "AA" "array2list[int](n)
                                                                (LAMBDA (j: nat):
                                                                   IF j > n THEN 0
                                                                   ELSIF j < n - m
                                                                     THEN h(m) * nth(array2list[int](1 + n)(g), j)
                                                                   ELSE h(m) * nth(array2list[int](1 + n)(g), j) -
                                                                         nth(array2list[int](1 + n)(g), n) * h(j - n + m)
                                                                   ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (expand "HH" +) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst - "R" "T" "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (replace -1) (("3" (case "NOT n-m-j = ii+1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (expand "GG" +) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (inst - "x!1") (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (expand "*") (("1" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (expand "HH") (("1" (expand "GG") (("1" (hide -) (("1" (grind :exclude ("nth" "pseudo_div")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "GG") (("2" (assert) (("2" (expand "pseudo_div" + 2) (("2" (assert) (("2" (expand "make_divlisttype") (("2" (expand "nth" + 2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide (-1 -2 -3 -4)) (("2" (replace -2) (("2" (assert) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (replaces -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -4) (("2" (hide (-1 -2 -3)) (("2" (assert) (("2" (expand "*") (("2" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "1+ii" "m" "n") (("3" (assert) (("3" (flatten) (("3" (replace -3 +) (("3" (expand "max" +) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (hide-all-but (-1 +)) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (hide (-6 -7)) (("4" (skosimp*) (("4" (assert) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide (-7 -8)) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div" + 3) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (hide -1) (("1" (hide -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2) (("1" (replace -3) (("1" (case "length(pseudo_div(g, n)(h, m)(1 + ii)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) (("1" (expand "pseudo_div" + 5) (("1" (expand "make_divlisttype") (("1" (replaces -1) (("1" (name "AB" "array2list[int](1 + ii + m)
                                                                                (LAMBDA (j: nat):
                                                                                   IF j > 1 + ii + m THEN 0
                                                                                   ELSIF j < 1 + ii
                                                                                     THEN h(m)
                                                                                          *
                                                                                          nth
                                                                                          (IF 1 + ii = n - m
                                                                                           THEN array2list[int](1 + n)(g)
                                                                                           ELSE pseudo_div
                                                                                                (g, n)(h, m)(2 + ii)`reml
                                                                                           ENDIF,
                                                                                           j)
                                                                                   ELSE h(m)
                                                                                        *
                                                                                        nth
                                                                                        (IF 1 + ii = n - m
                                                                                         THEN array2list[int](1 + n)(g)
                                                                                         ELSE pseudo_div
                                                                                              (g, n)(h, m)(2 + ii)`reml
                                                                                         ENDIF,
                                                                                         j)
                                                                                        -
                                                                                        nth
                                                                                        (IF 1 + ii = n - m
                                                                                         THEN array2list[int](1 + n)(g)
                                                                                         ELSE pseudo_div
                                                                                              (g, n)(h, m)(2 + ii)`reml
                                                                                         ENDIF,
                                                                                         IF 1 + ii = n - m
                                                                                         THEN n
                                                                                         ELSE pseudo_div
                                                                                              (g, n)(h, m)(2 + ii)`rdegl
                                                                                         ENDIF)
                                                                                        *
                                                                                        h(j - 1 - ii)
                                                                                   ENDIF)") (("1" (replaces -1) (("1" (typepred "AB") (("1" (replaces -2) (("1" (hide -3) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (expand "HH") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt" + 3) (("1" (expand "expt" + 4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" + 3) (("2" (expand "expt" + 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (hide -) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lift-if) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) (("6" (lift-if) (("6" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (hide -) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (hide -) (("3" (assert) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (case "NOT x!1=ii+m") (("1" (assert) (("1" (case "FORALL (kn:nat): kn>ii-1+m AND kn<=ii+m IMPLIES kn = ii+m") (("1" (inst - "x!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "kn>=ii+m") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (case "FORALL (a1,a2:nat): a1>a2-1 IMPLIES a1>=a2") (("1" (inst - "kn" "ii+m") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but (-1 +)) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "pseudo_div_lengths") (("4" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skosimp*) (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (max_npreal_0 formula-decl nil min_max reals) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (length_singleton formula-decl nil more_list_props structures) (make_divtype const-decl "DivType" polynomial_division nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list type-decl nil list_adt nil) (DivType type-eq-decl nil polynomial_division nil) (poly_divide def-decl "DivType" polynomial_division nil)) nil) (pseudo_div_def-5 nil 3593447223 ("" (case "FORALL (R, T: nat, g, h: [nat -> int], i, m, n: nat):
                                                                                     (h(m) /= 0 AND
                                                                                       i <= n - m AND
                                                                                        (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                                                         (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                                                      IMPLIES
                                                                                      LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                                                          pd = poly_divide(g, n)(h, m)(n-m-i),
                                                                                          qlength = length(psd`quotl),
                                                                                          rlength = length(psd`reml)
                                                                                        IN
                                                                                        (pd`quot =
                                                                                          (LAMBDA (k: nat): (1 / h(m)) ^ GG(k, n, m, n-m-i, R, T)) *
                                                                                           (LAMBDA (k: nat):
                                                                                              IF k <= pd`qdeg AND k >= pd`qdeg - qlength + 1
                                                                                                THEN nth(psd`quotl, k - (pd`qdeg - qlength + 1))
                                                                                              ELSE 0
                                                                                              ENDIF))
                                                                                         AND
                                                                                         pd`rem =
                                                                                          (LAMBDA (k: nat): (1 / h(m)) ^ HH(k, n, m, n-m-i, R, T)) *
                                                                                           (LAMBDA (k: nat):
                                                                                              IF k <= pd`rdeg AND m > 0 THEN nth(psd`reml, k)
                                                                                              ELSE 0
                                                                                              ENDIF)") (("1" (skeep) (("1" (inst - "R" "T" "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "GG") (("1" (lift-if) (("1" (ground) (("1" (inst - "m+x!1") (("1" (replaces -2 :dir rl) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -4 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (decompose-equality 2) (("1" (lift-if) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) (("1" (expand "length" +) (("1" (expand "*") (("1" (expand "nth" + 1) (("1" (replace -3 :dir rl) (("1" (expand "GG") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) (("2" (expand "length" +) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality +) (("1" (expand "*") (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (name "AA" "array2list[int](n)
                      (LAMBDA (j: nat):
                         IF j > n THEN 0
                         ELSIF j < n - m
                           THEN h(m) * nth(array2list[int](1 + n)(g), j)
                         ELSE h(m) * nth(array2list[int](1 + n)(g), j) -
                               nth(array2list[int](1 + n)(g), n) * h(j - n + m)
                         ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "HH" +) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (ground) (("2" (name "AA" "array2list[int](n)
                      (LAMBDA (j: nat):
                         IF j > n THEN 0
                         ELSIF j < n - m
                           THEN h(m) * nth(array2list[int](1 + n)(g), j)
                         ELSE h(m) * nth(array2list[int](1 + n)(g), j) -
                               nth(array2list[int](1 + n)(g), n) * h(j - n + m)
                         ENDIF)") (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (expand "HH" +) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst - "R" "T" "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (replace -1) (("3" (case "NOT n-m-j = ii+1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (expand "GG" +) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (inst - "x!1") (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (expand "*") (("1" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (expand "HH") (("1" (expand "GG") (("1" (hide -) (("1" (grind :exclude ("nth" "pseudo_div")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "GG") (("2" (assert) (("2" (expand "pseudo_div" + 2) (("2" (assert) (("2" (expand "make_divlisttype") (("2" (expand "nth" + 2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide (-1 -2 -3 -4)) (("2" (replace -2) (("2" (assert) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (replaces -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -4) (("2" (hide (-1 -2 -3)) (("2" (assert) (("2" (expand "*") (("2" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "1+ii" "m" "n") (("3" (assert) (("3" (flatten) (("3" (replace -3 +) (("3" (expand "max" +) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (hide-all-but (-1 +)) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (hide (-6 -7)) (("4" (skosimp*) (("4" (assert) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide (-7 -8)) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div" + 3) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (hide -1) (("1" (hide -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2) (("1" (replace -3) (("1" (case "length(pseudo_div(g, n)(h, m)(1 + ii)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) (("1" (expand "pseudo_div" + 5) (("1" (expand "make_divlisttype") (("1" (replaces -1) (("1" (name "AB" "array2list[int](1 + ii + m)
                              (LAMBDA (j: nat):
                                 IF j > 1 + ii + m THEN 0
                                 ELSIF j < 1 + ii
                                   THEN h(m)
                                        *
                                        nth
                                        (IF 1 + ii = n - m
                                         THEN array2list[int](1 + n)(g)
                                         ELSE pseudo_div
                                              (g, n)(h, m)(2 + ii)`reml
                                         ENDIF,
                                         j)
                                 ELSE h(m)
                                      *
                                      nth
                                      (IF 1 + ii = n - m
                                       THEN array2list[int](1 + n)(g)
                                       ELSE pseudo_div
                                            (g, n)(h, m)(2 + ii)`reml
                                       ENDIF,
                                       j)
                                      -
                                      nth
                                      (IF 1 + ii = n - m
                                       THEN array2list[int](1 + n)(g)
                                       ELSE pseudo_div
                                            (g, n)(h, m)(2 + ii)`reml
                                       ENDIF,
                                       IF 1 + ii = n - m
                                       THEN n
                                       ELSE pseudo_div
                                            (g, n)(h, m)(2 + ii)`rdegl
                                       ENDIF)
                                      *
                                      h(j - 1 - ii)
                                 ENDIF)") (("1" (replaces -1) (("1" (typepred "AB") (("1" (replaces -2) (("1" (hide -3) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (expand "HH") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt" + 3) (("1" (expand "expt" + 4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" + 3) (("2" (expand "expt" + 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (hide -) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lift-if) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) (("7" (hide -) (("7" (lift-if) (("7" (ground) (("7" (expand "pseudo_div") (("7" (expand "make_divlisttype") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (hide -) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (hide -) (("3" (assert) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (case "NOT x!1=ii+m") (("1" (assert) (("1" (case "FORALL (kn:nat): kn>ii-1+m AND kn<=ii+m IMPLIES kn = ii+m") (("1" (inst - "x!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "kn>=ii+m") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (case "FORALL (a1,a2:nat): a1>a2-1 IMPLIES a1>=a2") (("1" (inst - "kn" "ii+m") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but (-1 +)) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "pseudo_div_lengths") (("4" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skosimp*) (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (make_divtype const-decl "DivType" polynomial_division nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (DivType type-eq-decl nil polynomial_division nil) (poly_divide def-decl "DivType" polynomial_division nil)) nil) (pseudo_div_def-4 nil 3583833143 ("" (case "FORALL (R, T: nat, g, h: [nat -> real], i, m, n: nat):
                                                                       (h(m) /= 0 AND
                                                                         i <= n - m AND
                                                                          (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                                           (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                                        IMPLIES
                                                                        LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                                            pd = poly_divide(g, n)(h, m)(n-m-i),
                                                                            qlength = length(psd`quotl),
                                                                            rlength = length(psd`reml)
                                                                          IN
                                                                          (pd`quot =
                                                                            (LAMBDA (k: nat): (1 / h(m)) ^ GG(k, n, m, n-m-i, R, T)) *
                                                                             (LAMBDA (k: nat):
                                                                                IF k <= pd`qdeg AND k >= pd`qdeg - qlength + 1
                                                                                  THEN nth(psd`quotl, k - (pd`qdeg - qlength + 1))
                                                                                ELSE 0
                                                                                ENDIF))
                                                                           AND
                                                                           pd`rem =
                                                                            (LAMBDA (k: nat): (1 / h(m)) ^ HH(k, n, m, n-m-i, R, T)) *
                                                                             (LAMBDA (k: nat):
                                                                                IF k <= pd`rdeg AND m > 0 THEN nth(psd`reml, k)
                                                                                ELSE 0
                                                                                ENDIF)") (("1" (skeep) (("1" (inst - "R" "T" "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "GG") (("1" (lift-if) (("1" (ground) (("1" (inst - "m+x!1") (("1" (replaces -2 :dir rl) (("1" (grind) nil))))) ("2" (inst -4 "x!1") (("2" (assert) nil))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))))))) ("2" (flatten) (("2" (assert) (("2" (decompose-equality 2) (("1" (lift-if) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) (("1" (expand "length" +) (("1" (expand "*") (("1" (expand "nth" + 1) (("1" (replace -3 :dir rl) (("1" (expand "GG") (("1" (hide -) (("1" (grind) nil))))))))))))))))))))) ("2" (expand "*") (("2" (assert) (("2" (expand "length" +) (("2" (lift-if) (("2" (ground) nil))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))))))))))))))))) ("2" (decompose-equality +) (("1" (expand "*") (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (hide -) (("1" (grind) nil))))))))))))))))))) ("2" (expand "HH" +) (("2" (grind) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))) ("2" (flatten) (("2" (assert) (("2" (ground) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (expand "HH" +) (("1" (hide -) (("1" (grind) nil))))))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil))))))))))))))))))))))) ("3" (skeep) (("3" (skeep) (("3" (inst - "R" "T" "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (replace -1) (("3" (case "NOT n-m-j = ii+1") (("1" (assert) nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (expand "GG" +) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (hide -) (("1" (grind) nil))))))) ("2" (assert) nil))))) ("2" (hide -2) (("2" (inst - "x!1") (("2" (assert) (("2" (ground) nil))))))))))))))))))))) ("2" (skosimp*) (("2" (ground) nil))))))))))))))))))))) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (expand "*") (("1" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (expand "HH") (("1" (expand "GG") (("1" (hide -) (("1" (grind :exclude ("nth" "pseudo_div")) nil))))))))))))))))))))))))))))))))))))))) ("2" (expand "GG") (("2" (assert) (("2" (expand "pseudo_div" + 2) (("2" (assert) (("2" (expand "make_divlisttype") (("2" (expand "nth" + 2) (("2" (lift-if) (("2" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide (-1 -2 -3 -4)) (("2" (replace -2) (("2" (assert) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (replaces -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -4) (("2" (hide (-1 -2 -3)) (("2" (assert) (("2" (expand "*") (("2" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "HH") (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil))))) ("2" (expand "^") (("2" (expand "expt" + 2) (("2" (assert) nil))))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "1+ii" "m" "n") (("3" (assert) (("3" (flatten) (("3" (replace -3 +) (("3" (expand "max" +) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (hide-all-but (-1 +)) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil))))))))))))))))))))))))))))))) ("4" (hide 2) (("4" (hide (-6 -7)) (("4" (skosimp*) (("4" (assert) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil))))))))))))) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide (-7 -8)) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil))))))))))))))))))))) ("2" (expand "pseudo_div" + 3) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (hide -1) (("1" (hide -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (replace -3) (("1" (case "length(pseudo_div(g, n)(h, m)(1 + ii)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) (("1" (expand "pseudo_div" + 5) (("1" (expand "make_divlisttype") (("1" (invoke (name "AB" "%1") (! 1 2 2 3 2 1 1)) (("1" (replaces -1) (("1" (typepred "AB") (("1" (replaces -2) (("1" (hide -3) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (expand "HH") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt" + 3) (("1" (expand "expt" + 4) (("1" (assert) nil))))))))))) ("2" (flatten) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" + 3) (("2" (expand "expt" + 4) (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil))))) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (hide -) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil))))))))))))) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil))))) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lift-if) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (ground) nil))))))))))))))) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil))))) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) (("7" (hide -) (("7" (lift-if) (("7" (ground) (("7" (expand "pseudo_div") (("7" (expand "make_divlisttype") (("7" (assert) nil))))))))))))))))) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil))))))))))))))) ("2" (hide 2) (("2" (assert) (("2" (hide -) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil))))) ("3" (hide 2) (("3" (skosimp*) (("3" (hide -) (("3" (assert) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil))))))))))))) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil))))))))))))) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil))))))))))))))))))))) ("3" (assert) (("3" (case "NOT x!1=ii+m") (("1" (assert) (("1" (case "FORALL (kn:nat): kn>ii-1+m AND kn<=ii+m IMPLIES kn = ii+m") (("1" (inst - "x!1") (("1" (assert) nil))) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "kn>=ii+m") (("1" (assert) nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (case "FORALL (a1,a2:nat): a1>a2-1 IMPLIES a1>=a2") (("1" (inst - "kn" "ii+m") (("1" (assert) nil))) ("2" (hide-all-but 1) (("2" (grind) nil))))))))))))))))))) ("2" (replaces -1) (("2" (assert) nil))))))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but (-1 +)) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil))))))))))) ("3" (skosimp*) (("3" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "pseudo_div_lengths") (("4" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil))) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil))))))))))))))))))) ("2" (assert) nil))))))))))))))))))) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil))))) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil))))) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil))))) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil))))) ("9" (hide 2) (("9" (skosimp*) (("9" (assert) nil))))))))) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil))) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil))))))))))))))))))) ("2" (assert) nil))))))))))))))))))) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil))))) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (assert) nil))))))))))))))) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil))))) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil))))) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil)))))) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (make_divtype const-decl "DivType" polynomial_division nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (DivType type-eq-decl nil polynomial_division nil) (poly_divide def-decl "DivType" polynomial_division nil)) nil) (pseudo_div_def-3 nil 3583594681 ("" (case "FORALL (R, T: nat, g, h: [nat -> real], i, m, n: nat):
                                                  (h(m) /= 0 AND
                                                    i <= n - m AND
                                                     (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                      (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                   IMPLIES
                                                   LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                       pd = poly_divide(g, n)(h, m)(n-m-i),
                                                       qlength = length(psd`quotl),
                                                       rlength = length(psd`reml)
                                                     IN
                                                     (pd`quot =
                                                       (LAMBDA (k: nat): (1 / h(m)) ^ GG(k, n, m, n-m-i, R, T)) *
                                                        (LAMBDA (k: nat):
                                                           IF k <= pd`qdeg AND k >= pd`qdeg - qlength + 1
                                                             THEN nth(psd`quotl, k - (pd`qdeg - qlength + 1))
                                                           ELSE 0
                                                           ENDIF))
                                                      AND
                                                      pd`rem =
                                                       (LAMBDA (k: nat): (1 / h(m)) ^ HH(k, n, m, n-m-i, R, T)) *
                                                        (LAMBDA (k: nat):
                                                           IF k <= pd`rdeg AND m > 0 THEN nth(psd`reml, k)
                                                           ELSE 0
                                                           ENDIF)") (("1" (skeep) (("1" (inst - "R" "T" "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (lemma "HHGGLEM") (("1" (assert) (("1" (expand "^") (("1" (expand "*") (("1" (expand "expt") (("1" (expand "expt") (("1" (decompose-equality +) (("1" (inst?) (("1" (flatten) (("1" (assert) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (inst - "x!1") (("1" (assert) nil nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "*") (("2" (expand "length" +) (("2" (expand "length" +) (("2" (decompose-equality 2) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) (("1" (lemma "HHGGLEM") (("1" (inst?) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (replace -9 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1) (("2" (decompose-equality 2) (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (expand "*") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6 :dir rl) (("1" (replace -3 :dir rl) (("1" (lemma "HHGGLEM") (("1" (inst - "R" "T" "n-m" "m" "n" "x!1") (("1" (flatten) (("1" (hide -) (("1" (grind) (("1" (lemma "HHGGLEM") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (expand "expt") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (ground) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (lemma "HHGGLEM") (("1" (inst?) (("1" (inst - "n-m") (("1" (flatten) (("1" (hide -) (("1" (grind) (("1" (lemma "HHGGLEM") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst - "R" "T" "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "-1 - j - m + n") (("3" (replace -1) (("3" (case "NOT n-m-j = ii+1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (lemma "HHGGLEM") (("1" (inst?) (("1" (flatten) (("1" (replace -1) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -2 :dir rl) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (expand "*") (("1" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -2 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lemma "HHGGLEM") (("1" (inst - "R" "T" "ii" "m" "n" "x!1") (("1" (replace -8) (("1" (flatten) (("1" (assert) (("1" (replace -6 :dir rl) (("1" (hide -) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "HHGGLEM") (("2" (inst?) (("2" (flatten) (("2" (assert) (("2" (replace -3) (("2" (expand "pseudo_div" + 2) (("2" (assert) (("2" (expand "make_divlisttype") (("2" (expand "nth" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii" "m" "n") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (hide (-1 -2 -3 -4)) (("2" (replace -2) (("2" (assert) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (lemma "poly_divide_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (replaces -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst - "g" "h" "ii+1" "m" "n") (("2" (assert) (("2" (flatten) (("2" (replaces -4) (("2" (hide (-1 -2 -3)) (("2" (assert) (("2" (expand "*") (("2" (decompose-equality +) (("1" (replace -6) (("1" (assert) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (assert) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (case "HH(x!1, n, m, ii, R, T) = HH(x!1, n, m, 1 + ii, R, T)+1") (("1" (replaces -1) (("1" (hide -) (("1" (expand "^") (("1" (expand "expt" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "HHGGLEM") (("2" (inst?) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "1+ii" "m" "n") (("3" (assert) (("3" (flatten) (("3" (replace -3 +) (("3" (expand "max" +) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (hide-all-but (-1 +)) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (hide (-6 -7)) (("4" (skosimp*) (("4" (assert) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide (-7 -8)) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div" + 3) (("2" (expand "make_divlisttype") (("2" (assert) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (hide -1) (("1" (hide -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (replace -3) (("1" (case "length(pseudo_div(g, n)(h, m)(1 + ii)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) (("1" (expand "pseudo_div" + 5) (("1" (expand "make_divlisttype") (("1" (invoke (name "AB" "%1") (! 1 2 2 3 2 1 1)) (("1" (replaces -1) (("1" (typepred "AB") (("1" (replaces -2) (("1" (hide -3) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (lemma "HHGGLEM") (("1" (inst - "R" "T" "ii" "m" "n" "x!1") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (replace -8 +) (("1" (expand "^" +) (("1" (expand "expt" + 3) (("1" (expand "expt" + 4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (hide -) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lift-if) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) (("7" (hide -) (("7" (lift-if) (("7" (ground) (("7" (expand "pseudo_div") (("7" (expand "make_divlisttype") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (hide -) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (hide -) (("3" (assert) (("3" (expand "pseudo_div") (("3" (expand "make_divlisttype") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -) (("4" (expand "pseudo_div") (("4" (expand "make_divlisttype") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (hide -) (("5" (expand "pseudo_div") (("5" (expand "make_divlisttype") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (case "NOT x!1=ii+m") (("1" (assert) (("1" (case "FORALL (kn:nat): kn>ii-1+m AND kn<=ii+m IMPLIES kn = ii+m") (("1" (inst - "x!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "kn>=ii+m") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (case "FORALL (a1,a2:nat): a1>a2-1 IMPLIES a1>=a2") (("1" (inst - "kn" "ii+m") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but (-1 +)) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "pseudo_div_lengths") (("4" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skosimp*) (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "pseudo_div_lengths") (("3" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -8 :dir rl) (("1" (case "length(psd`reml)-1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (replace -8 1) (("2" (expand "pseudo_div" +) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (make_divtype const-decl "DivType" polynomial_division nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list type-decl nil list_adt nil) (DivType type-eq-decl nil polynomial_division nil) (poly_divide def-decl "DivType" polynomial_division nil)) nil) (pseudo_div_def-2 nil 3582990057 ("" (case "FORALL (g, h: [nat -> real], i, m, n: nat):
                                                         (h(m) /= 0 AND
                                                           i <= n - m AND
                                                            (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                                                             (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                                                          IMPLIES
                                                          LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                                                              pd = poly_divide(g, n)(h, m)(n-m-i),
                                                              qlength = length(psd`quotl),
                                                              rlength = length(psd`reml)
                                                            IN
                                                            (pd`quot =
                                                              (1 / h(m)) ^ (IF m = 0 THEN 1 ELSE i+1 ENDIF) *
                                                               (LAMBDA (j: nat):
                                                                  IF j <= pd`qdeg AND j >= pd`qdeg - qlength + 1
                                                                    THEN nth(psd`quotl, j - (pd`qdeg - qlength + 1))
                                                                  ELSE 0
                                                                  ENDIF))
                                                             AND
                                                             pd`rem =
                                                               (1/h(m))^(IF m = 0 THEN 1 ELSE i+1 ENDIF)*(LAMBDA (j: nat):
                                                                  IF j <= pd`rdeg AND m > 0 THEN nth(psd`reml, j)
                                                                  ELSE 0
                                                                  ENDIF)") (("1" (skeep) (("1" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (inst - "x!1") (("1" (assert) nil nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (decompose-equality 2) (("1" (expand "*") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1) (("2" (decompose-equality 2) (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "*") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (typepred "array2list(1+n)(g)") (("1" (inst-cp - "x!1") (("1" (replace -4 :dir rl) (("1" (inst - "n") (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (inst - "g" "h" "m" "n") (("3" (assert) (("3" (replace -3) (("3" (replace -4) (("3" (flatten) (("3" (name "ii" "n-m-(j_1+1)") (("3" (replace -1) (("3" (case "NOT n-m-j_1 = ii+1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "poly_divide" +) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "*") (("1" (expand "make_divtype") (("1" (expand "pseudo_div" +) (("1" (expand "make_divlisttype") (("1" (decompose-equality 2) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (replace -1) (("1" (assert) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -2 :dir rl) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4)) (("1" (replace -1) (("1" (assert) (("1" (name "K" "(1/h(m))^(1+j_1)") (("1" (replace -1) (("1" (case "(1/h(m))^(2+j_1) = K/h(m)") (("1" (replace -1) (("1" (decompose-equality +) (("1" (expand "poly_divide" 1) (("1" (expand "make_divtype") (("1" (replace -7 +) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (replaces -4) (("1" (hide (-1 -2 -3)) (("1" (assert) (("1" (lift-if) (("1" (expand "*") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (replaces -1) (("1" (assert) (("1" (replace -8 +) (("1" (assert) (("1" (expand "pseudo_div" + 2) (("1" (assert) (("1" (expand "make_divlisttype") (("1" (lemma "pseudo_div_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (expand "nth") (("1" (assert) (("1" (lemma "poly_divide_lengths") (("1" (inst - "g" "h" "ii+1" "m" "n") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "pseudo_div" + 2) (("1" (expand "make_divlisttype") (("1" (expand "nth" + 2) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil) nil nil) (pseudo_div_def-1 nil 3582647859 ("" (case "FORALL (g, h: [nat -> real], i, m, n: nat):
               (h(m) /= 0 AND
                 i <= n - m AND
                  (FORALL (ii: nat): ii > n IMPLIES g(ii) = 0) AND
                   (FORALL (ii: nat): ii > m IMPLIES h(ii) = 0))
                IMPLIES
                LET psd = pseudo_div(g, n)(h, m)(n-m-i),
                    pd = poly_divide(g, n)(h, m)(n-m-i),
                    qlength = length(psd`quotl),
                    rlength = length(psd`reml)
                  IN
                  (pd`quot =
                    (1 / h(m)) ^ (i + 1) *
                     (LAMBDA (j: nat):
                        IF j <= pd`qdeg AND j >= pd`qdeg - qlength + 1
                          THEN nth(psd`quotl, j - (pd`qdeg - qlength + 1))
                        ELSE 0
                        ENDIF))
                   AND
                   pd`rem =
                    (1 / h(m)) ^ (i + 1) *
                     (LAMBDA (j: nat):
                        IF j <= pd`rdeg AND m > 0 THEN nth(psd`reml, j)
                        ELSE 0
                        ENDIF)") (("1" (skeep) (("1" (inst - "g" "h" "n-m-i" "m" "n") (("1" (assert) (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep) (("2" (assert) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "poly_divide") (("1" (lift-if) (("1" (expand "make_divtype") (("1" (expand "make_divlisttype") (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (decompose-equality +) (("1" (expand "*") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (typepred "array2list(1+n)(g)") (("1" (hide -1) (("1" (inst - "x!1") (("1" (assert) nil nil) ("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (decompose-equality 2) (("1" (expand "*") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "nth" + 1) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (decompose-equality 2) (("1" (expand "poly_divide" +) (("1" (expand "make_divtype") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (assert) (("1" (expand "*") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (invoke (name "AA" "%1") (! 1 2 2 1)) (("1" (replace -1) (("1" (typepred "AA") (("1" (inst - "x!1") (("1" (lift-if) (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "x!1") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (replace -6 :dir rl) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil) nil shostak)) (poly_pseudo_remainder_def_TCC1 0 (poly_pseudo_remainder_def_TCC1-1 nil 3583669888 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (poly_pseudo_remainder_def subtype "polynomial_pseudo_divide.k" "below[length[int](psd`reml)]"))) (poly_pseudo_remainder_def 0 (poly_pseudo_remainder_def-1 nil 3583669890 ("" (skeep) (("" (skoletin 2) (("" (skoletin 1) (("" (skoletin 1) (("" (skoletin 1) (("" (lemma "pseudo_div_def") (("" (inst?) (("" (inst - "1" "1") (("" (assert) (("" (replace -7) (("" (replace -8) (("" (replace -4 :dir rl) (("" (replace -5 :dir rl) (("" (replace -3 :dir rl) (("" (case "NOT psd`rdegl = pd`rdeg") (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1) (("2" (flatten) (("2" (hide -2) (("2" (replace -2 +) (("2" (expand "*") (("2" (decompose-equality +) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "HH") (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "pd`rdeg = m-1") (("1" (assert) nil nil) ("2" (expand "pd" 1) (("2" (expand "poly_divide" 1) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (case "length(pseudo_div(g, n)(h, m)(0)`reml) - 1>=0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (expand "pseudo_div" 1) (("2" (expand "make_divlisttype") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (list type-decl nil list_adt nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivType type-eq-decl nil polynomial_division nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil) (poly_divide def-decl "DivType" polynomial_division nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[T -> real]" real_fun_ops reals) (^ const-decl "real" exponentiation nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (pseudo_div_def formula-decl nil polynomial_pseudo_divide nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (* const-decl "[T -> real]" real_fun_ops reals) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (max_npreal_0 formula-decl nil min_max reals) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (int_times_int_is_int application-judgement "int" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_divtype const-decl "DivType" polynomial_division nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (pd skolem-const-decl "DivType" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (psd skolem-const-decl "{DT: DivListType |
   (m > n OR 0 > n - m AND length(DT`reml) = 1 + n AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m AND length(DT`reml) = 1 + DT`rdegl)}" polynomial_pseudo_divide nil) (HH const-decl "int" polynomial_pseudo_divide nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (adjusted_remainder_TCC1 0 (adjusted_remainder_TCC1-1 nil 3593448570 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (lift-if) (("" (ground) (("1" (replace -2) (("1" (assert) (("1" (expand "divides") (("1" (inst + "-nth[int](nonzero_version(primitize_list(thisrem)), ii)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -2) (("2" (expand "divides") (("2" (inst + "-nth[int](nonzero_version(primitize_list(thisrem)), ii)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replaces -2) (("3" (expand "divides") (("3" (inst + "-nth[int](nonzero_version(primitize_list(thisrem)), ii)") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (replaces -1) (("4" (expand "divides") (("4" (assert) (("4" (inst + "nth[int](nonzero_version(primitize_list(thisrem)), ii)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "below(m)" mod nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (primitize_list const-decl "list[int]" gcd_coeff nil) (int_times_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (TRUE const-decl "bool" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil)) nil (adjusted_remainder subtype "(number_fields.-)(polynomial_pseudo_divide.pseudosign)" "{k: integers.nzint | FORALL (ii: naturalnumbers.nat): booleans.IMPLIES(reals.<(ii, list_props[int].length(gcd_coeff.nonzero_version(gcd_coeff.primitize_list(polynomial_pseudo_divide.thisrem)))), divides.divides(k, list_props[int].nth(gcd_coeff.nonzero_version(gcd_coeff.primitize_list(polynomial_pseudo_divide.thisrem)), ii)))}"))) (adjusted_remainder_def_TCC1 0 (adjusted_remainder_def_TCC1-1 nil 3593450591 ("" (subtype-tcc) nil nil) ((odd_minus_even_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (/= const-decl "boolean" notequal nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (adjusted_remainder const-decl "list[int]" polynomial_pseudo_divide nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (adjusted_remainder_def subtype "polynomial_pseudo_divide.i" "below[length[int](thisrem)]"))) (adjusted_remainder_def 0 (adjusted_remainder_def-5 "" 3884450660 ("" (skeep) (("" (case "m > n") (("1" (case "FORALL (i:nat): i<=n IMPLIES g(i)=0") (("1" (assert) (("1" (flatten) (("1" (hide (-3 -4 +)) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (rewrite "primitize_zero_list") (("1" (typepred "array2list[int](1+n)(g)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "array2list[int]
                                            (1 + n)(LAMBDA (i: nat): 0)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3)) (("1" (hide (-2 -3)) (("1" (skosimp*) (("1" (typepred "i!1") (("1" (typepred "array2list[int](1 + n)(LAMBDA (i: nat): 0)") (("1" (hide (-1 -2)) (("1" (inst - "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "array2list(1 + n)(g)") (("2" (inst - "i") (("1" (assert) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "gzero" 1) (("2" (hide "gzero") (("2" (assert) (("2" (expand "adjusted_remainder") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (flatten) (("2" (split +) (("1" (name "gp" "gcd_coeff(array2list(1+n)(g))") (("1" (case "gp > 0") (("1" (name "cp" "1/gp") (("1" (case "cp > 0") (("1" (label "cpname" -2) (("1" (hide "cpname") (("1" (hide -2) (("1" (inst + "cp") (("1" (label "cppos" -1) (("1" (hide "cppos") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version
                                                             (primitize_list
                                                              (array2list(1 + n)(g))),
                                                             -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (decompose-equality) (("1" (lemma "poly_eq") (("1" (inst?) (("1" (replace 1) (("1" (hide 2) (("1" (split 1) (("1" (skeep) (("1" (assert) (("1" (expand "min" -1) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -6 "ii") (("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (case "g(ii) = 0") (("1" (assert) (("1" (expand "*" +) (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-2 -3)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "ii") (("1" (replaces -3 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT ii<=n") (("1" (assert) nil nil) ("2" (inst + "ii") (("2" (assert) (("2" (flatten) (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "ii") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (typepred "descalarize_list(nonzero_version
                                                                     (primitize_list
                                                                      (array2list(1 + n)(g))),
                                                                     -1)") (("2" (hide (-1 -2)) (("2" (inst - "ii") (("2" (mult-by -1 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (expand "*") (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -2 "ii") (("2" (assert) (("2" (replaces -2 :dir rl) (("2" (hide (-1 -2 -3 -4)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "ii") (("1" (replaces -1 :dir rl) (("1" (replace -3 2) (("1" (expand "cp" 2) (("1" (expand "gp" 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (hide (-1 -3 -4)) (("2" (skolem -1 "kv") (("2" (assert) (("2" (lemma "primitize_list_def") (("2" (expand "primitize_list" -2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (inst + "kv") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(array2list(1 + n)(g),
                                                     gcd_coeff(array2list(1 + n)(g)))") (("2" (inst - "kv") (("1" (assert) (("1" (inst + "kv") (("1" (flatten) (("1" (replace -5) (("1" (assert) (("1" (lemma "nzreal_times_nzreal_is_nzreal") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "kv") (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                                 ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                              (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                               ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cp" 1) (("2" (cross-mult 1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "gzero") (("2" (skeep) (("2" (inst + "i") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                           (array2list(1 + n)(g))),
                           -1)") (("2" (replace -2) (("2" (inst - "length[int]
              (nonzero_version(primitize_list(array2list(1 + n)(g))))
           - 1") (("2" (mult-by -3 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (hide (-1 -2)) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1+n)(g))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT n>=m") (("1" (assert) nil nil) ("2" (copy -3) (("2" (copy -3) (("2" (hide -4) (("2" (hide -4) (("2" (hide 1) (("2" (case "m = 0") (("1" (assert) (("1" (case "NOT pseudo_div(g,n)(h,0)(0)`reml = null[int]") (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (case "NOT adjusted_remainder(g,n)(h,m) = null[int]") (("1" (hide 3) (("1" (expand "adjusted_remainder" 1) (("1" (case "NOT primitize_list
                                                                                                                                                       (pseudo_div
                                                                                                                                                        (g, n)(h, m)(0)`reml) = null[int]") (("1" (hide 2) (("1" (expand "primitize_list" 1) (("1" (lift-if) (("1" (ground) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (expand "gcd_coeff") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "nonzero_version" 1) (("2" (expand "reverse" + 2) (("2" (expand "nonzero_version_rec") (("2" (expand "reverse") (("2" (expand "descalarize_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (label "ip1" -1) (("2" (label "mn" -3) (("2" (label "ip2" -2) (("2" (skoletin 2) (("2" (label "thisremdef" -1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (flatten) (("2" (case "NOT LET ppde = pseudo_div(g, n)(h, m)(0) IN EXISTS (i: below(length[int](ppde`reml))): nth[int](ppde`reml, i) /= 0") (("1" (hide 2) (("1" (assert) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (invoke (typepred "%1") (! -1 1 1 1)) (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                                                   (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3 -5 -6)) (("1" (skeep) (("1" (inst + "i") (("1" (flatten) (("1" (expand "primitize_list" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (invoke (typepred "%1") (! 3 1 1)) (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (assert) (("2" (replace -2) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (hide -2) (("2" (expand "primitize_list" -1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "nonzeep" -1) (("2" (hide "nonzeep") (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (lemma "poly_pseudo_remainder_def") (("1" (inst?) (("1" (assert) (("1" (replace "ip1") (("1" (replace "ip2") (("1" (replace -5 :dir rl) (("1" (name "ppd" "pseudo_div(g, n)(h, m)(0)") (("1" (replace -1) (("1" (copy "thisremdef") (("1" (expand "adjusted_remainder" -1) (("1" (name "psign" "IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN 1
                                                                                               ELSE -1
                                                                                               ENDIF") (("1" (invoke (case "-psign = %1") (! -2 2 2)) (("1" (replace -1 :dir rl) (("1" (replace -4) (("1" (invoke (name "AA" "%1") (! -3 2 1)) (("1" (replace -1) (("1" (typepred "descalarize_list(AA, psign)") (("1" (hide (-1 -2)) (("1" (case "EXISTS (cp: posreal):
                                                                                                                                                               polynomial(thispoly, thisdeg) = polynomial(-cp*psign*h(m)^(1-m+n) * pd`rem, pd`rdeg)") (("1" (skeep) (("1" (inst + "cp * psign * h(m) ^ (1 - m + n)") (("1" (assert) nil nil) ("2" (case "NOT h(m) ^ (1 - m + n) * psign > 0") (("1" (hide-all-but (-4 1 3)) (("1" (lift-if) (("1" (ground) (("1" (lemma "posreal_expt") (("1" (expand "^") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "mod_0_divides") (("2" (inst?) (("2" (assert) (("2" (expand "divides") (("2" (skeep) (("2" (replace -1) (("2" (case "x<=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "x" "x" "h(m)") (("2" (case "sq(h(m)^x)>0") (("1" (expand "sq") (("1" (assert) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "even_or_odd") (("3" (inst - "1-m+n") (("3" (flatten) (("3" (hide -1) (("3" (split -) (("1" (rewrite "mod_0_divides") (("1" (expand "divides") (("1" (expand "even?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "odd?") (("2" (skeep) (("2" (case "NOT n = m + 2*j") (("1" (assert) nil nil) ("2" (hide -2) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (lemma "negreal_times_negreal_is_posreal") (("2" (inst - "h(m)" "-(h(m)^(2*j))") (("1" (expand "^") (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil) ("2" (case "h(m)^(2*j)>0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "j" "j" "h(m)") (("2" (assert) (("2" (replaces -1) (("2" (case "sq(h(m)^j)>0") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "j = 0") (("1" (replaces -1) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (mult-by -1 "cp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "PP" "(LAMBDA (k: nat):
                                                                                                                                                                             IF k <= ppd`rdegl AND m > 0 THEN nth(ppd`reml, k) ELSE 0 ENDIF)") (("1" (replace -1) (("1" (replace -8 +) (("1" (case "NOT pd`rdeg = ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (name "DD" "(-psign*PP)") (("2" (case "EXISTS (cp: posreal):
                                                                                                                                                                                                                  polynomial(thispoly, thisdeg) =
                                                                                                                                                                                                                   polynomial(cp * DD,
                                                                                                                                                                                                                              ppd`rdegl)") (("1" (skeep) (("1" (inst + "cp") (("1" (assert) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (lemma "poly_eq_le_degree") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (expand "*") (("1" (expand "DD") (("1" (case "h(m) ^ (1 - m + n) * (1 / h(m)) ^ (1 - m + n) = 1") (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "div_expt") (("2" (inst - "1-m+n" "1" "h(m)") (("2" (assert) (("2" (lemma "expt_1n_aux") (("2" (inst - "1-m+n") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA2" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (hide (-1 -2 -3)) (("2" (case "NOT thisdeg <= ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -9) (("1" (replace -2) (("1" (hide (-1 -2)) (("1" (expand "thisdeg" 1) (("1" (case "length[int](thisrem) <= length[int](ppd`reml)") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (name "AA1" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (lemma "thisrem") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (typepred "%1") (! -1 2)) (("1" (replace -4 :dir rl) (("1" (replaces -2) (("1" (hide (-1 -2 -3)) (("1" (lemma "nonzero_version_def") (("1" (replace -7) (("1" (inst - "primitize_list(ppd`reml)") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3 -4 -5 -6)) (("1" (assert) (("1" (case "length[int](primitize_list(ppd`reml)) = length[int](ppd`reml)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "primitize_list") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA3" "1") (("2" (hide -1) (("2" (expand "DD" 1) (("2" (case "(FORALL (i:nat): i>thisdeg AND i<=ppd`rdegl IMPLIES PP(i)=0) AND (EXISTS (cp:posreal): FORALL (i:nat): i<=thisdeg IMPLIES thispoly(i)=(-cp*psign)*PP(i))") (("1" (flatten) (("1" (skeep) (("1" (inst + "cp") (("1" (expand "polynomial" 1) (("1" (decompose-equality 1) (("1" (lemma "sigma_split") (("1" (invoke (inst - "%1" "ppd`rdegl" "0" "thisdeg") (! 1 2 3)) (("1" (assert) (("1" (invoke (case "%1 = 0") (! -1 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "sigma_eq") (("1" (skeep) (("1" (inst -2 "n!1") (("1" (assert) (("1" (expand "*") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "sigma_restrict_eq_0") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA4" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (split +) (("1" (skeep) (("1" (expand "PP" 1) (("1" (lift-if) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (copy -3) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (assert) (("1" (invoke (case "%1 = -psign") (! -1 1 1 1 2)) (("1" (replace -1) (("1" (replace -11) (("1" (replace -7) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -3)) (("1" (replaces -1 -3) (("1" (case "NOT i>=length[int](AA)") (("1" (assert) nil nil) ("2" (name "AA5" "-1") (("2" (hide -1) (("2" (name "pl" "primitize_list(ppd`reml)") (("2" (replace -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "pl") (("2" (replace -10) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (case "i < length[int](pl)") (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "AA6" -1) (("2" (hide -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "length(ppd`reml)>0") (("1" (expand "max" -3) (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst?) (("1" (assert) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "PP") (("2" (lemma "primitize_list_def") (("2" (inst?) (("2" (replace -8) (("2" (assert) (("2" (invoke (case "%1") (! -1 1)) (("1" (replace -1) (("1" (assert) (("1" (flatten) (("1" (inst + "1/gcd_coeff(ppd`reml)") (("1" (assert) (("1" (skeep) (("1" (expand "thispoly" 1) (("1" (assert) (("1" (expand "PP" 1) (("1" (reveal "mzero") (("1" (assert) (("1" (inst - "i") (("1" (expand "thisrem" 2) (("1" (expand "adjusted_remainder" 2) (("1" (replace -13) (("1" (case "NOT  IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN -1
                                                                                                                                                                                                      ELSE --1
                                                                                                                                                                                                      ENDIF = -psign") (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                                                                                                                                                                                                                               -psign)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (mult-by -1 "-psign") (("2" (case "psign*psign=1") (("1" (invoke (mult-by -1 "%1") (! -2 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 + :dir rl) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(ppd`reml)") (("1" (replace -11) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -2 + :dir rl) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -3 +) (("1" (hide -) (("1" (real-props) (("1" (case "nth[int](primitize_list(ppd`reml), i) =
                                                                                                                                                                                                 gcd_coeff(ppd`reml) * nth[int](primitize_list(ppd`reml), i) *
                                                                                                                                                                                                  (1 / gcd_coeff(ppd`reml))") (("1" (assert) (("1" (mult-by -1 "-psign") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8 -9)) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (typepred "gcd_coeff(ppd`reml)") (("1" (lemma "gcd_coeff_nonzero") (("1" (inst?) (("1" (assert) (("1" (reveal "nonzeep") (("1" (assert) (("1" (skeep) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gcd_coeff_nonzero") (("3" (inst?) (("3" (assert) (("3" (reveal "nonzeep") (("3" (assert) (("3" (skeep -1) (("3" (inst + "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i") (("1" (flatten) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -2)) (("1" (inst - "i") (("1" (case "NOT nth[int](AA,i)=0") (("1" (assert) nil nil) ("2" (hide -2) (("2" (expand "AA" -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -7) (("2" (assert) (("2" (flatten) (("2" (inst - "i") (("2" (assert) (("2" (split -2) (("1" (invoke (case "%1 = 0") (! -1 1)) (("1" (expand "primitize_list" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(ppd`reml, gcd_coeff(ppd`reml))") (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (replace -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -6) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "thisrem" 1) (("2" (expand "adjusted_remainder" 1) (("2" (replace -8) (("2" (replace -4) (("2" (replace -5 1 :dir rl) (("2" (typepred "descalarize_list(AA,-psign)") (("2" (replace -2) (("2" (assert) (("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -8) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -12) (("2" (case "length(ppd`reml)>0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split 1) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) (("1" (expand "divides") (("1" (inst + "nth[int](AA,ii)") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "divides") (("2" (inst + "nth[int](AA,ii)") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "divides") (("3" (inst + "-nth[int](AA,ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (label "answer" 1) (("2" (expand "thispoly" "answer") (("2" (expand "thisdeg" -3) (("2" (copy "thisremdef") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (name "psign" "%1") (! -1 2 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                                        (g, n)(h, m)(0)") (("2" (replace -1) (("2" (name "AA" "nonzero_version(primitize_list(ppd`reml))") (("2" (replace -1) (("2" (case "nth(AA,length[int](AA)-1)/=0") (("1" (flatten) (("1" (case "NOT length[int](AA) = length[int](thisrem)") (("1" (assert) nil nil) ("2" (replace -1 +) (("2" (expand "AA" 1) (("2" (replace -4 "answer") (("2" (typepred "descalarize_list(AA,psign)") (("2" (hide (-1 -2)) (("2" (inst - "length[int](thisrem)-1") (("1" (replace -5 :dir rl) (("1" (replace "answer") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -2) (("2" (assert) (("2" (flatten) (("2" (split -3) (("1" (assert) nil nil) ("2" (reveal "nonzeep") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (adjusted_remainder_def-4 "" 3790098733 ("" (skeep) (("" (case "m > n") (("1" (case "FORALL (i:nat): i<=n IMPLIES g(i)=0") (("1" (assert) (("1" (flatten) (("1" (hide (-3 -4 +)) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (rewrite "primitize_zero_list") (("1" (typepred "array2list[int](1+n)(g)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "array2list[int]
                                            (1 + n)(LAMBDA (i: nat): 0)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3)) (("1" (hide (-2 -3)) (("1" (skosimp*) (("1" (typepred "i!1") (("1" (typepred "array2list[int](1 + n)(LAMBDA (i: nat): 0)") (("1" (hide (-1 -2)) (("1" (inst - "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "array2list(1 + n)(g)") (("2" (inst - "i") (("1" (assert) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "gzero" 1) (("2" (hide "gzero") (("2" (assert) (("2" (expand "adjusted_remainder") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (flatten) (("2" (split +) (("1" (name "gp" "gcd_coeff(array2list(1+n)(g))") (("1" (case "gp > 0") (("1" (name "cp" "1/gp") (("1" (case "cp > 0") (("1" (label "cpname" -2) (("1" (hide "cpname") (("1" (hide -2) (("1" (inst + "cp") (("1" (label "cppos" -1) (("1" (hide "cppos") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version
                                                             (primitize_list
                                                              (array2list(1 + n)(g))),
                                                             -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (decompose-equality) (("1" (lemma "poly_eq") (("1" (inst?) (("1" (replace 1) (("1" (hide 2) (("1" (split 1) (("1" (skeep) (("1" (assert) (("1" (expand "min" -1) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -6 "ii") (("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (case "g(ii) = 0") (("1" (assert) (("1" (expand "*" +) (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-2 -3)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "ii") (("1" (replaces -3 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT ii<=n") (("1" (assert) nil nil) ("2" (inst + "ii") (("2" (assert) (("2" (flatten) (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "ii") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (typepred "descalarize_list(nonzero_version
                                                                     (primitize_list
                                                                      (array2list(1 + n)(g))),
                                                                     -1)") (("2" (hide (-1 -2)) (("2" (inst - "ii") (("2" (mult-by -1 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (expand "*") (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -2 "ii") (("2" (assert) (("2" (replaces -2 :dir rl) (("2" (hide (-1 -2 -3 -4)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "ii") (("1" (replaces -1 :dir rl) (("1" (replace -3 2) (("1" (expand "cp" 2) (("1" (expand "gp" 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (hide (-1 -3 -4)) (("2" (skolem -1 "kv") (("2" (assert) (("2" (lemma "primitize_list_def") (("2" (expand "primitize_list" -2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (inst + "kv") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(array2list(1 + n)(g),
                                                     gcd_coeff(array2list(1 + n)(g)))") (("2" (inst - "kv") (("1" (assert) (("1" (inst + "kv") (("1" (flatten) (("1" (replace -5) (("1" (assert) (("1" (lemma "nzreal_times_nzreal_is_nzreal") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "kv") (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                                 ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                              (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                               ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cp" 1) (("2" (cross-mult 1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "gzero") (("2" (skeep) (("2" (inst + "i") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                           (array2list(1 + n)(g))),
                           -1)") (("2" (replace -2) (("2" (inst - "length[int]
              (nonzero_version(primitize_list(array2list(1 + n)(g))))
           - 1") (("2" (mult-by -3 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (hide (-1 -2)) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1+n)(g))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT n>=m") (("1" (assert) nil nil) ("2" (copy -3) (("2" (copy -3) (("2" (hide -4) (("2" (hide -4) (("2" (hide 1) (("2" (case "m = 0") (("1" (assert) (("1" (case "NOT pseudo_div(g,n)(h,0)(0)`reml = null[int]") (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (case "NOT adjusted_remainder(g,n)(h,m) = null[int]") (("1" (hide 3) (("1" (expand "adjusted_remainder" 1) (("1" (case "NOT primitize_list
                                                                                                                                                       (pseudo_div
                                                                                                                                                        (g, n)(h, m)(0)`reml) = null[int]") (("1" (hide 2) (("1" (expand "primitize_list" 1) (("1" (lift-if) (("1" (ground) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (expand "gcd_coeff") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "nonzero_version" 1) (("2" (expand "reverse" + 2) (("2" (expand "nonzero_version_rec") (("2" (expand "reverse") (("2" (expand "descalarize_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (label "ip1" -1) (("2" (label "mn" -3) (("2" (label "ip2" -2) (("2" (skoletin 2) (("2" (label "thisremdef" -1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (flatten) (("2" (case "NOT LET ppde = pseudo_div(g, n)(h, m)(0) IN EXISTS (i: below(length[int](ppde`reml))): nth[int](ppde`reml, i) /= 0") (("1" (hide 2) (("1" (assert) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (invoke (typepred "%1") (! -1 1 1 1)) (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                                                   (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3 -5 -6)) (("1" (skeep) (("1" (inst + "i") (("1" (flatten) (("1" (expand "primitize_list" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (invoke (typepred "%1") (! 3 1 1)) (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (assert) (("2" (replace -2) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (hide -2) (("2" (expand "primitize_list" -1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "nonzeep" -1) (("2" (hide "nonzeep") (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (lemma "poly_pseudo_remainder_def") (("1" (inst?) (("1" (assert) (("1" (replace "ip1") (("1" (replace "ip2") (("1" (replace -5 :dir rl) (("1" (name "ppd" "pseudo_div(g, n)(h, m)(0)") (("1" (replace -1) (("1" (copy "thisremdef") (("1" (expand "adjusted_remainder" -1) (("1" (name "psign" "IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN 1
                                                                                               ELSE -1
                                                                                               ENDIF") (("1" (invoke (case "-psign = %1") (! -2 2 2)) (("1" (replace -1 :dir rl) (("1" (replace -4) (("1" (invoke (name "AA" "%1") (! -3 2 1)) (("1" (replace -1) (("1" (typepred "descalarize_list(AA, psign)") (("1" (hide (-1 -2)) (("1" (case "EXISTS (cp: posreal):
                                                                                                                                                               polynomial(thispoly, thisdeg) = polynomial(-cp*psign*h(m)^(1-m+n) * pd`rem, pd`rdeg)") (("1" (skeep) (("1" (inst + "cp * psign * h(m) ^ (1 - m + n)") (("1" (assert) nil nil) ("2" (case "NOT h(m) ^ (1 - m + n) * psign > 0") (("1" (hide-all-but (-4 1 3)) (("1" (lift-if) (("1" (ground) (("1" (lemma "posreal_expt") (("1" (expand "^") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "mod_0_divides") (("2" (inst?) (("2" (assert) (("2" (expand "divides") (("2" (skeep) (("2" (replace -1) (("2" (case "x<=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "x" "x" "h(m)") (("2" (case "sq(h(m)^x)>0") (("1" (expand "sq") (("1" (assert) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "even_or_odd") (("3" (inst - "1-m+n") (("3" (flatten) (("3" (hide -1) (("3" (split -) (("1" (rewrite "mod_0_divides") (("1" (expand "divides") (("1" (expand "even?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "odd?") (("2" (skeep) (("2" (case "NOT n = m + 2*j") (("1" (assert) nil nil) ("2" (hide -2) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (lemma "negreal_times_negreal_is_posreal") (("2" (inst - "h(m)" "-(h(m)^(2*j))") (("1" (expand "^") (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil) ("2" (case "h(m)^(2*j)>0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "j" "j" "h(m)") (("2" (assert) (("2" (replaces -1) (("2" (case "sq(h(m)^j)>0") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "j = 0") (("1" (replaces -1) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (mult-by -1 "cp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "PP" "(LAMBDA (k: nat):
                                                                                                                                                                             IF k <= ppd`rdegl AND m > 0 THEN nth(ppd`reml, k) ELSE 0 ENDIF)") (("1" (replace -1) (("1" (replace -8 +) (("1" (case "NOT pd`rdeg = ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (name "DD" "(-psign*PP)") (("2" (case "EXISTS (cp: posreal):
                                                                                                                                                                                                                  polynomial(thispoly, thisdeg) =
                                                                                                                                                                                                                   polynomial(cp * DD,
                                                                                                                                                                                                                              ppd`rdegl)") (("1" (skeep) (("1" (inst + "cp") (("1" (assert) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (lemma "poly_eq_le_degree") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (expand "*") (("1" (expand "DD") (("1" (case "h(m) ^ (1 - m + n) * (1 / h(m)) ^ (1 - m + n) = 1") (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "div_expt") (("2" (inst - "1-m+n" "1" "h(m)") (("2" (assert) (("2" (lemma "expt_1n_aux") (("2" (inst - "1-m+n") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA2" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (hide (-1 -2 -3)) (("2" (case "NOT thisdeg <= ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -9) (("1" (replace -2) (("1" (hide (-1 -2)) (("1" (expand "thisdeg" 1) (("1" (case "length[int](thisrem) <= length[int](ppd`reml)") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (name "AA1" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (lemma "thisrem") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (typepred "%1") (! -1 2)) (("1" (replace -4 :dir rl) (("1" (replaces -2) (("1" (hide (-1 -2 -3)) (("1" (lemma "nonzero_version_def") (("1" (replace -7) (("1" (inst - "primitize_list(ppd`reml)") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3 -4 -5 -6)) (("1" (assert) (("1" (case "length[int](primitize_list(ppd`reml)) = length[int](ppd`reml)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "primitize_list") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA3" "1") (("2" (hide -1) (("2" (expand "DD" 1) (("2" (case "(FORALL (i:nat): i>thisdeg AND i<=ppd`rdegl IMPLIES PP(i)=0) AND (EXISTS (cp:posreal): FORALL (i:nat): i<=thisdeg IMPLIES thispoly(i)=(-cp*psign)*PP(i))") (("1" (flatten) (("1" (skeep) (("1" (inst + "cp") (("1" (expand "polynomial" 1) (("1" (decompose-equality 1) (("1" (lemma "sigma_split") (("1" (invoke (inst - "%1" "ppd`rdegl" "0" "thisdeg") (! 1 2 3)) (("1" (assert) (("1" (invoke (case "%1 = 0") (! -1 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "sigma_eq") (("1" (skeep) (("1" (inst -2 "n!1") (("1" (assert) (("1" (expand "*") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "sigma_restrict_eq_0") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA4" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (split +) (("1" (skeep) (("1" (expand "PP" 1) (("1" (lift-if) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (copy -3) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (assert) (("1" (invoke (case "%1 = -psign") (! -1 1 1 1 2)) (("1" (replace -1) (("1" (replace -11) (("1" (replace -7) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -3)) (("1" (replaces -1 -3) (("1" (case "NOT i>=length[int](AA)") (("1" (assert) nil nil) ("2" (name "AA5" "-1") (("2" (hide -1) (("2" (name "pl" "primitize_list(ppd`reml)") (("2" (replace -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "pl") (("2" (replace -10) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (case "i < length[int](pl)") (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "AA6" -1) (("2" (hide -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "length(ppd`reml)>0") (("1" (expand "max" -3) (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst?) (("1" (assert) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "PP") (("2" (lemma "primitize_list_def") (("2" (inst?) (("2" (replace -8) (("2" (assert) (("2" (invoke (case "%1") (! -1 1)) (("1" (replace -1) (("1" (assert) (("1" (flatten) (("1" (inst + "1/gcd_coeff(ppd`reml)") (("1" (assert) (("1" (skeep) (("1" (expand "thispoly" 1) (("1" (assert) (("1" (expand "PP" 1) (("1" (reveal "mzero") (("1" (assert) (("1" (inst - "i") (("1" (expand "thisrem" 2) (("1" (expand "adjusted_remainder" 2) (("1" (replace -13) (("1" (case "NOT  IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN -1
                                                                                                                                                                                                      ELSE --1
                                                                                                                                                                                                      ENDIF = -psign") (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (propax) nil nil)) nil)) nil) ("2" (replace -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                                                                                                                                                                                                                               -psign)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (mult-by -1 "-psign") (("2" (case "psign*psign=1") (("1" (invoke (mult-by -1 "%1") (! -2 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 + :dir rl) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(ppd`reml)") (("1" (replace -11) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -2 + :dir rl) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -3 +) (("1" (hide -) (("1" (real-props) (("1" (case "nth[int](primitize_list(ppd`reml), i) =
                                                                                                                                                                                                 gcd_coeff(ppd`reml) * nth[int](primitize_list(ppd`reml), i) *
                                                                                                                                                                                                  (1 / gcd_coeff(ppd`reml))") (("1" (assert) (("1" (mult-by -1 "-psign") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8 -9)) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (typepred "gcd_coeff(ppd`reml)") (("1" (lemma "gcd_coeff_nonzero") (("1" (inst?) (("1" (assert) (("1" (reveal "nonzeep") (("1" (assert) (("1" (skeep) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gcd_coeff_nonzero") (("3" (inst?) (("3" (assert) (("3" (reveal "nonzeep") (("3" (assert) (("3" (skeep -1) (("3" (inst + "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i") (("1" (flatten) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -2)) (("1" (inst - "i") (("1" (case "NOT nth[int](AA,i)=0") (("1" (assert) nil nil) ("2" (hide -2) (("2" (expand "AA" -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -7) (("2" (assert) (("2" (flatten) (("2" (inst - "i") (("2" (assert) (("2" (split -2) (("1" (invoke (case "%1 = 0") (! -1 1)) (("1" (expand "primitize_list" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(ppd`reml, gcd_coeff(ppd`reml))") (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (replace -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -6) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "thisrem" 1) (("2" (expand "adjusted_remainder" 1) (("2" (replace -8) (("2" (replace -4) (("2" (replace -5 1 :dir rl) (("2" (typepred "descalarize_list(AA,-psign)") (("2" (replace -2) (("2" (assert) (("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -8) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -12) (("2" (case "length(ppd`reml)>0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split 1) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) (("1" (expand "divides") (("1" (inst + "nth[int](AA,ii)") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "divides") (("2" (inst + "nth[int](AA,ii)") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "divides") (("3" (inst + "-nth[int](AA,ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (label "answer" 1) (("2" (expand "thispoly" "answer") (("2" (expand "thisdeg" -3) (("2" (copy "thisremdef") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (name "psign" "%1") (! -1 2 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                                        (g, n)(h, m)(0)") (("2" (replace -1) (("2" (name "AA" "nonzero_version(primitize_list(ppd`reml))") (("2" (replace -1) (("2" (case "nth(AA,length[int](AA)-1)/=0") (("1" (flatten) (("1" (case "NOT length[int](AA) = length[int](thisrem)") (("1" (assert) nil nil) ("2" (replace -1 +) (("2" (expand "AA" 1) (("2" (replace -4 "answer") (("2" (typepred "descalarize_list(AA,psign)") (("2" (hide (-1 -2)) (("2" (inst - "length[int](thisrem)-1") (("1" (replace -5 :dir rl) (("1" (replace "answer") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -2) (("2" (assert) (("2" (flatten) (("2" (split -3) (("1" (assert) nil nil) ("2" (reveal "nonzeep") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (reverse def-decl "list[T]" list_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (DivType type-eq-decl nil polynomial_division nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (thisrem skolem-const-decl "list[int]" polynomial_pseudo_divide nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "below(m)" mod nil) (h skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (i skolem-const-decl "below(length[int](primitize_list(pseudo_div(g, n)(h, m)(0)`reml)))" polynomial_pseudo_divide nil) (ii skolem-const-decl "nat" polynomial_pseudo_divide nil) (ii skolem-const-decl "nat" polynomial_pseudo_divide nil) (thisdeg skolem-const-decl "int" polynomial_pseudo_divide nil) (AA skolem-const-decl "list[int]" polynomial_pseudo_divide nil) (int_times_even_is_even application-judgement "even_int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (poly_eq_le_degree formula-decl nil polynomials reals) (div_expt formula-decl nil exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (rat_expt application-judgement "rat" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt_1n_aux formula-decl nil exponentiation nil) (DD skolem-const-decl "[nat -> real]" polynomial_pseudo_divide nil) (uint8 type-eq-decl nil integertypes nil) (AA skolem-const-decl "list[int]" polynomial_pseudo_divide nil) (i skolem-const-decl "below(length[int](pseudo_div(g, n)(h, m)(0)`reml))" polynomial_pseudo_divide nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (thispoly skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (negint_times_negint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ppd skolem-const-decl "{DT: DivListType |
   (m > n OR 0 > n - m AND length(DT`reml) = 1 + n AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m AND length(DT`reml) = 1 + DT`rdegl)}" polynomial_pseudo_divide nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (max_npreal_0 formula-decl nil min_max reals) (PP skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_eq formula-decl nil sigma reals) (subrange type-eq-decl nil integers nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_split formula-decl nil sigma reals) (ii!1 skolem-const-decl "nat" polynomial_pseudo_divide nil) (ii!1 skolem-const-decl "nat" polynomial_pseudo_divide nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (int8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (even_or_odd formula-decl nil naturalnumbers nil) (even? const-decl "bool" integers nil) (negreal_times_negreal_is_posreal judgement-tcc nil real_types nil) (int_exp application-judgement "int" exponentiation nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (expt def-decl "real" exponentiation nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (j skolem-const-decl "int" polynomial_pseudo_divide nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (odd? const-decl "bool" integers nil) (mod_0_divides formula-decl nil mod_lems ints) (expt_plus formula-decl nil exponentiation nil) (sq const-decl "nonneg_real" sq reals) (expt_eq_0 formula-decl nil exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (sq_eq_0 formula-decl nil sq reals) (posreal_expt judgement-tcc nil exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (psign skolem-const-decl "int" polynomial_pseudo_divide nil) (cp skolem-const-decl "posreal" polynomial_pseudo_divide nil) (rat_exp application-judgement "rat" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (poly_pseudo_remainder_def formula-decl nil polynomial_pseudo_divide nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (adjusted_remainder const-decl "list[int]" polynomial_pseudo_divide nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (i skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (nil application-judgement "above(n)" exp2 nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (primitize_zero_list formula-decl nil gcd_coeff nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil) (int_times_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (make_divtype const-decl "DivType" polynomial_division nil) (cp skolem-const-decl "nzrat" polynomial_pseudo_divide nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (ii!1 skolem-const-decl "nat" polynomial_pseudo_divide nil) (poly_eq formula-decl nil polynomials reals) (ii!1 skolem-const-decl "nat" polynomial_pseudo_divide nil) (minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (primitize_list_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (nzreal_times_nzreal_is_nzreal judgement-tcc nil real_types nil) (kv skolem-const-decl "below(length[int](primitize_list(array2list(1 + n)(g))))" polynomial_pseudo_divide nil) (gp skolem-const-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](array2list(1 + n)(g)) IMPLIES
      divides(m, nth[int](array2list(1 + n)(g), ii))}" polynomial_pseudo_divide nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (g skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[T -> real]" real_fun_ops reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (polynomial const-decl "[real -> real]" polynomials reals) (sequence type-eq-decl nil sequences nil) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzint nonempty-type-eq-decl nil integers nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzrat nonempty-type-eq-decl nil rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (gcd_coeff_nonzero formula-decl nil gcd_coeff nil) (i skolem-const-decl "nat" polynomial_pseudo_divide nil) (divides const-decl "bool" divides nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (poly_divide def-decl "DivType" polynomial_division nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (adjusted_remainder_def-3 "" 3755374185 ("" (skeep) (("" (case "m > n") (("1" (case "FORALL (i:nat): i<=n IMPLIES g(i)=0") (("1" (assert) (("1" (flatten) (("1" (hide (-3 -4 +)) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (rewrite "primitize_zero_list") (("1" (typepred "array2list[int](1+n)(g)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "array2list[int]
                                            (1 + n)(LAMBDA (i: nat): 0)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3)) (("1" (hide (-2 -3)) (("1" (skosimp*) (("1" (typepred "i!1") (("1" (typepred "array2list[int](1 + n)(LAMBDA (i: nat): 0)") (("1" (hide (-1 -2)) (("1" (inst - "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "array2list(1 + n)(g)") (("2" (inst - "i") (("1" (assert) (("1" (inst - "i") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "gzero" 1) (("2" (hide "gzero") (("2" (assert) (("2" (expand "adjusted_remainder") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (flatten) (("2" (split +) (("1" (name "gp" "gcd_coeff(array2list(1+n)(g))") (("1" (case "gp > 0") (("1" (name "cp" "1/gp") (("1" (case "cp > 0") (("1" (label "cpname" -2) (("1" (hide "cpname") (("1" (hide -2) (("1" (inst + "cp") (("1" (label "cppos" -1) (("1" (hide "cppos") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version
                                                             (primitize_list
                                                              (array2list(1 + n)(g))),
                                                             -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (decompose-equality) (("1" (lemma "poly_eq") (("1" (inst?) (("1" (replace 1) (("1" (hide 2) (("1" (split 1) (("1" (skeep) (("1" (assert) (("1" (expand "min" -1) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -6 "ii") (("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (case "g(ii) = 0") (("1" (assert) (("1" (expand "*" +) (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-2 -3)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "ii") (("1" (replaces -3 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT ii<=n") (("1" (assert) nil nil) ("2" (inst + "ii") (("2" (assert) (("2" (flatten) (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "ii") (("2" (assert) (("2" (replace -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (typepred "descalarize_list(nonzero_version
                                                                     (primitize_list
                                                                      (array2list(1 + n)(g))),
                                                                     -1)") (("2" (hide (-1 -2)) (("2" (inst - "ii") (("2" (mult-by -1 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (expand "*") (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -2 "ii") (("2" (assert) (("2" (replaces -2 :dir rl) (("2" (hide (-1 -2 -3 -4)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "ii") (("1" (replaces -1 :dir rl) (("1" (replace -3 2) (("1" (expand "cp" 2) (("1" (expand "gp" 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (hide (-1 -3 -4)) (("2" (skolem -1 "kv") (("2" (assert) (("2" (lemma "primitize_list_def") (("2" (expand "primitize_list" -2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (inst + "kv") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(array2list(1 + n)(g),
                                                     gcd_coeff(array2list(1 + n)(g)))") (("2" (inst - "kv") (("1" (assert) (("1" (inst + "kv") (("1" (flatten) (("1" (replace -5) (("1" (assert) (("1" (lemma "nzreal_times_nzreal_is_nzreal") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "kv") (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                                 ii!1)") (("1" (assert) (("1" (case-replace "array2list[real](1 + n)(g) = array2list[int](1 + n)(g)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3 -5 -6 2) (("2" (case-replace "array2list[real](1 + n)(g) = array2list[int](1 + n)(g)") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                              (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                               ii!1)") (("1" (assert) (("1" (case-replace "array2list[real](1 + n)(g) = array2list[int](1 + n)(g)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "array2list[real](1 + n)(g) = array2list[int](1 + n)(g)") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cp" 1) (("2" (cross-mult 1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "gzero") (("2" (skeep) (("2" (inst + "i") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "i") (("1" (assert) (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "every_nth") (("2" (skeep) (("2" (typepred "array2list(1 + n)(g)") (("2" (inst -3 "i") (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                           (array2list(1 + n)(g))),
                           -1)") (("2" (replace -2) (("2" (inst - "length[int]
              (nonzero_version(primitize_list(array2list(1 + n)(g))))
           - 1") (("2" (mult-by -3 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (hide (-1 -2)) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1+n)(g))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT n>=m") (("1" (assert) nil nil) ("2" (copy -3) (("2" (copy -3) (("2" (hide -4) (("2" (hide -4) (("2" (hide 1) (("2" (case "m = 0") (("1" (assert) (("1" (case "NOT pseudo_div(g,n)(h,0)(0)`reml = null[int]") (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (case "NOT adjusted_remainder(g,n)(h,m) = null[int]") (("1" (hide 3) (("1" (expand "adjusted_remainder" 1) (("1" (case "NOT primitize_list
                                                                                                                                                       (pseudo_div
                                                                                                                                                        (g, n)(h, m)(0)`reml) = null[int]") (("1" (hide 2) (("1" (replaces -1) (("1" (expand "primitize_list" 1) (("1" (lift-if) (("1" (ground) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (expand "gcd_coeff") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "nonzero_version" 1) (("2" (expand "reverse" + 2) (("2" (expand "nonzero_version_rec") (("2" (expand "reverse") (("2" (expand "descalarize_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (label "ip1" -1) (("2" (label "mn" -3) (("2" (label "ip2" -2) (("2" (skoletin 2) (("2" (label "thisremdef" -1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (flatten) (("2" (case "NOT LET ppde = pseudo_div(g, n)(h, m)(0) IN EXISTS (i: below(length[int](ppde`reml))): nth[int](ppde`reml, i) /= 0") (("1" (hide 2) (("1" (assert) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (invoke (typepred "%1") (! -1 1 1 1)) (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                                                   (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3 -5 -6)) (("1" (skeep) (("1" (inst + "i") (("1" (flatten) (("1" (expand "primitize_list" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (invoke (typepred "%1") (! 3 1 1)) (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (assert) (("2" (replace -2) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (hide -2) (("2" (expand "primitize_list" -1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "nonzeep" -1) (("2" (hide "nonzeep") (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (lemma "poly_pseudo_remainder_def") (("1" (inst?) (("1" (assert) (("1" (replace "ip1") (("1" (replace "ip2") (("1" (replace -5 :dir rl) (("1" (name "ppd" "pseudo_div(g, n)(h, m)(0)") (("1" (replace -1) (("1" (copy "thisremdef") (("1" (expand "adjusted_remainder" -1) (("1" (name "psign" "IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN 1
                                                                                               ELSE -1
                                                                                               ENDIF") (("1" (invoke (case "-psign = %1") (! -2 2 2)) (("1" (replace -1 :dir rl) (("1" (replace -4) (("1" (invoke (name "AA" "%1") (! -3 2 1)) (("1" (replace -1) (("1" (typepred "descalarize_list(AA, psign)") (("1" (hide (-1 -2)) (("1" (case "EXISTS (cp: posreal):
                                                                                                                                                               polynomial(thispoly, thisdeg) = polynomial(-cp*psign*h(m)^(1-m+n) * pd`rem, pd`rdeg)") (("1" (skeep) (("1" (inst + "cp * psign * h(m) ^ (1 - m + n)") (("1" (assert) nil nil) ("2" (case "NOT h(m) ^ (1 - m + n) * psign > 0") (("1" (hide-all-but (-4 1 3)) (("1" (lift-if) (("1" (ground) (("1" (lemma "posreal_expt") (("1" (expand "^") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "mod_0_divides") (("2" (inst?) (("2" (assert) (("2" (expand "divides") (("2" (skeep) (("2" (replace -1) (("2" (case "x<=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "x" "x" "h(m)") (("2" (case "sq(h(m)^x)>0") (("1" (expand "sq") (("1" (assert) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "even_or_odd") (("3" (inst - "1-m+n") (("3" (flatten) (("3" (hide -1) (("3" (split -) (("1" (rewrite "mod_0_divides") (("1" (expand "divides") (("1" (expand "even?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "odd?") (("2" (skeep) (("2" (case "NOT n = m + 2*j") (("1" (assert) nil nil) ("2" (hide -2) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (lemma "negreal_times_negreal_is_posreal") (("2" (inst - "h(m)" "-(h(m)^(2*j))") (("1" (expand "^") (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil) ("2" (case "h(m)^(2*j)>0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "j" "j" "h(m)") (("2" (assert) (("2" (replaces -1) (("2" (case "sq(h(m)^j)>0") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "j = 0") (("1" (replaces -1) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (mult-by -1 "cp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "PP" "(LAMBDA (k: nat):
                                                                                                                                                                             IF k <= ppd`rdegl AND m > 0 THEN nth(ppd`reml, k) ELSE 0 ENDIF)") (("1" (replace -1) (("1" (replace -8 +) (("1" (case "NOT pd`rdeg = ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (name "DD" "(-psign*PP)") (("2" (case "EXISTS (cp: posreal):
                                                                                                                                                                                                                  polynomial(thispoly, thisdeg) =
                                                                                                                                                                                                                   polynomial(cp * DD,
                                                                                                                                                                                                                              ppd`rdegl)") (("1" (skeep) (("1" (inst + "cp") (("1" (assert) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (lemma "poly_eq_le_degree") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (expand "*") (("1" (expand "DD") (("1" (case "h(m) ^ (1 - m + n) * (1 / h(m)) ^ (1 - m + n) = 1") (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "div_expt") (("2" (inst - "1-m+n" "1" "h(m)") (("2" (assert) (("2" (lemma "expt_1n_aux") (("2" (inst - "1-m+n") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA2" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (hide (-1 -2 -3)) (("2" (case "NOT thisdeg <= ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -9) (("1" (replace -2) (("1" (hide (-1 -2)) (("1" (expand "thisdeg" 1) (("1" (case "length[int](thisrem) <= length[int](ppd`reml)") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (name "AA1" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (lemma "thisrem") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (typepred "%1") (! -1 2)) (("1" (replace -4 :dir rl) (("1" (replaces -2) (("1" (hide (-1 -2 -3)) (("1" (lemma "nonzero_version_def") (("1" (replace -7) (("1" (inst - "primitize_list(ppd`reml)") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3 -4 -5 -6)) (("1" (assert) (("1" (case "length[int](primitize_list(ppd`reml)) = length[int](ppd`reml)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "primitize_list") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA3" "1") (("2" (hide -1) (("2" (expand "DD" 1) (("2" (case "(FORALL (i:nat): i>thisdeg AND i<=ppd`rdegl IMPLIES PP(i)=0) AND (EXISTS (cp:posreal): FORALL (i:nat): i<=thisdeg IMPLIES thispoly(i)=(-cp*psign)*PP(i))") (("1" (flatten) (("1" (skeep) (("1" (inst + "cp") (("1" (expand "polynomial" 1) (("1" (decompose-equality 1) (("1" (lemma "sigma_split") (("1" (invoke (inst - "%1" "ppd`rdegl" "0" "thisdeg") (! 1 2 3)) (("1" (assert) (("1" (invoke (case "%1 = 0") (! -1 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "sigma_eq") (("1" (skeep) (("1" (inst -2 "n!1") (("1" (assert) (("1" (expand "*") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "sigma_restrict_eq_0") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA4" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (split +) (("1" (skeep) (("1" (expand "PP" 1) (("1" (lift-if) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (copy -3) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (assert) (("1" (invoke (case "%1 = -psign") (! -1 1 1 1 2)) (("1" (replace -1) (("1" (replace -11) (("1" (replace -7) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -3)) (("1" (replaces -1 -3) (("1" (case "NOT i>=length[int](AA)") (("1" (assert) nil nil) ("2" (name "AA5" "-1") (("2" (hide -1) (("2" (name "pl" "primitize_list(ppd`reml)") (("2" (replace -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "pl") (("2" (replace -10) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (case "i < length[int](pl)") (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "AA6" -1) (("2" (hide -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "length(ppd`reml)>0") (("1" (expand "max" -3) (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst?) (("1" (assert) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "PP") (("2" (lemma "primitize_list_def") (("2" (inst?) (("2" (replace -8) (("2" (assert) (("2" (invoke (case "%1") (! -1 1)) (("1" (replace -1) (("1" (assert) (("1" (flatten) (("1" (inst + "1/gcd_coeff(ppd`reml)") (("1" (assert) (("1" (skeep) (("1" (expand "thispoly" 1) (("1" (assert) (("1" (expand "PP" 1) (("1" (reveal "mzero") (("1" (assert) (("1" (inst - "i") (("1" (expand "thisrem" 2) (("1" (expand "adjusted_remainder" 2) (("1" (replace -13) (("1" (case "NOT  IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN -1
                                                                                                                                                                                                      ELSE --1
                                                                                                                                                                                                      ENDIF = -psign") (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (propax) nil nil)) nil)) nil) ("2" (replace -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                                                                                                                                                                                                                               -psign)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (mult-by -1 "-psign") (("2" (case "psign*psign=1") (("1" (invoke (mult-by -1 "%1") (! -2 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 + :dir rl) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(ppd`reml)") (("1" (replace -11) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -2 + :dir rl) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -3 +) (("1" (hide -) (("1" (real-props) (("1" (case "nth[int](primitize_list(ppd`reml), i) =
                                                                                                                                                                                                 gcd_coeff(ppd`reml) * nth[int](primitize_list(ppd`reml), i) *
                                                                                                                                                                                                  (1 / gcd_coeff(ppd`reml))") (("1" (assert) (("1" (mult-by -1 "-psign") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8 -9)) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (typepred "gcd_coeff(ppd`reml)") (("1" (lemma "gcd_coeff_nonzero") (("1" (inst?) (("1" (assert) (("1" (reveal "nonzeep") (("1" (assert) (("1" (skeep) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gcd_coeff_nonzero") (("3" (inst?) (("3" (assert) (("3" (reveal "nonzeep") (("3" (assert) (("3" (skeep -1) (("3" (inst + "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i") (("1" (flatten) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -2)) (("1" (inst - "i") (("1" (case "NOT nth[int](AA,i)=0") (("1" (assert) nil nil) ("2" (hide -2) (("2" (expand "AA" -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -7) (("2" (assert) (("2" (flatten) (("2" (inst - "i") (("2" (assert) (("2" (split -2) (("1" (invoke (case "%1 = 0") (! -1 1)) (("1" (expand "primitize_list" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(ppd`reml, gcd_coeff(ppd`reml))") (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (replace -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -6) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "thisrem" 1) (("2" (expand "adjusted_remainder" 1) (("2" (replace -8) (("2" (replace -4) (("2" (replace -5 1 :dir rl) (("2" (typepred "descalarize_list(AA,-psign)") (("2" (replace -2) (("2" (assert) (("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -8) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -12) (("2" (case "length(ppd`reml)>0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split 1) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) (("1" (expand "divides") (("1" (inst + "nth[int](AA,ii)") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "divides") (("2" (inst + "nth[int](AA,ii)") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "divides") (("3" (inst + "-nth[int](AA,ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (label "answer" 1) (("2" (expand "thispoly" "answer") (("2" (expand "thisdeg" -3) (("2" (copy "thisremdef") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (name "psign" "%1") (! -1 2 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                                        (g, n)(h, m)(0)") (("2" (replace -1) (("2" (name "AA" "nonzero_version(primitize_list(ppd`reml))") (("2" (replace -1) (("2" (case "nth(AA,length[int](AA)-1)/=0") (("1" (flatten) (("1" (case "NOT length[int](AA) = length[int](thisrem)") (("1" (assert) nil nil) ("2" (replace -1 +) (("2" (expand "AA" 1) (("2" (replace -4 "answer") (("2" (typepred "descalarize_list(AA,psign)") (("2" (hide (-1 -2)) (("2" (inst - "length[int](thisrem)-1") (("1" (replace -5 :dir rl) (("1" (replace "answer") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -2) (("2" (assert) (("2" (flatten) (("2" (split -3) (("1" (assert) nil nil) ("2" (reveal "nonzeep") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((poly_divide def-decl "DivType" polynomial_division nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (gcd_coeff_nonzero formula-decl nil gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (primitize_list const-decl "list[int]" gcd_coeff nil) (polynomial const-decl "[real -> real]" polynomials reals) (primitize_list_length formula-decl nil gcd_coeff nil) (primitize_list_def formula-decl nil gcd_coeff nil) (poly_eq formula-decl nil polynomials reals) (make_divtype const-decl "DivType" polynomial_division nil) (primitize_zero_list formula-decl nil gcd_coeff nil) (list type-decl nil list_adt nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nonzero_version_def formula-decl nil gcd_coeff nil) (sq_eq_0 formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (mod_0_divides formula-decl nil mod_lems ints) (sigma_split formula-decl nil sigma reals) (sigma_restrict_eq_0 formula-decl nil sigma reals) (sigma_eq formula-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (max_npreal_0 formula-decl nil min_max reals) (poly_eq_le_degree formula-decl nil polynomials reals) (DivType type-eq-decl nil polynomial_division nil) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil)) shostak) (adjusted_remainder_def-2 nil 3593524728 ("" (skeep) (("" (case "m > n") (("1" (case "FORALL (i:nat): i<=n IMPLIES g(i)=0") (("1" (assert) (("1" (flatten) (("1" (hide (-3 -4 +)) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (rewrite "primitize_zero_list") (("1" (typepred "array2list[int](1+n)(g)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "array2list[int]
                                            (1 + n)(LAMBDA (i: nat): 0)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3)) (("1" (hide (-2 -3)) (("1" (skosimp*) (("1" (typepred "i!1") (("1" (typepred "array2list[int](1 + n)(LAMBDA (i: nat): 0)") (("1" (hide (-1 -2)) (("1" (inst - "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "array2list(1 + n)(g)") (("2" (inst - "i") (("1" (assert) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "gzero" 1) (("2" (hide "gzero") (("2" (assert) (("2" (expand "adjusted_remainder") (("2" (expand "poly_divide") (("2" (expand "make_divtype") (("2" (flatten) (("2" (split +) (("1" (name "gp" "gcd_coeff(array2list(1+n)(g))") (("1" (case "gp > 0") (("1" (name "cp" "1/gp") (("1" (case "cp > 0") (("1" (label "cpname" -2) (("1" (hide "cpname") (("1" (hide -2) (("1" (inst + "cp") (("1" (label "cppos" -1) (("1" (hide "cppos") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version
                                                             (primitize_list
                                                              (array2list(1 + n)(g))),
                                                             -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (decompose-equality) (("1" (lemma "poly_eq") (("1" (inst?) (("1" (replace 1) (("1" (hide 2) (("1" (split 1) (("1" (skeep) (("1" (assert) (("1" (expand "min" -1) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -6 "ii") (("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (case "g(ii) = 0") (("1" (assert) (("1" (expand "*" +) (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-2 -3)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "ii") (("1" (replaces -3 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT ii<=n") (("1" (assert) nil nil) ("2" (inst + "ii") (("2" (assert) (("2" (flatten) (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "ii") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (typepred "descalarize_list(nonzero_version
                                                                     (primitize_list
                                                                      (array2list(1 + n)(g))),
                                                                     -1)") (("2" (hide (-1 -2)) (("2" (inst - "ii") (("2" (mult-by -1 "-1") (("2" (assert) (("2" (replaces -1 :dir rl) (("2" (expand "*") (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (inst -2 "ii") (("2" (assert) (("2" (replaces -2 :dir rl) (("2" (hide (-1 -2 -3 -4)) (("2" (lemma "primitize_list_def") (("2" (inst - "array2list(1+n)(g)") (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (inst - "ii") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "ii") (("1" (replaces -1 :dir rl) (("1" (replace -3 2) (("1" (expand "cp" 2) (("1" (expand "gp" 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(array2list(1 + n)(g))") (("2" (assert) (("2" (flatten) (("2" (hide (-1 -3 -4)) (("2" (skolem -1 "kv") (("2" (assert) (("2" (lemma "primitize_list_def") (("2" (expand "primitize_list" -2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (inst + "kv") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(array2list(1 + n)(g),
                                                     gcd_coeff(array2list(1 + n)(g)))") (("2" (inst - "kv") (("1" (assert) (("1" (inst + "kv") (("1" (flatten) (("1" (replace -5) (("1" (assert) (("1" (lemma "nzreal_times_nzreal_is_nzreal") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "kv") (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                                 ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                              (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                               ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "-nth[int]
                            (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                             ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cp" 1) (("2" (cross-mult 1) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "gzero") (("2" (skeep) (("2" (inst + "i") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pseudo_div") (("2" (expand "make_divlisttype") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                           (array2list(1 + n)(g))),
                           -1)") (("1" (replace -2) (("1" (inst - "length[int]
              (nonzero_version(primitize_list(array2list(1 + n)(g))))
           - 1") (("1" (mult-by -3 "-1") (("1" (assert) (("1" (replaces -1 :dir rl) (("1" (hide (-1 -2)) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1+n)(g))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "-nth[int]
            (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
             ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT n>=m") (("1" (assert) nil nil) ("2" (copy -3) (("2" (copy -3) (("2" (hide -4) (("2" (hide -4) (("2" (hide 1) (("2" (case "m = 0") (("1" (assert) (("1" (case "NOT pseudo_div(g,n)(h,0)(0)`reml = null[int]") (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (case "NOT adjusted_remainder(g,n)(h,m) = null[int]") (("1" (hide 3) (("1" (expand "adjusted_remainder" 1) (("1" (case "NOT primitize_list
                                                                                                                                                       (pseudo_div
                                                                                                                                                        (g, n)(h, m)(0)`reml) = null[int]") (("1" (hide 2) (("1" (replaces -1) (("1" (expand "primitize_list" 1) (("1" (lift-if) (("1" (ground) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (expand "gcd_coeff") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "nonzero_version" 1) (("2" (expand "reverse" + 2) (("2" (expand "nonzero_version_rec") (("2" (expand "reverse") (("2" (expand "descalarize_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (label "ip1" -1) (("2" (label "mn" -3) (("2" (label "ip2" -2) (("2" (skoletin 2) (("2" (label "thisremdef" -1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (flatten) (("2" (case "NOT LET ppde = pseudo_div(g, n)(h, m)(0) IN EXISTS (i: below(length[int](ppde`reml))): nth[int](ppde`reml, i) /= 0") (("1" (hide 2) (("1" (assert) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (invoke (typepred "%1") (! -1 1 1 1)) (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                                                   (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3 -5 -6)) (("1" (skeep) (("1" (inst + "i") (("1" (flatten) (("1" (expand "primitize_list" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (invoke (typepred "%1") (! 3 1 1)) (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (assert) (("2" (replace -2) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (hide -2) (("2" (expand "primitize_list" -1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                    (nonzero_version(primitize_list(pseudo_div
                                                                                    (g, n)(h, m)(0)`reml)),
                                                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "nonzeep" -1) (("2" (hide "nonzeep") (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (lemma "poly_pseudo_remainder_def") (("1" (inst?) (("1" (assert) (("1" (replace "ip1") (("1" (replace "ip2") (("1" (replace -5 :dir rl) (("1" (name "ppd" "pseudo_div(g, n)(h, m)(0)") (("1" (replace -1) (("1" (copy "thisremdef") (("1" (expand "adjusted_remainder" -1) (("1" (name "psign" "IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN 1
                                                                                               ELSE -1
                                                                                               ENDIF") (("1" (invoke (case "-psign = %1") (! -2 2 2)) (("1" (replace -1 :dir rl) (("1" (replace -4) (("1" (invoke (name "AA" "%1") (! -3 2 1)) (("1" (replace -1) (("1" (typepred "descalarize_list(AA, psign)") (("1" (hide (-1 -2)) (("1" (case "EXISTS (cp: posreal):
                                                                                                                                                               polynomial(thispoly, thisdeg) = polynomial(-cp*psign*h(m)^(1-m+n) * pd`rem, pd`rdeg)") (("1" (skeep) (("1" (inst + "cp * psign * h(m) ^ (1 - m + n)") (("1" (assert) nil nil) ("2" (case "NOT h(m) ^ (1 - m + n) * psign > 0") (("1" (hide-all-but (-4 1 3)) (("1" (lift-if) (("1" (ground) (("1" (lemma "posreal_expt") (("1" (expand "^") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "mod_0_divides") (("2" (inst?) (("2" (assert) (("2" (expand "divides") (("2" (skeep) (("2" (replace -1) (("2" (case "x<=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "x" "x" "h(m)") (("2" (case "sq(h(m)^x)>0") (("1" (expand "sq") (("1" (assert) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "even_or_odd") (("3" (inst - "1-m+n") (("3" (flatten) (("3" (hide -1) (("3" (split -) (("1" (rewrite "mod_0_divides") (("1" (expand "divides") (("1" (expand "even?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "odd?") (("2" (skeep) (("2" (case "NOT n = m + 2*j") (("1" (assert) nil nil) ("2" (hide -2) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (lemma "negreal_times_negreal_is_posreal") (("2" (inst - "h(m)" "-(h(m)^(2*j))") (("1" (expand "^") (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil) ("2" (case "h(m)^(2*j)>0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "j" "j" "h(m)") (("2" (assert) (("2" (replaces -1) (("2" (case "sq(h(m)^j)>0") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "j = 0") (("1" (replaces -1) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (mult-by -1 "cp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "PP" "(LAMBDA (k: nat):
                                                                                                                                                                             IF k <= ppd`rdegl AND m > 0 THEN nth(ppd`reml, k) ELSE 0 ENDIF)") (("1" (replace -1) (("1" (replace -8 +) (("1" (case "NOT pd`rdeg = ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (name "DD" "(-psign*PP)") (("2" (case "EXISTS (cp: posreal):
                                                                                                                                                                                                                  polynomial(thispoly, thisdeg) =
                                                                                                                                                                                                                   polynomial(cp * DD,
                                                                                                                                                                                                                              ppd`rdegl)") (("1" (skeep) (("1" (inst + "cp") (("1" (assert) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (lemma "poly_eq_le_degree") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (expand "*") (("1" (expand "DD") (("1" (case "h(m) ^ (1 - m + n) * (1 / h(m)) ^ (1 - m + n) = 1") (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "div_expt") (("2" (inst - "1-m+n" "1" "h(m)") (("2" (assert) (("2" (lemma "expt_1n_aux") (("2" (inst - "1-m+n") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA2" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (hide (-1 -2 -3)) (("2" (case "NOT thisdeg <= ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -9) (("1" (replace -2) (("1" (hide (-1 -2)) (("1" (expand "thisdeg" 1) (("1" (case "length[int](thisrem) <= length[int](ppd`reml)") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (name "AA1" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (lemma "thisrem") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (typepred "%1") (! -1 2)) (("1" (replace -4 :dir rl) (("1" (replaces -2) (("1" (hide (-1 -2 -3)) (("1" (lemma "nonzero_version_def") (("1" (replace -7) (("1" (inst - "primitize_list(ppd`reml)") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3 -4 -5 -6)) (("1" (assert) (("1" (case "length[int](primitize_list(ppd`reml)) = length[int](ppd`reml)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "primitize_list") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                                                                                                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                                                                                                                                   ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA3" "1") (("2" (hide -1) (("2" (expand "DD" 1) (("2" (case "(FORALL (i:nat): i>thisdeg AND i<=ppd`rdegl IMPLIES PP(i)=0) AND (EXISTS (cp:posreal): FORALL (i:nat): i<=thisdeg IMPLIES thispoly(i)=(-cp*psign)*PP(i))") (("1" (flatten) (("1" (skeep) (("1" (inst + "cp") (("1" (expand "polynomial" 1) (("1" (decompose-equality 1) (("1" (lemma "sigma_split") (("1" (invoke (inst - "%1" "ppd`rdegl" "0" "thisdeg") (! 1 2 3)) (("1" (assert) (("1" (invoke (case "%1 = 0") (! -1 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "sigma_eq") (("1" (skeep) (("1" (inst -2 "n!1") (("1" (assert) (("1" (expand "*") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "sigma_restrict_eq_0") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AA4" "-1") (("2" (hide -1) (("2" (hide 2) (("2" (split +) (("1" (skeep) (("1" (expand "PP" 1) (("1" (lift-if) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (copy -3) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (assert) (("1" (invoke (case "%1 = -psign") (! -1 1 1 1 2)) (("1" (replace -1) (("1" (replace -11) (("1" (replace -7) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -3)) (("1" (replaces -1 -3) (("1" (assert) (("1" (case "NOT i>=length[int](AA)") (("1" (assert) nil nil) ("2" (name "AA5" "-1") (("2" (hide -1) (("2" (name "pl" "primitize_list(ppd`reml)") (("2" (replace -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "pl") (("2" (replace -10) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (case "i < length[int](pl)") (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "AA6" -1) (("2" (hide -1) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "length(ppd`reml)>0") (("1" (expand "max" -3) (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst?) (("1" (assert) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "PP") (("2" (lemma "primitize_list_def") (("2" (inst?) (("2" (replace -8) (("2" (assert) (("2" (invoke (case "%1") (! -1 1)) (("1" (replace -1) (("1" (assert) (("1" (flatten) (("1" (inst + "1/gcd_coeff(ppd`reml)") (("1" (assert) (("1" (skeep) (("1" (expand "thispoly" 1) (("1" (assert) (("1" (expand "PP" 1) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (inst - "i") (("1" (expand "thisrem" 2) (("1" (expand "adjusted_remainder" 2) (("1" (replace -13) (("1" (case "NOT  IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN -1
                                                                                                                                                                                                      ELSE --1
                                                                                                                                                                                                      ENDIF = -psign") (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                                                                                                                                                                                                                               -psign)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (mult-by -1 "-psign") (("2" (case "psign*psign=1") (("1" (invoke (mult-by -1 "%1") (! -2 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 + :dir rl) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(ppd`reml)") (("1" (replace -11) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -2 + :dir rl) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -3 +) (("1" (assert) (("1" (hide -) (("1" (real-props) (("1" (case "nth[int](primitize_list(ppd`reml), i) =
                                                                                                                                                                                                 gcd_coeff(ppd`reml) * nth[int](primitize_list(ppd`reml), i) *
                                                                                                                                                                                                  (1 / gcd_coeff(ppd`reml))") (("1" (assert) (("1" (mult-by -1 "-psign") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8 -9)) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (typepred "gcd_coeff(ppd`reml)") (("1" (lemma "gcd_coeff_nonzero") (("1" (inst?) (("1" (assert) (("1" (reveal "nonzeep") (("1" (assert) (("1" (skeep) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "gcd_coeff_nonzero") (("2" (inst?) (("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gcd_coeff_nonzero") (("3" (inst?) (("3" (assert) (("3" (reveal "nonzeep") (("3" (assert) (("3" (skeep -1) (("3" (inst + "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i") (("1" (flatten) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -2)) (("1" (inst - "i") (("1" (case "NOT nth[int](AA,i)=0") (("1" (assert) nil nil) ("2" (hide -2) (("2" (expand "AA" -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -7) (("2" (assert) (("2" (flatten) (("2" (inst - "i") (("2" (assert) (("2" (split -2) (("1" (invoke (case "%1 = 0") (! -1 1)) (("1" (expand "primitize_list" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "descalarize_list(ppd`reml, gcd_coeff(ppd`reml))") (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (replace -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (assert) (("2" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -6) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "thisrem" 1) (("2" (expand "adjusted_remainder" 1) (("2" (replace -8) (("2" (replace -4) (("2" (replace -5 1 :dir rl) (("2" (typepred "descalarize_list(AA,-psign)") (("2" (replace -2) (("2" (assert) (("2" (expand "AA" 1) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -8) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (split -6) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (inst - "i") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "primitize_list" 1) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -12) (("2" (case "length(ppd`reml)>0") (("1" (expand "max") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) (("1" (expand "divides") (("1" (inst + "nth[int](AA,ii)") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "divides") (("2" (inst + "nth[int](AA,ii)") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "divides") (("3" (inst + "-nth[int](AA,ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (label "answer" 1) (("2" (expand "thispoly" "answer") (("2" (expand "thisdeg" -3) (("2" (copy "thisremdef") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (name "psign" "%1") (! -1 2 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                                        (g, n)(h, m)(0)") (("2" (replace -1) (("2" (name "AA" "nonzero_version(primitize_list(ppd`reml))") (("2" (replace -1) (("2" (case "nth(AA,length[int](AA)-1)/=0") (("1" (flatten) (("1" (case "NOT length[int](AA) = length[int](thisrem)") (("1" (assert) nil nil) ("2" (replace -1 +) (("2" (expand "AA" 1) (("2" (replace -4 "answer") (("2" (typepred "descalarize_list(AA,psign)") (("2" (hide (-1 -2)) (("2" (inst - "length[int](thisrem)-1") (("1" (replace -5 :dir rl) (("1" (replace "answer") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (replace -2) (("2" (assert) (("2" (flatten) (("2" (split -3) (("1" (assert) nil nil) ("2" (reveal "nonzeep") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (DivType type-eq-decl nil polynomial_division nil) (poly_eq_le_degree formula-decl nil polynomials reals) (max_npreal_0 formula-decl nil min_max reals) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (sigma_eq formula-decl nil sigma reals) (sigma_restrict_eq_0 formula-decl nil sigma reals) (sigma_split formula-decl nil sigma reals) (mod_0_divides formula-decl nil mod_lems ints) (sq const-decl "nonneg_real" sq reals) (sq_eq_0 formula-decl nil sq reals) (nonzero_version_def formula-decl nil gcd_coeff nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (list type-decl nil list_adt nil) (primitize_zero_list formula-decl nil gcd_coeff nil) (make_divtype const-decl "DivType" polynomial_division nil) (poly_eq formula-decl nil polynomials reals) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (primitize_list_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (polynomial const-decl "[real -> real]" polynomials reals) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (gcd_coeff_nonzero formula-decl nil gcd_coeff nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (poly_divide def-decl "DivType" polynomial_division nil)) nil) (adjusted_remainder_def-1 nil 3593450592 ("" (skeep) (("" (case "m = 0") (("1" (assert) (("1" (case "NOT pseudo_div(g,n)(h,0)(0)`reml = null[int]") (("1" (hide 3) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (case "NOT adjusted_remainder(g,n)(h,m) = null[int]") (("1" (hide 3) (("1" (expand "adjusted_remainder" 1) (("1" (case "NOT primitize_list
                                                                                           (pseudo_div
                                                                                            (g, n)(h, m)(0)`reml) = null[int]") (("1" (hide 2) (("1" (replaces -1) (("1" (expand "primitize_list" 1) (("1" (lift-if) (("1" (ground) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (expand "gcd_coeff") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "nonzero_version" 1) (("2" (expand "reverse" + 2) (("2" (expand "nonzero_version_rec") (("2" (expand "reverse") (("2" (expand "descalarize_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (label "ip1" -2) (("2" (label "mn" -1) (("2" (label "ip2" -3) (("2" (skoletin 2) (("2" (label "thisremdef" -1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (skoletin 1) (("2" (flatten) (("2" (case "NOT LET ppde = pseudo_div(g, n)(h, m)(0) IN EXISTS (i: below(length[int](ppde`reml))): nth[int](ppde`reml, i) /= 0") (("1" (hide 2) (("1" (assert) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (invoke (typepred "%1") (! -1 1 1 1)) (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                           (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3 -5 -6)) (("1" (skeep) (("1" (inst + "i") (("1" (flatten) (("1" (expand "primitize_list" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (invoke (typepred "%1") (! 3 1 1)) (("2" (hide (-1 -2)) (("2" (inst - "i") (("2" (assert) (("2" (replace -2) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (hide -2) (("2" (expand "primitize_list" -1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + "nth[int]
            (nonzero_version(primitize_list(pseudo_div
                                            (g, n)(h, m)(0)`reml)),
             ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
            (nonzero_version(primitize_list(pseudo_div
                                            (g, n)(h, m)(0)`reml)),
             ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "nonzeep" -1) (("2" (hide "nonzeep") (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (lemma "poly_pseudo_remainder_def") (("1" (inst?) (("1" (assert) (("1" (replace "ip1") (("1" (replace "ip2") (("1" (replace -5 :dir rl) (("1" (name "ppd" "pseudo_div(g, n)(h, m)(0)") (("1" (replace -1) (("1" (copy "thisremdef") (("1" (expand "adjusted_remainder" -1) (("1" (name "psign" "IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN 1
                                   ELSE -1
                                   ENDIF") (("1" (invoke (case "-psign = %1") (! -2 2 2)) (("1" (replace -1 :dir rl) (("1" (replace -4) (("1" (invoke (name "AA" "%1") (! -3 2 1)) (("1" (replace -1) (("1" (typepred "descalarize_list(AA, psign)") (("1" (hide (-1 -2)) (("1" (case "EXISTS (cp: posreal):
                                                                                   polynomial(thispoly, thisdeg) = polynomial(-cp*psign*h(m)^(1-m+n) * pd`rem, pd`rdeg)") (("1" (skeep) (("1" (inst + "cp * psign * h(m) ^ (1 - m + n)") (("1" (assert) nil nil) ("2" (case "NOT h(m) ^ (1 - m + n) * psign > 0") (("1" (hide-all-but (-4 1 3)) (("1" (lift-if) (("1" (ground) (("1" (lemma "posreal_expt") (("1" (expand "^") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "mod_0_divides") (("2" (inst?) (("2" (assert) (("2" (expand "divides") (("2" (skeep) (("2" (replace -1) (("2" (case "x<=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "x" "x" "h(m)") (("2" (case "sq(h(m)^x)>0") (("1" (expand "sq") (("1" (assert) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "even_or_odd") (("3" (inst - "1-m+n") (("3" (flatten) (("3" (hide -1) (("3" (split -) (("1" (rewrite "mod_0_divides") (("1" (expand "divides") (("1" (expand "even?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "odd?") (("2" (skeep) (("2" (case "NOT n = m + 2*j") (("1" (assert) nil nil) ("2" (hide -2) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (lemma "negreal_times_negreal_is_posreal") (("2" (inst - "h(m)" "-(h(m)^(2*j))") (("1" (expand "^") (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil) ("2" (case "h(m)^(2*j)>0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "j" "j" "h(m)") (("2" (assert) (("2" (replaces -1) (("2" (case "sq(h(m)^j)>0") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "expt_eq_0") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "j = 0") (("1" (replaces -1) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (mult-by -1 "cp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "PP" "(LAMBDA (k: nat):
                                                                                         IF k <= ppd`rdegl AND m > 0 THEN nth(ppd`reml, k) ELSE 0 ENDIF)") (("1" (replace -1) (("1" (replace -8 +) (("1" (case "NOT pd`rdeg = ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (name "DD" "(-psign*PP)") (("2" (case "EXISTS (cp: posnat):
                                                                                                              polynomial(thispoly, thisdeg) =
                                                                                                               polynomial(cp * DD,
                                                                                                                          ppd`rdegl)") (("1" (skeep) (("1" (inst + "cp") (("1" (assert) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (lemma "poly_eq_le_degree") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (expand "*") (("1" (expand "DD") (("1" (case "h(m) ^ (1 - m + n) * (1 / h(m)) ^ (1 - m + n) = 1") (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "div_expt") (("2" (inst - "1-m+n" "1" "h(m)") (("2" (assert) (("2" (lemma "expt_1n_aux") (("2" (inst - "1-m+n") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-1 -2 -3)) (("2" (case "NOT thisdeg <= ppd`rdegl") (("1" (hide 2) (("1" (lemma "pseudo_div_lengths") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (replace -9) (("1" (replace -2) (("1" (hide (-1 -2)) (("1" (expand "thisdeg" 1) (("1" (case "length[int](thisrem) <= length[int](ppd`reml)") (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "thisrem") (("2" (expand "adjusted_remainder" -1) (("2" (invoke (typepred "%1") (! -1 2)) (("1" (replace -4 :dir rl) (("1" (replaces -2) (("1" (hide (-1 -2 -3)) (("1" (lemma "nonzero_version_def") (("1" (replace -7) (("1" (inst - "primitize_list(ppd`reml)") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3 -4 -5 -6)) (("1" (assert) (("1" (case "length[int](primitize_list(ppd`reml)) = length[int](ppd`reml)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "primitize_list") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "nth[int]
                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                   ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skosimp*) (("3" (expand "divides") (("3" (inst + "-nth[int]
                                                                                                                  (nonzero_version(primitize_list(pseudo_div
                                                                                                                                                  (g, n)(h, m)(0)`reml)),
                                                                                                                   ii!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "DD" 1) (("2" (case "(FORALL (i:nat): i>thisdeg AND i<=ppd`rdegl IMPLIES PP(i)=0) AND (EXISTS (cp:posnat): FORALL (i:nat): i<=thisdeg IMPLIES thispoly(i)=(-cp*psign)*PP(i))") (("1" (flatten) (("1" (skeep) (("1" (inst + "cp") (("1" (expand "polynomial" 1) (("1" (decompose-equality 1) (("1" (lemma "sigma_split") (("1" (invoke (inst - "%1" "ppd`rdegl" "0" "thisdeg") (! 1 2 3)) (("1" (assert) (("1" (invoke (case "%1 = 0") (! -1 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "sigma_eq") (("1" (skeep) (("1" (inst -2 "n!1") (("1" (assert) (("1" (expand "*") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "sigma_restrict_eq_0") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split +) (("1" (skeep) (("1" (expand "PP" 1) (("1" (lift-if) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (copy -3) (("1" (expand "thisdeg" -1) (("1" (expand "thisrem" -1) (("1" (expand "adjusted_remainder" -1) (("1" (assert) (("1" (invoke (case "%1 = -psign") (! -1 1 1 1 2)) (("1" (replace -1) (("1" (replace -11) (("1" (replace -7) (("1" (typepred "descalarize_list(AA, -psign)") (("1" (hide (-1 -3)) (("1" (replaces -1 -3) (("1" (assert) (("1" (case "NOT i>=length[int](AA)") (("1" (assert) nil nil) ("2" (name "pl" "primitize_list(ppd`reml)") (("2" (replace -1) (("2" (lemma "nonzero_version_def") (("2" (inst - "pl") (("2" (replace -10) (("2" (assert) (("2" (flatten) (("2" (inst -6 "i") (("2" (assert) (("2" (case "i < length[int](pl)") (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "length(ppd`reml)>0") (("1" (expand "max" -3) (("1" (assert) (("1" (lemma "primitize_list_def") (("1" (inst?) (("1" (assert) (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "primitize_list_def") (("2" (inst?) (("2" (assert) (("2" (inst + "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "PP") (("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "PP") (("2" (lemma "primitize_list_def") (("2" (inst?) (("2" (replace -8) (("2" (assert) (("2" (invoke (case "%1") (! -1 1)) (("1" (replace -1) (("1" (assert) (("1" (flatten) (("1" (inst + "1/gcd_coeff(ppd`reml)") (("1" (assert) (("1" (skeep) (("1" (expand "thispoly" 1) (("1" (assert) (("1" (expand "PP" 1) (("1" (assert) (("1" (reveal "mzero") (("1" (assert) (("1" (inst - "i") (("1" (expand "thisrem" 2) (("1" (expand "adjusted_remainder" 2) (("1" (replace -13) (("1" (case "NOT  IF h(m) > 0 OR mod(1 - m + n, 2) = 0 THEN -1
                                                            ELSE --1
                                                            ENDIF = -psign") (("1" (hide-all-but 1) (("1" (expand "psign") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                                                                                       -psign)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (mult-by -1 "-psign") (("2" (case "psign*psign=1") (("1" (invoke (mult-by -1 "%1") (! -2 2 2)) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1 + :dir rl) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(ppd`reml)") (("1" (replace -11) (("1" (assert) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -2 + :dir rl) (("1" (lemma "primitize_list_def") (("1" (inst - "ppd`reml") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -3 +) (("1" (assert) (("1" (hide -) (("1" (real-props) (("1" (case "nth[int](primitize_list(ppd`reml), i) =
                                         gcd_coeff(ppd`reml) * nth[int](primitize_list(ppd`reml), i) *
                                          (1 / gcd_coeff(ppd`reml))") (("1" (assert) (("1" (mult-by -1 "-psign") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8 -9)) (("2" (reveal "nonzeep") (("2" (assert) (("2" (skeep) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "psign") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (adjusted_remainder_length 0 (adjusted_remainder_length-2 "" 3790098737 ("" (skeep) (("" (assert) (("" (case "m > n") (("1" (assert) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (array2list(1 + n)(g))),
                              -1)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3)) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "mgtn" 1) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (expand "adjusted_remainder") (("1" (invoke (name "DS" "%1") (! 3 1 1 2)) (("1" (replace -1) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (expand "primitize_list") (("1" (assert) (("1" (expand "gcd_coeff") (("1" (expand "nonzero_version") (("1" (case "reverse[int]((::)) = (::)") (("1" (replace -1) (("1" (expand "nonzero_version_rec") (("1" (replace -1) (("1" (expand "descalarize_list") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (expand "adjusted_remainder") (("2" (invoke (name "DS" "%1") (! 3 1 1 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                        (g, n)(h, m)(0)") (("2" (replaces -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                        DS)") (("2" (hide (-1 -3)) (("2" (replaces -1) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)=0") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)<=m") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide -) (("2" (hide (2 4)) (("2" (lemma "pseudo_div_lengths") (("2" (expand "ppd") (("2" (inst?) (("2" (lemma "ppd") (("2" (replace -1 :dir rl) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (poly_divide_lengths formula-decl nil polynomial_division nil) (max_nnreal_0 formula-decl nil min_max reals) (ppd skolem-const-decl "{DT: DivListType |
   (m > n OR 0 > n - m AND length(DT`reml) = 1 + n AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m AND length(DT`reml) = 1 + DT`rdegl)}" polynomial_pseudo_divide nil) (<= const-decl "bool" reals nil) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (reverse def-decl "list[T]" list_props nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nil application-judgement "below(m)" mod nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (divides const-decl "bool" divides nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (TRUE const-decl "bool" booleans nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (adjusted_remainder const-decl "list[int]" polynomial_pseudo_divide nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (adjusted_remainder_length-1 nil 3593530910 ("" (skeep) (("" (assert) (("" (case "m > n") (("1" (assert) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (array2list(1 + n)(g))),
                              -1)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3)) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "-nth[int]
            (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
             ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "mgtn" 1) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (expand "adjusted_remainder") (("1" (invoke (name "DS" "%1") (! 3 1 1 2)) (("1" (replace -1) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (expand "primitize_list") (("1" (assert) (("1" (expand "gcd_coeff") (("1" (expand "nonzero_version") (("1" (case "reverse[int]((::)) = (::)") (("1" (replace -1) (("1" (expand "nonzero_version_rec") (("1" (replace -1) (("1" (expand "descalarize_list") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (expand "adjusted_remainder") (("2" (invoke (name "DS" "%1") (! 3 1 1 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                        (g, n)(h, m)(0)") (("2" (replaces -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                        DS)") (("2" (hide (-1 -3)) (("2" (replaces -1) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)=0") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)<=m") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide -) (("2" (hide (2 4)) (("2" (lemma "pseudo_div_lengths") (("2" (expand "ppd") (("2" (inst?) (("2" (lemma "ppd") (("2" (replace -1 :dir rl) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (max_nnreal_0 formula-decl nil min_max reals) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (list type-decl nil list_adt nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil)) shostak)) (adjusted_remainder_length2 0 (adjusted_remainder_length2-2 "" 3790098743 ("" (skeep) (("" (assert) (("" (case "m > n") (("1" (assert) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                                  (array2list(1 + n)(g))),
                                  -1)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3)) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "mgtn" 1) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (expand "adjusted_remainder") (("1" (invoke (name "DS" "%1") (! 3 1 1 2)) (("1" (replace -1) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (expand "primitize_list") (("1" (assert) (("1" (expand "gcd_coeff") (("1" (expand "nonzero_version") (("1" (case "reverse[int]((::)) = (::)") (("1" (replace -1) (("1" (expand "nonzero_version_rec") (("1" (replace -1) (("1" (expand "descalarize_list") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (expand "adjusted_remainder") (("2" (invoke (name "DS" "%1") (! 3 1 1 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                                   (g, n)(h, m)(0)") (("2" (replaces -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                              DS)") (("2" (hide (-1 -3)) (("2" (replaces -1) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)=0") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)<=m") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide -) (("2" (hide (2 4)) (("2" (lemma "pseudo_div_lengths") (("2" (expand "ppd") (("2" (inst?) (("2" (lemma "ppd") (("2" (replace -1 :dir rl) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (poly_divide_lengths formula-decl nil polynomial_division nil) (max_nnreal_0 formula-decl nil min_max reals) (ppd skolem-const-decl "{DT: DivListType |
   (m > n OR 0 > n - m AND length(DT`reml) = 1 + n AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m AND length(DT`reml) = 1 + DT`rdegl)}" polynomial_pseudo_divide nil) (<= const-decl "bool" reals nil) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (reverse def-decl "list[T]" list_props nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nil application-judgement "below(m)" mod nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (divides const-decl "bool" divides nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (TRUE const-decl "bool" booleans nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (adjusted_remainder const-decl "list[int]" polynomial_pseudo_divide nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (adjusted_remainder_length2-1 nil 3619190066 ("" (skeep) (("" (assert) (("" (case "m > n") (("1" (assert) (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                                  (array2list(1 + n)(g))),
                                  -1)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3)) (("1" (lemma "primitize_list_length") (("1" (inst?) (("1" (assert) nil))))))))))))))))))))) ("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "-nth[int]
                  (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
                   ii!1)") (("2" (assert) nil))))))))))))))))) ("2" (label "mgtn" 1) (("2" (case "m = 0") (("1" (assert) (("1" (replace -1) (("1" (expand "adjusted_remainder") (("1" (invoke (name "DS" "%1") (! 3 1 1 2)) (("1" (replace -1) (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (expand "primitize_list") (("1" (assert) (("1" (expand "gcd_coeff") (("1" (expand "nonzero_version") (("1" (case "reverse[int]((::)) = (::)") (("1" (replace -1) (("1" (expand "nonzero_version_rec") (("1" (replace -1) (("1" (expand "descalarize_list") (("1" (assert) nil))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))))))))))))))))))))))) ("2" (assert) (("2" (label "mzero" 1) (("2" (hide "mzero") (("2" (expand "adjusted_remainder") (("2" (invoke (name "DS" "%1") (! 3 1 1 2)) (("2" (replaces -1) (("2" (name "ppd" "pseudo_div
                                                                                   (g, n)(h, m)(0)") (("2" (replaces -1) (("2" (typepred "descalarize_list(nonzero_version(primitize_list(ppd`reml)),
                                              DS)") (("2" (hide (-1 -3)) (("2" (replaces -1) (("2" (assert) (("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)=0") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil))))))) ("2" (lemma "nonzero_version_def") (("2" (inst - "primitize_list(ppd`reml)") (("2" (assert) (("2" (flatten) (("2" (case "length[int](ppd`reml)<=m") (("1" (assert) (("1" (expand "primitize_list") (("1" (lift-if) (("1" (ground) nil))))))) ("2" (hide -) (("2" (hide (2 4)) (("2" (lemma "pseudo_div_lengths") (("2" (expand "ppd") (("2" (inst?) (("2" (lemma "ppd") (("2" (replace -1 :dir rl) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "poly_divide_lengths") (("2" (inst?) (("2" (assert) nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) nil) ((poly_divide_lengths formula-decl nil polynomial_division nil) (max_nnreal_0 formula-decl nil min_max reals) (nonzero_version_rec def-decl "{nl: list[int] |
   length[int](nl) <= length[int](ll) AND
    (FORALL (i: nat):
       i < length[int](ll) IMPLIES
        nth[int](ll, i) =
         (IF i < length[int](ll) - length[int](nl) THEN 0
          ELSE nth[int](nl, i - length[int](ll) + length[int](nl))
          ENDIF))
     AND
     ((length[int](nl) > 0 OR
        EXISTS (i: below(length[int](ll))): nth(ll, i) /= 0)
       IMPLIES (length[int](nl) > 0 AND car[int](nl) /= 0))}" gcd_coeff nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (gcd_coeff def-decl "{m: nat |
   FORALL (ii: nat):
     ii < length[int](ll) IMPLIES divides(m, nth[int](ll, ii))}" gcd_coeff nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (list type-decl nil list_adt nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil)) nil)) (adjusted_remainder_empty 0 (adjusted_remainder_empty-3 "" 3790098745 ("" (skeep) (("" (case "m > n") (("1" (assert) (("1" (expand "poly_divide") (("1" (expand "make_divtype") (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (array2list(1 + n)(g))),
                              -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (skeep 3) (("1" (inst + "j") (("1" (lemma "primitize_list_def") (("1" (inst - "array2list(1+n)(g)") (("1" (assert) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (inst - "j") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "j") (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "mgtn" 1) (("2" (expand "adjusted_remainder") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (pseudo_div
                                               (g, n)(h, m)(0)`reml)),
                              IF h(m) > 0 OR mod(1 - m + n, 2) = 0 OR m > n
                                THEN -1
                              ELSE --1
                              ENDIF)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                      (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (hide (-1 -2 -3 -4)) (("1" (skeep 4) (("1" (case "j < length[int]
                                                     (primitize_list(pseudo_div
                                                                     (g, n)(h, m)(0)`reml))") (("1" (inst + "j") (("1" (assert) (("1" (flatten) (("1" (copy -1) (("1" (label "pz" -2) (("1" (hide "pz") (("1" (rewrite "primitize_list_length" -1) (("1" (reveal "pz") (("1" (case "nth(pseudo_div(g, n)(h, m)(0)`reml, j) = 0") (("1" (delabel "pz") (("1" (lemma "pseudo_div_def") (("1" (inst?) (("1" (inst - "1" "1") (("1" (assert) (("1" (replace -6) (("1" (replace -7) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst - "j") (("1" (replace -1 +) (("1" (hide (-1 -2)) (("1" (assert) (("1" (expand "*") (("1" (replace -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "primitize_list_def") (("2" (inst - "pseudo_div(g,n)(h,m)(0)`reml") (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst + "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "primitize_list_length") (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "max") (("2" (lift-if) (("2" (ground) (("2" (typepred "pseudo_div(g, n)(h, m)(0)") (("2" (assert) (("2" (replace -1) (("2" (assert) (("2" (expand "poly_divide" -10) (("2" (expand "make_divtype") (("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (expand "poly_divide" +) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + " nth[int]
                    (nonzero_version(primitize_list(pseudo_div
                                                    (g, n)(h, m)(0)`reml)),
                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                    (nonzero_version(primitize_list(pseudo_div
                                                    (g, n)(h, m)(0)`reml)),
                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (poly_divide def-decl "DivType" polynomial_division nil) (int_minus_int_is_int application-judgement "int" integers nil) (adjusted_remainder const-decl "list[int]" polynomial_pseudo_divide nil) (make_divlisttype const-decl "DivListType" polynomial_pseudo_divide nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j skolem-const-decl "nat" polynomial_pseudo_divide nil) (n skolem-const-decl "nat" polynomial_pseudo_divide nil) (g skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (primitize_list_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (divides const-decl "bool" divides nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (primitize_list const-decl "list[int]" gcd_coeff nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (pseudo_div def-decl "{DT: DivListType |
   (m > n OR i > n - m AND length(DT`reml) = n + 1 AND DT`rdegl = n) OR
    (m = 0 AND length(DT`reml) = 0 AND DT`rdegl = 0) OR
     (m > 0 AND length(DT`reml) = m + i AND length(DT`reml) = DT`rdegl + 1)}" polynomial_pseudo_divide nil) (int_times_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (make_divtype const-decl "DivType" polynomial_division nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" polynomial_pseudo_divide nil) (ii skolem-const-decl "nat" polynomial_pseudo_divide nil) (minus_int_is_int application-judgement "int" integers nil) (ii skolem-const-decl "nat" polynomial_pseudo_divide nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (DivType type-eq-decl nil polynomial_division nil) (* const-decl "[T -> real]" real_fun_ops reals) (^ const-decl "real" exponentiation nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (HH const-decl "int" polynomial_pseudo_divide nil) (<= const-decl "bool" reals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (pseudo_div_def formula-decl nil polynomial_pseudo_divide nil) (m skolem-const-decl "nat" polynomial_pseudo_divide nil) (h skolem-const-decl "[nat -> int]" polynomial_pseudo_divide nil) (j skolem-const-decl "nat" polynomial_pseudo_divide nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (pseudo_div_lengths formula-decl nil polynomial_pseudo_divide nil) (nil application-judgement "below(m)" mod nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (DivListType type-eq-decl nil polynomial_pseudo_divide nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil)) shostak) (adjusted_remainder_empty-2 "" 3755374918 ("" (skeep) (("" (case "m > n") (("1" (assert) (("1" (expand "poly_divide") (("1" (expand "make_divtype") (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (array2list(1 + n)(g))),
                              -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (skeep 3) (("1" (inst + "j") (("1" (lemma "primitize_list_def") (("1" (inst - "array2list(1+n)(g)") (("1" (assert) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (inst - "j") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "j") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "j") (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "j") (("2" (assert) (("2" (replace -3 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "mgtn" 1) (("2" (expand "adjusted_remainder") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (pseudo_div
                                               (g, n)(h, m)(0)`reml)),
                              IF h(m) > 0 OR mod(1 - m + n, 2) = 0 OR m > n
                                THEN -1
                              ELSE --1
                              ENDIF)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                      (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (hide (-1 -2 -3 -4)) (("1" (skeep 4) (("1" (case "j < length[int]
                                                     (primitize_list(pseudo_div
                                                                     (g, n)(h, m)(0)`reml))") (("1" (inst + "j") (("1" (assert) (("1" (flatten) (("1" (copy -1) (("1" (label "pz" -2) (("1" (hide "pz") (("1" (rewrite "primitize_list_length" -1) (("1" (reveal "pz") (("1" (case "nth(pseudo_div(g, n)(h, m)(0)`reml, j) = 0") (("1" (delabel "pz") (("1" (lemma "pseudo_div_def") (("1" (inst?) (("1" (inst - "1" "1") (("1" (assert) (("1" (replace -6) (("1" (replace -7) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst - "j") (("1" (replace -1 +) (("1" (hide (-1 -2)) (("1" (assert) (("1" (expand "*") (("1" (replace -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "primitize_list_def") (("2" (inst - "pseudo_div(g,n)(h,m)(0)`reml") (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst + "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "primitize_list_length") (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "max") (("2" (lift-if) (("2" (ground) (("2" (typepred "pseudo_div(g, n)(h, m)(0)") (("2" (assert) (("2" (replace -1) (("2" (assert) (("2" (expand "poly_divide" -10) (("2" (expand "make_divtype") (("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (expand "poly_divide" +) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + " nth[int]
                    (nonzero_version(primitize_list(pseudo_div
                                                    (g, n)(h, m)(0)`reml)),
                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                    (nonzero_version(primitize_list(pseudo_div
                                                    (g, n)(h, m)(0)`reml)),
                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((poly_divide def-decl "DivType" polynomial_division nil) (primitize_list_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (list type-decl nil list_adt nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (primitize_list const-decl "list[int]" gcd_coeff nil) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (make_divtype const-decl "DivType" polynomial_division nil) (DivType type-eq-decl nil polynomial_division nil)) shostak) (adjusted_remainder_empty-1 nil 3593852901 ("" (skeep) (("" (case "m > n") (("1" (assert) (("1" (expand "poly_divide") (("1" (expand "make_divtype") (("1" (expand "adjusted_remainder") (("1" (expand "pseudo_div") (("1" (expand "make_divlisttype") (("1" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (array2list(1 + n)(g))),
                              -1)") (("1" (hide (-1 -3)) (("1" (replaces -1) (("1" (assert) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(array2list(1 + n)(g))") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (skeep 3) (("1" (inst + "j") (("1" (lemma "primitize_list_def") (("1" (inst - "array2list(1+n)(g)") (("1" (assert) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (inst - "j") (("1" (assert) (("1" (typepred "array2list(1+n)(g)") (("1" (hide (-1 -2)) (("1" (inst - "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "j") (("2" (typepred "array2list(1+n)(g)") (("2" (inst - "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "primitize_list_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divides") (("2" (inst + "-nth[int]
            (nonzero_version(primitize_list(array2list[int](1 + n)(g))),
             ii!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "mgtn" 1) (("2" (expand "adjusted_remainder") (("2" (typepred "descalarize_list(nonzero_version(primitize_list
                                              (pseudo_div
                                               (g, n)(h, m)(0)`reml)),
                              IF h(m) > 0 OR mod(1 - m + n, 2) = 0 OR m > n
                                THEN -1
                              ELSE --1
                              ENDIF)") (("1" (replaces -2) (("1" (hide (-1 -2)) (("1" (lemma "nonzero_version_def") (("1" (inst - "primitize_list(pseudo_div
                                                      (g, n)(h, m)(0)`reml)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (hide (-1 -2 -3 -4)) (("1" (skeep 4) (("1" (case "j < length[int]
                                                     (primitize_list(pseudo_div
                                                                     (g, n)(h, m)(0)`reml))") (("1" (inst + "j") (("1" (assert) (("1" (flatten) (("1" (copy -1) (("1" (label "pz" -2) (("1" (hide "pz") (("1" (rewrite "primitize_list_length" -1) (("1" (reveal "pz") (("1" (case "nth(pseudo_div(g, n)(h, m)(0)`reml, j) = 0") (("1" (delabel "pz") (("1" (lemma "pseudo_div_def") (("1" (inst?) (("1" (inst - "1" "1") (("1" (assert) (("1" (replace -6) (("1" (replace -7) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst - "j") (("1" (replace -1 +) (("1" (hide (-1 -2)) (("1" (assert) (("1" (expand "*") (("1" (replace -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "primitize_list_def") (("2" (inst - "pseudo_div(g,n)(h,m)(0)`reml") (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst - "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst + "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "primitize_list_length") (("2" (lemma "pseudo_div_lengths") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "max") (("2" (lift-if) (("2" (ground) (("2" (typepred "pseudo_div(g, n)(h, m)(0)") (("2" (assert) (("2" (replace -1) (("2" (assert) (("2" (expand "poly_divide" -10) (("2" (expand "make_divtype") (("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (expand "poly_divide" +) (("2" (expand "make_divtype") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "divides") (("2" (inst + " nth[int]
                    (nonzero_version(primitize_list(pseudo_div
                                                    (g, n)(h, m)(0)`reml)),
                     ii)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep) (("3" (expand "divides") (("3" (inst + "-nth[int]
                    (nonzero_version(primitize_list(pseudo_div
                                                    (g, n)(h, m)(0)`reml)),
                     ii)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DivType type-eq-decl nil polynomial_division nil) (make_divtype const-decl "DivType" polynomial_division nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (primitize_list const-decl "list[int]" gcd_coeff nil) (nonzero_version const-decl "list[int]" gcd_coeff nil) (descalarize_list def-decl "{nl: list[int] |
   length[int](nl) = length[int](ll) AND
    FORALL (i: below(length[int](ll))):
      nth[int](ll, i) = k * nth[int](nl, i)}" gcd_coeff nil) (list type-decl nil list_adt nil) (nonzero_version_def formula-decl nil gcd_coeff nil) (primitize_list_length formula-decl nil gcd_coeff nil) (primitize_list_def formula-decl nil gcd_coeff nil) (poly_divide def-decl "DivType" polynomial_division nil)) shostak)) (adjusted_remainder_test_TCC1 0 (adjusted_remainder_test_TCC1-1 nil 3609086516 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil)) nil (adjusted_remainder_test subtype "4" "{m | polynomial_pseudo_divide.h(polynomial_pseudo_divide.m) /= 0}"))) (adjusted_remainder_test 0 (adjusted_remainder_test-1 nil 3609086516 ("" (eval-formula) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)))
