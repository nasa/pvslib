(polylist (eval_polylist_TCC1 0 (eval_polylist_TCC1-1 nil 3601220513 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (eval_polylist subtype "polylist.thisdeg" "{i: integers.int | booleans.OR(polylist.x /= 0, reals.>=(i, 0))}"))) (eval_polylist_TCC2 0 (eval_polylist_TCC2-1 nil 3601220513 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (eval_polylist subtype "polylist.newl" "Polylist"))) (eval_polylist_TCC3 0 (eval_polylist_TCC3-1 nil 3601220513 ("" (termination-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (eval_polylist subtype "polylist.deg" "integers.upfrom((number_fields.-)(list_props[rat].length(polylist.newl), 1))"))) (eval_polylist_TCC4 0 (eval_polylist_TCC4-1 nil 3601220513 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (eval_polylist subtype "polylist.thisdeg" "{i: integers.int | booleans.OR(polylist.x /= 0, reals.>=(i, 0))}"))) (eval_polylist_TCC5 0 (eval_polylist_TCC5-1 nil 3601224651 ("" (termination-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (eval_polylist termination "polylist.eval_polylist(polylist.newl, polylist.deg, (number_fields.+)(polylist.acc, number_fields.*(polylist.thisco, exponentiation.^(polylist.x, polylist.thisdeg))))" "nil"))) (eval_polylist_times_x_TCC1 0 (eval_polylist_times_x_TCC1-1 nil 3601231397 ("" (subtype-tcc) nil nil) nil nil (eval_polylist_times_x subtype "(number_fields.-)(polylist.deg, 1)" "integers.upfrom((number_fields.-)(list_props[rat].length(polylist.pl), 1))"))) (eval_polylist_times_x_TCC2 0 (eval_polylist_times_x_TCC2-1 nil 3601231397 ("" (subtype-tcc) nil nil) nil nil (eval_polylist_times_x subtype "polylist.deg" "integers.upfrom((number_fields.-)(list_props[rat].length(polylist.pl), 1))"))) (eval_polylist_times_x 0 (eval_polylist_times_x-1 nil 3601231398 ("" (induct "pl") (("1" (grind) nil nil) ("2" (ground) nil nil) ("3" (ground) (("3" (skeep) (("3" (skeep) (("3" (assert) (("3" (expand "eval_polylist" +) (("3" (lift-if) (("3" (split +) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) (("2" (inst?) (("1" (assert) (("1" (lemma "expt_plus") (("1" (inst - "(deg - length(cons(cons1_var, cons2_var)))" "1" "x") (("1" (expand "^" -1 3) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces -1) (("2" (assert) (("2" (expand "^" 2) (("2" (expand "expt" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "deg") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (x skolem-const-decl "real" polylist nil) (nzreal nonempty-type-eq-decl nil reals nil) (TRUE const-decl "bool" booleans nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nat_exp application-judgement "nat" exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (deg skolem-const-decl "upfrom(length(cons(cons1_var, cons2_var)))" polylist nil) (cons2_var skolem-const-decl "list[rat]" polylist nil) (cons1_var skolem-const-decl "rat" polylist nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (eval_polylist def-decl "real" polylist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Polylist type-eq-decl nil polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (eval_polylist_remove_acc 0 (eval_polylist_remove_acc-1 nil 3601307736 ("" (induct "pl") (("1" (grind) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (assert) (("3" (skeep) (("3" (expand "eval_polylist" +) (("3" (lift-if) (("3" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (copy -1) (("2" (inst?) (("2" (replaces -1) (("2" (invoke (name "AA" "%1") (! 2 1)) (("2" (replace -1) (("2" (hide -1) (("2" (inst?) (("2" (replace -1) (("2" (expand "AA") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (AA skolem-const-decl "real" polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (eval_polylist def-decl "real" polylist nil) (Polylist type-eq-decl nil polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (eval_polylist_test_TCC1 0 (eval_polylist_test_TCC1-1 nil 3601225669 ("" (grind) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (eval_polylist_test subtype "3" "integers.upfrom((number_fields.-)(list_props[rat].length((: 1, 2, 3, 4 :)), 1))"))) (eval_polylist_test_TCC2 0 (eval_polylist_test_TCC2-1 nil 3601225669 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil)) nil (eval_polylist_test subtype "2" "{i: integers.int | booleans.OR(polylist.x /= 0, reals.>=(i, 0))}"))) (eval_polylist_test_TCC3 0 (eval_polylist_test_TCC3-1 nil 3601225669 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (eval_polylist_test subtype "3" "{i: integers.int | booleans.OR(polylist.x /= 0, reals.>=(i, 0))}"))) (eval_polylist_test 0 (eval_polylist_test-1 nil 3601225671 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (eval_polylist def-decl "real" polylist nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (polylist_TCC1 0 (polylist_TCC1-1 nil 3601220513 ("" (subtype-tcc) nil nil) nil nil (polylist subtype "(number_fields.-)(list_props[rat].length(polylist.pl), 1)" "integers.upfrom((number_fields.-)(list_props[rat].length(polylist.pl), 1))"))) (pmonom_TCC1 0 (pmonom_TCC1-1 nil 3601224651 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (/= const-decl "boolean" notequal nil)) nil (pmonom subtype "polylist.deg" "{i: integers.int | booleans.OR(polylist.x /= 0, reals.>=(i, 0))}"))) (pmonom_TCC2 0 (pmonom_TCC2-1 nil 3601313859 ("" (skeep) (("" (split) (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil) ((pconst const-decl "Polylist" polylist nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (polylist const-decl "real" polylist nil) (eval_polylist def-decl "real" polylist nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil)) nil (pmonom subtype "polylist.pconst(polylist.c)" "{pl: polylist.Polylist | booleans.AND(list_props[rat].length(pl) = (number_fields.+)(1, polylist.deg), FORALL (x: reals.real): polylist.polylist(pl)(x) = number_fields.*(polylist.c, exponentiation.^(x, polylist.deg)))}"))) (pmonom_TCC3 0 (pmonom_TCC3-1 nil 3601313859 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (pmonom subtype "(number_fields.-)(polylist.deg, 1)" "nat"))) (pmonom_TCC4 0 (pmonom_TCC4-1 nil 3601313859 ("" (termination-tcc) nil nil) nil nil (pmonom termination "polylist.pmonom(polylist.c, (number_fields.-)(polylist.deg, 1))" "nil"))) (pmonom_TCC5 0 (pmonom_TCC5-1 nil 3601313859 ("" (skeep) (("" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (expand "length" +) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "v(c,deg-1)") (("2" (inst - "x") (("2" (expand "^") (("2" (expand "expt" +) (("2" (mult-by -4 "x") (("2" (replace -1 :dir rl) (("2" (expand "polylist" +) (("2" (expand "eval_polylist" + 1) (("2" (expand "length" 2 1) (("2" (rewrite "eval_polylist_times_x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (Polylist type-eq-decl nil polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (polylist const-decl "real" polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (expt def-decl "real" exponentiation nil) (eval_polylist def-decl "real" polylist nil) (upfrom nonempty-type-eq-decl nil integers nil) (eval_polylist_times_x formula-decl nil polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times1_imp formula-decl nil extra_real_props nil)) nil (pmonom subtype "list_adt[rat].cons(0, polylist.pmonom(polylist.c, (number_fields.-)(polylist.deg, 1)))" "{pl: polylist.Polylist | booleans.AND(list_props[rat].length(pl) = (number_fields.+)(1, polylist.deg), FORALL (x: reals.real): polylist.polylist(pl)(x) = number_fields.*(polylist.c, exponentiation.^(x, polylist.deg)))}"))) (psum_TCC1 0 (psum_TCC1-1 nil 3601220513 ("" (skeep*) (("" (expand "polylist" + 2) (("" (expand "length" +) (("" (expand "length" +) (("" (assert) (("" (expand "eval_polylist") (("" (expand "length" +) (("" (expand "length" +) (("" (expand "^" +) (("" (expand "expt") (("" (expand "polylist" +) (("" (expand "length" + 1) (("" (expand "eval_polylist" +) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (assert) (("" (ground) (("1" (grind) nil nil) ("2" (replace -5 :dir rl) (("2" (expand "length" + 3) (("2" (expand "length" + 3) (("2" (case "x^0=1") (("1" (assert) (("1" (replaces -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (invoke (name "AA" "%1") (! 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (expand "AA") (("1" (assert) (("1" (expand "length" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist const-decl "real" polylist nil) (eval_polylist def-decl "real" polylist nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (eval_polylist_remove_acc formula-decl nil polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rat nonempty-type-eq-decl nil rationals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (AA skolem-const-decl "real" polylist nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_plus_real_is_real application-judgement "real" reals nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (psum subtype "list_adt[rat].cons((number_fields.+)(polylist.plcoeff, polylist.qlcoeff), polylist.newql)" "{pql: polylist.Polylist | FORALL (x): polylist.polylist(pql)(polylist.x) = (number_fields.+)(polylist.polylist(polylist.pl)(polylist.x), polylist.polylist(polylist.ql)(polylist.x))}"))) (psum_TCC2 0 (psum_TCC2-2 nil 3601315963 ("" (skeep*) (("" (expand "polylist" + 3) (("" (expand "length" +) (("" (expand "length" +) (("" (assert) (("" (expand "eval_polylist") (("" (expand "length" +) (("" (expand "length" +) (("" (expand "^" +) (("" (expand "expt") (("" (expand "polylist" +) (("" (expand "length" + 1) (("" (expand "eval_polylist" +) (("" (assert) (("" (expand "length" + 3) (("" (expand "length" + 3) (("" (case "x^0=1") (("1" (assert) (("1" (replaces -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (invoke (name "AA" "%1") (! 2 1)) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (expand "AA") (("1" (assert) (("1" (expand "length" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist const-decl "real" polylist nil) (eval_polylist def-decl "real" polylist nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_polylist_remove_acc formula-decl nil polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rat nonempty-type-eq-decl nil rationals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (AA skolem-const-decl "real" polylist nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_plus_real_is_real application-judgement "real" reals nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (psum subtype "list_adt[rat].cons((number_fields.+)(polylist.plcoeff, polylist.qlcoeff), polylist.newpl)" "{pql: polylist.Polylist | FORALL (x): polylist.polylist(pql)(polylist.x) = (number_fields.+)(polylist.polylist(polylist.pl)(polylist.x), polylist.polylist(polylist.ql)(polylist.x))}")) (psum_TCC2-1 nil 3601220513 ("" (termination-tcc) nil nil) ((list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (psum subtype "list_adt[rat].cons((number_fields.+)(polylist.plcoeff, polylist.qlcoeff), polylist.newpl)" "{pql: polylist.Polylist | FORALL (x): polylist.polylist(pql)(polylist.x) = (number_fields.+)(polylist.polylist(polylist.pl)(polylist.x), polylist.polylist(polylist.ql)(polylist.x))}"))) (psum_TCC3 0 (psum_TCC3-1 nil 3601225382 ("" (termination-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil)) nil (psum subtype "list_adt[rat].cdr(polylist.pl)" "Polylist"))) (psum_TCC4 0 (psum_TCC4-1 nil 3601315195 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil)) nil (psum subtype "list_adt[rat].cdr(polylist.ql)" "Polylist"))) (psum_TCC5 0 (psum_TCC5-1 nil 3601315195 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (psum termination "polylist.psum(list_adt[rat].cdr(polylist.pl), list_adt[rat].cdr(polylist.ql))" "nil"))) (psum_TCC6 0 (psum_TCC6-1 nil 3601315195 ("" (skeep*) (("" (expand "polylist" +) (("" (expand "length" + 1) (("" (expand "eval_polylist" +) (("" (assert) (("" (lift-if) (("" (ground) (("" (expand "length" + 3) (("" (expand "length" + 3) (("" (case "x^0=1") (("1" (replaces -1) (("1" (assert) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (invoke (name "AA" "%1") (! 2 1)) (("1" (replaces -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (invoke (name "BB" "%1") (! 2 2 1)) (("1" (replaces -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (expand "AA") (("1" (expand "BB") (("1" (assert) (("1" (typepred "v(cdr[rat](pl), cdr[rat](ql))") (("1" (inst - "x") (("1" (expand "polylist" -) (("1" (lemma "eval_polylist_times_x") (("1" (case "0 = 0*x") (("1" (replaces -1 +) (("1" (rewrite -1 + :dir rl) (("1" (invoke (name "AAA" "%1") (! 2 1)) (("1" (replaces -1) (("1" (rewrite -1 + :dir rl) (("1" (invoke (name "BBB" "%1") (! 2 2 1)) (("1" (replaces -1) (("1" (rewrite -1 + :dir rl) (("1" (expand "AAA") (("1" (expand "BBB") (("1" (expand "length" 2 2) (("1" (expand "length" 2 3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist const-decl "real" polylist nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (eval_polylist def-decl "real" polylist nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (AA skolem-const-decl "real" polylist nil) (eval_polylist_times_x formula-decl nil polylist nil) (pl skolem-const-decl "Polylist" polylist nil) (AAA skolem-const-decl "real" polylist nil) (BBB skolem-const-decl "real" polylist nil) (ql skolem-const-decl "Polylist" polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (BB skolem-const-decl "real" polylist nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Polylist type-eq-decl nil polylist nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (eval_polylist_remove_acc formula-decl nil polylist nil) (expt def-decl "real" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (psum subtype "list_adt[rat].cons((number_fields.+)(list_adt[rat].car(polylist.pl), list_adt[rat].car(polylist.ql)), polylist.psum(list_adt[rat].cdr(polylist.pl), list_adt[rat].cdr(polylist.ql)))" "{pql: polylist.Polylist | FORALL (x): polylist.polylist(pql)(polylist.x) = (number_fields.+)(polylist.polylist(polylist.pl)(polylist.x), polylist.polylist(polylist.ql)(polylist.x))}"))) (pscal_TCC1 0 (pscal_TCC1-1 nil 3601227496 ("" (skeep) (("" (grind) nil nil)) nil) ((length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (eval_polylist def-decl "real" polylist nil) (polylist const-decl "real" polylist nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (pscal subtype "(: number_fields.*(polylist.c, list_adt[rat].car(polylist.pl)) :)" "{pql: polylist.Polylist | booleans.AND(list_props[rat].length(pql) = list_props[rat].length(polylist.pl), FORALL (x): polylist.polylist(pql)(polylist.x) = number_fields.*(polylist.c, polylist.polylist(polylist.pl)(polylist.x)))}"))) (pscal_TCC2 0 (pscal_TCC2-1 nil 3601747475 ("" (termination-tcc) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil)) nil (pscal subtype "list_adt[rat].cdr(polylist.pl)" "Polylist"))) (pscal_TCC3 0 (pscal_TCC3-1 nil 3601747631 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil)) nil (pscal termination "polylist.pscal(polylist.c, list_adt[rat].cdr(polylist.pl))" "nil"))) (pscal_TCC4 0 (pscal_TCC4-1 nil 3601747631 ("" (skeep) (("" (split) (("1" (expand "length" + 1) (("1" (assert) (("1" (typepred "v(c,cdr[rat](pl))") (("1" (replace -3) (("1" (expand "length" + 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "polylist" +) (("2" (expand "length" + 1) (("2" (typepred "v(c,cdr[rat](pl))") (("1" (expand "polylist") (("1" (expand "eval_polylist" +) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "length" + 3) (("2" (case "x^0=1") (("1" (replaces -1) (("1" (assert) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (invoke (name "AA" "%1") (! 2 1)) (("1" (replace -1) (("1" (rewrite "eval_polylist_remove_acc" +) (("1" (hide -1) (("1" (expand "AA") (("1" (assert) (("1" (inst - "x") (("1" (mult-by -4 "x") (("1" (rewrite "eval_polylist_times_x") (("1" (name "BBC" "eval_polylist(cdr[rat](pl), length(cdr[rat](pl)) - 1, 0)(x) * x") (("1" (rewrite "eval_polylist_times_x" -1) (("1" (expand "BBC" -1) (("1" (mult-by -1 "c") (("1" (replace -1 :dir rl) (("1" (assert) (("1" (expand "length" 2 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (< const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (polylist const-decl "real" polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (length def-decl "nat" list_props nil) (eval_polylist def-decl "real" polylist nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AA skolem-const-decl "real" polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_polylist_times_x formula-decl nil polylist nil) (BBC skolem-const-decl "real" polylist nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (eval_polylist_remove_acc formula-decl nil polylist nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (expt def-decl "real" exponentiation nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (pscal subtype "list_adt[rat].cons(number_fields.*(polylist.c, list_adt[rat].car(polylist.pl)), polylist.pscal(polylist.c, list_adt[rat].cdr(polylist.pl)))" "{pql: polylist.Polylist | booleans.AND(list_props[rat].length(pql) = list_props[rat].length(polylist.pl), FORALL (x): polylist.polylist(pql)(polylist.x) = number_fields.*(polylist.c, polylist.polylist(polylist.pl)(polylist.x)))}"))) (pprod_TCC1 0 (pprod_TCC1-1 nil 3601224651 ("" (grind) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil)) nil (pprod subtype "(number_fields.-)(list_props[rat].length(polylist.pl), 1)" "nat"))) (pprod_TCC2 0 (pprod_TCC2-3 "" 3790098813 ("" (skeep) (("" (skolem 1 "ii") (("" (case "FORALL (a,b:[nat->rat],n,m:nat): rational_pred(polynomial_prod(a,
                                                         n,
                                                         b,
                                                         m)
                                                        (ii))") (("1" (case "FORALL (pzl:Polylist): FORALL (x1: nat): rational_pred(list2array[rat](0)(pzl)(x1))") (("1" (inst? -2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "polynomial_prod") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_rat application-judgement "rational" sigma_nat reals) (list2array def-decl "T" array2list structures) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ql skolem-const-decl "Polylist" polylist nil) (pl skolem-const-decl "Polylist" polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (sequence type-eq-decl nil sequences nil) (polynomial_prod const-decl "real" polynomials reals) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak (pprod subtype "polynomials.polynomial_prod(array2list[rat].list2array(0)(polylist.pl), (number_fields.-)(list_props[rat].length(polylist.pl), 1), array2list[rat].list2array(0)(polylist.ql), (number_fields.-)(list_props[rat].length(polylist.ql), 1))" "[nat -> rat]")) (pprod_TCC2-2 nil 3601806618 ("" (skeep) (("" (skolem 1 "ii") (("" (case "FORALL (a,b:[nat->rat],n,m:nat): rational_pred(polynomial_prod(a,
                                                         n,
                                                         b,
                                                         m)
                                                        (ii))") (("1" (case "FORALL (pzl:Polylist): FORALL (x1: nat): rational_pred(list2array[rat](0)(pzl)(x1))") (("1" (inst? -2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "polynomial_prod") (("2" (case "FORALL (FF:[nat->rat],mm,nn:nat): rational_pred(sigma(mm,nn,FF))") (("1" (rewrite -1) (("1" (assert) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (grind) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "FF" "mm") (("2" (expand "sigma" +) (("2" (ground) (("2" (case "FORALL (r1,r2:rat): rational_pred(r1+r2)") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) (nil (list2array def-decl "T" array2list structures) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) nil nil (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (sequence type-eq-decl nil sequences nil) (polynomial_prod const-decl "real" polynomials reals) nil) nil (pprod subtype "polynomials.polynomial_prod(array2list[rat].list2array(0)(polylist.pl), (number_fields.-)(list_props[rat].length(polylist.pl), 1), array2list[rat].list2array(0)(polylist.ql), (number_fields.-)(list_props[rat].length(polylist.ql), 1))" "[nat -> rat]")) (pprod_TCC2-1 nil 3601376563 ("" (grind) nil nil) ((list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (pprod subtype "polynomials.polynomial_prod(array2list[rat].list2array(0)(polylist.pl), (number_fields.-)(list_props[rat].length(polylist.pl), 1), array2list[rat].list2array(0)(polylist.ql), (number_fields.-)(list_props[rat].length(polylist.ql), 1))" "[nat -> rat]"))) (pprod_TCC3 0 (pprod_TCC3-1 nil 3601728884 ("" (grind) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (pprod subtype "(number_fields.-)((number_fields.+)(list_props[rat].length(polylist.pl), list_props[rat].length(polylist.ql)), 1)" "nat"))) (pprod_TCC4 0 (pprod_TCC4-1 nil 3601806454 ("" (grind) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (int_times_int_is_int application-judgement "int" integers nil) (sigma_rat application-judgement "rational" sigma_nat reals) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (polynomial_prod const-decl "real" polynomials reals) (list2array def-decl "T" array2list structures) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (length def-decl "nat" list_props nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (pprod subtype "array2list[rat].array2list((number_fields.-)((number_fields.+)(list_props[rat].length(polylist.pl), list_props[rat].length(polylist.ql)), 1))(polynomials.polynomial_prod(array2list[rat].list2array(0)(polylist.pl), (number_fields.-)(list_props[rat].length(polylist.pl), 1), array2list[rat].list2array(0)(polylist.ql), (number_fields.-)(list_props[rat].length(polylist.ql), 1)))" "Polylist"))) (deg_rec_TCC1 0 (deg_rec_TCC2-1 nil 3601811247 ("" (grind) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil)) nil (deg_rec subtype "0" "naturalnumbers.below(list_props[rat].length(polylist.pl))"))) (deg_rec_TCC2 0 (deg_rec_TCC3-1 nil 3601811247 ("" (skeep) (("" (grind) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "(# allzero := booleans.TRUE, maxnon := 0 #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}"))) (deg_rec_TCC3 0 (deg_rec_TCC4-1 nil 3601811247 ("" (grind) nil nil) ((listn_0 name-judgement "listn[rat](0)" polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (deg_rec subtype "0" "naturalnumbers.below(list_props[rat].length(polylist.pl))"))) (deg_rec_TCC4 0 (deg_rec_TCC5-1 nil 3601811247 ("" (skeep) (("" (assert) (("" (ground) (("1" (inst - "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "j") (("2" (case "NOT j = 1") (("1" (grind) nil nil) ("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pl skolem-const-decl "Polylist" polylist nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "(# allzero := booleans.FALSE, maxnon := 0 #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}"))) (deg_rec_TCC5 0 (deg_rec_TCC5-1 "" 3804477776 ("" (skeep) (("" (skeep) (("" (assert) (("" (hide 1) (("" (typepred "v(cdr(pl))") (("" (replace -5 :dir rl) (("" (assert) (("" (typepred "v(cdr(pl))`maxnon") (("" (expand "length" 3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (deg_rec subtype "(number_fields.+)(1, polylist.upans`maxnon)" "naturalnumbers.below(list_props[rat].length(polylist.pl))")) (deg_rec_TCC6-1 nil 3601811247 ("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (hide 2) (("" (typepred "v(cdr(pl))") (("" (replace -5 :dir rl) (("" (assert) (("" (typepred "v(cdr(pl))`maxnon") (("" (expand "length" 4) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (< const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "(number_fields.+)(1, polylist.upans`maxnon)" "naturalnumbers.below(list_props[rat].length(polylist.pl))"))) (deg_rec_TCC6 0 (deg_rec_TCC6-1 "" 3804477891 ("" (skeep) (("" (skeep) (("" (assert) (("" (hide 1) (("" (split) (("1" (typepred "v(cdr(pl))") (("1" (replace -6 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (inst -3 "upans`maxnon+1") (("1" (expand "nth" -3) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (typepred "v(cdr(pl))`maxnon") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "v(cdr(pl))") (("2" (assert) (("2" (hide -1) (("2" (inst - "j-1") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (typepred "v(cdr(pl))") (("3" (assert) (("3" (hide (-1 -2)) (("3" (expand "nth" -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (deg_rec subtype "(# allzero := booleans.FALSE, maxnon := (number_fields.+)(1, polylist.upans`maxnon) #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}")) (deg_rec_TCC7-1 nil 3601811247 ("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (hide 2) (("" (split) (("1" (typepred "v(cdr(pl))") (("1" (replace -6 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (inst -3 "upans`maxnon+1") (("1" (expand "nth" -3) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (typepred "v(cdr(pl))`maxnon") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "v(cdr(pl))") (("2" (assert) (("2" (hide -1) (("2" (inst - "j-1") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (typepred "v(cdr(pl))") (("3" (assert) (("3" (hide (-1 -2)) (("3" (expand "nth" -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "below(length(pl))" polylist nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (< const-decl "bool" reals nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (upans skolem-const-decl "{degans: [# allzero: bool, maxnon: below(length(cdr(pl))) #] |
   (degans`allzero IFF
     FORALL (j: below(length(cdr(pl)))): nth(cdr(pl), j) = 0)
    AND
    (degans`allzero OR
      FORALL (j: below(length(cdr(pl)))):
        j > degans`maxnon IMPLIES nth(cdr(pl), j) = 0)
     AND (degans`allzero OR nth(cdr(pl), degans`maxnon) /= 0)}" polylist nil) (pl skolem-const-decl "Polylist" polylist nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "(# allzero := booleans.FALSE, maxnon := (number_fields.+)(1, polylist.upans`maxnon) #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}"))) (deg_rec_TCC7 0 (deg_rec_TCC8-1 nil 3601811247 ("" (skeep) (("" (skeep) (("" (skeep) (("" (hide 2) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "0" "naturalnumbers.below(list_props[rat].length(polylist.pl))"))) (deg_rec_TCC8 0 (deg_rec_TCC9-1 nil 3601811247 ("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (hide 2) (("" (skeep) (("" (case "j = 0") (("1" (expand "nth" 3) (("1" (assert) nil nil)) nil) ("2" (expand "nth" +) (("2" (assert) (("2" (typepred "v(cdr(pl))") (("2" (replace -5 :dir rl) (("2" (assert) (("2" (hide -3) (("2" (hide -2) (("2" (inst - "j-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "(# allzero := booleans.TRUE, maxnon := 0 #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}"))) (deg_rec_TCC9 0 (deg_rec_TCC10-1 nil 3601811247 ("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (hide 2) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "0" "naturalnumbers.below(list_props[rat].length(polylist.pl))"))) (deg_rec_TCC10 0 (deg_rec_TCC10-1 "" 3804477949 ("" (skeep) (("" (skeep) (("" (assert) (("" (hide 1) (("" (split) (("1" (inst - "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "v(cdr(pl))") (("2" (replace -6 :dir rl) (("2" (assert) (("2" (inst -1 "j-1") (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (typepred "j") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (deg_rec subtype "(# allzero := booleans.FALSE, maxnon := 0 #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}")) (deg_rec_TCC11-1 nil 3601811247 ("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (hide 2) (("" (split) (("1" (inst - "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "v(cdr(pl))") (("2" (replace -6 :dir rl) (("2" (assert) (("2" (inst -1 "j-1") (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (typepred "j") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "below(length(pl))" polylist nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pl skolem-const-decl "Polylist" polylist nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg_rec subtype "(# allzero := booleans.FALSE, maxnon := 0 #)" "{degans: [# allzero: booleans.bool, maxnon: naturalnumbers.below(list_props[rat].length(polylist.pl)) #] | booleans.AND((booleans.IFF(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): list_props[rat].nth(polylist.pl, j) = 0)), booleans.AND((booleans.OR(degans`allzero, FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, degans`maxnon), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.OR(degans`allzero, list_props[rat].nth(polylist.pl, degans`maxnon) /= 0))))}"))) (deg_TCC1 0 (deg_TCC1-2 "" 3755375556 ("" (skeep) (("" (assert) (("" (typepred "drec") (("" (assert) (("" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst - "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak (deg subtype "0" "{d: naturalnumbers.below(list_props[rat].length(polylist.pl)) | booleans.AND((booleans.IFF(reals.>(d, 0), EXISTS (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.AND(reals.>(j, 0), list_props[rat].nth(polylist.pl, j) /= 0))), booleans.AND((booleans.IMPLIES(reals.>(d, 0), FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, d), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.IMPLIES(reals.>(d, 0), list_props[rat].nth(polylist.pl, d) /= 0))))}")) (deg_TCC1-1 nil 3601814826 ("" (skeep) (("" (assert) (("" (typepred "drec") (("" (assert) (("" (split +) (("1" (skeep) (("1" (inst - "j") nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (deg subtype "0" "{d: naturalnumbers.below(list_props[rat].length(polylist.pl)) | booleans.AND((booleans.IFF(reals.>(d, 0), EXISTS (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.AND(reals.>(j, 0), list_props[rat].nth(polylist.pl, j) /= 0))), booleans.AND((booleans.IMPLIES(reals.>(d, 0), FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, d), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.IMPLIES(reals.>(d, 0), list_props[rat].nth(polylist.pl, d) /= 0))))}"))) (deg_TCC2 0 (deg_TCC2-1 nil 3601814826 ("" (skeep) (("" (assert) (("" (typepred "drec") (("" (assert) (("" (hide -1) (("" (split) (("1" (flatten) (("1" (assert) (("1" (inst + "drec`maxnon") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (skeep -1) (("2" (inst - "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) nil (deg subtype "polylist.drec`maxnon" "{d: naturalnumbers.below(list_props[rat].length(polylist.pl)) | booleans.AND((booleans.IFF(reals.>(d, 0), EXISTS (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.AND(reals.>(j, 0), list_props[rat].nth(polylist.pl, j) /= 0))), booleans.AND((booleans.IMPLIES(reals.>(d, 0), FORALL (j: naturalnumbers.below(list_props[rat].length(polylist.pl))): booleans.IMPLIES(reals.>(j, d), list_props[rat].nth(polylist.pl, j) = 0))), (booleans.IMPLIES(reals.>(d, 0), list_props[rat].nth(polylist.pl, d) /= 0))))}"))) (polylist_eval 0 (polylist_eval-1 nil 3601229241 ("" (expand "polylist") (("" (case "FORALL (pl: Polylist, x,acc: real):
                                           eval_polylist(pl, length(pl) - 1, acc)(x) = acc+
                                            polynomial(list2array(0)(pl), length(pl)-1)(x)") (("1" (skeep) (("1" (inst - "pl" "x" "0") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "pl") (("1" (grind) nil nil) ("2" (ground) nil nil) ("3" (skeep) (("3" (skeep) (("3" (assert) (("3" (expand "length" +) (("3" (assert) (("3" (expand "eval_polylist" +) (("3" (lift-if) (("3" (split +) (("1" (flatten) (("1" (expand "length" +) (("1" (assert) (("1" (expand "length" +) (("1" (assert) (("1" (expand "list2array" +) (("1" (assert) (("1" (expand "list2array" +) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length" + 3) (("2" (assert) (("2" (inst - "x" "cons1_var*x^0+acc") (("2" (expand "^") (("2" (expand "expt") (("2" (assert) (("2" (lemma "polynomial_eq_a0_plus") (("2" (inst - "list2array(0)(cons(cons1_var, cons2_var))" "length(cons2_var)" "x") (("2" (assert) (("2" (split -1) (("1" (replaces -1 +) (("1" (expand "list2array" 2 1) (("1" (case "NOT (LAMBDA (i: nat):
                                                                                 list2array(0)(cons(cons1_var, cons2_var))(1 + i)) = list2array(0)(cons2_var)") (("1" (decompose-equality 1) (("1" (expand "list2array" 1 1) (("1" (propax) nil nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "eval_polylist_remove_acc" +) (("2" (rewrite "eval_polylist_remove_acc" +) (("2" (lemma "eval_polylist_times_x") (("2" (assert) (("2" (inst - "0" "cons2_var" "x" "length[rat](cons2_var)") (("2" (assert) (("2" (replace -1 :dir rl) (("2" (rewrite "eval_polylist_remove_acc" -2) (("2" (rewrite "eval_polylist_remove_acc" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil) ((list2array def-decl "T" array2list structures) (polynomial const-decl "[real -> real]" polynomials reals) (sequence type-eq-decl nil sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (eval_polylist def-decl "real" polylist nil) (upfrom nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (sigma def-decl "real" sigma reals) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (polynomial_eq_a0_plus formula-decl nil polynomials reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_polylist_times_x formula-decl nil polylist nil) (eval_polylist_remove_acc formula-decl nil polylist nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (polylist const-decl "real" polylist nil)) shostak)) (polylist_eval_deg 0 (polylist_eval_deg-1 nil 3601815971 ("" (case "FORALL (pl: Polylist, x: real,k:nat):
        deg(pl) > 0 IMPLIES
         polynomial(list2array[rat](0)(pl), deg(pl)+k)(x) =
          polynomial(list2array[rat](0)(pl), deg(pl))(x)") (("1" (skeep) (("1" (inst - "pl" "x" "length(pl)-1-deg(pl)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (skeep) (("1" (assert) nil nil)) nil) ("2" (skolem 1 "k") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst - "pl" "x") (("2" (assert) (("2" (rewrite "polynomial_rec" 1) (("2" (case " list2array[rat](0)(pl)(1 + deg(pl) + k) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1)) (("2" (rewrite "list2array_sound") (("2" (lift-if) (("2" (ground) (("2" (typepred "deg(pl)") (("2" (assert) (("2" (inst -4 "1+deg(pl)+k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (polynomial_rec formula-decl nil polynomials reals) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list2array_sound formula-decl nil array2list structures) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pl skolem-const-decl "Polylist" polylist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist nil) (sequence type-eq-decl nil sequences nil) (polynomial const-decl "[real -> real]" polynomials reals) (list2array def-decl "T" array2list structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (polylist_const 0 (polylist_const-1 nil 3601309766 ("" (grind) nil nil) ((pconst const-decl "Polylist" polylist nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (eval_polylist def-decl "real" polylist nil) (polylist const-decl "real" polylist nil)) shostak)) (polylist_monom_TCC1 0 (polylist_monom_TCC1-1 nil 3601220513 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (polylist_monom subtype "polylist.n" "{i: integers.int | booleans.OR(polylist.x /= 0, reals.>=(i, 0))}"))) (polylist_monom 0 (polylist_monom-1 nil 3601309814 ("" (skeep) (("" (typepred "pmonom(c,n)") (("" (inst - "x") nil nil)) nil)) nil) ((pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}" polylist nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (polylist const-decl "real" polylist nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (polylist_prod 0 (polylist_prod-1 nil 3601373214 ("" (case "FORALL (pl, ql: Polylist, x: real):
              polylist(pl)(x) * polylist(ql)(x) =  polylist(pprod(pl, ql))(x)") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "pprod" 1) (("2" (rewrite "polylist_eval") (("2" (rewrite "polylist_eval") (("2" (rewrite "polylist_eval") (("1" (name "plp" "polynomial_prod(list2array(0)(pl),
                                                                            length(pl)-1,
                                                                            list2array(0)(ql),
                                                                            length(ql)-1)") (("1" (replace -1) (("1" (case "plp = list2array(0)(array2list(length(pl) + length(ql)-1)(plp))") (("1" (replace -1 :dir rl) (("1" (assert) (("1" (typepred "array2list(length(pl) + length(ql)-1)(plp)") (("1" (replace -2) (("1" (rewrite "polynomial_prod_def") (("1" (replace -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (rewrite "array2list_inv") (("2" (invoke (case "NOT %1 = 0") (! 2 2)) (("1" (typepred "array2list(length(pl) + length(ql)-1)(plp)") (("1" (rewrite "list2array_sound") nil nil)) nil) ("2" (replaces -1) (("2" (hide -) (("2" (expand "plp") (("2" (expand "polynomial_prod") (("2" (expand "max") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (polynomial_prod_def formula-decl nil polynomials reals) (NOT const-decl "[bool -> bool]" booleans nil) (list2array_sound formula-decl nil array2list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_rat application-judgement "rational" sigma_nat reals) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma reals) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (plp skolem-const-decl "[nat -> real]" polylist nil) (TRUE const-decl "bool" booleans nil) (array2list_inv formula-decl nil array2list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list2array def-decl "T" array2list structures) (polynomial_prod const-decl "real" polynomials reals) (sequence type-eq-decl nil sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (polylist_eval formula-decl nil polylist nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (polylist const-decl "real" polylist nil) (pprod const-decl "Polylist" polylist nil)) shostak)) (polylist_scal 0 (polylist_scal-1 nil 3601744687 ("" (skeep) (("" (typepred "pscal(c,pl)") (("" (inst - "x") nil nil)) nil)) nil) ((pscal def-decl "{pql: Polylist |
   length[rat](pql) = length[rat](pl) AND
    FORALL (x: real): polylist(pql)(x) = c * polylist(pl)(x)}" polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (polylist const-decl "real" polylist nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak)) (polylist_sum 0 (polylist_sum-1 nil 3601314376 ("" (skeep) (("" (typepred "psum(pl,ql)") (("" (inst - "x") nil nil)) nil)) nil) ((psum def-decl "{pql: Polylist |
   FORALL (x: real): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}" polylist nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (polylist const-decl "real" polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak)) (polylist_minus 0 (polylist_minus-1 nil 3601748130 ("" (skeep) (("" (expand "pminus") (("" (rewrite "polylist_sum") (("" (rewrite "polylist_scal") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (pminus const-decl "Polylist" polylist nil) (polylist_scal formula-decl nil polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (pscal def-decl "{pql: Polylist |
   length[rat](pql) = length[rat](pl) AND
    FORALL (x: real): polylist(pql)(x) = c * polylist(pl)(x)}" polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (polylist const-decl "real" polylist nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (polylist_sum formula-decl nil polylist nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak)) (polylist_pow_TCC1 0 (polylist_pow_TCC1-1 nil 3601377289 ("" (subtype-tcc) nil nil) ((polylist const-decl "real" polylist nil)) nil (polylist_pow subtype "polylist.n" "{i: integers.int | booleans.OR(polylist.polylist(polylist.pl)(polylist.x) /= 0, reals.>=(i, 0))}"))) (polylist_pow 0 (polylist_pow-4 "" 3790098819 ("" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "pl" "x") (("2" (expand "^") (("2" (expand "expt" +) (("2" (replaces -1 :dir rl) (("2" (rewrite "polylist_prod" :dir rl) (("2" (expand "ppow" + 1) (("2" (lift-if) (("2" (ground) (("2" (replaces -1) (("2" (expand "ppow" +) (("2" (case "pprod(pl,pconst(1)) = pl") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "pprod") (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "pconst" 1) (("2" (expand "length" + 1) (("2" (expand "length" + 3) (("2" (expand "length" + 3) (("2" (case "NOT polynomial_prod(list2array[rat](0)(pl), length[rat](pl) - 1,
                                                                  list2array[rat](0)((: 1 :)), 0) = list2array[rat](0)(pl)") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "polynomial_prod") (("1" (expand "max") (("1" (lemma "sigma_eq_one_arg") (("1" (inst?) (("1" (inst - "x!1") (("1" (assert) (("1" (split) (("1" (replaces -1) (("1" (expand "list2array" + 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "sigma") (("2" (case "FORALL (kk:nat,plz:list[rat]): kk>length[rat](plz)-1 IMPLIES 0=list2array[rat](0)(plz)(kk)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide (2 3)) (("2" (induct "plz") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "length" -2) (("2" (inst - "kk-1") (("1" (assert) (("1" (expand "list2array" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pl") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "FORALL (plz:list[rat]): array2list[rat](length[rat](plz))(list2array[rat](0)(plz)) = plz") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "list2array_inv_ext") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist_prod formula-decl nil polylist nil) (pprod const-decl "Polylist" polylist nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list2array_inv_ext formula-decl nil array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_eq_one_arg formula-decl nil sigma reals) (sigma def-decl "real" sigma reals) (kk skolem-const-decl "nat" polylist nil) (list_induction formula-decl nil list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (sigma_rat application-judgement "rational" sigma_nat reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (x!1 skolem-const-decl "nat" polylist nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (pl skolem-const-decl "Polylist" polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (list2array def-decl "T" array2list structures) (polynomial_prod const-decl "real" polynomials reals) (sequence type-eq-decl nil sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (listn_0 name-judgement "listn[rat](0)" polylist nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (pconst const-decl "Polylist" polylist nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (eval_polylist def-decl "real" polylist nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ppow def-decl "Polylist" polylist nil) (polylist const-decl "real" polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (polylist_pow-3 nil 3601740624 ("" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "pl" "x") (("2" (expand "^") (("2" (expand "expt" +) (("2" (replaces -1) (("2" (replaces -1 :dir rl) (("2" (rewrite "polylist_prod" :dir rl) (("2" (expand "ppow" + 1) (("2" (lift-if) (("2" (ground) (("2" (replaces -1) (("2" (expand "ppow" +) (("2" (case "pprod(pl,pconst(1)) = pl") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "pprod") (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "pconst" 1) (("2" (expand "length" + 1) (("2" (expand "deg") (("2" (expand "length" + 3) (("2" (expand "length" + 3) (("2" (case "NOT polynomial_prod(list2array[rat](0)(pl), length[rat](pl) - 1,
                                                                  list2array[rat](0)((: 1 :)), 0) = list2array[rat](0)(pl)") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "polynomial_prod") (("1" (expand "max") (("1" (lemma "sigma_eq_one_arg") (("1" (inst?) (("1" (inst - "x!1") (("1" (assert) (("1" (split) (("1" (replaces -1) (("1" (expand "list2array" + 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "sigma") (("2" (case "FORALL (kk:nat,plz:list[rat]): kk>length[rat](plz)-1 IMPLIES 0=list2array[rat](0)(plz)(kk)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide (2 3)) (("2" (induct "plz") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "length" -2) (("2" (inst - "kk-1") (("1" (assert) (("1" (expand "list2array" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pl") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "FORALL (plz:list[rat]): array2list[rat](length[rat](plz))(list2array[rat](0)(plz)) = plz") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "list2array_inv_ext") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist_prod formula-decl nil polylist nil) (pprod const-decl "Polylist" polylist nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list2array_inv_ext formula-decl nil array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_eq_one_arg formula-decl nil sigma reals) (sigma def-decl "real" sigma reals) nil (list_induction formula-decl nil list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) nil (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) nil (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) nil (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (list2array def-decl "T" array2list structures) (polynomial_prod const-decl "real" polynomials reals) (sequence type-eq-decl nil sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) nil (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (pconst const-decl "Polylist" polylist nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (eval_polylist def-decl "real" polylist nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ppow def-decl "Polylist" polylist nil) (polylist const-decl "real" polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil) (polylist_pow-2 nil 3601740585 ("" (induct "n") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "pl" "x") (("2" (expand "^") (("2" (expand "expt" +) (("2" (replaces -1) (("2" (rewrite "polylist_prod") (("2" (expand "ppow" + 2) (("2" (lift-if) (("2" (ground) (("2" (replaces -1) (("2" (expand "ppow") (("2" (case "pprod(pl,pconst(1)) = pl") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "pprod") (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "pconst" 1) (("2" (expand "length" + 1) (("2" (expand "deg") (("2" (expand "length" + 3) (("2" (expand "length" + 3) (("2" (case "NOT polynomial_prod(list2array(0)(pl), length(pl) - 1,
                                            list2array(0)((: 1 :)), 0) = list2array(0)(pl)") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "polynomial_prod") (("1" (expand "max") (("1" (lemma "sigma_eq_one_arg") (("1" (inst?) (("1" (inst - "x!1") (("1" (assert) (("1" (split) (("1" (replaces -1) (("1" (expand "list2array" + 2) (("1" (propax) nil))))) ("2" (assert) (("2" (expand "sigma") (("2" (case "FORALL (kk:nat,plz:list[real]): kk>length(plz)-1 IMPLIES 0=list2array(0)(plz)(kk)") (("1" (inst?) (("1" (assert) nil))) ("2" (hide (2 3)) (("2" (induct "plz") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "length" -2) (("2" (inst - "kk-1") (("1" (assert) (("1" (expand "list2array" 1) (("1" (propax) nil))))) ("2" (assert) nil))))))))))))))))))) ("3" (hide 2) (("3" (skosimp*) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))))) ("2" (typepred "pl") (("2" (grind) nil))))))) ("2" (replaces -1) (("2" (case "FORALL (plz:list[real]): array2list[rat](length[rat](plz))(list2array[rat](0)(plz)) = plz") (("1" (inst?) nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "list2array_inv_ext") nil))))))))) ("3" (hide 2) (("3" (grind) nil)))))))))))))))))))))))))))))))))))))))))))))))))) nil) nil nil) (polylist_pow-1 nil 3601377290 ("" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "pl" "x") (("2" (expand "^") (("2" (expand "expt" +) (("2" (replaces -1) (("2" (rewrite "polylist_prod") (("2" (expand "ppow" + 2) (("2" (lift-if) (("2" (ground) (("2" (replaces -1) (("2" (expand "ppow") (("2" (case "pprod(pl,pconst(1)) = pl") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "pprod") (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "pconst" 1) (("2" (expand "length" + 1) (("2" (expand "deg") (("2" (expand "length" + 3) (("2" (expand "length" + 3) (("2" (case "NOT polynomial_prod(list2array(0)(pl), length(pl) - 1,
                                 list2array(0)((: 1 :)), 0) = list2array(0)(pl)") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "polynomial_prod") (("1" (expand "max") (("1" (lemma "sigma_eq_one_arg") (("1" (inst?) (("1" (inst - "x!1") (("1" (assert) (("1" (split) (("1" (replaces -1) (("1" (expand "list2array" + 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "sigma") (("2" (case "FORALL (kk:nat,plz:list[real]): kk>length(plz)-1 IMPLIES 0=list2array(0)(plz)(kk)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide (2 3)) (("2" (induct "plz") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "length" -2) (("2" (inst - "kk-1") (("1" (assert) (("1" (expand "list2array" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pl") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (case "FORALL (plz:list[real]): array2list[real](length[real](plz))(list2array[real](0)(plz)) = plz") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "list2array_inv_ext") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polynomial_prod const-decl "real" polynomials reals) (list2array def-decl "T" array2list structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (list_induction formula-decl nil list_adt nil) (sigma def-decl "real" sigma reals) (sigma_eq_one_arg formula-decl nil sigma reals) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (list2array_inv_ext formula-decl nil array2list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil)) shostak)) (polylist_neg 0 (polylist_neg-1 nil 3601744560 ("" (skeep) (("" (expand "pneg") (("" (rewrite "polylist_scal") (("" (assert) nil nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (pneg const-decl "Polylist" polylist nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (polylist_scal formula-decl nil polylist nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak)) (polylist_div 0 (polylist_div-1 nil 3601748272 ("" (skeep) (("" (expand "pdiv") (("" (rewrite "polylist_scal") (("" (assert) nil nil)) nil)) nil)) nil) ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (pdiv const-decl "Polylist" polylist nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (Polylist type-eq-decl nil polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (nzrat nonempty-type-eq-decl nil rationals nil) (rational nonempty-type-from-decl nil rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (polylist_scal formula-decl nil polylist nil) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak)) (polylist_sq 0 (polylist_sq-1 nil 3601748553 ("" (skeep) (("" (expand "psq") (("" (expand "sq") (("" (rewrite "polylist_prod") nil nil)) nil)) nil)) nil) ((psq const-decl "Polylist" polylist nil) (polylist_prod formula-decl nil polylist nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Polylist type-eq-decl nil polylist nil) (sq const-decl "nonneg_real" sq reals) (listn_0 name-judgement "listn[rat](0)" polylist nil)) shostak)))
