;-*-Lisp-*-

;;
;; This file is part of a generic framework to define branch & bound strategies.
;;

;; Every element in *ia-builtin* has the form (<f> <F>), where <F> is either an atom, for
;; rational functions, or it has the form (<F> <n>) for approximated ones. It is expected that these functions
;; satisfy the inclusion and fundamental theorems of interval arithmetic. The element may optional has the form
;; (<f> <F> <nm>), where <nm> is the name of a fully qualified constant that has exists in the current context for
;; the strategy to work properly

(defparameter *ia-builtin*
  '(;; Special cases
    ("*real*" "interval_expr.r2E")
    ("*bool*" "interval_bexpr.b2B")
    ("*var*" "interval_expr.X")
    ("*neg*" "IntervalExpr_adt.NEG")
    ("*bite*" "IntervalExpr_adt.BITE")
    ("*letin*" "IntervalExpr_adt.LETIN")
    ("*bletin*" "IntervalExpr_adt.BLETIN")
    ("*excluded*" ("Tan?" "[||]" "sqrt_safe"))
    ("*expand*" ("interval_expr_extra.FLOOR"
		 "interval_expr_extra.MAX"
		 "interval_expr_extra.MIN"
		 "interval_expr_extra.SQRT_n"
		 "interval_expr_trig.PI_n"
		 "interval_expr_trig.SIN_n"
		 "interval_expr_trig.COS_n"
		 "interval_expr_trig.TAN_n"
		 "interval_expr_trig.ATAN_n"
		 "interval_expr_lnexp.LN_n"
		 "interval_expr_lnexp.EXP_n"
		 "interval_expr_lnexp.E_n"))
    ;; Standard operations
    ("sq" "IntervalExpr_adt.SQ")
    ("abs" "IntervalExpr_adt.ABS")
    ("+" "IntervalExpr_adt.ADD")
    ("-" "IntervalExpr_adt.SUB")
    ("*" "IntervalExpr_adt.MULT")
    ("/" "IntervalExpr_adt.DIV")
    ("^" "IntervalExpr_adt.POW")
    ("TRUE" "IntervalExpr_adt.BCONST(TRUE)")
    ("FALSE" "IntervalExpr_adt.BCONST(FALSE)")
    ("NOT" "IntervalExpr_adt.BNOT")
    ("AND" "IntervalExpr_adt.BAND")
    ("&" "IntervalExpr_adt.BAND")
    ("OR" "IntervalExpr_adt.BOR")
    ("IMPLIES" "IntervalExpr_adt.BIMPLIES")
    ("=>" "IntervalExpr_adt.BIMPLIES")
    ("##" "interval_bexpr.BINCLUDEX")
    (">" "interval_bexpr.REL(>)")
    (">=" "interval_bexpr.REL(>=)")
    ("<" "interval_bexpr.REL(<)")
    ("<=" "interval_bexpr.REL(<=)")
    ("=" "interval_bexpr.EQ")
    ("max" "interval_expr_extra.MAX")
    ("min" "interval_expr_extra.MIN")
    ("floor" "interval_expr_extra.FLOOR")
    ("sqrt" ("interval_expr_extra.SQRT_n"))
    
    ;; The following functions require interval_arith@strategies.IntervalStrategies__
    
    ("pi" ("interval_expr_trig.PI_n") "interval_arith@strategies.IntervalStrategies__") 
    ("sin" ("interval_expr_trig.SIN_n") "interval_arith@strategies.IntervalStrategies__") 
    ("cos" ("interval_expr_trig.COS_n") "interval_arith@strategies.IntervalStrategies__") 
    ("tan" ("interval_expr_trig.TAN_n") "interval_arith@strategies.IntervalStrategies__") 
    ("atan" ("interval_expr_trig.ATAN_n") "interval_arith@strategies.IntervalStrategies__") 
    ("ln" ("interval_expr_lnexp.LN_n") "interval_arith@strategies.IntervalStrategies__") 
    ("exp" ("interval_expr_lnexp.EXP_n") "interval_arith@strategies.IntervalStrategies__") 
    ("e" ("interval_expr_lnexp.E_n") "interval_arith@strategies.IntervalStrategies__")))

(defparameter *ia-let-names* nil)

(defun ia-get-vars-from-expr (expr subs)
  (get-vars-from-expr expr (mapcar #'car subs)))

;; Find unbounded vars (vars is a list of variable names) 
(defun ia-find-unbound-vars (vars)
  (loop for v in vars
	when (let ((xv (gethash v *extra-varranges*)))
	       (or (null xv) (null (xterval-lb xv)) (null (xterval-ub xv))))
	collect v))

(defun ia-complete-vars (vars morevars)
  (let ((vars (remove-if-not 
	       #'(lambda(x)(member (extra-var-name x) morevars :test #'string=)) vars)))
    (append vars
	    (loop for v in morevars
		  unless (member v vars
				 :test #'(lambda (x y) (string= x (extra-var-name y))))
		  collect v))))

(defun ia-var-intervals (vars)
  (loop for v in vars
	for xv = (gethash v *extra-varranges*)
	collect (format nil "[|~a,~a|]" (xterval-lb xv) (xterval-ub xv))))

;; Form a string representing the box of variables vars
(defun ia-box (vars)
  (if vars
      (format nil "(: ~{~a~^,~} :)" (ia-var-intervals vars))
    "(::)"))

;; Is id in subs?
(defun ia-idsubs? (id subs)
  (car (member id subs
	       :test #'(lambda (x y) (string= x (car y))))))

;; Return a list of symbols associated to id in subs. Typically used with *expand* and *excluded*
(defun ia-allsubs (id subs)
  (let ((l (member id subs :test #'(lambda (x y) (string= x (car y))))))
    (when l (append (cadar l) (ia-allsubs id (cdr l))))))

;; Form a string representing an interval expression of expr, where
;;   - n      : precision
;;   - vars   : list of variables
;;   - subs   : list of substitutions of the general form (<f> (<F> <n>))
;; Output:
;;   - Interval expression
(defun ia-interval-expr (expr n vars subs)
  (setq *ia-let-names* nil)
  (catch '*ia-error*
    (ia-interval-expr-rec expr n vars subs)))

(defun ia-approx-n (n nn)
  (if nn (max (+ n nn) 0) n))

(defun ia-error (msg)
  (throw '*ia-error* (list msg)))

(defun ia-format-local-var (vl n)
  (let ((posvar (+ n (1- (length vl)))))
    (if (is-number-type (cdar vl))
	(format nil "X(~a)" posvar)
      (format nil "POS?(X(~a))" posvar))))

;; Check if id exists in subs as an element of the form (id <something> <name>), where
;; name is a fully qualified PVS constant. If id doesn't exist, return nil.
;; If it exists but name doesn't occur in the current context
;; the exception *ia-error* is raised. Otherwise, return (id <somehting> <name>)

(defun ia-check-required (id subs)
  (let* ((opl (ia-idsubs? id subs))
	 (th  (no-qualified-name (nth 2 opl))))
    (if th
	(ia-error
	 (format nil "Theory ~a needs to be imported to support ~a" th id))
      opl)))

(defun ia-interval-expr-rec (expr n vars subs &optional localvars)
  (let ((val (when (or (is-number-type (type expr)) (is-bool-type (type expr)))
	       (typecheck (extra-add-evalexpr expr)))))
    (cond ((and val (is-number-type  (type val)))
	   (let ((opl (ia-idsubs? "*real*" subs)))
	     (if opl (format nil "~a(~a)" (cadr opl) val)
	       (ia-error (format nil "Don't know how to translate number ~a" val)))))
	  ((and val (is-bool-type (type val)))
	   (let ((opl (ia-idsubs? "*bool*" subs)))
	     (if opl (format nil "~a(~a)" (cadr opl) val)
	       (ia-error (format nil "Don't know how to translate boolean ~a" val)))))
	  ((is-const-decl-expr expr (mapcar #'car subs)) ;; Is a constant, but not a rational one
	   (let ((opl (ia-check-required (expr2str expr) subs)))
	     (if opl
		 (let ((op (cadr opl)))
		   (if (listp op)
		       (format nil "~a(~a)" (car op) (ia-approx-n n (nth 1 op)))
		     (format nil "~a" op)))
	       (ia-error (format nil "Don't know how to translate constant ~a" expr)))))
	  ((is-variable-expr expr)
	   (let ((vl (when (name-expr? expr)
		       (member (id expr) localvars :test #'(lambda(x y) (equal x (car y)))))))
	     (if vl (ia-format-local-var vl (length vars))
	       (let ((vl  (member (expr2str expr) vars :test #'string=))
		     (opl (ia-idsubs? "*var*" subs)))
		 (if (and vl opl)
		     (format nil "~a(~a)" (cadr opl) (- (length vars) (length vl)))
		   (ia-error (format nil "Don't know how to translate variable ~a" expr)))))))
	  ((and (unary-application? expr) (is-function-expr expr "-"))
	   (let ((opl (ia-idsubs? "*neg*" subs)))
	     (if opl (format nil "~a(~a)" (cadr opl)
			     (ia-interval-expr-rec (args1 expr) n vars subs localvars))
	       (ia-error (format nil "Don't know how to translate unary operator -")))))
	  ((is-function-expr expr "^")
	   (let ((opl (ia-idsubs? "^" subs)))
	     (if opl (format nil "~a(~a,~a)" (cadr opl)
			     (ia-interval-expr-rec (args1 expr) n vars subs localvars)
			     (args2 expr))
	       (ia-error (format nil "Don't know how to translate operator ^")))))
	  ((is-function-expr expr "##")
	   (let ((val (extra-add-evalexpr (args2 expr)))
		 (opl (ia-idsubs? "##" subs)))
	     (if (and (record-expr? val) opl)
		 (format nil "~a(~a,~a)" (cadr opl)
			 (ia-interval-expr-rec (args1 expr) n vars subs localvars)
			 val)
	       (ia-error (format nil "Don't know how to translate operator ##")))))
	  ((if-expr? expr)
	   (let ((opl (ia-idsubs? "*bite*" subs)))
	     (if (and (is-bool-type (type expr)) opl)
		 (format nil "~a(~a,~a,~a)" (cadr opl)
			 (ia-interval-expr-rec (nth 0 (arguments expr)) n vars subs localvars)
			 (ia-interval-expr-rec (nth 1 (arguments expr)) n vars subs localvars)
			 (ia-interval-expr-rec (nth 2 (arguments expr)) n vars subs localvars))
	       (ia-error (format nil "Don't know how to translate IF-THEN-ELSE")))))
	  ((let-expr? expr)
	   (let ((opl (cond ((is-bool-type (type expr))  (ia-idsubs? "*bletin*" subs))
			    ((is-number-type (type expr)) (ia-idsubs? "*letin*" subs)))))
	     (if opl
		 (let* ((op  (operator expr))
			(typ (domain (type op))))
		   (if (or (is-number-type typ) (and (is-bool-type (type expr))
						     (is-bool-type typ)))
		       (let* ((vt  (cons (id (car (bindings op))) typ))
			      (xm  (ia-interval-expr-rec (argument expr) n vars subs localvars))
			      (nm  (freshname (format nil "V_~a" (length *ia-let-names*)))))
			 (setq *ia-let-names* (append *ia-let-names* (list (cons nm xm))))
			 (format nil "~a(~a,~a)" (cadr opl) nm
				 (ia-interval-expr-rec (expression op) n vars subs (cons vt localvars))))
		     (ia-error (format nil "Don't know how to translate LET-IN"))))
	       (ia-error (format nil "Don't know how to translate LET-IN")))))
	  ((arg-tuple-expr? expr)
	   (format nil "~{~a~^,~}"
		   (mapcar #'(lambda(x)(ia-interval-expr-rec x n vars subs localvars))
			   (exprs expr))))
	  ((is-function-expr expr)
	   (let ((opl (ia-check-required (id (operator expr)) subs)))
	     (if opl 
		 (let ((op (cadr opl)))
		   (if (listp op)
		       (if (eq (length op) 1)
			   (format nil "~a(~a)(~{~a~^, ~})"
				   (car op) (ia-approx-n n (nth 1 op))
				   (let ((args (arguments expr)))
				     (loop for i from 0 to (- (length args) 1)
					   collect (ia-interval-expr-rec (nth i args) n vars subs localvars))))
			 (funcall (second op)
			      (arguments expr)
			      (lambda (pvs-expr)
				(ia-interval-expr-rec pvs-expr n vars subs localvars))))
		     (format nil "~a(~{~a~^, ~})" op
			     (let ((args (arguments expr)))
			       (loop for i from 0 to (- (length args) 1)
				     collect (ia-interval-expr-rec (nth i args) n vars subs localvars))))))
	       (ia-error (format nil "Don't know how to translate function ~a" (id (operator expr)))))))
	  (t (ia-error (format nil "Don't know how to translate expression ~a" expr))))))

(defhelper interval-eq__ (names
			  fnum
			  subs
			  rewrite-decls
			  &optional
			  nohide
			  (boolean-eval-fun-name "beval") ;; defaul values for interval_arith functions
			  (expr-eval-fun-name "eval")
			  )
  (let ((oplx  (enlist-it (cadr (ia-idsubs? "*var*" subs))))
	(oplr  (enlist-it (cadr (ia-idsubs? "*real*" subs))))
	(oplb  (enlist-it (cadr (ia-idsubs? "*bool*" subs))))
	(opexp (remove-if-not #'check-name (ia-allsubs "*expand*" subs)))
	(lexp  (append oplx oplr oplb opexp))
	(excl  (append
		(ia-allsubs "*excluded*" subs)
		(loop for sub in subs
		      unless  (find #\* (car sub))
		      collect (car sub)))))
    (with-fresh-labels
     ((!ieq fnum))
     (apply (repeat (expand "length" !ieq)))
     (apply (repeat (expand names !ieq)))
     (expand lexp !ieq)
     (apply (repeat (expand "list2array" !ieq)))
     (apply (repeat (then (expand boolean-eval-fun-name !ieq)
			  (expand "realexpr?")
			  (expand expr-eval-fun-name !ieq))))
     (assert)
     (expand "##")
     (flatten)
     (when rewrite-decls
       (install-rewrites :defs t :rewrites rewrite-decls))
     (assert)
     (protect (^ !ieq) (then (hide-all-but (!ieq nohide))
			     (grind :exclude excl)))
     (assert)))
  "[Interval] Internal strategy." "")

(defhelper vars-sharp__ ()
  (then
   (expand* "##" "contains?")
   (rewrite* ("abs_lt" "abs_le" "ge_abs" "gt_abs"))
   (flatten)
   (assert))
  "[Interval] Internal strategy." "")

(defhelper vars-in-box__ ()
  (then
   (apply (repeat (expand "list2array" 1)))
   (rewrite "vars_in_box")
   (apply (repeat (expand "length" 1)))
   (apply (repeat (expand "vars_in_box_rec" 1)))
   (vars-sharp__$))
  "[Interval] Internal strategy." "")

(defun ia-is-true-output (ans)
  (and (is-function-expr ans "Some")
       (extra-is-true (argument ans))))

(defun ia-is-false-output (ans)
  (and (is-function-expr ans "Some")
       (extra-is-false (argument ans))))

;; *** Generic branch and bound strategies (interval and numerical) by Mariano Moscato

;; -------------------------------------------------------------------------- ;;
(defhelper gbandb_interval__ (required-constant
			      pvsexpr-to-strobj
			      bandb-function-name
			      soundness-lemma-name
			      rewrite-decls
			      beval-solver
			      &optional 
			      (fnums 1) (precision 3) maxdepth sat?
			      vars 
			      subs 
			      dirvar
			      verbose?
			      label
			      (equiv? t)
			      (tccs? t))
  (let ((name     (freshname "iar"))
	(fns      (extra-get-fnums fnums))
	(fn       (if (= (length fns) 1) (car fns) 0))
	(expr     (when fns
		    (if (equal fn 0)
			(mk-disjunction (mapcar #'formula (extra-get-seqfs fns)))
			(extra-get-formula-from-fnum fn))))
	(quant    (cond ((forall-expr? expr) 1)
			((exists-expr? expr) -1)
			(t 0))) ;; forall: quant > 0, exists: quant < 0, none: 0
	(fms      (append (mapcar #'(lambda (f) (extra-get-formula-from-fnum f))
				  (extra-get-fnums `(-^ ,fnums)))
			  (mapcar #'(lambda (f) 
				      (make-negation
				       (extra-get-formula-from-fnum f)))
				  (extra-get-fnums `(+^ ,fnums)))))
	(qexpr    (when (/= quant 0) (lift-predicates-in-quantifier expr (list *real*))))
	(andexprs (when expr
		    (cond ((< quant 0) 
			   (get-ands-expr (expression qexpr)))
			  ((> quant 0) 
			   (cdr (get-hypotheses (expression qexpr))))
			  ((and (= quant 0) (< fn 0))
			   (get-ands-expr expr))
			  ((and (= quant 0) (> fn 0))
			   (cdr (get-hypotheses expr))))))
	(ia-expr  (if (= quant 0) expr (expression qexpr)))
	(qvars    (when (/= quant 0)
		    (mapcar #'(lambda (x) (format nil "~a" (id x))) (bindings qexpr))))
	;; qvars has quantified variables
	(vars     (ia-complete-vars
		   (enlist-it vars)
		   (if (/= quant 0) ;; Quantifier
		       ;; Only consider variables in the quantifier
		       qvars
		     ;; Consider all variables in the expression
		     (ia-get-vars-from-expr ia-expr subs))))
	;; vars has user provided variables + quantified variables
	(initeqs (extra-reset-evalexprs))
	(ia-vars (extra-get-var-ranges
		  (if (/= quant 0) ;; Quantifier
		      ;; Only consider ranges in the quantifier
		      andexprs
		    ;; Consider all ranges
		    (append andexprs fms))
		  vars))
	;; ia-vars is just like vars but only names
	(unvars  (ia-find-unbound-vars ia-vars))
	(tccs?   (and tccs? (not sat?)))
	(qth     (no-qualified-name required-constant))
	(msg     (cond ((null expr)
			(format nil "Formula ~a not found" fnums))
		       (qth
			(format nil "This strategy requires theory ~a to be imported in the current context" qth))
		       ((and sat? (null ia-vars))
			(format nil "Formula ~a doesn't seem to have variables. It cannot be checked for satisfiability"
				fnums))
		       (unvars
			(format nil "Variable~:[~;s~] ~{~a~^,~} ~:[is~;are~] unbounded."
				(cdr unvars) unvars (cdr unvars))))))
    (if msg
	(printf msg)
      (let ((findcex   (if sat? (<= quant 0) (< (* fn quant) 0)))
	    (neg       (if sat? (<= quant 0) (or (< quant 0) (and (= quant 0) (< fn 0)))))
	    (nname     (if neg (format nil "BNOT(~a)" name) name))
	    (ia-box    (ia-box ia-vars))
	    (ia-iexpr  (funcall pvsexpr-to-strobj ia-expr precision ia-vars subs))
	    (names     (append (mapcar #'car *ia-let-names*) (list name)))
	    (exprs     (append (mapcar #'cdr *ia-let-names*) (list ia-iexpr)))
	    (namexprs  (merge-lists names exprs))
	    (ia-dirvar (or dirvar "alt_max"))
	    (maxdepth  (cond ((null ia-vars) 0)
			     (maxdepth maxdepth)
			     (findcex 10)
			     (t 100)))
	    (ia-eval   (format nil "~a(~a,~a,~:[TRUE~;FALSE~])(~a,~a)"
			       bandb-function-name
			       maxdepth ia-dirvar findcex nname ia-box))
	    (msg       (when (listp ia-iexpr) (car ia-iexpr))))
	(if msg
	    (printf msg)
	  (with-fresh-labels@
	   ((!ia fnums :tccs? tccs?)
	    (!label))
	   (let ((label (or label !label)))
	     (spread
	      (name-label* namexprs :hide? t :tcc-step (then (hide !ia) (extra-tcc-step)))
	      ((try-branch
		(eval-expr ia-eval :safe? nil)
		((then
		  (relabel label -1)
		  (let ((output  (args2 (extra-get-formula -1)))
			(splits  (get-expr-from-obj output 'splits))
			(depth   (get-expr-from-obj output 'depth))
			(answer  (get-expr-from-obj output 'ans 'answer))
			(istrue  (ia-is-true-output answer))
			(isfalse (ia-is-false-output answer))
			(cex     (get-list-from-literal (get-expr-from-obj output 'ans 'counterex))))
		    (then
		     (when verbose? (printf "~%----"))
		     (if (and (not istrue) (not isfalse))
			 (then
			  (printf "Formula cannot be proved nor disproved")
			  (printf "Set MAXDEPTH or PRECISION to values greater than ~a AND ~a, respectively" 
				  maxdepth precision))
		       (let ((prfex    (and cex findcex (/= quant 0) (not sat?))) ;; Existential proof
			     (prfall   (and istrue (not findcex) (not sat?)))     ;; Universal proof
			     (disprf   (and (if findcex istrue cex) (not sat?)))  ;; Disproof
			     (varvals  (if cex (merge-lists ia-vars cex)
					 (merge-lists ia-vars (ia-var-intervals ia-vars))))
			     (eqs      (extra-get-evalexprs))
			     (msg      (format nil
					       (if cex "~:[Formula~;Sequent~] ~@[~a ~]~a for ~{~a = ~a~^, ~}"
						 "~:[Formula~;Sequent~] ~@[~a ~]~a for any ~{~a ## ~a~^, ~}")
					       (or prfex prfall disprf)
					       (unless (or prfex prfall disprf) fnums)
					       (cond ((or prfex prfall) "holds")
						     (disprf "can be disproved")
						     ((and cex findcex) "is satisfiable")
						     (findcex "is not satisfiable")
						     (istrue "is valid")
						     (t "is invalid"))
					       varvals)))
			 (if (or prfex prfall) ;; Proof needs to be done
			     (then
			      (when verbose? (printf "~a~%Splits: ~a. Depth: ~a~%----~%" msg splits depth))
			      (let ((name soundness-lemma-name))
				(lemma name))
			      (with-fresh-labels 
			       ((!ia-inst -1) (!ia-eqs))
			       (inst? !ia-inst)
			       (replaces label)
			       (beta !ia-inst)
			       (expand "sound?" !ia-inst)
			       (apply (repeat (expand "length" !ia-inst)))
			       (extra-evalexprs$ eqs !ia-eqs)
			       (branch (split !ia-inst)
				       ((if prfex ;; Existential proof
					    (let ((vs     (pairlis ia-vars cex))
						  (instvs (mapcar 
							   #'(lambda (x)
							       (format nil "~a" 
								       (cdr (assoc x vs :test #'string=))))
							   qvars))
						  (instp  (cons 'inst (cons !ia instvs))))
					      (then
					       (flatten)
					       (hide (-1 1))
					       instp
					       (eval-formula !ia :quiet? t)
					       (when equiv? 
						 (reveal !ia-eqs) 
						 (replaces !ia-eqs :hide? nil)
						 (beval-solver names 1 subs rewrite-decls))
					       (eval-formula !ia)))
					  ;; Universal proof
					  (let ((nqvars   (freshnames "x" (length qvars)))
						(vs       (when nqvars (pairlis qvars nqvars)))
						(skvs     (if nqvars
							      (mapcar #'(lambda (x)
									  (cdr (assoc x vs :test #'string=))) 
								      ia-vars)
							    ia-vars))
						(ia-lvars (format nil "list2array(0)((:~{~a~^, ~}:))" skvs)))
					    (then
					     (when nqvars (skolem !ia nqvars :skolem-typepreds? t))
					     (spread (inst !ia-inst ia-lvars)
						     ((when equiv? 
							(reveal !ia-eqs) 
							(replaces !ia-eqs :hide? nil)
							(beval-solver names !ia-inst subs rewrite-decls :nohide *!ia-tccs*))
						      (if (null ia-vars)
							  (eval-formula)
							(then (flatten)
							      (reveal !ia-eqs) 
							      (replaces !ia-eqs :hide? nil)
							      (vars-in-box__$))))))))
					(eval-formula)))))
			   (printf msg))))
		     (hide label)
		     (when verbose?
		       (printf "Splits: ~a. Depth: ~a" splits depth)
		       (printf "See hidden formulas for more information~%----~%")))))
		 (hide !ia))
		(skip))))))))))
  "Checks if formulas FNUMS, which may be simply quantified, holds using the
algorithm called BANDB-FUNCTION-NAME. Its soundness must be guaranteed by
a lemma of name SOUNDNESS-LEMMA-NAME. BEVAL-SOLVER is the name of the
strategy that should be used to prove that the PVS expression corresponds
with the beval of the interval expr. REWRITE-DECLS are the rewriting
rules to be used as to simplify the evaluation expression.

REQUIRED-CONSTANT is a fully qualified constant that must occur in the
current context for this strategy to work. The name of the function to
translate a pvs expression to a string representation of a ObjType is
the parameter PVSEXPR-TO-STROBJ.

The parameter PRECISION indicates an accuracy of
10^-PRECISION in every atomic computation. However, this accuracy is
not guaranteed in the final result. MAXDEPTH is a maximum recursion
depth for the branch and bound algorithm.

If SAT? is set to t, the strategy checks if formula FNUMS,
whether in the antecedent or in the consequent, is satisfiable
and, in the positive case, prints a provably correct witness.
If formula FNUMS is quantified, it is checked for validity.

VARS is a list of the form (<v1> ... <vn>), where each <vi> is either a
variable name, e.g., \"x\", or a list consisting of a variable name and
an interval, e.g., (\"x\" \"[|-1/3,1/3|]\"). This list is used to specify
the variables in EXPR and to provide their ranges. If this list is not
provided, this information is extracted from the sequent.

SUBS is a list of substitutions for translating user-defined
real-valued functions into interval ones. Each substitution has the
form (<f> <F> [<nm>]), where <f> is the name of a real-valued function
and <F> is the name of its interval counterpart. It is assumed that
<F> satisfies the Inclusion and the Fundamental theorems of interval
arithmetic for <f>. If <nm> is provided, it should be a
fully-qualified name of a constant that has to occur in the current
context for operator <F> to be supported. An error is raised if this
is not the case. If <f> is not a rational function, the element <F>
may have the form (<F> <n>), where the parameter <n> indicates a
relative precision with respect to PRECISION.

DIRVAR is the name of a direction and variable selection method for
the branch an bound algorithm. Theory interval_bandb includes some
pre-defined methods. If none is provided, a choice is made base on the
problem.

If VERBOSE? is set to t, the strategy prints information about number of
splits, depth, etc. 

LABEL is used to label formulas containing additional information computed
by the branch and bound algorithm. These formulas are hidden, but they can
be brought to the sequent using the proof command REVEAL.

If EQUIV? is set to nil, the strategy doesn't try to prove that the
deep embedding of the original expression is correct. The proof of
this fact is trivial from a logical point of view, but requires
unfolding of several definitions which is time consuming in PVS.

If TCCs? is set to nil, the strategy doesn't try to prove possible
TCCs generated during its execution." "")

;; -------------------------------------------------------------------------- ;;
(defhelper gbandb_numerical__ (required-constant   
			       pvsexpr-to-strobj   
			       bandb-function-name
			       soundness-lemma-name
			       rewrite-decls
			       beval-solver
			       expr
			       &optional (precision 3) (maxdepth 10)
			       min? max?
			       vars 
			       subs
			       dirvar
			       verbose?
			       label
			       (equiv? t))
  (let ((name      (freshname "nml"))
	(accuracy  (ratio2decimal (expt 10 (- precision)) nil precision))
	(ia-expr   (typecheck (extra-get-expr expr)))
	(ia-estr   (expr2str ia-expr))
	(fms       (append (mapcar #'(lambda (f) (extra-get-formula-from-fnum f))
				   (extra-get-fnums '-))
			   (mapcar #'(lambda (f) 
				       (make-negation
					(extra-get-formula-from-fnum f)))
				   (extra-get-fnums '+))))
	(vars      (ia-complete-vars (enlist-it vars) (ia-get-vars-from-expr ia-expr subs)))
	(initeqs   (extra-reset-evalexprs))
	(ia-vars   (extra-get-var-ranges fms vars))
	(unvars    (ia-find-unbound-vars ia-vars))
	(qth       (no-qualified-name required-constant))
	(msg       (cond (qth (format nil "This strategy requires theory ~a to be imported in the current context" qth))
			 (unvars
			  (format nil "Variable~:[~;s~] ~{~a~^,~} ~:[is~;are~] unbounded."
				  (cdr unvars) unvars (cdr unvars)))
			 ((null ia-expr)
			  (format nil "Do not understand argument ~a." expr))
			 ((not (is-number-type (type ia-expr)))
			  (format nil "Expresion ~a is not a real number expression." ia-expr))))
	(ia-box    (unless msg (ia-box ia-vars)))
	(m_or_m    (+ (if min? -1 0) (if max? 1 0)))
	
	(ia-iexpr  (unless msg (funcall pvsexpr-to-strobj ia-expr precision ia-vars subs)))
	(names     (unless msg (append (mapcar #'car *ia-let-names*) (list name))))
	(exprs     (unless msg (append (mapcar #'cdr *ia-let-names*) (list ia-iexpr))))
	
	(namexprs  (merge-lists names exprs))
	(ia-dirvar (or dirvar (cond ((< m_or_m 0) "mindir_maxvar")
				    ((> m_or_m 0) "maxdir_maxvar")
				    (t "altdir_maxvar"))))
	(maxdepth  (if (null ia-vars) 0 maxdepth))
	(ia-eval   (format nil "~a(~a,~a,~a,~a)(~a,~a)"
			   bandb-function-name maxdepth accuracy ia-dirvar m_or_m name ia-box))
	(ia-lvars  (format nil "list2array(0)((:~{~a~^, ~}:))" ia-vars))
	(msg       (or msg (when (listp ia-iexpr) (car ia-iexpr)))))
    (if msg
	(printf msg)
      (spread
       (name-label* namexprs :hide? t)
       ((try-branch
	 (eval-expr ia-eval :safe? nil)
	 ((let ((output (args2 (extra-get-formula -1)))
		(depth  (extra-get-number-from-expr (get-expr-from-obj output 'depth)))
		(splits (get-expr-from-obj output 'splits))
		(ans    (get-expr-from-obj output 'ans)))
	    (if (and (name-expr? ans) (eq (id ans) 'None))
		(then (printf "Error evaluating the expression") (fail))
	      (let ((ans    (if (record-expr? ans) ans (args1 ans)))
		    (lbacc  (ratio2decimal (- (extra-get-number-from-expr 
					       (get-expr-from-obj ans 'lb_max))
					      (extra-get-number-from-expr 
					       (get-expr-from-obj ans 'mm 'lb)))
					   true precision))
		    (ubacc  (ratio2decimal (- (extra-get-number-from-expr 
					       (get-expr-from-obj ans 'mm 'ub))
					      (extra-get-number-from-expr 
					       (get-expr-from-obj ans 'ub_min)))
					   true precision))
		    (eqs    (extra-get-evalexprs))
		    (maxd   (and ia-vars (= depth maxdepth))))
		(with-fresh-labels 
		 ((!iax) (!label))
		 (let ((label (or label !label)))
		   (then
		    (relabel label -1)
		    (lemma soundness-lemma-name)
		    (inst? -1)
		    (replaces label)
		    (beta -1)
		    (expand "sound?" -1)
		    (apply (repeat (expand "length" -1)))
		    (extra-evalexprs$ eqs !iax)
		    (branch
		     (split -1)
		     ((then
		       (flatten)
		       (relabel label (-2 -3 -4 -5))
		       (hide label)
		       (spread
			(inst -1 ia-lvars)
			((branch
			  (invoke (case "%1 = %2") (! -1 1) ia-estr)
			  ((then 
			    (when verbose?
			      (printf "~%----")
			      (when maxd
				(printf "Maximum depth has been reached."))
			      (printf "Lower bound accuracy <= ~a" lbacc) 
			      (printf "Upper bound accuracy <= ~a" ubacc)
			      (printf "Splits: ~a. Depth: ~a" splits depth)
			      (printf "See hidden formulas for more information~%----~%"))
			    (replaces -1)
			    (decimalize -1 precision))
			   (then (hide -1) (when equiv? (beval-solver names 1 subs rewrite-decls)))
			   (then (hide -1) (reveal !iax) (replaces !iax :hide? nil) (vars-sharp__$))))
			 (if (null ia-vars)
			     (eval-formula)
			   (then 
			    (reveal !iax)
			    (replaces !iax :hide? nil) 
			    (vars-in-box__$))))))
		      (eval-formula)))))))))
	  (skip))
	 (skip))))))
  "Computes lower and upper bounds of the minimum and maximum values
of EXPR using the algorithm called BANDB-FUNCTION-NAME. Its soundness
must be guaranteed by a lemma of name SOUNDNESS-LEMMA-NAME.
BEVAL-SOLVER is the name of the strategy that should be used to prove
that the PVS expression corresponds with the beval of the interval
expr. REWRITE-DECLS are the rewriting rules to be used as to simplify
the evaluation expression.

REQUIRED-CONSTANT is a fully qualified constant that must occur in the
current context for this strategy to work. The name of the function to
translate a pvs expression to a string representation of a ObjType is
the parameter PVSEXPR-TO-STROBJ.

PRECISION is the number of decimals in the output interval. PRECISION also
indicates an accuracy of 10^-PRECISION in every atomic computation. However,
this accuracy is not guaranteed in the final result. MAXDEPTH is a maximum
recursion depth for the branch and bound algorithm. For efficiency, the MIN?
and MAX? options can be used to restrict the precision of the computations
to either the lower or upper bound, respectively.

VARS is a list of the form (<v1> ... <vn>), where each <vi> is either a
variable name, e.g., \"x\", or a list consisting of a variable name and
an interval, e.g., (\"x\" \"[|-1/3,1/3|]\"). This list is used to specify
the variables in EXPR and to provide their ranges. If this list is not
provided, this information is extracted from the sequent.

SUBS is a list of substitutions for translating user-defined
real-valued functions into interval ones. Each substitution has the
form (<f> <F> [<nm>]), where <f> is the name of a real-valued function
and <F> is the name of its interval counterpart. It is assumed that
<F> satisfies the Inclusion and the Fundamental theorems of interval
arithmetic for <f>. If <nm> is provided, it should be a
fully-qualified name of a constant that has to occur in the current
context for operator <F> to be supported. An error is raised if this
is not the case. If <f> is not a rational function, the element <F>
may have the form (<F> <n>), where the parameter <n> indicates a
relative precision with respect to PRECISION.

DIRVAR is the name of a direction and variable selection method for
the branch an bound algorithm. Theory numerical_bandb includes some
pre-defined methods. If none is provided, a choice is made base on the
problem.

If VERBOSE? is set to t, the strategy prints information about number of
splits, depth, etc. 

LABEL is used to label formulas containing additional information computed
by the branch and bound algorithm. These formulas are hidden, but they can
be brought to the sequent using the proof command REVEAL.

If EQUIV? is set to nil, the strategy doesn't try to prove that the
deep embedding of the original expression is correct. The proof of
this fact is trivial from a logical point of view, but requires
unfolding of several definitions which is time consuming in PVS." "")

(defparameter *interval-strategies* "
%  decimalize: Decimalizes relational formulas involving rational numbers.
%  decimalize-expr: Decimalizes rational expressions.
%  numerical: Computes bounds to minimum and maximum values of real-valued expressions.
%  interval: Checks whether or not properties on real-valued formulas hold.
%  Supported operations include: +,-,*,/,^,sq,abs,sqrt,pi,sin,cos,tan,atan,ln,exp,e")

;; The parameter intervl is a list of 2 lisp numbers (ratios), over is a boolean,
;; and n is the number of decimals in the output. The output is a string representing
;; a decimal interval, where the bounds are exact to the original one up to the n-1 decimal.
;; Furthermore, if over is t, then the output is an over-approximation. Otherwise, the
;; output is an under-approximation.
(defun ia-interval2decimal (intervl over n)
  (when (and intervl
	     (numberp (nth 0 intervl))
	     (numberp (nth 1 intervl)))
    (format nil "[|~a,~a|]"
	    (ratio2decimal (nth 0 intervl) (not over) n)
	    (ratio2decimal (nth 1 intervl) over n))))

(defun ia-concrete-interval (expr)
  (let ((val (extra-add-evalexpr expr)))
    (when (record-expr? val)
      (let ((lb (extra-get-number-from-expr (get-expr-from-obj val 'lb)))
	    (ub (extra-get-number-from-expr (get-expr-from-obj val 'ub))))
	(when (and lb ub) (list lb ub))))))

(defstep decimalize (fnum &optional (precision 3) (side r) (tccs? t))
  (let ((initeqs (extra-reset-evalexprs))
	(fnum    (extra-get-fnum fnum)))
    (when fnum
      (with-fresh-labels
       ((!dec fnum :tccs? tccs?))
       (let ((expr  (extra-get-formula !dec))
	     (castr (if (is-function-expr expr "##")
			(let ((int2dec (ia-interval2decimal (ia-concrete-interval (args2 expr))
							    (< fnum 0) precision)))
			  (when int2dec
			    (format nil "~a ## ~a" (args1 expr) int2dec)))
		      (let* ((rel (car (is-relation expr)))
			     (num (when rel (extra-get-number-from-expr 
					     (extra-add-evalexpr
					      (if (member side '(r R))
						  (args2 expr)
						(args1 expr)))))))
			(when num
			  (if (and (equal rel '=) (< fnum 0))
			      (format nil "~a ## [| ~a, ~a |]" (if (member side '(r R))
								   (args1 expr)
								 (args2 expr))
				      (ratio2decimal num nil precision)
				      (ratio2decimal num t precision))
			    (unless (equal rel '=)
			      (if (member side '(r R))
				  (format nil "~a ~a ~a" (args1 expr) rel
					  (ratio2decimal num	
							 (iff (< fnum 0) (member rel '(< <=)))
							 precision))
				(format nil "~a ~a ~a" 
					(ratio2decimal num	
						       (iff (> fnum 0) (member rel '(< <=)))
						       precision)
					rel (args2 expr)))))))))
	     (eqs   (when castr (extra-get-evalexprs))))
	 (if castr
	     (then
	      (extra-evalexprs$ eqs)
	      (branch (case castr)
		      ((if (< fnum 0)
			   (hide !dec)
			 (then
			  (hide-all-but (!dec -1))
			  (expand "##")
			  (flatten)
			  (assert)))
		       (if (> fnum 0)
			   (hide !dec)
			 (then
			  (hide-all-but (!dec 1))
			  (expand "##")
			  (flatten)
			  (assert)))
		       (assert))))
	   (printf "Formula ~a is not suitable for decimalization" fnum))))))
  "[Interval] Decimalizes a rational number in one side of relational formula FNUM
by a decimal number that is exact to the rational number up to the PRECISION-1 decimal.
SIDE can be either r (right) or l (left). If TCCs? is set to nil, the strategy doesn't try
to prove possible TCCs generated during its execution."
  "Decimalizing ~2@*~ahs of relational formula ~@*~a to precision ~1@*~a")

(defstep decimalize-expr (expr &optional (precision 3))
  (let ((initeqs (extra-reset-evalexprs))
	(exprat  (extra-get-expr expr))
	(num     (extra-get-number-from-expr (extra-add-evalexpr exprat)))
	(castr   (when num
		   (format nil "~a ## [| ~a, ~a |]"
		 	  exprat
			  (ratio2decimal num nil precision)
			  (ratio2decimal num t precision))))
	(eqs    (when castr (extra-get-evalexprs))))
    (if castr
	(spread (case castr)
		((skip)
		 (then
		  (hide-all-but 1)
		  (extra-evalexprs$ eqs)
		  (expand "##")
		  (flatten)
		  (assert))))
      (printf "Expression ~a is not suitable for decimalization" expr)))
  "[Interval] Decimalizes a rational number by a decimal number that is exact to the
rational number up to the PRECISION-1 decimal."
  "Decimalizing expression ~a to the precision ~a")

;; The following strategy is provided for didactic purposes only.
;; The most sophisticated strategy numerical should be used in proofs instead of simple-numerical
(defstep simple-numerical (expr &optional (precision 3) (maxdepth 5))
  (let ((subs    *ia-builtin*)
	(ia-expr (extra-get-expr expr))
	(ia-estr (expr2str ia-expr))
	(fms     (mapcar #'(lambda (fn) (extra-get-formula-from-fnum fn)) (extra-get-fnums '-)))
	(vars    (ia-get-vars-from-expr ia-expr subs))
	(ia-vars (extra-get-var-ranges fms vars))
	(unvars  (ia-find-unbound-vars ia-vars))
	(msg     (cond (unvars
			(format nil "Variable~:[~;s~] ~{~a~^, ~} ~:[is~;are~] unbounded."
				(cdr unvars) unvars (cdr unvars)))
		       ((null ia-expr)
			(format nil "Do not understand argument ~a." expr))
		       ((not (is-number-type (type ia-expr)))
			(format nil "Expresion ~a is not a real number expression." ia-expr))))
	(ia-box    (unless msg (ia-box ia-vars)))
	(ia-iexpr  (unless msg (ia-interval-expr ia-expr precision ia-vars subs)))
	(maxdepth  (if (null ia-vars) 0 maxdepth))
	(msg       (or msg (when (listp ia-iexpr) (car ia-iexpr)))))
    (if msg
	(printf msg)
      (with-fresh-names
       ((sia ia-iexpr))
       (let ((ia-eval  (format nil "simple_bandb.simple_interval(~a,~a,~a)" maxdepth sia ia-box))
	     (ia-lvars (format nil "list2array(0)((:~{~a~^, ~}:))" ia-vars)))
	 (then
	  (eval-expr ia-eval :safe? nil)
	  (lemma "simple_bandb.simple_interval_soundness")
	  (inst? -1)
	  (replaces -2)
	  (beta -1)
	  (expand "sound?" -1)
	  (branch (split -1)
		  ((spread (inst -1 ia-lvars)
			   ((branch (invoke (case "%1 = %2") (! -1 1) ia-estr)
				    ((then (replaces -1)
					   (decimalize -1 precision))
				     (interval-eq__$ sia 1 subs nil)
				     (then (hide -1)(vars-sharp__))))
			    (if (null ia-vars)
				(eval-formula)
			      (vars-in-box__))))
		   (eval-formula))))))))
  "[Interval] Computes a simple estimation of the minimum and maximum
values of EXPR using a branch and bound algorithm based on interval
arithmetic.  PRECISION is the number of decimals in the output
interval. PRECISION also indicates an accuracy of 10^-PRECISION in
every atomic computation. However, this accuracy is not guaranteed in
the final result.

MAXDEPTH is a maximum recursion depth for the branch and bound
algorithm.

This strategy is a simplified version of the more elaborated strategy
NUMERICAL."
  "Computing estimates to the minmax of expression ~a,~%using interval arithmetic")

;; *** Concrete instantiations of branch and bound strategies (interval and numerical) 
;; *** for interval arithmetic by Mariano Moscato

(defstep interval (&optional 
		   (fnums 1) (precision 3) maxdepth sat?
		   vars 
		   subs 
		   dirvar
		   verbose?
		   label
		   (equiv? t)
		   (tccs? t))
  (let ((subs (append subs *ia-builtin*)))
    (gbandb_interval__$
     "interval_arith@strategies4Q.IntervalStrategies4Q__" ;;; required-constant
     ia-interval-expr                                     ;;; pvsexpr-to-strobj
     "interval_bandb.interval"                            ;;; bandb-function-name
     "interval_bandb.interval_soundness"                  ;;; bandb soundness theorem
     nil                                                  ;;; rewrite-decls
     interval-eq__$                                       ;;; beval-solver
     fnums precision maxdepth sat? vars subs              ;;; (Pass-through params.)
     dirvar verbose? label equiv? tccs?))                 ;;; (Pass-through params.)
  "[Interval] Checks if formulas FNUMS, which may be simply
quantified, holds using a branch and bound algorithm based on interval
arithmetic.  The parameter PRECISION indicates an accuracy of
10^-PRECISION in every atomic computation. However, this accuracy is
not guaranteed in the final result. MAXDEPTH is a maximum recursion
depth for the branch and bound algorithm.

The interval approximations of sin, cos, tan are defined for the
ranges [-pi_lb,pi_lb], [-pi_lb,pi_lb], and [-pi_lb/2,pi_lb/2].

If SAT? is set to t, the strategy checks if formula FNUMS,
whether in the antecedent or in the consequent, is satisfiable
and, in the positive case, prints a provably correct witness.
If formula FNUMS is quantified, it is checked for validity.

VARS is a list of the form (<v1> ... <vn>), where each <vi> is either a
variable name, e.g., \"x\", or a list consisting of a variable name and
an interval, e.g., (\"x\" \"[|-1/3,1/3|]\"). This list is used to specify
the variables in EXPR and to provide their ranges. If this list is not
provided, this information is extracted from the sequent.

SUBS is a list of substitutions for translating user-defined
real-valued functions into interval ones. Each substitution has
the form (<f> <F>), where <f> is the name of a real-valued function
and <F> is the name of its interval counterpart. It is assumed that
<F> satisfies the Inclusion and the Fundamental theorems of interval
arithmetic for <f>. Standard substitutions for basic arithmetic
operators, abs, sq, sqrt, trigonometric functions, exp, and ln
are already provided. This parameter can be used to change the precision
for a particular function, e.g., ((\"pi\" \"PI_n(4)\") (\"cos\"
(\"COS_n\" 1))(\"sin\" (\"SIN_n\" -1))) specifies the precision 4,
PRECISION+1, and PRECISION-1 for pi, cos, and sin, respectively.

DIRVAR is the name of a direction and variable selection method for
the branch an bound algorithm. Theory interval_bandb includes some
pre-defined methods. If none is provided, a choice is made base on the
problem.

If VERBOSE? is set to t, the strategy prints information about number of
splits, depth, etc. 

LABEL is used to label formulas containing additional information computed
by the branch and bound algorithm. These formulas are hidden, but they can
be brought to the sequent using the proof command REVEAL.

If EQUIV? is set to nil, the strategy doesn't try to prove that the
deep embedding of the original expression is correct. The proof of
this fact is trivial from a logical point of view, but requires
unfolding of several definitions which is time consuming in PVS.

If TCCs? is set to nil, the strategy doesn't try to prove possible
TCCs generated during its execution."
  "Checking formula ~a using interval arithmetic")

(defstep numerical (expr 
		    &optional (precision 3) (maxdepth 10)
		    min? max?
		    vars 
		    subs
		    dirvar
		    verbose?
		    label
		    (equiv? t))
  (let ((subs (append subs *ia-builtin*)))
    (gbandb_numerical__$ 
     "interval_arith@strategies4Q.IntervalStrategies4Q__" ;;; required-constant
     ia-interval-expr                                     ;;; pvsexpr-to-strobj 
     "numerical_bandb.numerical"                          ;;; bandb-function-name
     "numerical_bandb.numerical_soundness"                ;;; bandb soundness theorem
     nil                                                  ;;; rewrite-decls
     interval-eq__$                                       ;;; beval-solver
     expr precision maxdepth min? max? vars subs          ;;; (Pass-through parameters.)
     dirvar verbose? label equiv?))                       ;;; (Pass-through parameters.)
  "[Interval] Computes lower and upper bounds of the minimum and
maximum values of EXPR using a branch and bound algorithm based on
interval arithmetic.  PRECISION is the number of decimals in the
output interval. PRECISION also indicates an accuracy of 10^-PRECISION
in every atomic computation. However, this accuracy is not guaranteed
in the final result. MAXDEPTH is a maximum recursion depth for the
branch and bound algorithm. For efficiency, the MIN? and MAX? options
can be used to restrict the precision of the computations to either
the lower or upper bound, respectively.

VARS is a list of the form (<v1> ... <vn>), where each <vi> is either a
variable name, e.g., \"x\", or a list consisting of a variable name and
an interval, e.g., (\"x\" \"[|-1/3,1/3|]\"). This list is used to specify
the variables in EXPR and to provide their ranges. If this list is not
provided, this information is extracted from the sequent.

SUBS is a list of substitutions for translating user-defined
real-valued functions into interval ones. Each substitution has the
form (<f> <F>), where <f> is the name of a real-valued function and
<F> is the name of its interval counterpart. It is assumed that <F>
satisfies the Inclusion and the Fundamental theorems of interval
arithmetic for <f>. Standard substitutions for basic arithmetic
operators, abs, sq, sqrt, trigonometric functions, exp, and ln are
already provided. This parameter can be used to change the precision
for a particular function, e.g., ((\"pi\" \"PI_n(4)\") (\"cos\"
(\"COS_n\" 1))(\"sin\" (\"SIN_n\" -1))) specifies the precision 4,
PRECISION+1, and PRECISION-1 for pi, cos, and sin, respectively.

DIRVAR is the name of a direction and variable selection method for
the branch an bound algorithm. Theory numerical_bandb includes some
pre-defined methods. If none is provided, a choice is made base on the
problem.

If VERBOSE? is set to t, the strategy prints information about number of
splits, depth, etc. 

LABEL is used to label formulas containing additional information computed
by the branch and bound algorithm. These formulas are hidden, but they can
be brought to the sequent using the proof command REVEAL.

If EQUIV? is set to nil, the strategy doesn't try to prove that the
deep embedding of the original expression is correct. The proof of
this fact is trivial from a logical point of view, but requires
unfolding of several definitions which is time consuming in PVS."
  "Computing minmax values of expression ~a,~%via interval arithmetic")
