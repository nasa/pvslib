(vsLevelOut (S1_TCC1 0 (S1_TCC1-1 nil 3613726992 ("" (skosimp*) (("" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (S1 subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.t /= 0, reals.>=(i, 0))}"))) (quadRoots_TCC1 0 (quadRoots_TCC1-1 nil 3613732864 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (quadRoots subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.b /= 0, reals.>=(i, 0))}"))) (quadRoots_TCC2 0 (quadRoots_TCC2-1 nil 3614934108 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (quadRoots subtype "(number_fields.*(2, vsLevelOut.a))" "nznum"))) (quad_contrapos_TCC1 0 (quad_contrapos_TCC1-1 nil 3613738798 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (quad_contrapos subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.a /= 0, reals.>=(i, 0))}"))) (quad_contrapos_TCC2 0 (quad_contrapos_TCC2-1 nil 3613738798 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (quad_contrapos subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.x /= 0, reals.>=(i, 0))}"))) (quad_contrapos 0 (quad_contrapos-1 nil 3613738823 ("" (skosimp*) (("" (case-replace "a!1 ^ 2 * x!1 ^ 2 + b!1 * a!1 * x!1 + a!1 * c!1 = a!1^2*(x!1+b!1/(2*a!1))^2 +(- (b!1^2-4*a!1*c!1)/4)") (("1" (mult-by 1 "4") (("1" (assert) (("1" (grind-reals) (("1" (move-terms 1 L 1) (("1" (move-terms 1 R 1) (("1" (assert) (("1" (case "4 * ((b!1 / (2 * a!1) + x!1) ^ 2 * a!1 ^ 2)>=0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (div-by 1 "4") (("2" (assert) (("2" (lemma "sq_pos") (("2" (inst-cp -1 "b!1/(2*a!1)+x!1") (("2" (inst -1 "a!1") (("2" (case "FORALL (s:real): sq(s) = s^2") (("1" (inst-cp -1 "a!1") (("1" (inst -1 "b!1/(2*a!1) + x!1") (("1" (replace -1) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (sq const-decl "nonneg_real" sq reals) (sq_nz_pos application-judgement "posreal" sq reals) (expt def-decl "real" exponentiation nil) (sq_pos formula-decl nil sq reals) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_ge1 formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (div_cancel1 formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nzreal_expt application-judgement "nzreal" exponentiation nil)) shostak)) (quad_lem_TCC1 0 (quad_lem_TCC1-1 nil 3613741430 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (quad_lem subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.y /= 0, reals.>=(i, 0))}"))) (quad_lem 0 (quad_lem-1 nil 3613741450 ("" (skosimp*) (("" (lemma "quad_contrapos") (("" (inst -1 "a!1" "b!1" "c!1") (("" (assert) (("" (case "a!1>0") (("1" (mult-by -4 "a!1") (("1" (inst -3 "y!1") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "x!1") (("2" (mult-by -2 "-a!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((quad_contrapos formula-decl nil vsLevelOut nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (a!1 skolem-const-decl "nzreal" vsLevelOut nil) (>= const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (expt def-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (quad_lem2_TCC1 0 (quad_lem2_TCC1-1 nil 3613743231 ("" (lemma "quad_lem") (("" (propax) nil nil)) nil) ((quad_lem formula-decl nil vsLevelOut nil)) nil (quad_lem2 subtype "(number_fields.-)(exponentiation.^(vsLevelOut.b, 2), number_fields.*(number_fields.*(4, vsLevelOut.a), vsLevelOut.c))" "nonneg_real"))) (quad_lem2_TCC2 0 (quad_lem2_TCC2-1 nil 3613743231 ("" (subtype-tcc) nil nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil)) nil (quad_lem2 subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.r1 /= 0, reals.>=(i, 0))}"))) (quad_lem2_TCC3 0 (quad_lem2_TCC3-1 nil 3613743231 ("" (subtype-tcc) nil nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil)) nil (quad_lem2 subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.r2 /= 0, reals.>=(i, 0))}"))) (quad_lem2 0 (quad_lem2-1 nil 3613743338 ("" (skosimp*) (("" (skoletin) (("" (skoletin) (("" (lemma "quad_lem") (("" (inst?) (("" (inst?) (("" (lemma "sq_sqrt") (("" (split 1) (("1" (inst -1 "b!1^2-4*a!1*c!1") (("1" (replace -4) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -1 "b!1^2-4*a!1*c!1") (("2" (replace -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (quad_lem formula-decl nil vsLevelOut nil) (expt def-decl "real" exponentiation nil) (sq const-decl "nonneg_real" sq reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_sqrt formula-decl nil sqrt reals) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (vsLevelOutTimes1_TCC1 0 (vsLevelOutTimes1_TCC1-1 nil 3613726992 ("" (skosimp*) (("" (grind) nil nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil)) nil (vsLevelOutTimes1 subtype "vsLevelOut.a1" "nznum"))) (vsLevelOutTimes1_TCC2 0 (vsLevelOutTimes1_TCC2-1 nil 3613726992 ("" (skosimp*) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil (vsLevelOutTimes1 subtype "vsLevelOut.a2" "nzreal"))) (vsLevelOutTimes1_TCC3 0 (vsLevelOutTimes1_TCC3-2 "" 3790107029 ("" (skosimp*) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (S1 const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (S3 const-decl "real" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak (vsLevelOutTimes1 subtype "vsLevelOut.cRate" "nznum")) (vsLevelOutTimes1_TCC3-1 nil 3613726992 ("" (skosimp*) (("" (lift-if -7) (("" (split -7) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (S1 const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (S3 const-decl "real" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (vsLevelOutTimes1 subtype "vsLevelOut.cRate" "nznum"))) (vsLevelOutTimes1_TCC4 0 (vsLevelOutTimes1_TCC4-1 nil 3613726992 ("" (skosimp*) (("" (grind) nil nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (S3 const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (S1 const-decl "real" vsLevelOut nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (vsLevelOutTimes1 subtype "(number_fields.*(2, vsLevelOut.a2))" "nznum"))) (vsLevelOutTimes1_TCC5 0 (vsLevelOutTimes1_TCC5-1 nil 3613726992 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (S1 const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (S3 const-decl "real" vsLevelOut nil) (/= const-decl "boolean" notequal nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (vsLevelOutTimes1 subtype "2" "{i: integers.int | booleans.OR(vsLevelOut.v0z /= 0, reals.>=(i, 0))}"))) (vsLevelOutTimes_TCC1 0 (vsLevelOutTimes_TCC1-1 nil 3613810277 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (vsLevelOutTimes subtype "vsLevelOut.a2" "nzreal"))) (vsLevelOutTimes_TCC2 0 (vsLevelOutTimes_TCC2-1 nil 3613810277 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (vsLevelOutTimes subtype "vsLevelOut.a1" "nzreal"))) (times_increase 0 (times_increase-2 nil 3613813416 ("" (skosimp*) (("" (skoletin) (("" (case "FORALL (s:real, v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, altcr:bool):
                LET times = vsLevelOutTimes1(s,v,cr, ta, au, ad, altcr),
               sv = IF v>=0 THEN 1 ELSE -1 ENDIF,
                aldir = IF ta-s>=0 THEN 1 ELSE -1 ENDIF IN
               (sv=aldir OR v=0) AND abs(ta-s)>= abs( S3(v, IF ta-s>=0 THEN ad ELSE au ENDIF)) IMPLIES 0<=times`1 AND times`1<=times`2 AND times`2<=times`3") (("1" (case "IF v0z!1>=0 THEN 1 ELSE -1 ENDIF = IF targetAlt!1-s0z!1>=0 THEN 1 ELSE -1 ENDIF OR v0z!1=0") (("1" (case "abs(targetAlt!1-s0z!1) >= abs(S3(v0z!1, IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF))") (("1" (expand "vsLevelOutTimes") (("1" (inst -3 "s0z!1" " v0z!1" "
                                      climbRate!1" "
                                      targetAlt!1" "
                                      accelup!1" "
                                      acceldown!1" "
                                      alterCR?!1") (("1" (replace -4) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (replace -2) (("1" (replace -3) (("1" (replace -4) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "s0z!1+S3(v0z!1, IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF)" " 0" " climbRate!1" " targetAlt!1" " accelup!1" " acceldown!1" " alterCR?!1") (("2" (case "-v0z!1/(IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF) >=0") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (replace -4) (("1" (replace -7) (("1" (expand "vsLevelOutTimes") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (case "LET  AY2= IF targetAlt!1-s0z!1>=0 then acceldown!1 ELSE accelup!1 ENDIF,  
tm = vsLevelOutTimes1(s0z!1 + S3(v0z!1, AY2),
                                          0,
                                          climbRate!1,
                                          targetAlt!1,
                                          accelup!1,
                                          acceldown!1,
                                          alterCR?!1) IN
0<=tm`1 AND tm`1<=tm`2 AND tm`2<=tm`3 IMPLIES 
0<= -v0z!1/AY2 +tm`1 AND -v0z!1/AY2+tm`1<=-v0z!1/AY2+tm`2 AND -v0z!1/AY2+tm`2<=-v0z!1/AY2+tm`3") (("1" (skoletin) (("1" (skoletin) (("1" (replace -2) (("1" (replace -3) (("1" (lift-if) (("1" (case " abs(S3(0, accelup!1))=0 AND abs(S3(0, acceldown!1))=0") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (skoletin) (("2" (skoletin) (("2" (replace -2) (("2" (lift-if) (("2" (hide -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp*) (("3" (lift-if) (("3" (hide-all-but (-1 -8)) (("3" (ground) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp*) (("4" (hide-all-but (-1 -7)) (("4" (lift-if) (("4" (ground) nil nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (skosimp*) (("5" (hide-all-but (-1 -6)) (("5" (lift-if) (("5" (ground) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (skosimp*) (("6" (lift-if) (("6" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (split -1) (("1" (lift-if 1) (("1" (lift-if -1) (("1" (lift-if -1) (("1" (lift-if -1) (("1" (split 1) (("1" (prop) (("1" (typepred (acceldown!1)) (("1" (cross-mult) nil nil)) nil) ("2" (cross-mult) nil nil)) nil) ("2" (prop) (("1" (cross-mult) nil nil) ("2" (cross-mult) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "AY1" "-v0z!1/(IF targetAlt!1 - s0z!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF)") (("2" (case "AY1>=0") (("1" (name "AA1" "IF targetAlt!1 - s0z!1 >= 0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("1" (case "AA1 /=0") (("1" (inst -5 "s0z!1+S3(v0z!1, AA1)" " 0" " climbRate!1" " targetAlt!1" " accelup!1" " acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (case "0 <= times`1 AND times`1 <= times`2 AND times`2 <= times`3 IMPLIES 
0 <= AY1+times`1 AND AY1+times`1 <= AY1+times`2 AND AY1+times`2 <= AY1+times`3") (("1" (case "abs(S3(0,
                IF targetAlt!1 - (s0z!1 + S3(v0z!1, AA1)) >= 0
                  THEN acceldown!1
                ELSE accelup!1
                ENDIF)) = 0") (("1" (replace -1) (("1" (skoletin) (("1" (lift-if -2) (("1" (bddsimp -2) (("1" (skoletin -3) (("1" (bddsimp -1) (("1" (bddsimp -8) (("1" (hide (-4 -5 -6)) (("1" (expand "vsLevelOutTimes") (("1" (merge-fnums (-1 -2 -3)) (("1" (replace -10 :dir rl) (("1" (replace -10) (("1" (replace -8) (("1" (name-replace "AA2" "IF targetAlt!1 - s0z!1 >= 0
                                      THEN acceldown!1
                                      ELSE accelup!1
                                      ENDIF") (("1" (expand "sv") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (simplify -11) (("1" (simplify 1) (("1" (bddsimp -11) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) (("4" (replace -2) (("4" (assert) (("4" (replace -7) (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (assert) nil nil) ("6" (assert) (("6" (replace -2) (("6" (assert) (("6" (replace -7) (("6" (propax) nil nil)) nil)) nil)) nil)) nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (cross-mult) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (cross-mult) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (skosimp*) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (flatten) (("2" (expand "vsLevelOutTimes1") (("2" (name-replace "CR" "IF ta!1 >= s!1 THEN 1 ELSE -1 ENDIF *
                      (IF altcr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF)") (("2" (name-replace "A1" "IF CR >= v!1 THEN au!1 ELSE ad!1 ENDIF") (("2" (name-replace "A2" "IF ta!1 >= s!1 THEN ad!1 ELSE au!1 ENDIF") (("2" (lift-if -5) (("2" (split -5) (("1" (flatten) (("1" (case "tee3(CR, A2)>=0") (("1" (case "(CR - v!1) / A1>=0") (("1" (case "((ta!1 - s!1) - S1(v!1, A1)((CR - v!1) / A1) -
           S3(V1(v!1, A1)((CR - v!1) / A1), A2))
          / CR>=0") (("1" (replace -5) (("1" (ground) nil nil)) nil) ("2" (hide (-2 -4 2)) (("2" (case "A1=A2") (("1" (replace -1) (("1" (case "- S1(v!1, A2)((CR - v!1) / A2) -
        S3(V1(v!1, A2)((CR - v!1) / A2), A2) = v!1^2/(2*A2)") (("1" (case-replace "IF ta!1 - s!1 >= 0 THEN ad!1 ELSE au!1 ENDIF=A2") (("1" (case-replace "S3(v!1, A2) = -v!1^2/(2*A2)") (("1" (case-replace "v!1 = 0") (("1" (ground) (("1" (grind) (("1" (expand "A2") (("1" (expand "A1") (("1" (expand "CR") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "CR") (("2" (expand "sv") (("2" (expand "aldir") (("2" (expand "A2") (("2" (expand "A1") (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ta!1-s!1>=0 IFF -v!1^2/(2*A2)>=0") (("1" (case "ta!1-s!1>=0") (("1" (flatten) (("1" (expand "abs") (("1" (lift-if -11) (("1" (prop) (("1" (ground) nil nil) ("2" (lift-if -1) (("2" (prop) (("1" (ground) nil nil) ("2" (case "CR>0") (("1" (cross-mult 4) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1 -3)) (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (lift-if -10) (("2" (case "CR<0") (("1" (prop) (("1" (grind) (("1" (cross-mult 5) nil nil)) nil) ("2" (cross-mult 6) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "A2") (("2" (grind) (("1" (cross-mult) nil nil) ("2" (cross-mult) (("2" (grind) (("2" (split-ineq -1) (("2" (grind) (("2" (lemma "sq_eq_0") (("2" (inst -1 "v!1") (("2" (flatten) (("2" (expand "sq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "A2") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "V1") (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "A2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "S1(v!1, A1)((CR - v!1) / A1) +
        S3(V1(v!1, A1)((CR - v!1) / A1), A2) = (CR^2-v!1^2)/(2*A1) - CR^2/(2*A2)") (("1" (case "CR^2-v!1^2>=0") (("1" (case "ta!1 -s!1>=0 IMPLIES (CR ^ 2 - v!1 ^ 2) / (2 * A1) - CR ^ 2 / (2 * A2)>=0") (("1" (case "ta!1-s!1>=0") (("1" (cross-mult 2) (("1" (expand "CR") (("1" (grind) nil nil)) nil)) nil) ("2" (case "ta!1-s!1<0 IMPLIES (CR ^ 2 - v!1 ^ 2) / (2 * A1) - CR ^ 2 / (2 * A2) <= 0") (("1" (cross-mult 3) (("1" (expand "CR") (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-1 -3 -4 -5 -7 4)) (("2" (lift-if -3) (("2" (flatten) (("2" (bddsimp -4) (("1" (propax) nil nil) ("2" (expand "A2") (("2" (lift-if 4) (("2" (bddsimp 4) (("1" (ground) nil nil) ("2" (lift-if 4) (("2" (bddsimp 4) (("1" (propax) nil nil) ("2" (case-replace "A1=ad!1") (("1" (hide-all-but (2 -4)) (("1" (div-by -1 "-(2*ad!1)") (("1" (case "CR^2/(2*au!1)>=0") (("1" (grind) nil nil) ("2" (cross-mult 1) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "A2") (("2" (lift-if 2) (("2" (bddsimp 2) (("1" (case-replace "A1=au!1") (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (hide-all-but (-5 1)) (("1" (div-by -1 "(2*au!1)") (("1" (case "-CR^2/(2*ad!1)>=0") (("1" (grind) nil nil) ("2" (cross-mult 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (expand "A1") (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ta!1>=s!1") (("1" (case "CR>=v!1") (("1" (mult-ineq -1 -1) (("1" (grind) nil nil) ("2" (expand "aldir") (("2" (expand "sv") (("2" (lift-if -6) (("2" (split -6) (("1" (expand "abs") (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (expand "A2") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (case "-CR > -v!1") (("1" (mult-ineq -1 -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil) ("3" (flatten) (("3" (expand "aldir") (("3" (expand "sv") (("3" (split -5) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S1") (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "V1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "A2") (("3" (grind) nil nil)) nil) ("4" (expand "A1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -5 2)) (("2" (expand "CR") (("2" (expand "A1") (("2" (cross-mult 1) (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "tee3") (("2" (hide (-2 2)) (("2" (cross-mult 1) (("2" (hide -) (("2" (expand "A2") (("2" (expand "CR") (("2" (case "IF altcr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF>=0") (("1" (grind) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "minpos(quadRoots(A1 / 2 - A1 ^ 2 / (2 * A2), v!1 - A1 / A2 * v!1,
                         -v!1 ^ 2 / (2 * A2) - ta!1 + s!1))>=0") (("1" (case "A1=A2") (("1" (case-replace "IF ta!1 - s!1 >= 0 THEN ad!1 ELSE au!1 ENDIF = A2") (("1" (replace -2) (("1" (case-replace "S1(v!1, A2)((CR - v!1) / A2) +
            S3(V1(v!1, A2)((CR - v!1) / A2), A2) = S3(v!1, A2)") (("1" (hide-all-but 1) (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "A2") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "T1" " minpos(quadRoots(A1 / 2 - A1 ^ 2 / (2 * A2), v!1 - A1 / A2 * v!1,
                       -v!1 ^ 2 / (2 * A2) - ta!1 + s!1))") (("2" (case "tee3(V1(v!1, A1)(T1), A2)>=0") (("1" (grind) nil nil) ("2" (hide (-2 -4 3 4)) (("2" (case "ta!1>=s!1") (("1" (expand "A2") (("1" (lift-if 2) (("1" (prop) (("1" (lift-if) (("1" (grind) (("1" (case-replace "A1=au!1") (("1" (cross-mult 2) (("1" (grind) (("1" (real-props) (("1" (typepred (au!1)) (("1" (mult-ineq -1 -6) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "V1") (("2" (lift-if 2) (("2" (prop) (("2" (expand "tee3") (("2" (expand "A1") (("2" (ground) (("2" (lift-if 2) (("2" (prop) (("2" (lift-if 2) (("2" (prop) (("2" (cross-mult 1) (("2" (typepred (au!1)) (("2" (mult-ineq -1 -9) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A2") (("2" (lift-if 3) (("2" (prop) (("1" (lift-if 4) (("1" (prop) (("1" (lift-if -3) (("1" (prop) (("1" (grind) nil nil) ("2" (expand "aldir") (("2" (expand "sv") (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (ground) nil nil) ("2" (lift-if -1) (("2" (prop) (("2" (expand "A1") (("2" (lift-if 8) (("2" (prop) (("2" (lift-if 8) (("2" (prop) (("2" (expand "V1") (("2" (expand "tee3") (("2" (cross-mult 2) (("2" (grind) (("2" (case "-ad!1>=0") (("1" (mult-ineq -1 -2) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand "V1") (("2" (expand "tee3") (("2" (lift-if 4) (("2" (prop) (("2" (expand "A1") (("2" (lift-if) (("2" (prop) (("1" (cross-mult 4) (("1" (grind) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) (("3" (cross-mult 5) (("3" (grind) (("3" (grind) (("3" (case "-ad!1>=0") (("1" (mult-ineq -1 -6) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "minpos") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (zero_times1 formula-decl nil real_props nil) (neg_ge formula-decl nil real_props nil) (quadRoots const-decl "[real, real]" vsLevelOut nil) (minpos const-decl "real" vsLevelOut nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_ge1 formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (A1 skolem-const-decl "real" vsLevelOut nil) (CR skolem-const-decl "real" vsLevelOut nil) (A2 skolem-const-decl "real" vsLevelOut nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sv skolem-const-decl "int" vsLevelOut nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (aldir skolem-const-decl "int" vsLevelOut nil) (hat_02n formula-decl nil power_series series) (sq const-decl "nonneg_real" sq reals) (sq_eq_0 formula-decl nil sq reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (V1 const-decl "real" vsLevelOut nil) (tee3 const-decl "real" vsLevelOut nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (S1 const-decl "real" vsLevelOut nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (expt def-decl "real" exponentiation nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sv skolem-const-decl "int" vsLevelOut nil) (AA1 skolem-const-decl "real" vsLevelOut nil) (div_cancel3 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (S3 const-decl "real" vsLevelOut nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil)) nil) (times_increase-1 nil 3613810335 ("" (skosimp*) (("" (skoletin) (("" (case "FORALL (s:real, v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, altcr:bool):
         LET times = vsLevelOutTimes1(s,v,cr, ta, au, ad, altcr),
        sv = IF v>=0 THEN 1 ELSE -1 ENDIF,
         aldir = IF ta-s>=0 THEN 1 ELSE -1 ENDIF IN
        (sv=aldir OR v=0) AND abs(ta-s)>= abs( S3(v, IF ta-s>=0 THEN ad ELSE au ENDIF)) IMPLIES 0<=times`1 AND times`1<=times`2 AND times`2<=times`3") (("1" (case "IF v0z!1>=0 THEN 1 ELSE -1 ENDIF = IF targetAlt!1-s0z!1>=0 THEN 1 ELSE -1 ENDIF") (("1" (case "abs(targetAlt!1-s0z!1) >= abs(S3(v0z!1, IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF))") (("1" (expand "vsLevelOutTimes") (("1" (lift-if -4) (("1" (lift-if -4) (("1" (lift-if -4) (("1" (lift-if -2) (("1" (lift-if -2) (("1" (lift-if -2) (("1" (lift-if -4) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil shostak)) (vsLevelOut_acc_TCC1 0 (vsLevelOut_acc_TCC1-1 nil 3613810277 ("" (lemma "times_increase") (("" (skosimp*) (("" (inst?) (("" (replace -2 :dir rl) (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((deriv_domain_real formula-decl nil deriv_domain analysis) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_increase formula-decl nil vsLevelOut nil)) nil (vsLevelOut_acc assuming "analysis@integral_split_fun[real].integral_split_fun" "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?"))) (vsLevelOut_acc_TCC2 0 (vsLevelOut_acc_TCC2-1 nil 3613810277 ("" (skosimp*) (("" (expand "connected?") (("" (propax) nil nil)) nil)) nil) ((connected? const-decl "bool" deriv_domain_def analysis)) nil (vsLevelOut_acc assuming "analysis@integral_split_fun[real].integral_split_fun" "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))) (vsLevelOut_acc_TCC3 0 (vsLevelOut_acc_TCC3-1 nil 3613810277 ("" (lemma "times_increase") (("" (skosimp*) (("" (inst?) (("" (replace -2 :dir rl) (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((not_one_element_real formula-decl nil deriv_domain analysis) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_increase formula-decl nil vsLevelOut nil)) nil (vsLevelOut_acc assuming "analysis@integral_split_fun[real].integral_split_fun" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (vel_prep_TCC1 0 (vel_prep_TCC1-1 nil 3613987276 ("" (assuming-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected? const-decl "bool" deriv_domain_def analysis)) nil (vel_prep assuming "analysis@integral_def[nnreal].integral_def" "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))) (vel_prep_TCC2 0 (vel_prep_TCC2-1 nil 3613987276 ("" (expand "not_one_element?") (("" (skosimp*) (("" (inst 1 "x!1+1") (("" (ground) nil nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (not_one_element? const-decl "bool" deriv_domain_def analysis)) nil (vel_prep assuming "analysis@integral_def[nnreal].integral_def" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (vel_prep 0 (vel_prep-2 "" 3804569555 ("" (skosimp*) (("" (expand "vsLevelOut_acc") (("" (lemma "split_fun3_Integrable[nnreal]") (("1" (lemma "times_increase") (("1" (inst -1 "s0z!1" " v0z!1" " climbRate!1" " targetAlt!1" "
                                  accelup!1" " acceldown!1" " alterCR?!1") (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (lemma "Integral_const_fun[nnreal]") (("1" (inst-cp -1 "nt`5" "0" "nt`1") (("1" (inst-cp -1 "0" "nt`1" "nt`2") (("1" (inst-cp -1 "nt`6" "nt`2" "nt`3") (("1" (inst -1 "0" "nt`3" "max(t!1, nt`3)") (("1" (inst -7 "restrict[real, nnreal, real]
                      (const_fun(vsLevelOutTimes(s0z!1,
                                                 v0z!1,
                                                 climbRate!1,
                                                 targetAlt!1,
                                                 accelup!1,
                                                 acceldown!1,
                                                 alterCR?!1)`5))" "
                  restrict[real, nnreal, real](const_fun(0))" "
                  restrict[real, nnreal, real]
                      (const_fun(vsLevelOutTimes(s0z!1,
                                                 v0z!1,
                                                 climbRate!1,
                                                 targetAlt!1,
                                                 accelup!1,
                                                 acceldown!1,
                                                 alterCR?!1)`6))" "
                  restrict[real, nnreal, real](const_fun(0))" " 0" "max(t!1, vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`3)" "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`1" "
                  vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`2" "
                  vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`3") (("1" (replace -6 :dir rl) (("1" (expand "restrict") (("1" (expand "const_fun") (("1" (expand "in_order?") (("1" (flatten) (("1" (case "nt`3 <= max(t!1, nt`3)") (("1" (prop) (("1" (lemma "Integrable?_inside[nnreal]") (("1" (inst -1 "0" "max(t!1, nt`3)" "split_fun3(nt`1, nt`2, nt`3, LAMBDA (s: nnreal): nt`5,
                             LAMBDA (s: nnreal): 0,
                             LAMBDA (s: nnreal): nt`6,
                             LAMBDA (s: nnreal): 0)" "0" "t!1") (("1" (prop) (("1" (ground) (("1" (case-replace "split_fun3(nt`1, nt`2, nt`3, LAMBDA (s: nnreal): nt`5,
                             LAMBDA (s: nnreal): 0,
                             LAMBDA (s: nnreal): nt`6,
                             LAMBDA (s: nnreal): 0) = LAMBDA (t: nnreal):
                    split_fun3(nt`1, nt`2, nt`3, LAMBDA (x: real): nt`5,
                               LAMBDA (x: real): 0, LAMBDA (x: real): nt`6,
                               LAMBDA (x: real): 0)
                              (t)") (("1" (hide-all-but 1) (("1" (decompose-equality 1) (("1" (grind) nil nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil)) nil) ("2" (ground) (("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil) ("6" (ground) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil) ("4" (flatten) (("4" (ground) nil nil)) nil) ("5" (flatten) (("5" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (vel_prep-1 nil 3613995124 ("" (skosimp*) (("" (expand "vsLevelOut_acc") (("" (lemma "split_fun3_Integrable[nnreal]") (("1" (lemma "times_increase") (("1" (inst -1 "s0z!1" " v0z!1" " climbRate!1" " targetAlt!1" "
                                  accelup!1" " acceldown!1" " alterCR?!1") (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (lemma "Integral_const_fun[nnreal]") (("1" (inst-cp -1 "nt`5" "0" "nt`1") (("1" (inst-cp -1 "0" "nt`1" "nt`2") (("1" (inst-cp -1 "nt`6" "nt`2" "nt`3") (("1" (inst -1 "0" "nt`3" "max(t!1, nt`3)") (("1" (inst -7 "restrict[real, nnreal, real]
                      (const_fun(vsLevelOutTimes(s0z!1,
                                                 v0z!1,
                                                 climbRate!1,
                                                 targetAlt!1,
                                                 accelup!1,
                                                 acceldown!1,
                                                 alterCR?!1)`5))" "
                  restrict[real, nnreal, real](const_fun(0))" "
                  restrict[real, nnreal, real]
                      (const_fun(vsLevelOutTimes(s0z!1,
                                                 v0z!1,
                                                 climbRate!1,
                                                 targetAlt!1,
                                                 accelup!1,
                                                 acceldown!1,
                                                 alterCR?!1)`6))" "
                  restrict[real, nnreal, real](const_fun(0))" " 0" "max(t!1, vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`3)" "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`1" "
                  vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`2" "
                  vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1,
                                  accelup!1, acceldown!1, alterCR?!1)`3") (("1" (replace -6 :dir rl) (("1" (expand "restrict") (("1" (expand "const_fun") (("1" (expand "in_order?") (("1" (flatten) (("1" (case "nt`3 <= max(t!1, nt`3)") (("1" (prop) (("1" (lemma "Integrable?_inside[nnreal]") (("1" (inst -1 "0" "max(t!1, nt`3)" "split_fun3(nt`1, nt`2, nt`3, LAMBDA (s: nnreal): nt`5,
                             LAMBDA (s: nnreal): 0,
                             LAMBDA (s: nnreal): nt`6,
                             LAMBDA (s: nnreal): 0)" "0" "t!1") (("1" (prop) (("1" (ground) (("1" (case-replace "split_fun3(nt`1, nt`2, nt`3, LAMBDA (s: nnreal): nt`5,
                             LAMBDA (s: nnreal): 0,
                             LAMBDA (s: nnreal): nt`6,
                             LAMBDA (s: nnreal): 0) = LAMBDA (t: nnreal):
                    split_fun3(nt`1, nt`2, nt`3, LAMBDA (x: real): nt`5,
                               LAMBDA (x: real): 0, LAMBDA (x: real): nt`6,
                               LAMBDA (x: real): 0)
                              (t)") (("1" (hide-all-but 1) (("1" (decompose-equality 1) (("1" (grind) nil nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil)) nil) ("2" (ground) (("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil) ("6" (ground) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil) ("4" (flatten) (("4" (ground) nil nil)) nil) ("5" (flatten) (("5" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (split_fun3_Integrable formula-decl nil integral_split_fun analysis) (deriv_domain? const-decl "bool" deriv_domain_def analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nt skolem-const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (s0z!1 skolem-const-decl "real" vsLevelOut nil) (v0z!1 skolem-const-decl "real" vsLevelOut nil) (climbRate!1 skolem-const-decl "posreal" vsLevelOut nil) (targetAlt!1 skolem-const-decl "nnreal" vsLevelOut nil) (accelup!1 skolem-const-decl "posreal" vsLevelOut nil) (acceldown!1 skolem-const-decl "negreal" vsLevelOut nil) (alterCR?!1 skolem-const-decl "bool" vsLevelOut nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (restrict const-decl "R" restrict nil) (in_order? const-decl "bool" integral_split_fun analysis) (Integrable?_inside formula-decl nil integral analysis) (not_one_element_real formula-decl nil deriv_domain analysis) (deriv_domain_real formula-decl nil deriv_domain analysis) (NOT const-decl "[bool -> bool]" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (deriv_domain_nnreal formula-decl nil deriv_domain analysis) (not_one_element_nnreal formula-decl nil deriv_domain analysis) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (real_times_real_is_real application-judgement "real" reals nil) (derivable_const application-judgement "deriv_fun" derivatives analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (t!1 skolem-const-decl "nnreal" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (Integral_const_fun formula-decl nil integral analysis) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (times_increase formula-decl nil vsLevelOut nil) (vsLevelOut_acc const-decl "real" vsLevelOut nil)) shostak)) (vsLevelOut_velInt_TCC1 0 (vsLevelOut_velInt_TCC1-1 nil 3613926760 ("" (lemma "vel_prep") (("" (propax) nil nil)) nil) ((vel_prep formula-decl nil vsLevelOut nil)) nil (vsLevelOut_velInt subtype "vsLevelOut.vsLevelOut_acc(vsLevelOut.s0z, vsLevelOut.v0z, vsLevelOut.climbRate, vsLevelOut.targetAlt, vsLevelOut.accelup, vsLevelOut.acceldown, vsLevelOut.alterCR?)" "integral_def[nnreal].Integrable_funs(0, vsLevelOut.t)"))) (vsLevelOut_velCalc_TCC1 0 (vsLevelOut_velCalc_TCC1-1 nil 3613926760 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                      acceldown!1, alterCR?!1)`5 = accelup!1") (("1" (ground) nil nil) ("2" (expand "vsLevelOutTimes") (("2" (expand "vsLevelOutTimes1") (("2" (ground) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (S1 const-decl "real" vsLevelOut nil) (S3 const-decl "real" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (vsLevelOut_velCalc subtype "vsLevelOut.vsLOT`5" "nzreal"))) (Integral_vsLO_vel 0 (Integral_vsLO_vel-2 "" 3804569706 ("" (skosimp*) (("" (expand "vsLevelOut_velInt") (("" (expand "vsLevelOut_acc") (("" (lemma "times_increase") (("" (inst -1 "s0z!1" "v0z!1" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("" (skoletin) (("" (replace -2 :dir rl) (("" (lemma "Integral_split_fun3[nnreal]") (("1" (lemma "Integral_const_fun[nnreal]") (("1" (inst-cp -1 "nt`5" "0" "nt`1") (("1" (inst-cp -1 "0" "nt`1" "nt`2") (("1" (inst-cp -1 "nt`6" "nt`2" "nt`3") (("1" (inst-cp -1 "0" "nt`3" "max(t!1, nt`3)") (("1" (hide -1) (("1" (flatten) (("1" (inst -9 "const_fun[nnreal](nt`5)" "const_fun[nnreal](0)" "const_fun[nnreal](nt`6)" "const_fun[nnreal](0)" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3" "t!1") (("1" (expand "in_order?") (("1" (prop) (("1" (case-replace "(LAMBDA (t: nnreal):
                 split_fun3(nt`1, nt`2, nt`3, const_fun(nt`5),
                            const_fun(0), const_fun(nt`6), const_fun(0))
                           (t)) = split_fun3(nt`1, nt`2, nt`3, const_fun[nnreal](nt`5),
                          const_fun[nnreal](0), const_fun[nnreal](nt`6),
                          const_fun[nnreal](0))") (("1" (replace -3) (("1" (replace -11) (("1" (replace -9) (("1" (replace -7) (("1" (hide -) (("1" (lemma "Integral_const_fun[nnreal]") (("1" (inst-cp -1 "nt`5" "0" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (inst-cp -1 "0" "nt`1" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (inst-cp -1 "nt`6" "nt`2" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (inst-cp -1 "0" "nt`3" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (hide -) (("1" (expand "vsLevelOut_velCalc") (("1" (reveal -23) (("1" (replace -1 :dir rl) (("1" (expand "split_fun3") (("1" (expand "V1") (("1" (expand "const_fun") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (reveal (-12 -13 -14)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal (-12 -13 -14)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal (-12 -13 -14)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (ground) (("1" (grind) nil nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (Integral_vsLO_vel-1 nil 3614002904 ("" (skosimp*) (("" (expand "vsLevelOut_velInt") (("" (expand "vsLevelOut_acc") (("" (lemma "times_increase") (("" (inst -1 "s0z!1" "v0z!1" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("" (skoletin) (("" (replace -2 :dir rl) (("" (lemma "Integral_split_fun3[nnreal]") (("1" (lemma "Integral_const_fun[nnreal]") (("1" (inst-cp -1 "nt`5" "0" "nt`1") (("1" (inst-cp -1 "0" "nt`1" "nt`2") (("1" (inst-cp -1 "nt`6" "nt`2" "nt`3") (("1" (inst-cp -1 "0" "nt`3" "max(t!1, nt`3)") (("1" (hide -1) (("1" (flatten) (("1" (inst -9 "const_fun[nnreal](nt`5)" "const_fun[nnreal](0)" "const_fun[nnreal](nt`6)" "const_fun[nnreal](0)" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3" "t!1") (("1" (expand "in_order?") (("1" (prop) (("1" (case-replace "(LAMBDA (t: nnreal):
                 split_fun3(nt`1, nt`2, nt`3, const_fun(nt`5),
                            const_fun(0), const_fun(nt`6), const_fun(0))
                           (t)) = split_fun3(nt`1, nt`2, nt`3, const_fun[nnreal](nt`5),
                          const_fun[nnreal](0), const_fun[nnreal](nt`6),
                          const_fun[nnreal](0))") (("1" (replace -3) (("1" (replace -11) (("1" (replace -9) (("1" (replace -7) (("1" (hide -) (("1" (lemma "Integral_const_fun[nnreal]") (("1" (inst-cp -1 "nt`5" "0" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (inst-cp -1 "0" "nt`1" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (inst-cp -1 "nt`6" "nt`2" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (inst-cp -1 "0" "nt`3" "t!1") (("1" (flatten) (("1" (replace -3) (("1" (hide -) (("1" (expand "vsLevelOut_velCalc") (("1" (reveal -23) (("1" (replace -1 :dir rl) (("1" (expand "split_fun3") (("1" (expand "V1") (("1" (expand "const_fun") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (reveal (-12 -13 -14)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal (-12 -13 -14)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal (-12 -13 -14)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (ground) (("1" (grind) nil nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vsLevelOut_acc const-decl "real" vsLevelOut nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (Integral_const_fun formula-decl nil integral analysis) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (t!1 skolem-const-decl "nnreal" vsLevelOut nil) (in_order? const-decl "bool" integral_split_fun analysis) (not_one_element_real formula-decl nil deriv_domain analysis) (deriv_domain_real formula-decl nil deriv_domain analysis) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (derivable_const application-judgement "deriv_fun" derivatives analysis) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (real_plus_real_is_real application-judgement "real" reals nil) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (deriv_domain_nnreal formula-decl nil deriv_domain analysis) (not_one_element_nnreal formula-decl nil deriv_domain analysis) (const_fun const-decl "[T -> real]" real_fun_ops reals) (nt skolem-const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (not_one_element? const-decl "bool" deriv_domain_def analysis) (connected? const-decl "bool" deriv_domain_def analysis) (deriv_domain? const-decl "bool" deriv_domain_def analysis) (Integral_split_fun3 formula-decl nil integral_split_fun analysis) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (times_increase formula-decl nil vsLevelOut nil) (vsLevelOut_velInt const-decl "real" vsLevelOut nil)) shostak)) (pos_prep 0 (pos_prep-3 "" 3804576690 ("" (skosimp*) (("" (expand "vsLevelOut_velCalc") (("" (name-replace "lot" "vsLevelOutTimes(s0z!1,
                                                     v0z!1,
                                                     climbRate!1,
                                                     targetAlt!1,
                                                     accelup!1,
                                                     acceldown!1,
                                                     alterCR?!1)") (("" (lemma "split_fun3_Integrable[nnreal]") (("1" (lemma "times_increase") (("1" (inst -1 "s0z!1" " v0z!1" " climbRate!1" " targetAlt!1" "                                  accelup!1" " acceldown!1" " alterCR?!1") (("1" (skoletin) (("1" (case-replace "lot=nt") (("1" (hide -1) (("1" (expand "V1") (("1" (flatten) (("1" (expand "const_fun") (("1" (lemma "integral_linear[nnreal]") (("1" (inst-cp -1 "0" "nt`1" "nt`5" "v0z!1") (("1" (inst-cp -1 "nt`1" "nt`2" "0" "nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`2" "nt`3" "nt`6" "-nt`2*nt`6+nt`5*nt`1+ v0z!1") (("1" (inst -1 "nt`3" "max(t!1, nt`3)" "0" "nt`3*nt`6 -nt`2*nt`6+nt`5*nt`1+ v0z!1") (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (inst -13 "f_3" "f_2" "f_1" "f" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3") (("1" (expand "in_order?") (("1" (prop) (("1" (lemma "Integrable?_inside[nnreal]") (("1" (inst -1 "0" "max(t!1, nt`3)" "split_fun3(nt`1, nt`2, nt`3, f_3, f_2, f_1, f)" "0" "t!1") (("1" (prop) (("1" (case-replace "split_fun3(nt`1, nt`2, nt`3, f_3, f_2, f_1, f) =LAMBDA (t: nnreal):
                    split_fun3(nt`1, nt`2, nt`3,
                               LAMBDA (t: real): nt`5 * t + v0z!1,
                               LAMBDA (x: real): nt`5 * nt`1 + v0z!1,
                               LAMBDA (s: real):
                                 s * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 +
                                  v0z!1,
                               LAMBDA (s: real):
                                 nt`3 * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 +
                                  v0z!1)
                              (t)") (("1" (hide-all-but 1) (("1" (decompose-equality 1) (("1" (grind) (("1" (expand "f_3") (("1" (propax) nil nil)) nil) ("2" (expand "f_2") (("2" (propax) nil nil)) nil) ("3" (expand "f_1") (("3" (ground) nil nil)) nil) ("4" (expand "f") (("4" (propax) nil nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil) ("3" (reveal (-12 -13 -14)) (("3" (ground) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (reveal (-12 -13 -14)) (("4" (ground) nil nil)) nil) ("5" (reveal (-12 -13 -14)) (("5" (ground) nil nil)) nil) ("6" (reveal (-12 -13 -14)) (("6" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (reveal (-12 -13 -14)) (("5" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil) ("6" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "lot") (("2" (expand "nt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (pos_prep-2 nil 3614002120 ("" (skosimp*) (("" (expand "vsLevelOut_velCalc") (("" (name-replace "lot" "vsLevelOutTimes(s0z!1,
                                                     v0z!1,
                                                     climbRate!1,
                                                     targetAlt!1,
                                                     accelup!1,
                                                     acceldown!1,
                                                     alterCR?!1)") (("" (lemma "split_fun3_Integrable[nnreal]") (("1" (lemma "times_increase") (("1" (inst -1 "s0z!1" " v0z!1" " climbRate!1" " targetAlt!1" "                                  accelup!1" " acceldown!1" " alterCR?!1") (("1" (skoletin) (("1" (case-replace "lot=nt") (("1" (hide -1) (("1" (expand "V1") (("1" (flatten) (("1" (expand "const_fun") (("1" (lemma "integral_linear[nnreal]") (("1" (inst-cp -1 "0" "nt`1" "nt`5" "v0z!1") (("1" (inst-cp -1 "nt`1" "nt`2" "0" "nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`2" "nt`3" "nt`6" "-nt`2*nt`6+nt`5*nt`1+ v0z!1") (("1" (inst -1 "nt`3" "max(t!1, nt`3)" "0" "nt`3*nt`6 -nt`2*nt`6+nt`5*nt`1+ v0z!1") (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (inst -13 "f_3" "f_2" "f_1" "f" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3") (("1" (expand "in_order?") (("1" (prop) (("1" (lemma "Integrable?_inside[nnreal]") (("1" (inst -1 "0" "max(t!1, nt`3)" "split_fun3(nt`1, nt`2, nt`3, f_3, f_2, f_1, f)" "0" "t!1") (("1" (prop) (("1" (case-replace "split_fun3(nt`1, nt`2, nt`3, f_3, f_2, f_1, f) =LAMBDA (t: nnreal):
                    split_fun3(nt`1, nt`2, nt`3,
                               LAMBDA (t: real): nt`5 * t + v0z!1,
                               LAMBDA (x: real): nt`5 * nt`1 + v0z!1,
                               LAMBDA (s: real):
                                 s * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 +
                                  v0z!1,
                               LAMBDA (s: real):
                                 nt`3 * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 +
                                  v0z!1)
                              (t)") (("1" (hide-all-but 1) (("1" (decompose-equality 1) (("1" (grind) (("1" (expand "f_3") (("1" (propax) nil nil)) nil) ("2" (expand "f_2") (("2" (propax) nil nil)) nil) ("3" (expand "f_1") (("3" (ground) nil nil)) nil) ("4" (expand "f") (("4" (propax) nil nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil) ("3" (reveal (-12 -13 -14)) (("3" (ground) nil nil)) nil) ("4" (reveal (-12 -13 -14)) (("4" (ground) nil nil)) nil) ("5" (reveal (-12 -13 -14)) (("5" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil) ("6" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "lot") (("2" (expand "nt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (times_increase formula-decl nil vsLevelOut nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (lot skolem-const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (integral_linear formula-decl nil table_of_integrals analysis) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (t!1 skolem-const-decl "nnreal" vsLevelOut nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (in_order? const-decl "bool" integral_split_fun analysis) (Integrable?_inside formula-decl nil integral analysis) (NOT const-decl "[bool -> bool]" booleans nil) (f_3 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (f_2 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (f_1 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (f skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (deriv_domain_real formula-decl nil deriv_domain analysis) (not_one_element_real formula-decl nil deriv_domain analysis) (deriv_domain_nnreal formula-decl nil deriv_domain analysis) (not_one_element_nnreal formula-decl nil deriv_domain analysis) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (hat_02n formula-decl nil power_series series) (Integral const-decl "real" integral_def analysis) (Integrable_funs type-eq-decl nil integral_def analysis) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Integrable? const-decl "bool" integral_def analysis) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nt skolem-const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (V1 const-decl "real" vsLevelOut nil) (not_one_element? const-decl "bool" deriv_domain_def analysis) (connected? const-decl "bool" deriv_domain_def analysis) (deriv_domain? const-decl "bool" deriv_domain_def analysis) (split_fun3_Integrable formula-decl nil integral_split_fun analysis) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (real_times_real_is_real application-judgement "real" reals nil)) nil) (pos_prep-1 nil 3614000623 ("" (skosimp*) (("" (expand "vsLevelOut_velCalc") (("" (name-replace "lot" "vsLevelOutTimes(s0z!1,
                                                   v0z!1,
                                                   climbRate!1,
                                                   targetAlt!1,
                                                   accelup!1,
                                                   acceldown!1,
                                                   alterCR?!1)") (("" (lemma "split_fun3_Integrable[nnreal]") (("1" (lemma "times_increase") (("1" (inst -1 "s0z!1" " v0z!1" " climbRate!1" " targetAlt!1" "                                  accelup!1" " acceldown!1" " alterCR?!1") (("1" (skoletin) (("1" (case-replace "lot=nt") (("1" (hide -1) (("1" (expand "V1") (("1" (flatten) (("1" (expand "const_fun") (("1" (lemma "integral_linear[real]") (("1" (inst-cp -1 "0" "nt`1" "nt`5" "v0z!1") (("1" (inst-cp -1 "nt`1" "nt`2" "0" "nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`2" "nt`3" "nt`6" "-nt`2*nt`6+nt`5*nt`1+ v0z!1") (("1" (inst -1 "nt`3" "max(t!1, nt`3)" "0" "nt`3*nt`6 -nt`2*nt`6+nt`5*nt`1+ v0z!1") (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (skoletin) (("1" (flatten) (("1" (hide -2) (("1" (inst -13 "f_3" "f_2" "f_1" "f" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3") (("1" (expand "in_order?") (("1" (expand "restrict") (("1" (prop) (("1" (postpone) nil nil) ("2" (ground) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "lot") (("2" (expand "nt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (vsLevelOut_posInt_TCC1 0 (vsLevelOut_posInt_TCC1-1 nil 3613926760 ("" (lemma "pos_prep") (("" (propax) nil nil)) nil) ((pos_prep formula-decl nil vsLevelOut nil)) nil (vsLevelOut_posInt subtype "vsLevelOut.vsLevelOut_velCalc(vsLevelOut.s0z, vsLevelOut.v0z, vsLevelOut.climbRate, vsLevelOut.targetAlt, vsLevelOut.accelup, vsLevelOut.acceldown, vsLevelOut.alterCR?)" "integral_def[nnreal].Integrable_funs(0, vsLevelOut.t)"))) (vsLevelOut_posCalc_TCC1 0 (vsLevelOut_posCalc_TCC1-4 nil 3614678785 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                           acceldown!1, alterCR?!1)`6 = accelup!1") (("1" (ground) nil nil) ("2" (expand "vsLevelOutTimes") (("2" (expand "vsLevelOutTimes1") (("2" (ground) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (S1 const-decl "real" vsLevelOut nil) (S3 const-decl "real" vsLevelOut nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (vsLevelOut_posCalc subtype "vsLevelOut.vsLOT`6" "nzreal")) (vsLevelOut_posCalc_TCC1-3 nil 3614000323 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                    acceldown!1, alterCR?!1)`5 = accelup!1") (("1" (ground) nil nil) ("2" (expand "vsLevelOutTimes") (("2" (expand "vsLevelOutTimes1") (("2" (ground) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs_nat formula-decl nil abs_lems reals)) nil (vsLevelOut_posCalc subtype "vsLevelOut.vsLOT`6" "nzreal")) (vsLevelOut_posCalc_TCC1-2 nil 3613990603 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                             acceldown!1, alterCR?!1)`6 = accelup!1") (("1" (ground) nil nil) ("2" (expand "vsLevelOutTimes") (("2" (expand "vsLevelOutTimes1") (("2" (ground) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs_nat formula-decl nil abs_lems reals)) nil (vsLevelOut_posCalc subtype "vsLevelOut.vsLOT`6" "nzreal")) (vsLevelOut_posCalc_TCC1-1 nil 3613926760 ("" (subtype-tcc) nil nil) nil nil (vsLevelOut_posCalc subtype "vsLevelOut.vsLOT`6" "nzreal"))) (Integral_vsLO_pos 0 (Integral_vsLO_pos-2 "" 3804576756 ("" (stop-rewrite "expt_x0") (("" (stop-rewrite "expt_x1") (("" (stop-rewrite "hat_02n") (("" (skosimp*) (("" (expand "vsLevelOut_posInt") (("" (expand "vsLevelOut_velCalc") (("" (lemma "times_increase") (("" (inst -1 "s0z!1" "v0z!1" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("" (skoletin) (("" (replace -2 :dir rl) (("" (lemma "Integral_split_fun3[nnreal]") (("1" (expand "V1") (("1" (expand "const_fun") (("1" (lemma "integral_linear[nnreal]") (("1" (inst-cp -1 "0" "nt`1" "nt`5" "v0z!1") (("1" (inst-cp -1 "nt`1" "nt`2" "0" "nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`2" "nt`3" "nt`6" "-nt`2*nt`6 +nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`3" "max(t!1, nt`3)" "0" "nt`3*nt`6-nt`2*nt`6 +nt`5*nt`1+ v0z!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (flatten) (("1" (inst -14 "f_3" "f_2" "f_1" "f" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3" "t!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (expand "in_order?") (("1" (prop) (("1" (case-replace "(LAMBDA (t: nnreal):
                                                 split_fun3(nt`1, nt`2, nt`3,
                                                            LAMBDA (t: real): nt`5 * t + v0z!1,
                                                            LAMBDA (x: real): nt`5 * nt`1 + v0z!1,
                                                            LAMBDA (s: real):
                                                              s * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 + v0z!1,
                                                            LAMBDA (s: real):
                                                              nt`3 * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 +
                                                               v0z!1)
                                                           (t))=split_fun3(nt`1, nt`2, nt`3, f_3, f_2, f_1, f)") (("1" (replace -3) (("1" (replace -6) (("1" (replace -8) (("1" (replace -10) (("1" (hide (-1 -2 -3 -4 -6 -8 -10 -12 -14 -16 -18)) (("1" (inst-cp -9 "0" "t!1" "nt`5" "v0z!1") (("1" (inst-cp -9 "nt`1" "t!1" "0" "nt`5 * nt`1 + v0z!1") (("1" (inst-cp -9 "nt`2" "t!1" "nt`6" "-nt`2 * nt`6 + nt`5 * nt`1 + v0z!1") (("1" (inst -9 "nt`3" "t!1" "0" "nt`3 * nt`6-nt`2 * nt`6 + nt`5 * nt`1 + v0z!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (flatten) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (case-replace "f_7=f_3") (("1" (case-replace "f_6=f_2") (("1" (case-replace "f_5=f_1") (("1" (case-replace "f_4=f") (("1" (replace -5) (("1" (replace -7) (("1" (replace -9) (("1" (replace -11) (("1" (expand "vsLevelOut_posCalc") (("1" (replace -32 :dir rl) (("1" (expand "split_fun3") (("1" (lift-if 1) (("1" (expand "F_4") (("1" (expand "S1") (("1" (expand "F") (("1" (expand "F_5") (("1" (expand "F_1") (("1" (expand "F_6") (("1" (expand "V1") (("1" (expand "F_2") (("1" (ground) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (simplify 2) (("2" (real-props 2) (("2" (hide -) (("2" (move-terms 2 R 1) (("2" (cross-mult 2) (("2" (real-props) (("2" (field 2) (("2" (expand "F_7") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "f_3") (("1" (expand "f_2") (("1" (expand "f_1") (("1" (expand "f") (("1" (hide-all-but 1) (("1" (expand "split_fun3") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil) ("6" (hide-all-but 1) (("6" (grind) nil nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (Integral_vsLO_pos-1 nil 3708685835 ("" (stop-rewrite "expt_x0") (("" (stop-rewrite "expt_x1") (("" (stop-rewrite "hat_02n") (("" (skosimp*) (("" (expand "vsLevelOut_posInt") (("" (expand "vsLevelOut_velCalc") (("" (lemma "times_increase") (("" (inst -1 "s0z!1" "v0z!1" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("" (skoletin) (("" (replace -2 :dir rl) (("" (lemma "Integral_split_fun3[nnreal]") (("1" (expand "V1") (("1" (expand "const_fun") (("1" (lemma "integral_linear[nnreal]") (("1" (inst-cp -1 "0" "nt`1" "nt`5" "v0z!1") (("1" (inst-cp -1 "nt`1" "nt`2" "0" "nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`2" "nt`3" "nt`6" "-nt`2*nt`6 +nt`5*nt`1+ v0z!1") (("1" (inst-cp -1 "nt`3" "max(t!1, nt`3)" "0" "nt`3*nt`6-nt`2*nt`6 +nt`5*nt`1+ v0z!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (flatten) (("1" (inst -14 "f_3" "f_2" "f_1" "f" "0" "max(t!1, nt`3)" "nt`1" "nt`2" "nt`3" "t!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (expand "in_order?") (("1" (prop) (("1" (case-replace "(LAMBDA (t: nnreal):
                                                 split_fun3(nt`1, nt`2, nt`3,
                                                            LAMBDA (t: real): nt`5 * t + v0z!1,
                                                            LAMBDA (x: real): nt`5 * nt`1 + v0z!1,
                                                            LAMBDA (s: real):
                                                              s * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 + v0z!1,
                                                            LAMBDA (s: real):
                                                              nt`3 * nt`6 - nt`2 * nt`6 + nt`5 * nt`1 +
                                                               v0z!1)
                                                           (t))=split_fun3(nt`1, nt`2, nt`3, f_3, f_2, f_1, f)") (("1" (replace -3) (("1" (replace -6) (("1" (replace -8) (("1" (replace -10) (("1" (hide (-1 -2 -3 -4 -6 -8 -10 -12 -14 -16 -18)) (("1" (inst-cp -9 "0" "t!1" "nt`5" "v0z!1") (("1" (inst-cp -9 "nt`1" "t!1" "0" "nt`5 * nt`1 + v0z!1") (("1" (inst-cp -9 "nt`2" "t!1" "nt`6" "-nt`2 * nt`6 + nt`5 * nt`1 + v0z!1") (("1" (inst -9 "nt`3" "t!1" "0" "nt`3 * nt`6-nt`2 * nt`6 + nt`5 * nt`1 + v0z!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (flatten) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (case-replace "f_7=f_3") (("1" (case-replace "f_6=f_2") (("1" (case-replace "f_5=f_1") (("1" (case-replace "f_4=f") (("1" (replace -5) (("1" (replace -7) (("1" (replace -9) (("1" (replace -11) (("1" (expand "vsLevelOut_posCalc") (("1" (replace -32 :dir rl) (("1" (expand "split_fun3") (("1" (lift-if 1) (("1" (expand "F_4") (("1" (expand "S1") (("1" (expand "F") (("1" (expand "F_5") (("1" (expand "F_1") (("1" (expand "F_6") (("1" (expand "V1") (("1" (expand "F_2") (("1" (ground) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (simplify 2) (("2" (real-props 2) (("2" (hide -) (("2" (move-terms 2 R 1) (("2" (cross-mult 2) (("2" (real-props) (("2" (field 2) (("2" (expand "F_7") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "f_3") (("1" (expand "f_2") (("1" (expand "f_1") (("1" (expand "f") (("1" (hide-all-but 1) (("1" (expand "split_fun3") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil) ("3" (flatten) (("3" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vsLevelOut_posInt const-decl "real" vsLevelOut nil) (times_increase formula-decl nil vsLevelOut nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Integral_split_fun3 formula-decl nil integral_split_fun analysis) (deriv_domain? const-decl "bool" deriv_domain_def analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis) (const_fun const-decl "[T -> real]" real_fun_ops reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nt skolem-const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (- const-decl "[numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Integrable? const-decl "bool" integral_def analysis) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Integrable_funs type-eq-decl nil integral_def analysis) (Integral const-decl "real" integral_def analysis) (minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (zero_hat formula-decl nil exponent_props reals) (in_order? const-decl "bool" integral_split_fun analysis) (not_one_element_real formula-decl nil deriv_domain analysis) (deriv_domain_real formula-decl nil deriv_domain analysis) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (S1 const-decl "real" vsLevelOut nil) (F_5 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (F_6 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (F_2 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (F_7 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (div_distributes formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (expt def-decl "real" exponentiation nil) (F_1 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (F skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (F_4 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (nat_exp application-judgement "nat" exponentiation nil) (vsLevelOut_posCalc const-decl "real" vsLevelOut nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (f_3 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (f_1 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (f skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (f_2 skolem-const-decl "[nnreal -> real]" vsLevelOut nil) (deriv_domain_nnreal formula-decl nil deriv_domain analysis) (not_one_element_nnreal formula-decl nil deriv_domain analysis) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (t!1 skolem-const-decl "nnreal" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (integral_linear formula-decl nil table_of_integrals analysis) (V1 const-decl "real" vsLevelOut nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (Velocity_after_level 0 (Velocity_after_level-2 "" 3790107232 ("" (case "FORALL (s, v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, acr:bool):
           LET mt = vsLevelOutTimes1(s,v,cr, ta, au, ad, acr) IN
           v+mt`5*mt`1+mt`6*(mt`3-mt`2) = 0") (("1" (lemma "times_increase") (("1" (skosimp*) (("1" (inst? -1) (("1" (skoletin) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (replace -3) (("1" (flatten) (("1" (expand "vsLevelOut_velCalc") (("1" (replace -4 :dir rl) (("1" (expand "split_fun3") (("1" (lift-if 1) (("1" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (expand "vsLevelOutTimes") (("4" (name-replace "Case1" "IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
           IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
           OR v0z!1 = 0") (("4" (name-replace "A2" "IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                         ELSE accelup!1
                         ENDIF") (("4" (name-replace "A1" "IF targetAlt!1 - s0z!1 >= 0
                                     THEN accelup!1
                                   ELSE acceldown!1
                                   ENDIF") (("4" (name-replace "Case1.2" "abs(targetAlt!1 - s0z!1) >= abs(S3(v0z!1, A2))") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (inst? -9) (("1" (skoletin) (("1" (replace -4 :dir rl) (("1" (replace -2) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -8 "s0z!1 + S3(v0z!1, A2)" " 0" " climbRate!1" "
                         targetAlt!1" " accelup!1" " acceldown!1" " alterCR?!1") (("2" (skoletin) (("2" (replace -2 :dir rl) (("2" (case "A2 = mt`5 AND A1 = mt`6") (("1" (flatten) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "targetAlt!1-s0z!1>=0 IMPLIES targetAlt!1- (s0z!1 + S3(v0z!1, A2))<0") (("1" (case "targetAlt!1-s0z!1>=0") (("1" (prop) (("1" (expand "A2") (("1" (lift-if 1) (("1" (prop) (("1" (hide (-1 -4 -6 -8 -9 -10 -11 3 4 5 6)) (("1" (expand "vsLevelOutTimes1") (("1" (ground) (("1" (replace -3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (lift-if 1) (("2" (ground) (("2" (hide (-1 -4 -6 -8 -9 -10 -11 12 3 4 5 6)) (("2" (replace -3) (("2" (hide -3) (("2" (expand "vsLevelOutTimes1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "targetAlt!1 - (s0z!1 + S3(v0z!1, A2)) >= 0") (("1" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (expand "A2") (("3" (lift-if 1) (("3" (prop) (("3" (replace -3) (("3" (hide-all-but (-1 -5 1 2 3 5)) (("3" (expand "vsLevelOutTimes1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -3 -5 1 2 4)) (("4" (replace -2) (("4" (hide -2) (("4" (expand "A1") (("4" (lift-if) (("4" (prop) (("4" (expand "vsLevelOutTimes1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A2") (("2" (hide-all-but (-1 -5 1 2)) (("2" (grind) (("2" (expand "Case1") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (ground) nil nil) ("2" (replace -1) (("2" (ground) (("2" (grind) (("2" (real-props) (("2" (reveal 2) (("2" (reveal -11) (("2" (replace -1 :dir rl) (("2" (expand "abs") (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "A2") (("2" (replace -2) (("2" (case "(accelup!1 / 2) * (-0 / accelup!1) ^ 2 + 0 * (-0 / accelup!1)=0") (("1" (replace -1) (("1" (lift-if 1) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (prop) (("1" (grind) (("1" (reveal 2) (("1" (reveal -11) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (expand "abs") (("1" (expand "A2") (("1" (expand "S3") (("1" (expand "S1") (("1" (case "(accelup!1 / 2) * (-v0z!1 / accelup!1) ^ 2 +
           v0z!1 * (-v0z!1 / accelup!1)
           < 0") (("1" (lift-if 1) (("1" (prop) (("1" (grind) nil nil)) nil)) nil) ("2" (case-replace "(accelup!1 / 2) * (-v0z!1 / accelup!1) ^ 2 +
           v0z!1 * (-v0z!1 / accelup!1)
           = -v0z!1^2/(2*accelup!1)") (("1" (cross-mult 1) (("1" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "S3") (("2" (expand "S1") (("2" (expand "A2") (("2" (flatten) (("2" (case-replace "IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
          ELSE accelup!1
          ENDIF = acceldown!1") (("1" (expand "Case1") (("1" (reveal -3) (("1" (case "S3(v0z!1, A2)>=0") (("1" (replace -2 :dir rl) (("1" (expand "abs") (("1" (lift-if 3) (("1" (lift-if 3) (("1" (hide (-2 -3 -5 -6 -7 -9 -10 -11 -12 -13 2 4 5 6 7)) (("1" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (lift-if 2) (("5" (prop) (("1" (ground) nil nil) ("2" (expand "S3") (("2" (expand "S1") (("2" (ground) (("2" (grind) (("2" (expand "A2") (("2" (add-formulas -2 -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lift-if 2) (("6" (prop) (("1" (ground) nil nil) ("2" (add-formulas -2 -3) (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (replace -1 :dir rl) (("2" (hide (-1 -2 -4 -5 -6 -7 -8 -9 -10 -11 -12 3 5 6 7 8)) (("2" (grind) (("2" (expand "A2") (("2" (grind) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -7 "s0z!1 + S3(v0z!1, A1)" " 0" " climbRate!1" "
                          targetAlt!1" " accelup!1" " acceldown!1" "
                          alterCR?!1") (("2" (skoletin) (("2" (replace -2 :dir rl) (("2" (hide-all-but (-1 -2 -3 3)) (("2" (replace -3) (("2" (simplify 1) (("2" (case-replace " A1 =mt`5") (("1" (ground) nil nil) ("2" (reveal 1) (("2" (expand "A1") (("2" (hide (-1 -3 3)) (("2" (expand "mt") (("2" (expand "vsLevelOutTimes1") (("2" (expand "Case1") (("2" (hide -) (("2" (grind) (("1" (expand "A1") (("1" (grind) (("1" (case-replace "(acceldown!1 / 2) * (-v0z!1 / acceldown!1 * (-v0z!1 / acceldown!1))
        + v0z!1 * (-v0z!1 / acceldown!1) = -v0z!1^2/(2*acceldown!1)") (("1" (case "-v0z!1^2/(2*acceldown!1)>=0") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (cross-mult) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (case-replace "(accelup!1 / 2) * (-v0z!1 / accelup!1 * (-v0z!1 / accelup!1)) +
        v0z!1 * (-v0z!1 / accelup!1) = -v0z!1^2/(2*accelup!1)") (("1" (case "0>= -v0z!1 ^ 2 / (2 * accelup!1)") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (cross-mult) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (skoletin) (("2" (expand "vsLevelOutTimes1") (("2" (name-replace "S" "ta!1-s!1") (("2" (name-replace "CR" "IF ta!1 >= s!1 THEN 1 ELSE -1 ENDIF *
                 (IF acr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF)
") (("2" (name-replace "A1" "IF CR >= v!1 THEN au!1 ELSE ad!1 ENDIF") (("2" (name-replace "A2" "IF ta!1 >= s!1 THEN ad!1 ELSE au!1 ENDIF") (("2" (name-replace "TQ" "minpos(quadRoots(A1 / 2 - A1 ^ 2 / (2 * A2),
                              v!1 - A1 / A2 * v!1,
                              -v!1 ^ 2 / (2 * A2) - ta!1 + s!1))") (("1" (name-replace "T1" "(CR - v!1) / A1") (("1" (name-replace "T2" "(S - S1(v!1, A1)(T1) - S3(V1(v!1, A1)(T1), A2)) / CR") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide -1) (("1" (expand "tee3") (("1" (replace -1) (("1" (grind) (("1" (expand "T1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (expand "V1") (("2" (expand "tee3") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil) ("3" (hide -1 2) (("3" (expand "A2") (("3" (grind) nil nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "A1") (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "A1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (grind) (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (grind) (("3" (expand "A2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (T1 skolem-const-decl "real" vsLevelOut nil) (CR skolem-const-decl "real" vsLevelOut nil) (A2 skolem-const-decl "real" vsLevelOut nil) (A1 skolem-const-decl "real" vsLevelOut nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (times_increase formula-decl nil vsLevelOut nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (mt skolem-const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (pos_times_lt formula-decl nil real_props nil) (pos_times_le formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (add_div formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (div_times formula-decl nil real_props nil) (neg_times_neg formula-decl nil real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (neg_div formula-decl nil extra_tegies nil) (neg_mult formula-decl nil extra_tegies nil) (neg_neg formula-decl nil extra_tegies nil) (mult_neg formula-decl nil extra_tegies nil) (neg_add formula-decl nil extra_tegies nil) (A1 skolem-const-decl "real" vsLevelOut nil) (minus_int_is_int application-judgement "int" integers nil) (A2 skolem-const-decl "real" vsLevelOut nil) (minpos const-decl "real" vsLevelOut nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (quadRoots const-decl "[real, real]" vsLevelOut nil) (tee3 const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (S1 const-decl "real" vsLevelOut nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (negreal_times_negreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nat_exp application-judgement "nat" exponentiation nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (hat_02n formula-decl nil power_series series) (div_mult_pos_lt1 formula-decl nil real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (zero_ge_zero formula-decl nil real_props nil) (zero_is_neg_zero formula-decl nil real_props nil) (zero_times2 formula-decl nil real_props nil) (Case1 skolem-const-decl "boolean" vsLevelOut nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_exp application-judgement "posreal" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (S3 const-decl "real" vsLevelOut nil) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil)) shostak) (Velocity_after_level-1 nil 3614069080 ("" (case "FORALL (s, v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, acr:bool):
           LET mt = vsLevelOutTimes1(s,v,cr, ta, au, ad, acr) IN
           v+mt`5*mt`1+mt`6*(mt`3-mt`2) = 0") (("1" (lemma "times_increase") (("1" (skosimp*) (("1" (inst? -1) (("1" (skoletin) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (replace -3) (("1" (flatten) (("1" (expand "vsLevelOut_velCalc") (("1" (replace -4 :dir rl) (("1" (expand "split_fun3") (("1" (lift-if 1) (("1" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (expand "vsLevelOutTimes") (("4" (name-replace "Case1" "IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
           IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
           OR v0z!1 = 0") (("4" (name-replace "A2" "IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                         ELSE accelup!1
                         ENDIF") (("4" (name-replace "A1" "IF targetAlt!1 - s0z!1 >= 0
                                     THEN accelup!1
                                   ELSE acceldown!1
                                   ENDIF") (("4" (name-replace "Case1.2" "abs(targetAlt!1 - s0z!1) >= abs(S3(v0z!1, A2))") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (inst? -9) (("1" (skoletin) (("1" (replace -4 :dir rl) (("1" (replace -2) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -8 "s0z!1 + S3(v0z!1, A2)" " 0" " climbRate!1" "
                         targetAlt!1" " accelup!1" " acceldown!1" " alterCR?!1") (("2" (skoletin) (("2" (replace -2 :dir rl) (("2" (case "A2 = mt`5 AND A1 = mt`6") (("1" (flatten) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "targetAlt!1-s0z!1>=0 IMPLIES targetAlt!1- (s0z!1 + S3(v0z!1, A2))<0") (("1" (case "targetAlt!1-s0z!1>=0") (("1" (prop) (("1" (expand "A2") (("1" (lift-if 1) (("1" (prop) (("1" (hide (-1 -4 -6 -8 -9 -10 -11 3 4 5 6)) (("1" (expand "vsLevelOutTimes1") (("1" (ground) (("1" (replace -3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (lift-if 1) (("2" (ground) (("2" (hide (-1 -4 -6 -8 -9 -10 -11 12 3 4 5 6)) (("2" (replace -3) (("2" (hide -3) (("2" (expand "vsLevelOutTimes1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "targetAlt!1 - (s0z!1 + S3(v0z!1, A2)) >= 0") (("1" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (expand "A2") (("3" (lift-if 1) (("3" (prop) (("3" (replace -3) (("3" (hide-all-but (-1 -5 1 2 3 5)) (("3" (expand "vsLevelOutTimes1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -3 -5 1 2 4)) (("4" (replace -2) (("4" (hide -2) (("4" (expand "A1") (("4" (lift-if) (("4" (prop) (("4" (expand "vsLevelOutTimes1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "A2") (("2" (hide-all-but (-1 -5 1 2)) (("2" (grind) (("2" (expand "Case1") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (ground) nil nil) ("2" (replace -1) (("2" (ground) (("2" (grind) (("2" (real-props) (("2" (reveal 2) (("2" (reveal -11) (("2" (replace -1 :dir rl) (("2" (expand "abs") (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "A2") (("2" (replace -2) (("2" (case "(accelup!1 / 2) * (-0 / accelup!1) ^ 2 + 0 * (-0 / accelup!1)=0") (("1" (replace -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (prop) (("1" (grind) (("1" (reveal 2) (("1" (reveal -11) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (expand "abs") (("1" (expand "A2") (("1" (expand "S3") (("1" (expand "S1") (("1" (case "(accelup!1 / 2) * (-v0z!1 / accelup!1) ^ 2 +
           v0z!1 * (-v0z!1 / accelup!1)
           < 0") (("1" (lift-if 1) (("1" (prop) (("1" (grind) nil nil)) nil)) nil) ("2" (case-replace "(accelup!1 / 2) * (-v0z!1 / accelup!1) ^ 2 +
           v0z!1 * (-v0z!1 / accelup!1)
           = -v0z!1^2/(2*accelup!1)") (("1" (cross-mult 1) (("1" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "S3") (("2" (expand "S1") (("2" (expand "A2") (("2" (flatten) (("2" (case-replace "IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
          ELSE accelup!1
          ENDIF = acceldown!1") (("1" (expand "Case1") (("1" (reveal -3) (("1" (case "S3(v0z!1, A2)>=0") (("1" (replace -2 :dir rl) (("1" (expand "abs") (("1" (lift-if 3) (("1" (lift-if 3) (("1" (hide (-2 -3 -5 -6 -7 -9 -10 -11 -12 -13 2 4 5 6 7)) (("1" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (ground) nil nil) ("5" (lift-if 2) (("5" (prop) (("1" (ground) nil nil) ("2" (expand "S3") (("2" (expand "S1") (("2" (ground) (("2" (grind) (("2" (expand "A2") (("2" (add-formulas -2 -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lift-if 2) (("6" (prop) (("1" (ground) nil nil) ("2" (add-formulas -2 -3) (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (replace -1 :dir rl) (("2" (hide (-1 -2 -4 -5 -6 -7 -8 -9 -10 -11 -12 3 5 6 7 8)) (("2" (grind) (("2" (expand "A2") (("2" (grind) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -7 "s0z!1 + S3(v0z!1, A1)" " 0" " climbRate!1" "
                          targetAlt!1" " accelup!1" " acceldown!1" "
                          alterCR?!1") (("2" (skoletin) (("2" (replace -2 :dir rl) (("2" (hide-all-but (-1 -2 -3 3)) (("2" (replace -3) (("2" (simplify 1) (("2" (case-replace " A1 =mt`5") (("1" (ground) nil nil) ("2" (reveal 1) (("2" (expand "A1") (("2" (hide (-1 -3 3)) (("2" (expand "mt") (("2" (expand "vsLevelOutTimes1") (("2" (expand "Case1") (("2" (hide -) (("2" (grind) (("1" (expand "A1") (("1" (grind) (("1" (case-replace "(acceldown!1 / 2) * (-v0z!1 / acceldown!1 * (-v0z!1 / acceldown!1))
        + v0z!1 * (-v0z!1 / acceldown!1) = -v0z!1^2/(2*acceldown!1)") (("1" (case "-v0z!1^2/(2*acceldown!1)>=0") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (cross-mult) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "A1") (("2" (case-replace "(accelup!1 / 2) * (-v0z!1 / accelup!1 * (-v0z!1 / accelup!1)) +
        v0z!1 * (-v0z!1 / accelup!1) = -v0z!1^2/(2*accelup!1)") (("1" (case "0>= -v0z!1 ^ 2 / (2 * accelup!1)") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (cross-mult) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (skoletin) (("2" (expand "vsLevelOutTimes1") (("2" (name-replace "S" "ta!1-s!1") (("2" (name-replace "CR" "IF ta!1 >= s!1 THEN 1 ELSE -1 ENDIF *
                 (IF acr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF)
") (("2" (name-replace "A1" "IF CR >= v!1 THEN au!1 ELSE ad!1 ENDIF") (("2" (name-replace "A2" "IF ta!1 >= s!1 THEN ad!1 ELSE au!1 ENDIF") (("2" (name-replace "TQ" "minpos(quadRoots(A1 / 2 - A1 ^ 2 / (2 * A2),
                              v!1 - A1 / A2 * v!1,
                              -v!1 ^ 2 / (2 * A2) - ta!1 + s!1))") (("1" (name-replace "T1" "(CR - v!1) / A1") (("1" (name-replace "T2" "(S - S1(v!1, A1)(T1) - S3(V1(v!1, A1)(T1), A2)) / CR") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide -1) (("1" (expand "tee3") (("1" (replace -1) (("1" (grind) (("1" (expand "T1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (expand "V1") (("2" (expand "tee3") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "CR") (("2" (grind) nil nil)) nil)) nil) ("3" (hide -1 2) (("3" (expand "A2") (("3" (grind) nil nil)) nil)) nil) ("4" (hide -1 2) (("4" (expand "A1") (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "A1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (grind) (("2" (expand "A2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (grind) (("3" (expand "A2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) nil nil nil nil (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (times_increase formula-decl nil vsLevelOut nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) nil (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (div_mult_pos_ge2 formula-decl nil real_props nil) nil (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (pos_times_lt formula-decl nil real_props nil) (pos_times_le formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (add_div formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (div_times formula-decl nil real_props nil) (neg_times_neg formula-decl nil real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (neg_div formula-decl nil extra_tegies nil) (neg_mult formula-decl nil extra_tegies nil) (neg_neg formula-decl nil extra_tegies nil) (mult_neg formula-decl nil extra_tegies nil) (neg_add formula-decl nil extra_tegies nil) nil (minus_int_is_int application-judgement "int" integers nil) nil (minpos const-decl "real" vsLevelOut nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (quadRoots const-decl "[real, real]" vsLevelOut nil) (tee3 const-decl "real" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (S1 const-decl "real" vsLevelOut nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (negreal_times_negreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nat_exp application-judgement "nat" exponentiation nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (hat_02n formula-decl nil power_series series) (div_mult_pos_lt1 formula-decl nil real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (zero_ge_zero formula-decl nil real_props nil) (zero_is_neg_zero formula-decl nil real_props nil) (zero_times2 formula-decl nil real_props nil) nil (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_exp application-judgement "posreal" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (S3 const-decl "real" vsLevelOut nil) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil)) shostak)) (Position_after_level 0 (Position_after_level-4 "" 3804577569 ("" (skosimp*) (("" (skoletin) (("" (flatten) (("" (case "FORALL (s,v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, acr:bool):
                             LET sgnv = IF v>=0 THEN 1 ELSE -1 ENDIF,
                             altDir = IF ta>=s THEN 1 ELSE -1 ENDIF,
                             a2 = IF ta>=s THEN ad ELSE au ENDIF,
                             lot = vsLevelOutTimes1(s, v, cr, ta, au, ad, acr)
                             IN
                              (sgnv = altDir OR v=0) AND abs(ta-s)>= abs( S3(v, a2)) IMPLIES
                             s+S1(v, lot`5)(lot`1) + V1(v, lot`5)(lot`1)*(lot`2-lot`1) +S1(V1(v, lot`5)(lot`1), lot`6)(lot`3-lot`2) = ta") (("1" (case-replace "vsLevelOut_posCalc(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                          acceldown!1, alterCR?!1)
                                         (t!1) =
                 s0z!1+S1(v0z!1, vsLOT`5)(vsLOT`1) + V1(v0z!1, vsLOT`5)(vsLOT`1)*(vsLOT`2-vsLOT`1) +S1(V1(v0z!1, vsLOT`5)(vsLOT`1), vsLOT`6)(vsLOT`3-vsLOT`2)") (("1" (hide -1) (("1" (case "((IF v0z!1>=0 THEN 1 ELSE -1 ENDIF) = IF targetAlt!1>=s0z!1 THEN 1 ELSE -1 ENDIF) OR v0z!1=0") (("1" (case "abs(targetAlt!1 - s0z!1) >= abs(S3(v0z!1, IF targetAlt!1>=s0z!1 THEN acceldown!1 ELSE accelup!1 ENDIF))") (("1" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                                    acceldown!1, alterCR?!1) = vsLevelOutTimes1(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                                    acceldown!1, alterCR?!1)") (("1" (replace -1) (("1" (hide -1) (("1" (inst? -3) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (skoletin) (("1" (skoletin) (("1" (replace -3 :dir rl) (("1" (replace -2) (("1" (replace -9 :dir rl) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 -4 -5 2)) (("2" (expand "vsLevelOutTimes") (("2" (case-replace "(IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                                              IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                                              OR v0z!1 = 0) = TRUE") (("1" (case-replace "( abs(targetAlt!1 - s0z!1) >=
                                                    abs(S3(v0z!1,
                                                           IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                                                           ELSE accelup!1
                                                           ENDIF)))=TRUE") (("1" (hide-all-but (-2 1)) (("1" (case-replace "(targetAlt!1 >= s0z!1) =  (targetAlt!1 - s0z!1>=0)") (("1" (iff 1) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (iff) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "a2" "IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF") (("2" (name "nt" "vsLevelOutTimes1(s0z!1+S3(v0z!1, a2),0, climbRate!1, targetAlt!1, accelup!1,
                                                                    acceldown!1, alterCR?!1)") (("1" (case-replace "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                           acceldown!1, alterCR?!1) =  ( -v0z!1/a2+nt`1, -v0z!1/a2+nt`2, -v0z!1/a2+nt`3, nt`4, nt`5, nt`6)") (("1" (replace -7) (("1" (simplify 2) (("1" (expand "S1" 2) (("1" (simplify 2) (("1" (expand "V1" 2) (("1" (simplify 2) (("1" (case-replace "a2=nt`5") (("1" (simplify 2) (("1" (expand "^" 2) (("1" (expand "expt" 2) (("1" (expand "expt" 2) (("1" (expand "expt" 2) (("1" (simplify 2) (("1" (inst -6 "s0z!1+S3(v0z!1, a2)" "0" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (expand "S3" -1) (("1" (expand "S1" -1) (("1" (expand "^" -1) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (case-replace "(a2_1 / 2) * (-0 / a2_1 * (-0 / a2_1))=0") (("1" (case-replace "(abs(-1 * (-v0z!1 / a2 * v0z!1) -
                                                                       -v0z!1 / a2 * (-v0z!1 / a2) * (a2 / 2)
                                                                       - s0z!1
                                                                       + targetAlt!1)
                                                                   >= abs(0))=TRUE") (("1" (replace -8 :dir rl) (("1" (replace -4) (("1" (replace -10) (("1" (replace -3 :dir rl) (("1" (expand "V1" 2) (("1" (replace -8 :dir rl) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "a2_1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 -6 -7 3)) (("2" (case-replace "IF targetAlt!1 >= s0z!1 THEN acceldown!1
                                                              ELSE accelup!1
                                                              ENDIF=a2") (("1" (case-replace "S3(v0z!1, a2) = -v0z!1^2/(2*a2)") (("1" (bddsimp -5) (("1" (expand "vsLevelOutTimes1") (("1" (replace -4 :dir rl) (("1" (simplify 1) (("1" (name "ald2" "IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a2) + s0z!1 THEN 1
                                                                                                ELSE -1
                                                                                                ENDIF") (("1" (replace -1) (("1" (hide -5) (("1" (case-replace "(IF alterCR?!1 THEN max(climbRate!1, abs(0))
                                                                                         ELSE climbRate!1
                                                                                         ENDIF) = climbRate!1") (("1" (case-replace "IF abs(-1 * (-v0z!1 ^ 2 / (2 * a2)) - s0z!1 + targetAlt!1) >=
                                                                                   abs(S1(0,
                                                                                          IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                          ELSE acceldown!1
                                                                                          ENDIF)
                                                                                         (ald2 * climbRate!1 /
                                                                                           IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                           ELSE acceldown!1
                                                                                           ENDIF)
                                                                                        +
                                                                                        S3(V1(0,
                                                                                              IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                              ELSE acceldown!1
                                                                                              ENDIF)
                                                                                             (ald2 * climbRate!1 /
                                                                                               IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                               ELSE acceldown!1
                                                                                               ENDIF),
                                                                                           IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a2) + s0z!1
                                                                                             THEN acceldown!1
                                                                                           ELSE accelup!1
                                                                                           ENDIF))
                                                                                 THEN IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                      ELSE acceldown!1
                                                                                      ENDIF
                                                                               ELSE IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                    ELSE acceldown!1
                                                                                    ENDIF
                                                                               ENDIF = IF ald2*climbRate!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("1" (hide -1) (("1" (hide -1) (("1" (case "targetAlt!1 - s0z!1 >= 0") (("1" (case-replace "a2=acceldown!1") (("1" (grind) (("1" (move-terms -3 R 2) (("1" (cross-mult -8) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (case-replace "a2 = accelup!1") (("1" (grind) (("1" (cross-mult 5) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a2") (("2" (lift-if 1) (("2" (lift-if 1) (("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 2)) (("2" (expand "vsLevelOutTimes") (("2" (reveal -1) (("2" (reveal -1) (("2" (reveal -2) (("2" (replace -2) (("2" (case "(IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                                                                   IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                                                                   OR v0z!1 = 0) = TRUE") (("1" (replace -1) (("1" (case-replace "( abs(targetAlt!1 - s0z!1) >=
                                                          abs(S3(v0z!1,
                                                                 IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                                                                 ELSE accelup!1
                                                                 ENDIF))) = FALSE") (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (hide (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "a1" "IF targetAlt!1-s0z!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("2" (name "nt" "vsLevelOutTimes1(s0z!1+S3(v0z!1, a1), 0, climbRate!1, targetAlt!1, accelup!1, acceldown!1, alterCR?!1)") (("1" (case-replace "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                     acceldown!1, alterCR?!1) = (-v0z!1/a1+nt`1, -v0z!1/a1+nt`2, -v0z!1/a1+nt`3, nt`4, nt`5, nt`6)") (("1" (inst -4 "s0z!1 + S3(v0z!1, a1)" "0" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (case-replace "(abs(targetAlt!1 - (s0z!1 + S3(v0z!1, a1))) >= abs(S3(0, a2)))=TRUE") (("1" (replace -3) (("1" (replace -8) (("1" (case-replace "a1=nt`5") (("1" (replace -12) (("1" (simplify 3) (("1" (replace -3 :dir rl) (("1" (hide-all-but (-1 3)) (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -7 -10 -11 4)) (("2" (replace -6 :dir rl) (("2" (hide -6) (("2" (hide -2) (("2" (expand "vsLevelOutTimes1") (("2" (case-replace "(IF alterCR?!1 THEN max(climbRate!1, abs(0))
                                                                 ELSE climbRate!1
                                                                 ENDIF)=climbRate!1") (("1" (case-replace "S3(v0z!1, a1) = -v0z!1^2/(2*a1)") (("1" (case-replace "IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a1) + s0z!1
                                                                                    THEN 1
                                                                                  ELSE -1
                                                                                  ENDIF = altDir") (("1" (case-replace "(targetAlt!1 >= -v0z!1 ^ 2 / (2 * a1) + s0z!1) = (targetAlt!1 >= s0z!1) ") (("1" (name "AY1" "IF altDir * climbRate!1 >= 0 THEN accelup!1
                                                                                                         ELSE acceldown!1
                                                                                                         ENDIF") (("1" (replace -1) (("1" (replace -7) (("1" (replace -7 :dir rl) (("1" (case-replace "IF abs(-1 * (-v0z!1 ^ 2 / (2 * a1)) - s0z!1 + targetAlt!1) >=
                                                                                   abs(S1(0, AY1)(altDir * climbRate!1 / AY1) +
                                                                                        S3(V1(0, AY1)(altDir * climbRate!1 / AY1), a2))
                                                                                 THEN AY1
                                                                               ELSE AY1
                                                                               ENDIF = AY1") (("1" (replace -10 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lift-if) (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "AY1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "targetAlt!1>=s0z!1") (("1" (case-replace "a1 = accelup!1") (("1" (case "0>=-v0z!1^2/(2*accelup!1)") (("1" (add-formulas -1 -3) nil nil) ("2" (cross-mult 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a1") (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "a1=acceldown!1") (("1" (flip-ineq 1) (("1" (case "0<= -v0z!1^2/(2*acceldown!1)") (("1" (add-formulas -1 -2) nil nil) ("2" (cross-mult 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a1") (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "altDir") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a1") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "^") (("2" (expand "abs") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 4 -4)) (("2" (hide -3) (("2" (expand "vsLevelOutTimes") (("2" (case-replace "( IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                                              IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                                              OR v0z!1 = 0)=FALSE") (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Velocity_after_level") (("2" (hide (-2 2)) (("2" (inst? -1) (("2" (inst -1 "t!1") (("2" (skoletin) (("2" (replace -2) (("2" (replace -4 :dir rl) (("2" (prop) (("2" (expand "vsLevelOut_velCalc") (("2" (replace -4 :dir rl) (("2" (lemma "times_increase") (("2" (inst?) (("2" (skoletin) (("2" (replace -2) (("2" (replace -6 :dir rl) (("2" (flatten) (("2" (expand "split_fun3") (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (expand "vsLevelOut_posCalc") (("4" (replace -8 :dir rl) (("4" (expand "split_fun3") (("4" (lift-if 4) (("4" (prop) (("4" (hide-all-but (-1 2)) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -3) (("3" (hide-all-but 1) (("3" (expand "vsLevelOutTimes") (("3" (expand "vsLevelOutTimes1") (("3" (ground) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -3) (("4" (hide-all-but 1) (("4" (expand "vsLevelOutTimes") (("4" (expand "vsLevelOutTimes1") (("4" (ground) (("4" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (flatten) (("2" (expand "vsLevelOutTimes1") (("2" (replace -5 :dir rl) (("2" (replace -4 :dir rl) (("2" (name "cr" "altDir * (IF acr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF)") (("2" (replace -1) (("2" (name "a1" "IF cr >= v!1 THEN au!1 ELSE ad!1 ENDIF") (("2" (replace -1) (("2" (name "root" "minpos(quadRoots(a1 / 2 - a1 ^ 2 / (2 * a2),
                                                         v!1 - a1 / a2 * v!1,
                                                         -v!1 ^ 2 / (2 * a2) - ta!1 + s!1))") (("1" (replace -1) (("1" (lift-if -6) (("1" (split -6) (("1" (flatten) (("1" (replace -2) (("1" (simplify 1) (("1" (hide-all-but 1) (("1" (expand "tee3") (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "a1=a2") (("1" (case-replace "S1(v!1, a2)((cr - v!1) / a2) +
                                          S3(V1(v!1, a2)((cr - v!1) / a2), a2) = S3(v!1, a2)") (("1" (hide-all-but 1) (("1" (expand "V1") (("1" (expand "S3") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "a1 / 2 - a1 ^ 2 / (2 * a2)/=0") (("1" (name "A" "a1 / 2 - a1 ^ 2 / (2 * a2)") (("1" (name "B" "v!1 - a1 / a2 * v!1") (("1" (name "C" "-v!1 ^ 2 / (2 * a2) - ta!1 + s!1") (("1" (case "A*C<=0") (("1" (case "discr(A,B,C)>=0") (("1" (name "sgna" "IF A>=0 THEN 1 ELSE -1 ENDIF") (("1" (case-replace "root = root(A, B, C, sgna)") (("1" (replace -9) (("1" (simplify 3) (("1" (hide-all-but (-3 1 3 -8)) (("1" (expand "tee3") (("1" (expand "V1") (("1" (expand "S1") (("1" (lemma "quad_eq_0") (("1" (inst -1 "A" "B" "C" "root(A,B,C,sgna)") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (expand "quadratic") (("1" (expand "C") (("1" (expand "A") (("1" (expand "B") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (inst 1 "sgna") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "root = root(A, B, C, -sgna)") (("1" (replace -9) (("1" (simplify 4) (("1" (hide-all-but (-3 2 4 -8)) (("1" (expand "tee3") (("1" (expand "V1") (("1" (expand "S1") (("1" (lemma "quad_eq_0") (("1" (inst -1 "A" "B" "C" "root") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (expand "quadratic") (("1" (expand "C") (("1" (expand "A") (("1" (expand "B") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (inst 1 "-sgna") (("1" (reveal -3) (("1" (propax) nil nil)) nil) ("2" (expand "sgna") (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "root_ge_0") (("2" (inst -1 "A" "B" "C" "sgna") (("2" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide (4 5 6 -8 -10 -11 -12 -13 -14 -15 -16)) (("1" (expand "minpos") (("1" (case "quadRoots(A,B,C) = (root(A,B,C,1), root(A,B,C,-1))") (("1" (replace -1) (("1" (simplify -9) (("1" (lift-if -9) (("1" (split -9) (("1" (flatten) (("1" (lift-if -5) (("1" (split -5) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (expand "max") (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (split-ineq -5) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (lift-if -5) (("1" (split -5) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (lift-if -1) (("2" (split -1) (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if -4) (("2" (split -4) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (copy -4) (("2" (expand "quadRoots") (("2" (expand "root") (("2" (expand "discr") (("2" (case-replace "B^2 = sq(B)") (("1" (case-replace "(A /= 0 AND sq(B) - 4 * (A * C) >= 0)=TRUE") (("1" (hide-all-but (-2 1 5)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sgna = sign(A)") (("1" (merge-fnums (-4 -1)) (("1" (ground) nil nil)) nil) ("2" (expand "sign") (("2" (expand "sgna") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "sgna") (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil) ("4" (propax) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "discr") (("2" (lemma "sq_pos") (("2" (inst -1 "B") (("2" (case "-4*(A*C)>=0") (("1" (add-formulas -1 -2) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "A") (("3" (propax) nil nil)) nil)) nil) ("2" (case-replace "S3(v!1, a2) = -v!1^2/(2*a2)") (("1" (case "ta!1>=s!1") (("1" (case "a1>=0 AND a2<=0 AND ta!1-s!1>=0 AND -v!1^2/(2*a2)>=0") (("1" (case "(1-a1/a2)>=0") (("1" (case "A>=0") (("1" (case "-C>=0") (("1" (hide-all-but (-1 -2 1)) (("1" (mult-ineq -1 -2) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-3 -15 1)) (("2" (flatten) (("2" (expand "abs") (("2" (lift-if -5) (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (lift-if -1) (("3" (prop) (("1" (ground) nil nil) ("2" (expand "C") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (flatten) (("2" (div-by -2 "2") (("2" (simplify -2) (("2" (mult-ineq -1 -2) (("2" (expand "A") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -10 -14 1 3)) (("2" (grind) (("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "a1") (("1" (hide (4 5 -8 -7)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (4 5 -8 -7)) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "a2") (("4" (hide (4 5 -8 -7)) (("4" (cross-mult 1) (("4" (lemma "sq_pos") (("4" (inst -1 "v!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "a1<=0 AND a2>=0 AND ta!1-s!1<0 and -v!1^2/(2*a2)<=0") (("1" (case "(1-a1/a2)>=0") (("1" (hide (-8 -9 4 5)) (("1" (case "C>=0") (("1" (case "-A>=0") (("1" (mult-ineq -1 -2) (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (div-by -3 "2") (("2" (simplify -3) (("2" (case "-a1/2>=0") (("1" (mult-ineq -1 -3) (("1" (expand "A") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "C") (("2" (hide-all-but (-4 -5 -10 -13 -14 1 2 5)) (("2" (expand "abs") (("2" (lift-if -4) (("2" (lift-if -4) (("2" (lift-if -4) (("2" (prop) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (split-ineq -4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -9 -13 1 2 4)) (("2" (grind) (("2" (expand "a1") (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 3 5 6)) (("2" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (cross-mult 1) (("4" (expand "a2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) (("2" (case "a1/2/=0") (("1" (case "(1-a1/a2)/=0") (("1" (case "(1-a1/a2)*a1/2/=0") (("1" (grind) nil nil) ("2" (prop) (("2" (cancel-by -1 "a1/2") nil nil)) nil)) nil) ("2" (prop) (("2" (grind) nil nil)) nil) ("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil) ("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide -9 1) (("3" (hide -6) (("3" (expand "vsLevelOutTimes1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (replace -4) (("4" (hide-all-but -7) (("4" (expand "vsLevelOutTimes1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (replace -3) (("5" (hide-all-but -6) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (Position_after_level-3 nil 3614691314 ("" (skosimp*) (("" (skoletin) (("" (flatten) (("" (case "FORALL (s,v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, acr:bool):
                             LET sgnv = IF v>=0 THEN 1 ELSE -1 ENDIF,
                             altDir = IF ta>=s THEN 1 ELSE -1 ENDIF,
                             a2 = IF ta>=s THEN ad ELSE au ENDIF,
                             lot = vsLevelOutTimes1(s, v, cr, ta, au, ad, acr)
                             IN
                              (sgnv = altDir OR v=0) AND abs(ta-s)>= abs( S3(v, a2)) IMPLIES
                             s+S1(v, lot`5)(lot`1) + V1(v, lot`5)(lot`1)*(lot`2-lot`1) +S1(V1(v, lot`5)(lot`1), lot`6)(lot`3-lot`2) = ta") (("1" (case-replace "vsLevelOut_posCalc(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                          acceldown!1, alterCR?!1)
                                         (t!1) =
                 s0z!1+S1(v0z!1, vsLOT`5)(vsLOT`1) + V1(v0z!1, vsLOT`5)(vsLOT`1)*(vsLOT`2-vsLOT`1) +S1(V1(v0z!1, vsLOT`5)(vsLOT`1), vsLOT`6)(vsLOT`3-vsLOT`2)") (("1" (hide -1) (("1" (case "((IF v0z!1>=0 THEN 1 ELSE -1 ENDIF) = IF targetAlt!1>=s0z!1 THEN 1 ELSE -1 ENDIF) OR v0z!1=0") (("1" (case "abs(targetAlt!1 - s0z!1) >= abs(S3(v0z!1, IF targetAlt!1>=s0z!1 THEN acceldown!1 ELSE accelup!1 ENDIF))") (("1" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                                    acceldown!1, alterCR?!1) = vsLevelOutTimes1(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                                    acceldown!1, alterCR?!1)") (("1" (replace -1) (("1" (hide -1) (("1" (inst? -3) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (skoletin) (("1" (skoletin) (("1" (replace -3 :dir rl) (("1" (replace -2) (("1" (replace -9 :dir rl) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 -4 -5 2)) (("2" (expand "vsLevelOutTimes") (("2" (case-replace "(IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                                              IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                                              OR v0z!1 = 0) = TRUE") (("1" (case-replace "( abs(targetAlt!1 - s0z!1) >=
                                                    abs(S3(v0z!1,
                                                           IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                                                           ELSE accelup!1
                                                           ENDIF)))=TRUE") (("1" (hide-all-but (-2 1)) (("1" (case-replace "(targetAlt!1 >= s0z!1) =  (targetAlt!1 - s0z!1>=0)") (("1" (iff 1) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (iff) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "a2" "IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF") (("2" (name "nt" "vsLevelOutTimes1(s0z!1+S3(v0z!1, a2),0, climbRate!1, targetAlt!1, accelup!1,
                                                                    acceldown!1, alterCR?!1)") (("1" (case-replace "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                           acceldown!1, alterCR?!1) =  ( -v0z!1/a2+nt`1, -v0z!1/a2+nt`2, -v0z!1/a2+nt`3, nt`4, nt`5, nt`6)") (("1" (replace -7) (("1" (simplify 2) (("1" (expand "S1" 2) (("1" (simplify 2) (("1" (expand "V1" 2) (("1" (simplify 2) (("1" (case-replace "a2=nt`5") (("1" (simplify 2) (("1" (expand "^" 2) (("1" (expand "expt" 2) (("1" (expand "expt" 2) (("1" (expand "expt" 2) (("1" (simplify 2) (("1" (inst -6 "s0z!1+S3(v0z!1, a2)" "0" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (expand "S3" -1) (("1" (expand "S1" -1) (("1" (expand "^" -1) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (case-replace "(a2_1 / 2) * (-0 / a2_1 * (-0 / a2_1))=0") (("1" (case-replace "(abs(-1 * (-v0z!1 / a2 * v0z!1) -
                                                                       -v0z!1 / a2 * (-v0z!1 / a2) * (a2 / 2)
                                                                       - s0z!1
                                                                       + targetAlt!1)
                                                                   >= abs(0))=TRUE") (("1" (replace -8 :dir rl) (("1" (replace -4) (("1" (replace -10) (("1" (replace -3 :dir rl) (("1" (expand "V1" 2) (("1" (replace -8 :dir rl) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "a2_1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 -6 -7 3)) (("2" (case-replace "IF targetAlt!1 >= s0z!1 THEN acceldown!1
                                                              ELSE accelup!1
                                                              ENDIF=a2") (("1" (case-replace "S3(v0z!1, a2) = -v0z!1^2/(2*a2)") (("1" (bddsimp -5) (("1" (expand "vsLevelOutTimes1") (("1" (replace -4 :dir rl) (("1" (simplify 1) (("1" (name "ald2" "IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a2) + s0z!1 THEN 1
                                                                                                ELSE -1
                                                                                                ENDIF") (("1" (replace -1) (("1" (hide -5) (("1" (case-replace "(IF alterCR?!1 THEN max(climbRate!1, abs(0))
                                                                                         ELSE climbRate!1
                                                                                         ENDIF) = climbRate!1") (("1" (case-replace "IF abs(-1 * (-v0z!1 ^ 2 / (2 * a2)) - s0z!1 + targetAlt!1) >=
                                                                                   abs(S1(0,
                                                                                          IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                          ELSE acceldown!1
                                                                                          ENDIF)
                                                                                         (ald2 * climbRate!1 /
                                                                                           IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                           ELSE acceldown!1
                                                                                           ENDIF)
                                                                                        +
                                                                                        S3(V1(0,
                                                                                              IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                              ELSE acceldown!1
                                                                                              ENDIF)
                                                                                             (ald2 * climbRate!1 /
                                                                                               IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                               ELSE acceldown!1
                                                                                               ENDIF),
                                                                                           IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a2) + s0z!1
                                                                                             THEN acceldown!1
                                                                                           ELSE accelup!1
                                                                                           ENDIF))
                                                                                 THEN IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                      ELSE acceldown!1
                                                                                      ENDIF
                                                                               ELSE IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                                                                    ELSE acceldown!1
                                                                                    ENDIF
                                                                               ENDIF = IF ald2*climbRate!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("1" (hide -1) (("1" (hide -1) (("1" (case "targetAlt!1 - s0z!1 >= 0") (("1" (case-replace "a2=acceldown!1") (("1" (grind) (("1" (move-terms -3 R 2) (("1" (cross-mult -8) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (case-replace "a2 = accelup!1") (("1" (grind) (("1" (cross-mult 5) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a2") (("2" (lift-if 1) (("2" (lift-if 1) (("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 2)) (("2" (expand "vsLevelOutTimes") (("2" (reveal -1) (("2" (reveal -1) (("2" (reveal -2) (("2" (replace -2) (("2" (case "(IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                                                                   IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                                                                   OR v0z!1 = 0) = TRUE") (("1" (replace -1) (("1" (case-replace "( abs(targetAlt!1 - s0z!1) >=
                                                          abs(S3(v0z!1,
                                                                 IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                                                                 ELSE accelup!1
                                                                 ENDIF))) = FALSE") (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (hide (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "a1" "IF targetAlt!1-s0z!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("2" (name "nt" "vsLevelOutTimes1(s0z!1+S3(v0z!1, a1), 0, climbRate!1, targetAlt!1, accelup!1, acceldown!1, alterCR?!1)") (("1" (case-replace "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                                     acceldown!1, alterCR?!1) = (-v0z!1/a1+nt`1, -v0z!1/a1+nt`2, -v0z!1/a1+nt`3, nt`4, nt`5, nt`6)") (("1" (inst -4 "s0z!1 + S3(v0z!1, a1)" "0" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (case-replace "(abs(targetAlt!1 - (s0z!1 + S3(v0z!1, a1))) >= abs(S3(0, a2)))=TRUE") (("1" (replace -3) (("1" (replace -8) (("1" (case-replace "a1=nt`5") (("1" (replace -12) (("1" (simplify 3) (("1" (replace -3 :dir rl) (("1" (hide-all-but (-1 3)) (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -7 -10 -11 4)) (("2" (replace -6 :dir rl) (("2" (hide -6) (("2" (hide -2) (("2" (expand "vsLevelOutTimes1") (("2" (case-replace "(IF alterCR?!1 THEN max(climbRate!1, abs(0))
                                                                 ELSE climbRate!1
                                                                 ENDIF)=climbRate!1") (("1" (case-replace "S3(v0z!1, a1) = -v0z!1^2/(2*a1)") (("1" (case-replace "IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a1) + s0z!1
                                                                                    THEN 1
                                                                                  ELSE -1
                                                                                  ENDIF = altDir") (("1" (case-replace "(targetAlt!1 >= -v0z!1 ^ 2 / (2 * a1) + s0z!1) = (targetAlt!1 >= s0z!1) ") (("1" (name "AY1" "IF altDir * climbRate!1 >= 0 THEN accelup!1
                                                                                                         ELSE acceldown!1
                                                                                                         ENDIF") (("1" (replace -1) (("1" (replace -7) (("1" (replace -7 :dir rl) (("1" (case-replace "IF abs(-1 * (-v0z!1 ^ 2 / (2 * a1)) - s0z!1 + targetAlt!1) >=
                                                                                   abs(S1(0, AY1)(altDir * climbRate!1 / AY1) +
                                                                                        S3(V1(0, AY1)(altDir * climbRate!1 / AY1), a2))
                                                                                 THEN AY1
                                                                               ELSE AY1
                                                                               ENDIF = AY1") (("1" (replace -10 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lift-if) (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "AY1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "targetAlt!1>=s0z!1") (("1" (case-replace "a1 = accelup!1") (("1" (case "0>=-v0z!1^2/(2*accelup!1)") (("1" (add-formulas -1 -3) nil nil) ("2" (cross-mult 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a1") (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "a1=acceldown!1") (("1" (flip-ineq 1) (("1" (case "0<= -v0z!1^2/(2*acceldown!1)") (("1" (add-formulas -1 -2) nil nil) ("2" (cross-mult 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a1") (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "altDir") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a1") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "^") (("2" (expand "abs") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 4 -4)) (("2" (hide -3) (("2" (expand "vsLevelOutTimes") (("2" (case-replace "( IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                                              IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                                              OR v0z!1 = 0)=FALSE") (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Velocity_after_level") (("2" (hide (-2 2)) (("2" (inst? -1) (("2" (inst -1 "t!1") (("2" (skoletin) (("2" (replace -2) (("2" (replace -4 :dir rl) (("2" (prop) (("2" (expand "vsLevelOut_velCalc") (("2" (replace -4 :dir rl) (("2" (lemma "times_increase") (("2" (inst?) (("2" (skoletin) (("2" (replace -2) (("2" (replace -6 :dir rl) (("2" (flatten) (("2" (expand "split_fun3") (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (expand "vsLevelOut_posCalc") (("4" (replace -8 :dir rl) (("4" (expand "split_fun3") (("4" (lift-if 4) (("4" (prop) (("4" (hide-all-but (-1 2)) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -3) (("3" (hide-all-but 1) (("3" (expand "vsLevelOutTimes") (("3" (expand "vsLevelOutTimes1") (("3" (ground) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -3) (("4" (hide-all-but 1) (("4" (expand "vsLevelOutTimes") (("4" (expand "vsLevelOutTimes1") (("4" (ground) (("4" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (flatten) (("2" (expand "vsLevelOutTimes1") (("2" (replace -5 :dir rl) (("2" (replace -4 :dir rl) (("2" (name "cr" "altDir * (IF acr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF)") (("2" (replace -1) (("2" (name "a1" "IF cr >= v!1 THEN au!1 ELSE ad!1 ENDIF") (("2" (replace -1) (("2" (name "root" "minpos(quadRoots(a1 / 2 - a1 ^ 2 / (2 * a2),
                                                         v!1 - a1 / a2 * v!1,
                                                         -v!1 ^ 2 / (2 * a2) - ta!1 + s!1))") (("1" (replace -1) (("1" (lift-if -6) (("1" (split -6) (("1" (flatten) (("1" (replace -2) (("1" (simplify 1) (("1" (hide-all-but 1) (("1" (expand "tee3") (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "a1=a2") (("1" (case-replace "S1(v!1, a2)((cr - v!1) / a2) +
                                          S3(V1(v!1, a2)((cr - v!1) / a2), a2) = S3(v!1, a2)") (("1" (hide-all-but 1) (("1" (expand "V1") (("1" (expand "S3") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "a1 / 2 - a1 ^ 2 / (2 * a2)/=0") (("1" (name "A" "a1 / 2 - a1 ^ 2 / (2 * a2)") (("1" (name "B" "v!1 - a1 / a2 * v!1") (("1" (name "C" "-v!1 ^ 2 / (2 * a2) - ta!1 + s!1") (("1" (case "A*C<=0") (("1" (case "discr(A,B,C)>=0") (("1" (name "sgna" "IF A>=0 THEN 1 ELSE -1 ENDIF") (("1" (case-replace "root = root(A, B, C, sgna)") (("1" (replace -9) (("1" (simplify 3) (("1" (hide-all-but (-3 1 3 -8)) (("1" (expand "tee3") (("1" (expand "V1") (("1" (expand "S1") (("1" (lemma "quad_eq_0") (("1" (inst -1 "A" "B" "C" "root(A,B,C,sgna)") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (expand "quadratic") (("1" (expand "C") (("1" (expand "A") (("1" (expand "B") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (inst 1 "sgna") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "root = root(A, B, C, -sgna)") (("1" (replace -9) (("1" (simplify 4) (("1" (hide-all-but (-3 2 4 -8)) (("1" (expand "tee3") (("1" (expand "V1") (("1" (expand "S1") (("1" (lemma "quad_eq_0") (("1" (inst -1 "A" "B" "C" "root") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (expand "quadratic") (("1" (expand "C") (("1" (expand "A") (("1" (expand "B") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (inst 1 "-sgna") (("1" (reveal -3) (("1" (propax) nil nil)) nil) ("2" (expand "sgna") (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "root_ge_0") (("2" (inst -1 "A" "B" "C" "sgna") (("2" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (replace -5) (("1" (replace -6) (("1" (replace -7) (("1" (hide (4 5 6 -8 -10 -11 -12 -13 -14 -15 -16)) (("1" (expand "minpos") (("1" (case "quadRoots(A,B,C) = (root(A,B,C,1), root(A,B,C,-1))") (("1" (replace -1) (("1" (simplify -9) (("1" (lift-if -9) (("1" (split -9) (("1" (flatten) (("1" (lift-if -5) (("1" (split -5) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (expand "max") (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (split-ineq -5) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (lift-if -5) (("1" (split -5) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (lift-if -1) (("2" (split -1) (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if -4) (("2" (split -4) (("1" (flatten) (("1" (replace -2 :dir rl) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (copy -4) (("2" (expand "quadRoots") (("2" (expand "root") (("2" (expand "discr") (("2" (case-replace "B^2 = sq(B)") (("1" (case-replace "(A /= 0 AND sq(B) - 4 * (A * C) >= 0)=TRUE") (("1" (hide-all-but (-2 1 5)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sgna = sign(A)") (("1" (merge-fnums (-4 -1)) (("1" (ground) nil nil)) nil) ("2" (expand "sign") (("2" (expand "sgna") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "sgna") (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil) ("4" (propax) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "discr") (("2" (lemma "sq_pos") (("2" (inst -1 "B") (("2" (case "-4*(A*C)>=0") (("1" (add-formulas -1 -2) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "A") (("3" (propax) nil nil)) nil)) nil) ("2" (case-replace "S3(v!1, a2) = -v!1^2/(2*a2)") (("1" (case "ta!1>=s!1") (("1" (case "a1>=0 AND a2<=0 AND ta!1-s!1>=0 AND -v!1^2/(2*a2)>=0") (("1" (case "(1-a1/a2)>=0") (("1" (case "A>=0") (("1" (case "-C>=0") (("1" (hide-all-but (-1 -2 1)) (("1" (mult-ineq -1 -2) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-3 -15 1)) (("2" (flatten) (("2" (expand "abs") (("2" (lift-if -5) (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (lift-if -1) (("3" (prop) (("1" (ground) nil nil) ("2" (expand "C") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (flatten) (("2" (div-by -2 "2") (("2" (simplify -2) (("2" (mult-ineq -1 -2) (("2" (expand "A") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -10 -14 1 3)) (("2" (grind) (("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "a1") (("1" (hide (4 5 -8 -7)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (4 5 -8 -7)) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "a2") (("4" (hide (4 5 -8 -7)) (("4" (cross-mult 1) (("4" (lemma "sq_pos") (("4" (inst -1 "v!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "a1<=0 AND a2>=0 AND ta!1-s!1<0 and -v!1^2/(2*a2)<=0") (("1" (case "(1-a1/a2)>=0") (("1" (hide (-8 -9 4 5)) (("1" (case "C>=0") (("1" (case "-A>=0") (("1" (mult-ineq -1 -2) (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (div-by -3 "2") (("2" (simplify -3) (("2" (case "-a1/2>=0") (("1" (mult-ineq -1 -3) (("1" (expand "A") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "C") (("2" (hide-all-but (-4 -5 -10 -13 -14 1 2 5)) (("2" (expand "abs") (("2" (lift-if -4) (("2" (lift-if -4) (("2" (lift-if -4) (("2" (prop) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (split-ineq -4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -9 -13 1 2 4)) (("2" (grind) (("2" (expand "a1") (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 -7 3 5 6)) (("2" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (cross-mult 1) (("4" (expand "a2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) (("2" (case "a1/2/=0") (("1" (case "(1-a1/a2)/=0") (("1" (case "(1-a1/a2)*a1/2/=0") (("1" (grind) nil nil) ("2" (prop) (("2" (cancel-by -1 "a1/2") nil nil)) nil)) nil) ("2" (prop) (("2" (grind) nil nil)) nil) ("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil) ("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide -9 1) (("3" (replace -6) (("3" (hide -6) (("3" (expand "vsLevelOutTimes1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (replace -6) (("4" (hide-all-but -7) (("4" (expand "vsLevelOutTimes1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (replace -3) (("5" (hide-all-but -6) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (minpos const-decl "real" vsLevelOut nil) (quadRoots const-decl "[real, real]" vsLevelOut nil) (sq_pos formula-decl nil sq reals) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (neg_mult formula-decl nil extra_tegies nil) (add_neg formula-decl nil extra_tegies nil) (sgna skolem-const-decl "int" vsLevelOut nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (root skolem-const-decl "real" vsLevelOut nil) (sign const-decl "Sign" sign reals) (root_ge_0 formula-decl nil quadratic reals) (quad_eq_0 formula-decl nil quadratic reals) (sq const-decl "nonneg_real" sq reals) (quadratic const-decl "real" quadratic reals) (C skolem-const-decl "real" vsLevelOut nil) (B skolem-const-decl "real" vsLevelOut nil) (A skolem-const-decl "real" vsLevelOut nil) (nzint nonempty-type-eq-decl nil integers nil) (Sign type-eq-decl nil sign reals) (root const-decl "real" quadratic reals) (discr const-decl "real" quadratic reals) (nonzero_real nonempty-type-eq-decl nil reals nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_even_is_even application-judgement "even_int" integers nil) (negreal_times_negreal_is_posreal application-judgement "posreal" real_types nil) (negreal_div_negreal_is_posreal application-judgement "posreal" real_types nil) (a2 skolem-const-decl "real" vsLevelOut nil) (ta!1 skolem-const-decl "nnreal" vsLevelOut nil) (s!1 skolem-const-decl "real" vsLevelOut nil) (ad!1 skolem-const-decl "negreal" vsLevelOut nil) (au!1 skolem-const-decl "posreal" vsLevelOut nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (both_sides_div_pos_ge1 formula-decl nil real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (a1 skolem-const-decl "real" vsLevelOut nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (div_mult_pos_neg_le1 formula-decl nil extra_real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (zero_div formula-decl nil extra_tegies nil) (div_172 skolem-const-decl "real" vsLevelOut nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (tee3 const-decl "real" vsLevelOut nil) (real_times_real_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (nat_exp application-judgement "nat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_neg_lt1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (expt def-decl "real" exponentiation nil) (a2 skolem-const-decl "real" vsLevelOut nil) (a2_1 skolem-const-decl "real" vsLevelOut nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (^ const-decl "real" exponentiation nil) (FALSE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (altDir skolem-const-decl "int" vsLevelOut nil) (AY1 skolem-const-decl "real" vsLevelOut nil) (a1 skolem-const-decl "real" vsLevelOut nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (neg_div formula-decl nil extra_tegies nil) (neg_add formula-decl nil extra_tegies nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (div_mult_neg_le2 formula-decl nil real_props nil) (a2 skolem-const-decl "real" vsLevelOut nil) (derivable_const application-judgement "deriv_fun" pi_def trig) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (times_increase formula-decl nil vsLevelOut nil) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (Velocity_after_level formula-decl nil vsLevelOut nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (S3 const-decl "real" vsLevelOut nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (S1 const-decl "real" vsLevelOut nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (V1 const-decl "real" vsLevelOut nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (vsLevelOut_posCalc const-decl "real" vsLevelOut nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) nil) (Position_after_level-2 nil 3614517072 ("" (skosimp*) (("" (skoletin) (("" (flatten) (("" (case "FORALL (s,v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, acr:bool):
               LET sgnv = IF v>=0 THEN 1 ELSE -1 ENDIF,
               altDir = IF ta>=s THEN 1 ELSE -1 ENDIF,
               a2 = IF ta>=s THEN ad ELSE au ENDIF,
               lot = vsLevelOutTimes1(s, v, cr, ta, au, ad, acr)
               IN
                (sgnv = altDir OR v=0) AND abs(ta-s)>= abs( S3(v, a2)) IMPLIES
               s+S1(v, lot`5)(lot`1) + V1(v, lot`5)(lot`1)*(lot`2-lot`1) +S1(V1(v, lot`5)(lot`1), lot`6)(lot`3-lot`2) = ta") (("1" (case-replace "vsLevelOut_posCalc(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                  acceldown!1, alterCR?!1)
                                 (t!1) =
         s0z!1+S1(v0z!1, vsLOT`5)(vsLOT`1) + V1(v0z!1, vsLOT`5)(vsLOT`1)*(vsLOT`2-vsLOT`1) +S1(V1(v0z!1, vsLOT`5)(vsLOT`1), vsLOT`6)(vsLOT`3-vsLOT`2)") (("1" (hide -1) (("1" (case "((IF v0z!1>=0 THEN 1 ELSE -1 ENDIF) = IF targetAlt!1>=s0z!1 THEN 1 ELSE -1 ENDIF) OR v0z!1=0") (("1" (case "abs(targetAlt!1 - s0z!1) >= abs(S3(v0z!1, IF targetAlt!1>=s0z!1 THEN acceldown!1 ELSE accelup!1 ENDIF))") (("1" (case "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                      acceldown!1, alterCR?!1) = vsLevelOutTimes1(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                      acceldown!1, alterCR?!1)") (("1" (replace -1) (("1" (hide -1) (("1" (inst? -3) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (skoletin) (("1" (replace -2 :dir rl) (("1" (skoletin) (("1" (skoletin) (("1" (replace -3 :dir rl) (("1" (replace -2) (("1" (replace -9 :dir rl) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 -4 -5 2)) (("2" (expand "vsLevelOutTimes") (("2" (case-replace "(IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                      IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                      OR v0z!1 = 0) = TRUE") (("1" (case-replace "( abs(targetAlt!1 - s0z!1) >=
                        abs(S3(v0z!1,
                               IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                               ELSE accelup!1
                               ENDIF)))=TRUE") (("1" (hide-all-but (-2 1)) (("1" (case-replace "(targetAlt!1 >= s0z!1) =  (targetAlt!1 - s0z!1>=0)") (("1" (iff 1) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (iff) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "a2" "IF targetAlt!1-s0z!1>=0 THEN acceldown!1 ELSE accelup!1 ENDIF") (("2" (name "nt" "vsLevelOutTimes1(s0z!1+S3(v0z!1, a2),0, climbRate!1, targetAlt!1, accelup!1,
                                      acceldown!1, alterCR?!1)") (("1" (case-replace "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                   acceldown!1, alterCR?!1) =  ( -v0z!1/a2+nt`1, -v0z!1/a2+nt`2, -v0z!1/a2+nt`3, nt`4, nt`5, nt`6)") (("1" (replace -7) (("1" (simplify 2) (("1" (expand "S1" 2) (("1" (simplify 2) (("1" (expand "V1" 2) (("1" (simplify 2) (("1" (case-replace "a2=nt`5") (("1" (simplify 2) (("1" (expand "^" 2) (("1" (expand "expt" 2) (("1" (expand "expt" 2) (("1" (expand "expt" 2) (("1" (simplify 2) (("1" (inst -6 "s0z!1+S3(v0z!1, a2)" "0" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (expand "S3" -1) (("1" (expand "S1" -1) (("1" (expand "^" -1) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (expand "expt" -1) (("1" (case-replace "(a2_1 / 2) * (-0 / a2_1 * (-0 / a2_1))=0") (("1" (case-replace "(abs(-1 * (-v0z!1 / a2 * v0z!1) -
                               -v0z!1 / a2 * (-v0z!1 / a2) * (a2 / 2)
                               - s0z!1
                               + targetAlt!1)
                           >= abs(0))=TRUE") (("1" (replace -8 :dir rl) (("1" (replace -4) (("1" (replace -10) (("1" (replace -3 :dir rl) (("1" (expand "V1" 2) (("1" (replace -8 :dir rl) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "a2_1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 -6 -7 3)) (("2" (case-replace "IF targetAlt!1 >= s0z!1 THEN acceldown!1
                              ELSE accelup!1
                              ENDIF=a2") (("1" (case-replace "S3(v0z!1, a2) = -v0z!1^2/(2*a2)") (("1" (bddsimp -5) (("1" (expand "vsLevelOutTimes1") (("1" (replace -4 :dir rl) (("1" (simplify 1) (("1" (name "ald2" "IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a2) + s0z!1 THEN 1
                                          ELSE -1
                                          ENDIF") (("1" (replace -1) (("1" (hide -5) (("1" (case-replace "(IF alterCR?!1 THEN max(climbRate!1, abs(0))
                                             ELSE climbRate!1
                                             ENDIF) = climbRate!1") (("1" (case-replace "IF abs(-1 * (-v0z!1 ^ 2 / (2 * a2)) - s0z!1 + targetAlt!1) >=
                                   abs(S1(0,
                                          IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                          ELSE acceldown!1
                                          ENDIF)
                                         (ald2 * climbRate!1 /
                                           IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                           ELSE acceldown!1
                                           ENDIF)
                                        +
                                        S3(V1(0,
                                              IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                              ELSE acceldown!1
                                              ENDIF)
                                             (ald2 * climbRate!1 /
                                               IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                               ELSE acceldown!1
                                               ENDIF),
                                           IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a2) + s0z!1
                                             THEN acceldown!1
                                           ELSE accelup!1
                                           ENDIF))
                                 THEN IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                      ELSE acceldown!1
                                      ENDIF
                               ELSE IF ald2 * climbRate!1 >= 0 THEN accelup!1
                                    ELSE acceldown!1
                                    ENDIF
                               ENDIF = IF ald2*climbRate!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("1" (hide -1) (("1" (hide -1) (("1" (case "targetAlt!1 - s0z!1 >= 0") (("1" (case-replace "a2=acceldown!1") (("1" (grind) (("1" (move-terms -3 R 2) (("1" (cross-mult -8) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (case-replace "a2 = accelup!1") (("1" (grind) (("1" (cross-mult 5) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a2") (("2" (lift-if 1) (("2" (lift-if 1) (("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 2)) (("2" (expand "vsLevelOutTimes") (("2" (reveal -1) (("2" (reveal -1) (("2" (reveal -2) (("2" (replace -2) (("2" (case "(IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                             IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                             OR v0z!1 = 0) = TRUE") (("1" (replace -1) (("1" (case-replace "( abs(targetAlt!1 - s0z!1) >=
                          abs(S3(v0z!1,
                                 IF targetAlt!1 - s0z!1 >= 0 THEN acceldown!1
                                 ELSE accelup!1
                                 ENDIF))) = FALSE") (("1" (replace -3) (("1" (replace -4) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (hide (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "a1" "IF targetAlt!1-s0z!1>=0 THEN accelup!1 ELSE acceldown!1 ENDIF") (("2" (name "nt" "vsLevelOutTimes1(s0z!1+S3(v0z!1, a1), 0, climbRate!1, targetAlt!1, accelup!1, acceldown!1, alterCR?!1)") (("1" (case-replace "vsLevelOutTimes(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                                 acceldown!1, alterCR?!1) = (-v0z!1/a1+nt`1, -v0z!1/a1+nt`2, -v0z!1/a1+nt`3, nt`4, nt`5, nt`6)") (("1" (inst -4 "s0z!1 + S3(v0z!1, a1)" "0" "climbRate!1" "targetAlt!1" "accelup!1" "acceldown!1" "alterCR?!1") (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (skoletin) (("1" (case-replace "(abs(targetAlt!1 - (s0z!1 + S3(v0z!1, a1))) >= abs(S3(0, a2)))=TRUE") (("1" (replace -3) (("1" (replace -8) (("1" (case-replace "a1=nt`5") (("1" (replace -12) (("1" (simplify 3) (("1" (replace -3 :dir rl) (("1" (hide-all-but (-1 3)) (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -7 -10 -11 4)) (("2" (replace -6 :dir rl) (("2" (hide -6) (("2" (hide -2) (("2" (expand "vsLevelOutTimes1") (("2" (case-replace "(IF alterCR?!1 THEN max(climbRate!1, abs(0))
                                 ELSE climbRate!1
                                 ENDIF)=climbRate!1") (("1" (case-replace "S3(v0z!1, a1) = -v0z!1^2/(2*a1)") (("1" (case-replace "IF targetAlt!1 >= -v0z!1 ^ 2 / (2 * a1) + s0z!1
                                            THEN 1
                                          ELSE -1
                                          ENDIF = altDir") (("1" (case-replace "(targetAlt!1 >= -v0z!1 ^ 2 / (2 * a1) + s0z!1) = (targetAlt!1 >= s0z!1) ") (("1" (name "AY1" "IF altDir * climbRate!1 >= 0 THEN accelup!1
                                               ELSE acceldown!1
                                               ENDIF") (("1" (replace -1) (("1" (replace -7) (("1" (replace -7 :dir rl) (("1" (case-replace "IF abs(-1 * (-v0z!1 ^ 2 / (2 * a1)) - s0z!1 + targetAlt!1) >=
                                   abs(S1(0, AY1)(altDir * climbRate!1 / AY1) +
                                        S3(V1(0, AY1)(altDir * climbRate!1 / AY1), a2))
                                 THEN AY1
                               ELSE AY1
                               ENDIF = AY1") (("1" (replace -10 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lift-if) (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "AY1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "targetAlt!1>=s0z!1") (("1" (case-replace "a1 = accelup!1") (("1" (case "0>=-v0z!1^2/(2*accelup!1)") (("1" (add-formulas -1 -3) nil nil) ("2" (cross-mult 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a1") (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "a1=acceldown!1") (("1" (flip-ineq 1) (("1" (case "0<= -v0z!1^2/(2*acceldown!1)") (("1" (add-formulas -1 -2) nil nil) ("2" (cross-mult 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "a1") (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "altDir") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a1") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "S3") (("2" (expand "S1") (("2" (expand "^") (("2" (expand "abs") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 4 -4)) (("2" (hide -3) (("2" (expand "vsLevelOutTimes") (("2" (case-replace "( IF v0z!1 >= 0 THEN 1 ELSE -1 ENDIF =
                      IF targetAlt!1 - s0z!1 >= 0 THEN 1 ELSE -1 ENDIF
                      OR v0z!1 = 0)=FALSE") (("1" (replace -3) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Velocity_after_level") (("2" (hide (-2 2)) (("2" (inst? -1) (("2" (inst -1 "t!1") (("2" (skoletin) (("2" (replace -2) (("2" (replace -4 :dir rl) (("2" (prop) (("2" (expand "vsLevelOut_velCalc") (("2" (replace -4 :dir rl) (("2" (lemma "times_increase") (("2" (inst?) (("2" (skoletin) (("2" (replace -2) (("2" (replace -6 :dir rl) (("2" (flatten) (("2" (expand "split_fun3") (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (expand "vsLevelOut_posCalc") (("4" (replace -8 :dir rl) (("4" (expand "split_fun3") (("4" (lift-if 4) (("4" (prop) (("4" (hide-all-but (-1 2)) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -3) (("3" (hide-all-but 1) (("3" (expand "vsLevelOutTimes") (("3" (expand "vsLevelOutTimes1") (("3" (ground) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -3) (("4" (hide-all-but 1) (("4" (expand "vsLevelOutTimes") (("4" (expand "vsLevelOutTimes1") (("4" (ground) (("4" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (skoletin) (("2" (flatten) (("2" (expand "vsLevelOutTimes1") (("2" (replace -5 :dir rl) (("2" (replace -4 :dir rl) (("2" (name "cr" "altDir * (IF acr!1 THEN max(cr!1, abs(v!1)) ELSE cr!1 ENDIF)") (("2" (replace -1) (("2" (name "a1" "IF cr >= v!1 THEN au!1 ELSE ad!1 ENDIF") (("2" (replace -1) (("2" (name "root" "minpos(quadRoots(a1 / 2 - a1 ^ 2 / (2 * a2),
                                       v!1 - a1 / a2 * v!1,
                                       -v!1 ^ 2 / (2 * a2) - ta!1 + s!1))") (("1" (replace -1) (("1" (lift-if -6) (("1" (split -6) (("1" (flatten) (("1" (replace -2) (("1" (simplify 1) (("1" (hide-all-but 1) (("1" (expand "tee3") (("1" (expand "S3") (("1" (expand "V1") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "a1=a2") (("1" (case-replace "S1(v!1, a2)((cr - v!1) / a2) +
                      S3(V1(v!1, a2)((cr - v!1) / a2), a2) = S3(v!1, a2)") (("1" (hide-all-but 1) (("1" (expand "V1") (("1" (expand "S3") (("1" (expand "S1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "a1 / 2 - a1 ^ 2 / (2 * a2)/=0") (("1" (name "A" "a1 / 2 - a1 ^ 2 / (2 * a2)") (("1" (name "B" "v!1 - a1 / a2 * v!1") (("1" (name "C" "-v!1 ^ 2 / (2 * a2) - ta!1 + s!1") (("1" (case "A*C<=0") (("1" (case "discr(A,B,C)>=0") (("1" (name "sgna" "IF A>=0 THEN 1 ELSE -1 ENDIF") (("1" (case-replace "root = root(A, B, C, sgna)") (("1" (replace -9) (("1" (simplify 3) (("1" (hide-all-but (-3 1 3 -8)) (("1" (expand "tee3") (("1" (expand "V1") (("1" (expand "S1") (("1" (lemma "quad_eq_0") (("1" (inst -1 "A" "B" "C" "root(A,B,C,sgna)") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (expand "quadratic") (("1" (expand "C") (("1" (expand "A") (("1" (expand "B") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (inst 1 "sgna") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "discr") (("2" (lemma "sq_pos") (("2" (inst -1 "B") (("2" (case "-4*(A*C)>=0") (("1" (add-formulas -1 -2) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "A") (("3" (propax) nil nil)) nil)) nil) ("2" (case-replace "S3(v!1, a2) = -v!1^2/(2*a2)") (("1" (case "ta!1>=s0z!1") (("1" (case "a1>=0 AND a2<=0 AND ta!1-s0z!1>=0 AND -v!1^2/(2*a2)>=0") (("1" (case "(1-a1/a2)>=0") (("1" (case "A>=0") (("1" (case "-C>=0") (("1" (hide-all-but (-1 -2 1)) (("1" (mult-ineq -1 -2) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-3 -15 1)) (("2" (flatten) (("2" (expand "abs") (("2" (lift-if -5) (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) (("2" (postpone) nil nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) (("2" (case "a1/2/=0") (("1" (case "(1-a1/a2)/=0") (("1" (case "(1-a1/a2)*a1/2/=0") (("1" (grind) nil nil) ("2" (prop) (("2" (cancel-by -1 "a1/2") nil nil)) nil)) nil) ("2" (prop) (("2" (grind) nil nil)) nil) ("3" (expand "a2") (("3" (grind) nil nil)) nil)) nil) ("2" (expand "a1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide -9 1) (("3" (replace -6) (("3" (hide -6) (("3" (expand "vsLevelOutTimes1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (replace -6) (("4" (hide-all-but -7) (("4" (expand "vsLevelOutTimes1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (replace -3) (("5" (hide-all-but -6) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (Position_after_level-1 nil 3614352610 ("" (skosimp*) (("" (skoletin) (("" (flatten) (("" (case "FORALL (s,v:real, cr:posreal, ta:nnreal, au:posreal, ad:negreal, acr:bool):
LET sgnv = IF v>=0 THEN 1 ELSE -1 ENDIF, 
altDir = IF ta>=0 THEN 1 ELSE -1 ENDIF, 
a2 = IF ta>=s THEN ad ELSE au ENDIF, 
lot = vsLevelOutTimes1(s, v, cr, ta, au, ad, acr)
IN
 (sgnv = altDir OR v=0) AND abs(ta-s)>= abs( S3(v, a2)) IMPLIES 
s+S1(v, lot`5)(lot`1) + V1(v, lot`5)(lot`1)*(lot`2-lot`1) +S1(V1(v, lot`5)(lot`1), lot`6)(lot`3-lot`2) = ta") (("1" (case-replace "vsLevelOut_posCalc(s0z!1, v0z!1, climbRate!1, targetAlt!1, accelup!1,
                         acceldown!1, alterCR?!1)
                        (t!1) = 
s0z!1+S1(v0z!1, vsLOT`5)(vsLOT`1) + V1(v0z!1, vsLOT`5)(vsLOT`1)*(vsLOT`2-vsLOT`1) +S1(V1(v0z!1, vsLOT`5)(vsLOT`1), vsLOT`6)(vsLOT`3-vsLOT`2)") (("1" (hide -1) (("1" (case "(IF v0z!1>=0 THEN 1 ELSE -1 ENDIF) = IF targetAlt!1>=s0z!1 THEN 1 ELSE -1 ENDIF") (("1" (case "abs(targetAlt!1 - s0z!1) >= abs(S3(v0z!1, IF targetAlt!1>=s0z!1 THEN acceldown!1 ELSE accelup!1 ENDIF))") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (lemma "Velocity_after_level") (("2" (hide (-2 2)) (("2" (inst? -1) (("2" (inst -1 "t!1") (("2" (skoletin) (("2" (replace -2) (("2" (replace -4 :dir rl) (("2" (prop) (("2" (expand "vsLevelOut_velCalc") (("2" (replace -4 :dir rl) (("2" (lemma "times_increase") (("2" (inst?) (("2" (skoletin) (("2" (replace -2) (("2" (replace -6 :dir rl) (("2" (flatten) (("2" (expand "split_fun3") (("2" (lift-if -5) (("2" (prop) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (expand "vsLevelOut_posCalc") (("4" (replace -8 :dir rl) (("4" (expand "split_fun3") (("4" (lift-if 4) (("4" (prop) (("4" (hide-all-but (-1 2)) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -3) (("3" (hide-all-but 1) (("3" (expand "vsLevelOutTimes") (("3" (expand "vsLevelOutTimes1") (("3" (ground) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -3) (("4" (hide-all-but 1) (("4" (expand "vsLevelOutTimes") (("4" (expand "vsLevelOutTimes1") (("4" (ground) (("4" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (skosimp*) (("3" (hide -9 1) (("3" (replace -6) (("3" (hide -6) (("3" (expand "vsLevelOutTimes1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (replace -6) (("4" (hide-all-but -7) (("4" (expand "vsLevelOutTimes1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (skosimp*) (("5" (replace -3) (("5" (hide-all-but -6) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (vsLevelOut_TCC1 0 (vsLevelOut_TCC1-1 nil 3630430319 ("" (skeep*) (("" (replaces -1) (("" (expand "vsLevelOutTimes") (("" (lift-if) (("" (ground) (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (expand "vsLevelOutTimes1") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (ground) (("1" (expand "vsLevelOutTimes1") (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (expand "vsLevelOutTimes1") (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "vsLevelOutTimes1") (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (real_minus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (vsLevelOut subtype "vsLevelOut.LevelParams`5" "nzreal"))) (vsLevelOut_TCC2 0 (vsLevelOut_TCC2-2 nil 3672057089 ("" (skeep*) (("" (replaces -1) (("" (expand "vsLevelOutTimes") (("" (lift-if) (("" (ground) (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (expand "vsLevelOutTimes1") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (ground) (("1" (expand "vsLevelOutTimes1") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (expand "vsLevelOutTimes1") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "vsLevelOutTimes1") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "vsLevelOutTimes1") (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (vsLevelOutTimes1 const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (real_minus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (vsLevelOut subtype "vsLevelOut.LevelParams`6" "nzreal")) (vsLevelOut_TCC2-1 nil 3630430319 ("" (subtype-tcc) nil nil) nil nil (vsLevelOut subtype "vsLevelOut.LevelParams`6" "nzreal"))) (vsLevelOut_TCC3 0 (vsLevelOut_TCC3-1 nil 3630430319 ("" (lemma "times_increase") (("" (skeep) (("" (inst - "sv0`1`z" "sv0`2`z" "climbRate" "targetAlt" "accelup" "acceldown" "alterCR?") (("" (ground) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_increase formula-decl nil vsLevelOut nil)) nil (vsLevelOut subtype "vsLevelOut.LevelParams`1" "nnreal"))) (vsLevelOut_TCC4 0 (vsLevelOut_TCC4-1 nil 3630430319 ("" (lemma "times_increase") (("" (skeep) (("" (inst - "sv0`1`z" "sv0`2`z" "climbRate" "targetAlt" "accelup" "acceldown" "alterCR?") (("" (ground) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_increase formula-decl nil vsLevelOut nil)) nil (vsLevelOut subtype "vsLevelOut.LevelParams`2" "nnreal"))) (vsLevelOut_TCC5 0 (vsLevelOut_TCC5-1 nil 3630430319 ("" (skeep) (("" (lemma "times_increase") (("" (inst - "sv0`1`z" "sv0`2`z" "climbRate" "targetAlt" "accelup" "acceldown" "alterCR?") (("" (ground) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((times_increase formula-decl nil vsLevelOut nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (vsLevelOut subtype "vsLevelOut.LevelParams`3" "nnreal"))) (vsLevelOutEquals 0 (vsLevelOutEquals-1 nil 3630430930 ("" (skeep) (("" (lemma "times_increase") (("" (inst - "sv0`1`z" "sv0`2`z" "climbRate" "targetAlt" "accelup" "acceldown" "alterCR?") (("" (ground) (("" (flatten) (("" (case "t<=vsLevelOutTimes(sv0`1`z, sv0`2`z, climbRate, targetAlt, accelup,
                       acceldown, alterCR?)`1") (("1" (expand "vsLevelOut") (("1" (expand "vsLevelOut_velCalc") (("1" (expand "vsLevelOut_posCalc") (("1" (expand "split_fun3") (("1" (assert) (("1" (expand "vsLevelOutCalculation") (("1" (expand "V1") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "t<=vsLevelOutTimes(sv0`1`z, sv0`2`z, climbRate, targetAlt, accelup,
                       acceldown, alterCR?)`2") (("1" (expand "vsLevelOut") (("1" (expand "vsLevelOut_posCalc") (("1" (expand "vsLevelOut_velCalc") (("1" (expand "split_fun3") (("1" (assert) (("1" (expand "vsLevelOutCalculation") (("1" (expand "const_fun") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "t<=vsLevelOutTimes(sv0`1`z, sv0`2`z, climbRate, targetAlt, accelup,
                       acceldown, alterCR?)`3") (("1" (expand "vsLevelOut_posCalc") (("1" (expand "vsLevelOut") (("1" (expand "vsLevelOut_velCalc") (("1" (expand "split_fun3") (("1" (expand "vsLevelOutCalculation") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vsLevelOut") (("2" (expand "vsLevelOutCalculation") (("2" (assert) (("2" (lemma "Velocity_after_level") (("2" (inst?) (("2" (assert) (("2" (lemma "Position_after_level") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((times_increase formula-decl nil vsLevelOut nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vsLevelOutTimes const-decl "[real, real, real, real, real, real]" vsLevelOut nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (vsLevelOut_velCalc const-decl "real" vsLevelOut nil) (split_fun3 const-decl "[T -> real]" integral_split_fun analysis) (vsLevelOutCalculation const-decl "[Vect3, Vect3]" vsLevelOut nil) (V1 const-decl "real" vsLevelOut nil) (vsLevelOut_posCalc const-decl "real" vsLevelOut nil) (vsLevelOut const-decl "[Vect3, Vect3]" vsLevelOut nil) (Velocity_after_level formula-decl nil vsLevelOut nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Position_after_level formula-decl nil vsLevelOut nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (vsLevelOut_vect2 0 (vsLevelOut_vect2-1 nil 3661165836 ("" (skeep*) (("" (skoletin 1) (("" (expand "vsLevelOutCalculation") (("" (lift-if) (("" (ground) (("1" (replaces -2) (("1" (grind) nil nil)) nil) ("2" (replaces -2) (("2" (grind) nil nil)) nil) ("3" (replaces -2) (("3" (grind) nil nil)) nil) ("4" (replaces -1) (("4" (grind) nil nil)) nil) ("5" (replaces -2) (("5" (grind) nil nil)) nil) ("6" (replaces -2) (("6" (grind) nil nil)) nil) ("7" (replaces -2) (("7" (grind) nil nil)) nil) ("8" (replaces -1) (("8" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (vsLevelOutCalculation const-decl "[Vect3, Vect3]" vsLevelOut nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (Vector type-eq-decl nil vectors_3D vectors) (+ const-decl "Vector" vectors_3D vectors) (* const-decl "Vector" vectors_3D vectors) (V1 const-decl "real" vsLevelOut nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (S1 const-decl "real" vsLevelOut nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (linear_pos const-decl "Vect3" util nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)))
