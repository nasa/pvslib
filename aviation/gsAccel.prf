(gsAccel (gsAccel_Vel_prep_TCC1 0 (gsAccel_Vel_prep_TCC1-1 nil 3616237515 ("" (assuming-tcc) nil nil) ((vect2 const-decl "Vect2" vect_3D_2D vectors) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (connected? const-decl "bool" deriv_domain_def analysis) (real_times_real_is_real application-judgement "real" reals nil)) nil (gsAccel_Vel_prep assuming "analysis@integral_def[real].integral_def" "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))) (gsAccel_Vel_prep_TCC2 0 (gsAccel_Vel_prep_TCC2-1 nil 3616237515 ("" (skosimp*) (("" (expand "not_one_element?") (("" (skosimp*) (("" (inst 1 "x!1+1") (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((not_one_element? const-decl "bool" deriv_domain_def analysis) (real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil (gsAccel_Vel_prep assuming "analysis@integral_def[real].integral_def" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (gsAccel_Vel_prep 0 (gsAccel_Vel_prep-2 nil 3616237784 ("" (skeep) (("" (skoletin) (("" (split) (("1" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`x")) (("1" (flatten) nil nil) ("2" (ground) (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`y")) (("1" (flatten) nil nil) ("2" (ground) (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`z")) (("1" (flatten) nil nil) ("2" (ground) (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Integrable? const-decl "bool" integral_def analysis) (const_fun const-decl "[T -> real]" real_fun_ops reals) (Integral_const_fun formula-decl nil integral analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig)) nil) (gsAccel_Vel_prep-1 nil 3616237587 ("" (skeep) (("" (skoletin) (("" (split) (("1" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`x")) (("1" (flatten) nil nil) ("2" (ground) (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (ground) (("2" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`y")) (("1" (flatten) nil nil) ("2" (ground) (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`z")) (("1" (flatten) nil nil) ("2" (ground) (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Vect3 type-eq-decl nil vectors_3D_def vectors) (const_fun const-decl "[T -> real]" real_fun_ops reals) (Integrable? const-decl "bool" integral_def analysis) (Integral_const_fun formula-decl nil integral analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis)) shostak)) (gsAccel_Vel_Int_TCC1 0 (gsAccel_Vel_Int_TCC1-1 nil 3616236812 ("" (skeep) (("" (lemma "gsAccel_Vel_prep" ("vo3" "vo3" "a" "a" "t" "t")) (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (gsAccel_Vel_prep formula-decl nil gsAccel nil) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (const_fun const-decl "[T -> real]" real_fun_ops reals) (Integrable? const-decl "bool" integral_def analysis) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil)) nil (gsAccel_Vel_Int subtype "real_fun_ops[real].const_fun(gsAccel.gsAS`x)" "integral_def[real].Integrable_funs(0, gsAccel.t)"))) (gsAccel_Vel_Int_TCC2 0 (gsAccel_Vel_Int_TCC2-1 nil 3616236812 ("" (skeep) (("" (skeep) (("" (lemma "gsAccel_Vel_prep" ("vo3" "vo3" "a" "a" "t" "t")) (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (gsAccel_Vel_prep formula-decl nil gsAccel nil) (real_plus_real_is_real application-judgement "real" reals nil) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (const_fun const-decl "[T -> real]" real_fun_ops reals) (Integrable? const-decl "bool" integral_def analysis) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil)) nil (gsAccel_Vel_Int subtype "real_fun_ops[real].const_fun(gsAccel.gsAS`y)" "integral_def[real].Integrable_funs(0, gsAccel.t)"))) (gsAccel_Vel_Int_TCC3 0 (gsAccel_Vel_Int_TCC3-1 nil 3616236812 ("" (skeep) (("" (skeep) (("" (skeep) (("" (lemma "gsAccel_Vel_prep" ("vo3" "vo3" "a" "a" "t" "t")) (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (gsAccel_Vel_prep formula-decl nil gsAccel nil) (real_plus_real_is_real application-judgement "real" reals nil) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (const_fun const-decl "[T -> real]" real_fun_ops reals) (Integrable? const-decl "bool" integral_def analysis) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil)) nil (gsAccel_Vel_Int subtype "real_fun_ops[real].const_fun(gsAccel.gsAS`z)" "integral_def[real].Integrable_funs(0, gsAccel.t)"))) (Integral_gsAccel_Vel 0 (Integral_gsAccel_Vel-1 nil 3616238097 ("" (skeep) (("" (case "connected?[real]") (("1" (decompose-equality) (("1" (expand "gsAccel_Vel_Int") (("1" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAccelSplit(vo3, a)`x")) (("1" (flatten) (("1" (replace -2) (("1" (expand "gsAccel_Vel_Calc") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccel_Vel_Int") (("2" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAccelSplit(vo3, a)`y")) (("2" (flatten) (("2" (replace -2) (("2" (expand "gsAccel_Vel_Calc") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gsAccel_Vel_Int") (("3" (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAccelSplit(vo3, a)`z")) (("3" (flatten) (("3" (replace -2) (("3" (expand "gsAccel_Vel_Calc") (("3" (expand "gsAccelSplit") (("3" (expand "Vect3") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil) ((connected? const-decl "bool" deriv_domain_def analysis) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (real_times_real_is_real application-judgement "real" reals nil) (constant_seq1 application-judgement "(convergent?)" convergence_ops analysis) (derivable_const application-judgement "deriv_fun" pi_def trig) (not_one_element? const-decl "bool" deriv_domain_def analysis) (gsAccelSplit const-decl "Vect3" gsAccel nil) (Integral_const_fun formula-decl nil integral analysis) (Vect3 type-eq-decl nil vectors_3D_def vectors) (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil) (gsAccel_Vel_Int const-decl "Vect3" gsAccel nil)) shostak)) (gsAccel_Pos_prep_TCC1 0 (gsAccel_Pos_prep_TCC1-1 nil 3804567798 ("" (assuming-tcc) nil nil) ((connected? const-decl "bool" deriv_domain_def analysis)) nil (gsAccel_Pos_prep assuming "analysis@integral_def[real].integral_def" "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))) (gsAccel_Pos_prep_TCC2 0 (gsAccel_Pos_prep_TCC2-2 "" 3804605684 ("" (expand "not_one_element?") (("" (skeep) (("" (inst 1 "x + 1") (("" (assert) nil nil)) nil)) nil)) nil) nil shostak (gsAccel_Pos_prep assuming "analysis@integral_def[real].integral_def" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")) (gsAccel_Pos_prep_TCC2-1 nil 3804567798 ("" (assuming-tcc) nil nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (not_one_element? const-decl "bool" deriv_domain_def analysis)) nil (gsAccel_Pos_prep assuming "analysis@integral_def[real].integral_def" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (gsAccel_Pos_prep 0 (gsAccel_Pos_prep-1 nil 3616239824 ("" (skeep) (("" (lemma "integral_linear[real]") (("1" (expand "gsAccel_Vel_Calc") (("1" (split) (("1" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`x" "vo3`x") (("1" (skoletin) (("1" (flatten) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`y" "vo3`y") (("2" (skoletin) (("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (inst -1 "0" "t" "0" "vo3`z") (("3" (skoletin) (("3" (flatten) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (integral_linear formula-decl nil table_of_integrals analysis) (connected? const-decl "bool" deriv_domain_def analysis) (not_one_element? const-decl "bool" deriv_domain_def analysis) (bool nonempty-type-eq-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Integrable? const-decl "bool" integral_def analysis) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Integral const-decl "real" integral_def analysis) (Integrable_funs type-eq-decl nil integral_def analysis) (real_div_nzreal_is_real application-judgement "real" reals nil) (nat_exp application-judgement "nat" exponentiation nil) (hat_02n formula-decl nil power_series series) (Vect3 type-eq-decl nil vectors_3D_def vectors) (gsAccelSplit const-decl "Vect3" gsAccel nil) (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (gsAccel_Pos_Int_TCC1 0 (gsAccel_Pos_Int_TCC1-1 nil 3616240762 ("" (skeep) (("" (lemma "gsAccel_Pos_prep" ("so3" "vo3" "vo3" "vo3" "a" "a" "t" "t")) (("" (flatten) nil nil)) nil)) nil) ((real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (gsAccel_Pos_prep formula-decl nil gsAccel nil)) nil (gsAccel_Pos_Int subtype "LAMBDA (s: reals.real): gsAccel.gsAccel_Vel_Calc(gsAccel.vo3, gsAccel.a, s)`x" "integral_def[real].Integrable_funs(0, gsAccel.t)"))) (gsAccel_Pos_Int_TCC2 0 (gsAccel_Pos_Int_TCC2-1 nil 3616240762 ("" (skeep) (("" (lemma "gsAccel_Pos_prep" ("so3" "vo3" "vo3" "vo3" "a" "a" "t" "t")) (("" (flatten) nil nil)) nil)) nil) ((real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (gsAccel_Pos_prep formula-decl nil gsAccel nil)) nil (gsAccel_Pos_Int subtype "LAMBDA (s: reals.real): gsAccel.gsAccel_Vel_Calc(gsAccel.vo3, gsAccel.a, s)`y" "integral_def[real].Integrable_funs(0, gsAccel.t)"))) (gsAccel_Pos_Int_TCC3 0 (gsAccel_Pos_Int_TCC3-1 nil 3616240762 ("" (skeep) (("" (skeep) (("" (lemma "gsAccel_Pos_prep" ("so3" "vo3" "vo3" "vo3" "a" "a" "t" "t")) (("" (flatten) nil nil)) nil)) nil)) nil) ((real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (gsAccel_Pos_prep formula-decl nil gsAccel nil)) nil (gsAccel_Pos_Int subtype "LAMBDA (s: reals.real): gsAccel.gsAccel_Vel_Calc(gsAccel.vo3, gsAccel.a, s)`z" "integral_def[real].Integrable_funs(0, gsAccel.t)"))) (gsAccel_Pos_Calc_TCC1 0 (gsAccel_Pos_Calc_TCC1-1 nil 3616240762 ("" (subtype-tcc) nil nil) ((vect2 const-decl "Vect2" vect_3D_2D vectors) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (/= const-decl "boolean" notequal nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (gsAccel_Pos_Calc subtype "2" "{i: integers.int | booleans.OR(gsAccel.t /= 0, reals.>=(i, 0))}"))) (Integral_gsAccel_Pos 0 (Integral_gsAccel_Pos-2 "" 3790107329 ("" (case "connected?[real]") (("1" (skeep) (("1" (lemma "integral_linear[real]") (("1" (decompose-equality) (("1" (expand "gsAccel_Pos_Int") (("1" (expand "gsAccel_Vel_Calc") (("1" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`x" "vo3`x") (("1" (flatten) (("1" (replace -2) (("1" (expand "gsAccel_Pos_Calc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccel_Pos_Int") (("2" (expand "gsAccel_Vel_Calc") (("2" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`y" "vo3`y") (("2" (flatten) (("2" (replace -2) (("2" (expand "gsAccel_Pos_Calc") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gsAccel_Pos_Int") (("3" (expand "gsAccel_Vel_Calc") (("3" (inst -1 "0" "t" "0" "vo3`z") (("3" (flatten) (("3" (replace -2) (("3" (expand "gsAccel_Pos_Calc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (gsAccel_Pos_Calc const-decl "Vect3" gsAccel nil) (gsAccel_Pos_Int const-decl "Vect3" gsAccel nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil) (nat_exp application-judgement "nat" exponentiation nil) (hat_02n formula-decl nil power_series series) (gsAccelSplit const-decl "Vect3" gsAccel nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (* const-decl "Vector" vectors_2D vectors) (comp_zero_y formula-decl nil vectors_2D vectors) (comp_zero_x formula-decl nil vectors_2D vectors) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (norm const-decl "nnreal" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (not_one_element? const-decl "bool" deriv_domain_def analysis) (integral_linear formula-decl nil table_of_integrals analysis) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (connected? const-decl "bool" deriv_domain_def analysis)) shostak) (Integral_gsAccel_Pos-1 nil 3616241128 ("" (case "connected?[real]") (("1" (skeep) (("1" (lemma "integral_linear[real]") (("1" (decompose-equality) (("1" (expand "gsAccel_Pos_Int") (("1" (expand "gsAccel_Vel_Calc") (("1" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`x" "vo3`x") (("1" (flatten) (("1" (replace -2) (("1" (expand "gsAccel_Pos_Calc") (("1" (ground) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccel_Pos_Int") (("2" (expand "gsAccel_Vel_Calc") (("2" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`y" "vo3`y") (("2" (flatten) (("2" (replace -2) (("2" (expand "gsAccel_Pos_Calc") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gsAccel_Pos_Int") (("3" (expand "gsAccel_Vel_Calc") (("3" (inst -1 "0" "t" "0" "vo3`z") (("3" (flatten) (("3" (replace -2) (("3" (expand "gsAccel_Pos_Calc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (gsAccel_Pos_Calc const-decl "Vect3" gsAccel nil) (gsAccel_Pos_Int const-decl "Vect3" gsAccel nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil) (nat_exp application-judgement "nat" exponentiation nil) (hat_02n formula-decl nil power_series series) (gsAccelSplit const-decl "Vect3" gsAccel nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (* const-decl "Vector" vectors_2D vectors) (comp_zero_y formula-decl nil vectors_2D vectors) (comp_zero_x formula-decl nil vectors_2D vectors) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (norm const-decl "nnreal" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (not_one_element? const-decl "bool" deriv_domain_def analysis) (integral_linear formula-decl nil table_of_integrals analysis) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (connected? const-decl "bool" deriv_domain_def analysis)) shostak)) (gsAccelToRTA_possible_TCC1 0 (gsAccelToRTA_possible_TCC1-1 nil 3616430961 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (gsAccelToRTA_possible subtype "2" "{i: integers.int | booleans.OR(gsAccel.t /= 0, reals.>=(i, 0))}"))) (gsAccelToRTA_possible_TCC2 0 (gsAccelToRTA_possible_TCC2-1 nil 3616430961 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (minus_real_is_real application-judgement "real" reals nil)) nil (gsAccelToRTA_possible subtype "2" "{i: integers.int | booleans.OR(gsAccel.t /= 0, reals.>=(i, 0))}"))) (gsAccelToRTA_possible_TCC3 0 (gsAccelToRTA_possible_TCC3-1 nil 3616433064 ("" (skeep) (("" (skeep) (("" (expand "min") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) (("1" (typepred (gsIn)) (("1" (div-by -1 "-a") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred (t)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_ge1 formula-decl nil real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_real_is_real application-judgement "real" reals nil)) nil (gsAccelToRTA_possible subtype "gsAccel.T" "nnreal"))) (neg_groundspeed 0 (neg_groundspeed-1 nil 3616430978 ("" (skeep) (("" (split) (("1" (flatten) (("1" (split) (("1" (flip-ineq 1) (("1" (typepred (gsIn)) (("1" (mult-by -2 "t") (("1" (add-formulas -1 -2) nil nil)) nil)) nil)) nil) ("2" (case "a<0") (("1" (cross-mult 1) (("1" (ground) nil nil)) nil) ("2" (flip-ineq 1) (("2" (typepred (gsIn)) (("2" (mult-by -2 "t") (("2" (add-formulas -1 -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (cross-mult) nil nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (nnreal type-eq-decl nil real_types nil) (zero_times1 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_neg_gt2 formula-decl nil extra_real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (a skolem-const-decl "nzreal" gsAccel nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (< const-decl "bool" reals nil)) shostak)))
