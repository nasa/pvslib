(pi_def (inf_sum_odd_0_TCC1 0 (inf_sum_odd_0_TCC1-1 nil 3708796321 ("" (subtype-tcc) nil nil) ((series const-decl "sequence[real]" series series) (convergence const-decl "bool" convergence_sequences analysis) (convergent? const-decl "bool" convergence_sequences analysis) (conv_series? const-decl "bool" series series) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (inf_sum_odd_0 subtype "pi_def.a" "(series.conv_series?)"))) (inf_sum_odd_0_TCC2 0 (inf_sum_odd_0_TCC2-1 nil 3708796321 ("" (subtype-tcc) nil nil) ((series const-decl "sequence[real]" series series) (convergence const-decl "bool" convergence_sequences analysis) (convergent? const-decl "bool" convergence_sequences analysis) (conv_series? const-decl "bool" series series) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (inf_sum_odd_0 subtype "pi_def.b" "(series.conv_series?)"))) (inf_sum_odd_0 0 (inf_sum_odd_0-1 nil 3706268250 ("" (skeep) (("" (lemma "infsum_by2s") (("" (inst -1 "a" "b") (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (skeep) (("3" (inst -2 "k") (("3" (flatten) (("3" (replace -3 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((infsum_by2s formula-decl nil series series) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (inf_sum_even_0_TCC1 0 (inf_sum_even_0_TCC1-1 nil 3708796321 ("" (subtype-tcc) nil nil) ((series const-decl "sequence[real]" series series) (convergence const-decl "bool" convergence_sequences analysis) (convergent? const-decl "bool" convergence_sequences analysis) (conv_series? const-decl "bool" series series) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (inf_sum_even_0 subtype "pi_def.a" "(series.conv_series?)"))) (inf_sum_even_0_TCC2 0 (inf_sum_even_0_TCC2-1 nil 3708796321 ("" (subtype-tcc) nil nil) ((series const-decl "sequence[real]" series series) (convergence const-decl "bool" convergence_sequences analysis) (convergent? const-decl "bool" convergence_sequences analysis) (conv_series? const-decl "bool" series series) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (inf_sum_even_0 subtype "pi_def.b" "(series.conv_series?)"))) (inf_sum_even_0 0 (inf_sum_even_0-1 nil 3706269687 ("" (skeep) (("" (lemma "infsum_by2s") (("" (inst -1 "a" "b") (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (skeep) (("3" (inst -2 "k") (("3" (flatten) (("3" (replace -3 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((infsum_by2s formula-decl nil series series) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (cos1_gt_0_prep_TCC1 0 (cos1_gt_0_prep_TCC1-1 nil 3706431277 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (cos1_gt_0_prep subtype "(number_fields.*(4, pi_def.n))" "{i: integers.int | booleans.OR(pi_def.x /= 0, reals.>=(i, 0))}"))) (cos1_gt_0_prep_TCC2 0 (cos1_gt_0_prep_TCC2-1 nil 3706431277 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (/= const-decl "boolean" notequal nil)) nil (cos1_gt_0_prep subtype "((number_fields.+)(number_fields.*(4, pi_def.n), 2))" "{i: integers.int | booleans.OR(pi_def.x /= 0, reals.>=(i, 0))}"))) (cos1_gt_0_prep 0 (cos1_gt_0_prep-1 nil 3706431290 ("" (case "FORALL (x:real): LET S = LAMBDA (n:nat): powerseq(cos_coef,x)(2*n) IN
        				    conv_series?(S) AND cos(x) = inf_sum(S)") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (hide -2) (("1" (lemma "infsum_by2s_prep") (("1" (inst -1 "LAMBDA (n: nat): powerseq(cos_coef, x)(2 * n)" "LAMBDA (n: nat):
                               x ^ (4 * n) / factorial(4 * n) -
                                (x ^ (2 + 4 * n)) / factorial(2 + 4 * n)") (("1" (case "(FORALL k:
                               x ^ (4 * k) / factorial(4 * k) -
                                (x ^ (2 + 4 * k)) / factorial(2 + 4 * k)
                                =
                                powerseq(cos_coef, x)(2 * (2 * k)) +
                                 powerseq(cos_coef, x)(2 * (2 * k + 1)))") (("1" (expand "conv_series?") (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (expand "powerseq") (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (case "NOT even?((2 + 4 * k) / 2) AND even?(4 * k / 2)") (("1" (flatten) (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "(2 + 4 * k) / 2") (("1" (inst -2 "4 * k / 2") (("1" (assert) (("1" (replaces -1 2) (("1" (replaces -1 2) (("1" (hide - 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide - 2 3) (("2" (case "4*k/2=2*k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide - 2 3) (("2" (case "(2+4*k)/2 = 1+2*k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "even?") (("1" (propax) nil nil)) nil) ("2" (expand "even?") (("2" (inst 1 "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (case "4*k/2=2*k") (("1" (replaces -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (case "(2+4*k)/2=1+2*k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -2 1) (("2" (lemma "infsum_by2s") (("2" (inst -1 "LAMBDA (n: nat): powerseq(cos_coef, x)(2 * n)" "LAMBDA (n: nat):
                                   x ^ (4 * n) / factorial(4 * n) -
                                    (x ^ (2 + 4 * n)) / factorial(2 + 4 * n)") (("2" (case "(FORALL k:
                                        x ^ (4 * k) / factorial(4 * k) -
                                         (x ^ (2 + 4 * k)) / factorial(2 + 4 * k)
                                         =
                                         powerseq(cos_coef, x)(2 * (2 * k)) +
                                          powerseq(cos_coef, x)(2 * (2 * k + 1)))") (("1" (expand "conv_series?") (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (expand "powerseq") (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (case "NOT even?((2 + 4 * k) / 2) AND even?(4 * k / 2)") (("1" (flatten) (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "(2 + 4 * k) / 2") (("1" (inst -2 "4 * k / 2") (("1" (assert) (("1" (replaces -1 2) (("1" (replaces -1 2) (("1" (hide - 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide - 2 3) (("2" (case "4*k/2=2*k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide - 2 3) (("2" (case "(2+4*k)/2 = 1+2*k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "even?") (("1" (propax) nil nil)) nil) ("2" (expand "even?") (("2" (inst 1 "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (case "4*k/2=2*k") (("1" (replaces -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (case "(2+4*k)/2=1+2*k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) (("2" (lemma "inf_sum_odd_0") (("2" (expand "conv_series?") (("2" (expand "cos") (("2" (expand "powerseq") (("2" (inst -1 "LAMBDA (k: nat): cos_coef(k) * x ^ k" "LAMBDA (n: nat): cos_coef(2 * n) * x ^ (2 * n)") (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "x") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (case "(FORALL (k_1: nat): cos_coef(2 * k_1 + 1) * x ^ (2 * k_1 + 1) = 0)") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (expand "cos_coef") (("2" (lift-if) (("2" (expand "altsign") (("2" (split) (("1" (expand "even?") (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cos_conv formula-decl nil sincos_def nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (powerseries const-decl "sequence[real]" power_series series) (conv_powerseries? const-decl "bool" power_series_conv series) (inf_sum_odd_0 formula-decl nil pi_def nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (infsum_by2s_prep formula-decl nil series series) (real_plus_real_is_real application-judgement "real" reals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (NOT const-decl "[bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (even_m1_pow formula-decl nil exponentiation nil) (k skolem-const-decl "nat" pi_def nil) (nil application-judgement "above(n)" exp2 nil) (real_times_real_is_real application-judgement "real" reals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (TRUE const-decl "bool" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (not_even_m1_pow formula-decl nil exponentiation nil) (altsign const-decl "{i: int | i = -1 OR i = 1}" sincos_def nil) (rat_exp application-judgement "rat" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (infsum_by2s formula-decl nil series series) (k skolem-const-decl "nat" pi_def nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (conv_series? const-decl "bool" series series) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def nil) (inf_sum const-decl "real" series series) (powerseq const-decl "sequence[real]" power_series series) (cos_coef const-decl "real" sincos_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (series_first_aux_TCC1 0 (series_first_aux_TCC1-1 nil 3706346493 ("" (skeep) (("" (lemma "tail_series_conv") (("" (inst -1 "1" "a") (("" (assert) nil nil)) nil)) nil)) nil) ((tail_series_conv formula-decl nil series series) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (series_first_aux subtype "series.series(LAMBDA (n: naturalnumbers.nat): pi_def.a((number_fields.+)(n, 1)))" "(convergence_sequences.convergent?)"))) (series_first_aux 0 (series_first_aux-3 "" 3790092005 ("" (skeep) (("" (expand "series") (("" (case "convergent?(LAMBDA (n_1: nat):
                                  sigma[nat](0, n_1, LAMBDA (n: nat): a(1 + n)))") (("1" (move-terms 1 r 2) (("1" (rewrite "limit_diff" :dir rl) (("1" (case "NOT (LAMBDA (n: nat): sigma(0, n, a)) = (LAMBDA (n: nat): a(0)+sigma(1, n, a))") (("1" (decompose-equality 1) (("1" (rewrite "sigma_first" 1) nil nil)) nil) ("2" (replaces -1) (("2" (expand "sigma" + 2) (("2" (expand "-" 1) (("2" (case "NOT (LAMBDA (x: nat):
                                    a(0) + sigma(1, x, a) - a(1 + x) -
                                     sigma(0, x - 1, LAMBDA (n: nat): a(1 + n))) = (LAMBDA (x: nat):
                                    a(0) - a(1 + x))") (("1" (decompose-equality 1) (("1" (lemma "sigma_shift") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "limit_def") (("1" (lemma "convergence_cauchy1") (("1" (label "hideme" -2) (("1" (hide "hideme") (("1" (inst?) (("1" (reveal "hideme") (("1" (delabel "hideme") (("1" (assert) (("1" (expand "convergence") (("1" (skeep) (("1" (expand "cauchy") (("1" (inst - "epsilon/2") (("1" (skosimp*) (("1" (inst + "n!1") (("1" (skosimp*) (("1" (inst - "i!1+1" "i!1") (("1" (assert) (("1" (expand "sigma" -2 1) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "convergent?" 1) (("2" (inst + "a(0)") (("2" (expand "convergence") (("2" (lemma "convergence_cauchy1") (("2" (label "hideme" -2) (("2" (hide "hideme") (("2" (inst?) (("2" (assert) (("2" (expand "cauchy") (("2" (skeep) (("2" (inst - "epsilon/2") (("2" (skosimp*) (("2" (inst + "n!1") (("2" (skosimp*) (("2" (inst - "i!1+1" "i!1") (("2" (assert) (("2" (expand "sigma" -1 1) (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "convergence_cauchy") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "convergence_cauchy") (("2" (inst?) (("2" (assert) (("2" (hide -2) (("2" (expand "cauchy") (("2" (skeep) (("2" (inst -1 "epsilon") (("2" (skolem -1 "n") (("2" (inst 1 "n") (("2" (skeep) (("2" (inst -1 "i+1" "j+1") (("2" (assert) (("2" (case "FORALL (i,j:nat): sigma(0, 1 + i, a) - sigma(0, 1 + j, a) = sigma[nat](0, i, LAMBDA (n: nat): a(1 + n)) -
                             sigma[nat](0, j, LAMBDA (n: nat): a(1 + n))") (("1" (inst -1 "i" "j") (("1" (replace -1 1 rl) (("1" (propax) nil nil)) nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (lemma "sigma_diff") (("2" (case "i!1 >= j!1") (("1" (inst-cp -2 "a" "i!1+1" "0" "1+j!1") (("1" (inst -2 "LAMBDA (n:nat): a(1+n)" "i!1" "0" "j!1") (("1" (typepred "i!1") (("1" (typepred "j!1") (("1" (assert) (("1" (replaces -4 1) (("1" (replaces -4 1) (("1" (grind) (("1" (lemma "sigma_shift_T") (("1" (inst -1 "a" "i!1+1" "j!1+1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -1 "a" "j!1+1" "0" "i!1+1") (("2" (inst -1 "LAMBDA (n:nat): a(1+n)" "j!1" "0" "i!1") (("2" (mult-by 2 "-1") (("2" (assert) (("2" (replaces -1 2) (("2" (replaces -1 2) (("2" (lemma "sigma_shift_T") (("2" (inst -1 "a" "j!1" "1+i!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((series const-decl "sequence[real]" series series) (sigma_diff formula-decl nil sigma reals) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_shift_T formula-decl nil sigma reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (convergence_cauchy formula-decl nil convergence_sequences analysis) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (limit const-decl "real" convergence_sequences analysis) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_first formula-decl nil sigma reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_shift formula-decl nil sigma_nat reals) (int_plus_int_is_int application-judgement "int" integers nil) (limit_def formula-decl nil convergence_sequences analysis) (real_times_real_is_real application-judgement "real" reals nil) (convergence const-decl "bool" convergence_sequences analysis) (cauchy const-decl "bool" convergence_sequences analysis) (nil application-judgement "above(n)" exp2 nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_real_is_real application-judgement "real" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (convergence_cauchy1 formula-decl nil convergence_sequences analysis) (- const-decl "[T -> real]" real_fun_ops reals) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (limit_diff formula-decl nil convergence_ops analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sequence type-eq-decl nil sequences nil) (convergent? const-decl "bool" convergence_sequences analysis) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (series_first_aux-2 nil 3706374039 ("" (skeep) (("" (expand "series") (("" (case "convergent?(LAMBDA (n_1: nat):
                                  sigma[nat](0, n_1, LAMBDA (n: nat): a(1 + n)))") (("1" (move-terms 1 r 2) (("1" (rewrite "limit_diff" :dir rl) (("1" (case "NOT (LAMBDA (n: nat): sigma(0, n, a)) = (LAMBDA (n: nat): a(0)+sigma(1, n, a))") (("1" (decompose-equality 1) (("1" (rewrite "sigma_first" 1) nil nil)) nil) ("2" (replaces -1) (("2" (expand "sigma" + 2) (("2" (expand "-" 1) (("2" (case "NOT (LAMBDA (x: nat):
                                    a(0) + sigma(1, x, a) - a(1 + x) -
                                     sigma(0, x - 1, LAMBDA (n: nat): a(1 + n))) = (LAMBDA (x: nat):
                                    a(0) - a(1 + x))") (("1" (decompose-equality 1) (("1" (lemma "sigma_shift") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst + "2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "limit_def") (("1" (lemma "convergence_cauchy1") (("1" (label "hideme" -2) (("1" (hide "hideme") (("1" (inst?) (("1" (reveal "hideme") (("1" (delabel "hideme") (("1" (assert) (("1" (expand "convergence") (("1" (skeep) (("1" (expand "cauchy") (("1" (inst - "epsilon/2") (("1" (skosimp*) (("1" (inst + "n!1") (("1" (skosimp*) (("1" (inst - "i!1+1" "i!1") (("1" (assert) (("1" (expand "sigma" -2 1) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "convergent?" 1) (("2" (inst + "a(0)") (("2" (expand "convergence") (("2" (lemma "convergence_cauchy1") (("2" (label "hideme" -2) (("2" (hide "hideme") (("2" (inst?) (("2" (assert) (("2" (expand "cauchy") (("2" (skeep) (("2" (inst - "epsilon/2") (("2" (skosimp*) (("2" (inst + "n!1") (("2" (skosimp*) (("2" (inst - "i!1+1" "i!1") (("2" (assert) (("2" (expand "sigma" -1 1) (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "convergence_cauchy") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "convergence_cauchy") (("2" (inst?) (("2" (assert) (("2" (hide -2) (("2" (expand "cauchy") (("2" (skeep) (("2" (inst -1 "epsilon") (("2" (skolem -1 "n") (("2" (inst 1 "n") (("2" (skeep) (("2" (inst -1 "i+1" "j+1") (("2" (assert) (("2" (case "FORALL (i,j:nat): sigma(0, 1 + i, a) - sigma(0, 1 + j, a) = sigma[nat](0, i, LAMBDA (n: nat): a(1 + n)) -
                             sigma[nat](0, j, LAMBDA (n: nat): a(1 + n))") (("1" (inst -1 "i" "j") (("1" (replace -1 1 rl) (("1" (propax) nil nil)) nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (lemma "sigma_diff") (("2" (case "i!1 >= j!1") (("1" (inst-cp -2 "a" "i!1+1" "0" "1+j!1") (("1" (inst -2 "LAMBDA (n:nat): a(1+n)" "i!1" "0" "j!1") (("1" (typepred "i!1") (("1" (typepred "j!1") (("1" (assert) (("1" (replaces -4 1) (("1" (replaces -4 1) (("1" (grind) (("1" (lemma "sigma_shift_T") (("1" (inst -1 "a" "i!1+1" "j!1+1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -1 "a" "j!1+1" "0" "i!1+1") (("2" (inst -1 "LAMBDA (n:nat): a(1+n)" "j!1" "0" "i!1") (("2" (mult-by 2 "-1") (("2" (assert) (("2" (replaces -1 2) (("2" (replaces -1 2) (("2" (lemma "sigma_shift_T") (("2" (inst -1 "a" "j!1" "1+i!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_diff formula-decl nil sigma reals) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_shift_T formula-decl nil sigma reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (convergence_cauchy formula-decl nil convergence_sequences analysis) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (limit const-decl "real" convergence_sequences analysis) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_first formula-decl nil sigma reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_shift formula-decl nil sigma_nat reals) (int_plus_int_is_int application-judgement "int" integers nil) (limit_def formula-decl nil convergence_sequences analysis) (real_times_real_is_real application-judgement "real" reals nil) (convergence const-decl "bool" convergence_sequences analysis) (cauchy const-decl "bool" convergence_sequences analysis) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_real_is_real application-judgement "real" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (convergence_cauchy1 formula-decl nil convergence_sequences analysis) (TRUE const-decl "bool" booleans nil) (limit_diff formula-decl nil convergence_ops analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sequence type-eq-decl nil sequences nil) (convergent? const-decl "bool" convergence_sequences analysis) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil) (series_first_aux-1 nil 3706346495 ("" (lemma "series_first") (("" (skeep) (("" (inst?) (("" (replaces -2 -1) (("" (replaces -1 1) (("" (move-terms 1 l 1) (("" (assert) (("" (expand "series") (("" (lemma "limit_equiv") (("" (inst -1 "limit(LAMBDA (n_1: nat): sigma(0, n_1, LAMBDA (n: nat): a(1 + n)))" "LAMBDA (n: nat): sigma(1, n, a)") (("1" (flatten) (("1" (case "convergence(LAMBDA (n: nat): sigma(1, n, a),
                  limit(LAMBDA (n_1: nat):
                          sigma(0, n_1, LAMBDA (n: nat): a(1 + n))))") (("1" (replaces -1 -2) (("1" (hide -2) (("1" (flatten) nil nil)) nil)) nil) ("2" (hide - 2) (("2" (expand "convergence") (("2" (skeep) (("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (hide - 2) (("3" (reveal -6) (("3" (lemma "tail_series_conv") (("3" (inst -1 "1" "a") (("3" (replaces -2 -1) (("3" (expand "series") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (hide 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "1" "a") (("2" (replaces -2 -1) (("2" (expand "series") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (cos1_gt_0 0 (cos1_gt_0-1 nil 3704716495 ("" (lemma "cos1_gt_0_prep") (("" (inst -1 "1") (("" (assert) (("" (flatten) (("" (replace -2 1) (("" (hide -2) (("" (lemma "inf_sum_gt_0") (("" (inst -1 "LAMBDA (p:nat): 1 / factorial(4 * p) - 1 / factorial(4 * p + 2)") (("" (assert) (("" (hide -1 2) (("" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (field) (("2" (hide -2) (("2" (expand "factorial" 1 1) (("2" (expand "factorial" 1 2) (("2" (expand "factorial" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sequence type-eq-decl nil sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (inf_sum_gt_0 formula-decl nil series series) (expt_1i formula-decl nil exponentiation nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cos1_gt_0_prep formula-decl nil pi_def nil)) shostak)) (cos2_lt_0 0 (cos2_lt_0-2 "" 3882557603 ("" (case "cos(2) < 1 - 2^2/factorial(2) + 2^4/factorial(4)") (("1" (case "1 - 2 ^ 2 / factorial(2) + 2 ^ 4 / factorial(4) < 0") (("1" (assert) nil nil) ("2" (hide - 2) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "cos") (("2" (move-terms 1 l) (("2" (expand "powerseq") (("2" (expand "inf_sum") (("2" (case "1 + 2 ^ 4 / factorial(4) -
                 limit(series(LAMBDA (k: nat): cos_coef(k) * 2 ^ k))
                 - 2 ^ 2 / factorial(2) = 0 - limit(series(LAMBDA (k: nat): cos_coef(k+5) * 2 ^ (k+5)))") (("1" (replaces -1 1) (("1" (assert) (("1" (lemma "limit_scal") (("1" (inst -1 "-1" "series(LAMBDA (k: nat): cos_coef(5 + k) * 2 ^ (5 + k))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_scal") (("1" (inst -1 "LAMBDA (k: nat): cos_coef(5 + k) * 2 ^ (5 + k)" "-1") (("1" (replaces -1 1) (("1" (lemma "inf_sum_even_0") (("1" (inst -1 "LAMBDA n: -1 * (cos_coef(5 + n) * 2 ^ (5 + n))" "LAMBDA (n:nat): -1 * (cos_coef(6+2*n) * 2^(6+2*n))") (("1" (case " (convergent?(series(LAMBDA n: -1 * (cos_coef(5 + n) * 2 ^ (5 + n))))
                   AND
                   (FORALL (k: nat):
                      -1 * (cos_coef(6 + 2 * k) * 2 ^ (6 + 2 * k)) =
                       -1 * (cos_coef(5 + (2 * k + 1)) * 2 ^ (5 + (2 * k + 1)))
                       AND -1 * (cos_coef(5 + 2 * k) * 2 ^ (5 + 2 * k)) = 0))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (lemma "infsum_by2s") (("1" (inst -1 "LAMBDA (n: nat):
                              -1 * (cos_coef(6 + 2 * n) * 2 ^ (6 + 2 * n))" "LAMBDA (n:nat): -1 * (cos_coef(6+4*n)*2^(6+4*n) + cos_coef(8+4*n)*2^(8+4*n))") (("1" (case "(convergent?(series(LAMBDA (n: nat):
                                         -1 * (cos_coef(6 + 2 * n) * 2 ^ (6 + 2 * n))))
                     AND
                     (FORALL k:
                        -1 *
                         (cos_coef(6 + 4 * k) * 2 ^ (6 + 4 * k) +
                           cos_coef(8 + 4 * k) * 2 ^ (8 + 4 * k))
                         =
                         -1 * (cos_coef(6 + 2 * (2 * k)) * 2 ^ (6 + 2 * (2 * k))) +
                          -1 *
                           (cos_coef(6 + 2 * (2 * k + 1)) * 2 ^ (6 + 2 * (2 * k + 1)))))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "LAMBDA (n: nat):
                                -1 * (cos_coef(6 + 4 * n) * 2 ^ (6 + 4 * n)) -
                                 cos_coef(8 + 4 * n) * 2 ^ (8 + 4 * n)") (("1" (case "(conv_series?(LAMBDA (n: nat):
                                     -1 * (cos_coef(6 + 4 * n) * 2 ^ (6 + 4 * n)) -
                                      cos_coef(8 + 4 * n) * 2 ^ (8 + 4 * n))
                       AND
                       (FORALL (n_1: nat):
                          -1 * (cos_coef(6 + 4 * n_1) * 2 ^ (6 + 4 * n_1)) -
                           cos_coef(8 + 4 * n_1) * 2 ^ (8 + 4 * n_1)
                           > 0))") (("1" (replaces -1 -2) (("1" (expand "inf_sum") (("1" (assert) nil nil)) nil)) nil) ("2" (split 1) (("1" (expand "conv_series?") (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (skolem 1 "n") (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (case "even?((8 + 4 * n) / 2) AND NOT even?((6 + 4 * n) / 2)") (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "(6 + 4 * n) / 2") (("1" (inst -2 "(8 + 4 * n) / 2") (("1" (flatten) (("1" (replaces -3 -2) (("1" (replaces 1 -1) (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (case "-1 * (-1 / factorial(6 + 4 * n) * 2 ^ (6 + 4 * n)) = 1 / factorial(6 + 4 * n) * 2 ^ (6 + 4 * n)") (("1" (replaces -1 1) (("1" (move-terms 1 l 2) (("1" (assert) (("1" (cross-mult) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (expand "expt" 1 2) (("1" (cancel-by 1 "expt(2,6+4*n)") (("1" (hide - 2) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 3) (("1" (case "56 * factorial(6 + 4 * n) + 60 * (factorial(6 + 4 * n) * n) +
                                  16 * (factorial(6 + 4 * n) * n * n) = factorial(6+4*n) * (56 + 60 *n + 16 * n * n)") (("1" (replaces -1 1) (("1" (cancel-by 1 "factorial(6+4*n)") nil nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (case-replace "(8 + 4 * n) / 2 = 4+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (case-replace "(6 + 4 * n) / 2 = 3+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "even?") (("2" (inst 1 "2+n") (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (assert) (("3" (case-replace "(6 + 4 * n) / 2 = 3 + 2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (case-replace "(8 + 4 * n) / 2 = 4 + 2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (propax) nil nil) ("2" (hide - 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide - 2) (("1" (lemma "tail_series_conv") (("1" (lemma "cos_conv") (("1" (expand "conv_powerseries?") (("1" (inst -1 "2") (("1" (expand "powerseries") (("1" (expand "powerseq") (("1" (inst -2 "5" "LAMBDA (k: nat): cos_coef(k) * 2 ^ k") (("1" (replaces -1 -2) (("1" (lemma "convergent_neg") (("1" (inst -1 "series(LAMBDA n: cos_coef(n + 5) * 2 ^ (n + 5))") (("1" (replaces -2 -1) (("1" (lemma "series_neg") (("1" (inst -1 "LAMBDA n: cos_coef(n + 5) * 2 ^ (n + 5)") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (expand "-" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (split) (("1" (assert) nil nil) ("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (expand "even?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (cancel-by 1 "-1") (("2" (hide 1) (("2" (move-terms 1 l 1) (("2" (assert) (("2" (mult-by 1 "-1") (("2" (assert) (("2" (lemma "series_first_aux") (("2" (inst -1 "LAMBDA (k: nat): cos_coef(k) * 2 ^ k") (("2" (case "convergent?(series(LAMBDA (k: nat): cos_coef(k) * 2 ^ k))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n: nat): cos_coef(n + 1) * 2 ^ (n + 1)") (("1" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n + 1) * 2 ^ (n + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n_1: nat):
                                    cos_coef(n_1 + 1 + 1) * 2 ^ (n_1 + 1 + 1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                                          cos_coef(n_1 + 1 + 1) * 2 ^ (n_1 + 1 + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n: nat):
                                        cos_coef(n + 1 + 1 + 1) *
                                         2 ^ (n + 1 + 1 + 1)") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(n + 1 + 1 + 1) * 2 ^ (n + 1 + 1 + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n_1: nat):
                                            cos_coef(n_1 + 1 + 1 + 1 + 1) *
                                             2 ^ (n_1 + 1 + 1 + 1 + 1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(n_1 + 1 + 1 + 1 + 1) *
                            2 ^ (n_1 + 1 + 1 + 1 + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (assert) (("1" (expand "cos_coef") (("1" (expand "altsign") (("1" (lift-if) (("1" (expand "even?") (("1" (assert) (("1" (case "(-1) ^ 2 / factorial(4) * 2 ^ (4) = ((2 ^ 4) / factorial(4))") (("1" (case "(-1) / factorial(2) * 2 ^ (2) = -((2 ^ 2) / factorial(2))") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "even_m1_pow") (("2" (inst -1 "2") (("2" (split) (("1" (assert) nil nil) ("2" (expand "even?") (("2" (inst 1 "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "4" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "3" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "2" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "1" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) nil nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "tail_series_conv") (("3" (lemma "cos_conv") (("3" (expand "conv_powerseries?") (("3" (inst -1 "2") (("3" (expand "powerseries") (("3" (expand "powerseq") (("3" (inst -2 "5" "LAMBDA (k: nat): cos_coef(k) * 2 ^ k") (("3" (replaces -1 -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (conv_series? const-decl "bool" series series) (inf_sum const-decl "real" series series) (powerseq const-decl "sequence[real]" power_series series) (cos_coef const-decl "real" sincos_def nil) (odd? const-decl "bool" integers nil) (int8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (both_sides_times1 formula-decl nil real_props nil) (nnrrat_div_negrat_is_nprat application-judgement "nprat" rationals nil) (series_first_aux formula-decl nil pi_def nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (factorial_0 formula-decl nil factorial ints) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (limit_scal formula-decl nil convergence_ops analysis) (series_scal formula-decl nil series series) (even_plus_even_is_even application-judgement "even_int" integers nil) (tail_series_conv formula-decl nil series series) (conv_powerseries? const-decl "bool" power_series_conv series) (powerseries const-decl "sequence[real]" power_series series) (convergent_neg formula-decl nil convergence_ops analysis) (- const-decl "[T -> real]" real_fun_ops reals) (series_neg formula-decl nil series series) (cos_conv formula-decl nil sincos_def nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (infsum_by2s formula-decl nil series series) (real_plus_real_is_real application-judgement "real" reals nil) (rat_exp application-judgement "rat" exponentiation nil) (altsign const-decl "{i: int | i = -1 OR i = 1}" sincos_def nil) (nil application-judgement "above(n)" exp2 nil) (even_m1_pow formula-decl nil exponentiation nil) (n skolem-const-decl "nat" pi_def nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (even_int nonempty-type-eq-decl nil integers nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div2 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (not_even_m1_pow formula-decl nil exponentiation nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inf_sum_gt_0 formula-decl nil series series) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (inf_sum_even_0 formula-decl nil pi_def nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (series const-decl "sequence[real]" series series) (limit const-decl "real" convergence_sequences analysis) (convergent? const-decl "bool" convergence_sequences analysis) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil) (expt def-decl "real" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (cos const-decl "real" sincos_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints)) shostak) (cos2_lt_0-1 nil 3704806668 ("" (case "cos(2) < 1 - 2^2/factorial(2) + 2^4/factorial(4)") (("1" (case "1 - 2 ^ 2 / factorial(2) + 2 ^ 4 / factorial(4) < 0") (("1" (assert) nil nil) ("2" (hide - 2) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "cos") (("2" (move-terms 1 l) (("2" (expand "powerseq") (("2" (expand "inf_sum") (("2" (case "1 + 2 ^ 4 / factorial(4) -
                 limit(series(LAMBDA (k: nat): cos_coef(k) * 2 ^ k))
                 - 2 ^ 2 / factorial(2) = 0 - limit(series(LAMBDA (k: nat): cos_coef(k+5) * 2 ^ (k+5)))") (("1" (replaces -1 1) (("1" (assert) (("1" (lemma "limit_scal") (("1" (inst -1 "-1" "series(LAMBDA (k: nat): cos_coef(5 + k) * 2 ^ (5 + k))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_scal") (("1" (inst -1 "LAMBDA (k: nat): cos_coef(5 + k) * 2 ^ (5 + k)" "-1") (("1" (replaces -1 1) (("1" (lemma "inf_sum_even_0") (("1" (inst -1 "LAMBDA n: -1 * (cos_coef(5 + n) * 2 ^ (5 + n))" "LAMBDA (n:nat): -1 * (cos_coef(6+2*n) * 2^(6+2*n))") (("1" (case " (convergent?(series(LAMBDA n: -1 * (cos_coef(5 + n) * 2 ^ (5 + n))))
                   AND
                   (FORALL (k: nat):
                      -1 * (cos_coef(6 + 2 * k) * 2 ^ (6 + 2 * k)) =
                       -1 * (cos_coef(5 + (2 * k + 1)) * 2 ^ (5 + (2 * k + 1)))
                       AND -1 * (cos_coef(5 + 2 * k) * 2 ^ (5 + 2 * k)) = 0))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (lemma "infsum_by2s") (("1" (inst -1 "LAMBDA (n: nat):
                              -1 * (cos_coef(6 + 2 * n) * 2 ^ (6 + 2 * n))" "LAMBDA (n:nat): -1 * (cos_coef(6+4*n)*2^(6+4*n) + cos_coef(8+4*n)*2^(8+4*n))") (("1" (case "(convergent?(series(LAMBDA (n: nat):
                                         -1 * (cos_coef(6 + 2 * n) * 2 ^ (6 + 2 * n))))
                     AND
                     (FORALL k:
                        -1 *
                         (cos_coef(6 + 4 * k) * 2 ^ (6 + 4 * k) +
                           cos_coef(8 + 4 * k) * 2 ^ (8 + 4 * k))
                         =
                         -1 * (cos_coef(6 + 2 * (2 * k)) * 2 ^ (6 + 2 * (2 * k))) +
                          -1 *
                           (cos_coef(6 + 2 * (2 * k + 1)) * 2 ^ (6 + 2 * (2 * k + 1)))))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "LAMBDA (n: nat):
                                -1 * (cos_coef(6 + 4 * n) * 2 ^ (6 + 4 * n)) -
                                 cos_coef(8 + 4 * n) * 2 ^ (8 + 4 * n)") (("1" (case "(conv_series?(LAMBDA (n: nat):
                                     -1 * (cos_coef(6 + 4 * n) * 2 ^ (6 + 4 * n)) -
                                      cos_coef(8 + 4 * n) * 2 ^ (8 + 4 * n))
                       AND
                       (FORALL (n_1: nat):
                          -1 * (cos_coef(6 + 4 * n_1) * 2 ^ (6 + 4 * n_1)) -
                           cos_coef(8 + 4 * n_1) * 2 ^ (8 + 4 * n_1)
                           > 0))") (("1" (replaces -1 -2) (("1" (expand "inf_sum") (("1" (assert) nil nil)) nil)) nil) ("2" (split 1) (("1" (expand "conv_series?") (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (skolem 1 "n") (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (case "even?((8 + 4 * n) / 2) AND NOT even?((6 + 4 * n) / 2)") (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "(6 + 4 * n) / 2") (("1" (inst -2 "(8 + 4 * n) / 2") (("1" (flatten) (("1" (replaces -3 -2) (("1" (replaces 1 -1) (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (case "-1 * (-1 / factorial(6 + 4 * n) * 2 ^ (6 + 4 * n)) = 1 / factorial(6 + 4 * n) * 2 ^ (6 + 4 * n)") (("1" (replaces -1 1) (("1" (move-terms 1 l 2) (("1" (assert) (("1" (cross-mult) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (expand "expt" 1 2) (("1" (cancel-by 1 "expt(2,6+4*n)") (("1" (hide - 2) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 3) (("1" (case "56 * factorial(6 + 4 * n) + 60 * (factorial(6 + 4 * n) * n) +
                                  16 * (factorial(6 + 4 * n) * n * n) = factorial(6+4*n) * (56 + 60 *n + 16 * n * n)") (("1" (replaces -1 1) (("1" (cancel-by 1 "factorial(6+4*n)") nil nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (case-replace "(8 + 4 * n) / 2 = 4+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (case-replace "(6 + 4 * n) / 2 = 3+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "even?") (("2" (inst 1 "2+n") (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (assert) (("3" (case-replace "(6 + 4 * n) / 2 = 3 + 2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (case-replace "(8 + 4 * n) / 2 = 4 + 2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (propax) nil nil) ("2" (hide - 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide - 2) (("1" (lemma "tail_series_conv") (("1" (lemma "cos_conv") (("1" (expand "conv_powerseries?") (("1" (inst -1 "2") (("1" (expand "powerseries") (("1" (expand "powerseq") (("1" (inst -2 "5" "LAMBDA (k: nat): cos_coef(k) * 2 ^ k") (("1" (replaces -1 -2) (("1" (lemma "convergent_neg") (("1" (inst -1 "series(LAMBDA n: cos_coef(n + 5) * 2 ^ (n + 5))") (("1" (replaces -2 -1) (("1" (lemma "series_neg") (("1" (inst -1 "LAMBDA n: cos_coef(n + 5) * 2 ^ (n + 5)") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (expand "-" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (skeep) (("2" (split) (("1" (assert) nil nil) ("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (expand "even?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (cancel-by 1 "-1") (("2" (hide 1) (("2" (move-terms 1 l 1) (("2" (assert) (("2" (mult-by 1 "-1") (("2" (assert) (("2" (lemma "series_first_aux") (("2" (inst -1 "LAMBDA (k: nat): cos_coef(k) * 2 ^ k") (("2" (case "convergent?(series(LAMBDA (k: nat): cos_coef(k) * 2 ^ k))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n: nat): cos_coef(n + 1) * 2 ^ (n + 1)") (("1" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n + 1) * 2 ^ (n + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n_1: nat):
                                    cos_coef(n_1 + 1 + 1) * 2 ^ (n_1 + 1 + 1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                                          cos_coef(n_1 + 1 + 1) * 2 ^ (n_1 + 1 + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n: nat):
                                        cos_coef(n + 1 + 1 + 1) *
                                         2 ^ (n + 1 + 1 + 1)") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(n + 1 + 1 + 1) * 2 ^ (n + 1 + 1 + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (lemma "series_first_aux") (("1" (inst -1 "LAMBDA (n_1: nat):
                                            cos_coef(n_1 + 1 + 1 + 1 + 1) *
                                             2 ^ (n_1 + 1 + 1 + 1 + 1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(n_1 + 1 + 1 + 1 + 1) *
                            2 ^ (n_1 + 1 + 1 + 1 + 1)))") (("1" (replaces -1 -2) (("1" (replaces -1 1) (("1" (assert) (("1" (expand "cos_coef") (("1" (expand "altsign") (("1" (lift-if) (("1" (expand "even?") (("1" (assert) (("1" (case "(-1) ^ 2 / factorial(4) * 2 ^ (4) = ((2 ^ 4) / factorial(4))") (("1" (case "(-1) / factorial(2) * 2 ^ (2) = -((2 ^ 2) / factorial(2))") (("1" (replaces -1 1) (("1" (replaces -1 1) nil nil)) nil) ("2" (hide - 2) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "even_m1_pow") (("2" (inst -1 "2") (("2" (split) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (expand "even?") (("2" (inst 1 "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "4" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "3" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "2" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "tail_series_conv") (("2" (inst -1 "1" "LAMBDA (n:nat): cos_coef(n)*2^n") (("2" (case "convergent?(series(LAMBDA (n: nat): cos_coef(n) * 2 ^ n))") (("1" (replaces -1 -2) nil nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "cos_conv") (("2" (expand "conv_powerseries?") (("2" (inst -1 "2") (("2" (expand "powerseries") (("2" (expand "powerseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "tail_series_conv") (("3" (lemma "cos_conv") (("3" (expand "conv_powerseries?") (("3" (inst -1 "2") (("3" (expand "powerseries") (("3" (expand "powerseq") (("3" (inst -2 "5" "LAMBDA (k: nat): cos_coef(k) * 2 ^ k") (("3" (replaces -1 -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (powerseq const-decl "sequence[real]" power_series series) (cos_coef const-decl "real" sincos_def nil) (int8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (both_sides_times1 formula-decl nil real_props nil) (nnrrat_div_negrat_is_nprat application-judgement "nprat" rationals nil) (series_first_aux formula-decl nil pi_def nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (factorial_0 formula-decl nil factorial ints) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (limit_scal formula-decl nil convergence_ops analysis) (series_scal formula-decl nil series series) (even_plus_even_is_even application-judgement "even_int" integers nil) (tail_series_conv formula-decl nil series series) (convergent_neg formula-decl nil convergence_ops analysis) (minus_real_is_real application-judgement "real" reals nil) (series_neg formula-decl nil series series) (cos_conv formula-decl nil sincos_def nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (infsum_by2s formula-decl nil series series) (real_plus_real_is_real application-judgement "real" reals nil) (rat_exp application-judgement "rat" exponentiation nil) (altsign const-decl "{i: int | i = -1 OR i = 1}" sincos_def nil) (nil application-judgement "above(n)" exp2 nil) (even_m1_pow formula-decl nil exponentiation nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (even_int nonempty-type-eq-decl nil integers nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div2 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (not_even_m1_pow formula-decl nil exponentiation nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inf_sum_gt_0 formula-decl nil series series) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (inf_sum_even_0 formula-decl nil pi_def nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (limit const-decl "real" convergence_sequences analysis) (convergent? const-decl "bool" convergence_sequences analysis) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil) (expt def-decl "real" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (cos const-decl "real" sincos_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints)) shostak)) (IMP_continuous_functions_props_TCC1 0 (IMP_continuous_functions_props_TCC1-1 nil 3706863225 ("" (assuming-tcc) nil nil) nil nil (IMP_continuous_functions_props assuming "analysis@continuous_functions_props[real].continuous_functions_props" "connected_domain: ASSUMPTION FORALL (x, y: continuous_functions_props.T), (z: reals.real): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), continuous_functions_props.T_pred(z))"))) (IMP_derivatives_TCC1 0 (IMP_derivatives_TCC1-1 nil 3706863225 ("" (rewrite "deriv_domain_real") nil nil) ((deriv_domain_real formula-decl nil deriv_domain analysis)) nil (IMP_derivatives assuming "analysis@derivatives[real].derivatives" "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?"))) (IMP_derivatives_TCC2 0 (IMP_derivatives_TCC2-1 nil 3706863225 ("" (expand "not_one_element?") (("" (skosimp*) (("" (inst + "x!1+1") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (not_one_element? const-decl "bool" deriv_domain_def analysis)) nil (IMP_derivatives assuming "analysis@derivatives[real].derivatives" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (poly_monincr_quad1_TCC1 0 (poly_monincr_quad1_TCC1-1 nil 3705934411 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (poly_monincr_quad1 subtype "((number_fields.+)(pi_def.n, 1))" "{i: integers.int | booleans.OR(pi_def.x /= 0, reals.>=(i, 0))}"))) (poly_monincr_quad1_TCC2 0 (poly_monincr_quad1_TCC2-1 nil 3705934411 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (poly_monincr_quad1 subtype "((number_fields.+)(pi_def.n, 1))" "{i: integers.int | booleans.OR(pi_def.y /= 0, reals.>=(i, 0))}"))) (poly_monincr_quad1 0 (poly_monincr_quad1-1 nil 3705934412 ("" (induct "n") (("1" (skeep) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (inst -1 "x" "y") (("2" (assert) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (mult-ineq -1 -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (expt def-decl "real" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (expt_x1 formula-decl nil exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (cos_mondecr_from1to2_prep 0 (cos_mondecr_from1to2_prep-1 nil 3706445642 ("" (skeep) (("" (lemma "inf_sum_even_0") (("" (expand "sin") (("" (expand "powerseq") (("" (expand "inf_sum") (("" (inst - "LAMBDA (k: nat): sin_coef(k) * c ^ k" "LAMBDA (k:nat): sin_coef(2*k+1) * c ^(2*k+1)") (("" (lemma "sin_conv") (("" (expand "conv_powerseries?") (("" (expand "powerseries") (("" (expand "powerseq") (("" (inst -1 "c") (("" (case " (FORALL (k_1: nat):
           sin_coef(2 * k_1 + 1) * c ^ (2 * k_1 + 1) =
            sin_coef(1 + 2 * k_1) * c ^ (1 + 2 * k_1)
            AND sin_coef(2 * k_1) * c ^ (2 * k_1) = 0)") (("1" (assert) (("1" (replaces -1 -3) (("1" (flatten) (("1" (replaces -3 1) (("1" (lemma "infsum_by2s") (("1" (inst -1 "LAMBDA (k: nat): sin_coef(1 + 2 * k) * c ^ (1 + 2 * k)" "LAMBDA (n:nat): sin_coef(4*n+1)*c^(4*n+1) + sin_coef(4*n+3)*c^(4*n+3)") (("1" (case "(FORALL (k_1: nat):
           sin_coef(4 * k_1 + 1) * c ^ (4 * k_1 + 1) +
            sin_coef(4 * k_1 + 3) * c ^ (4 * k_1 + 3)
            =
            sin_coef(1 + 2 * (2 * k_1)) * c ^ (1 + 2 * (2 * k_1)) +
             sin_coef(1 + 2 * (2 * k_1 + 1)) *
              c ^ (1 + 2 * (2 * k_1 + 1)))") (("1" (assert) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -3 1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "LAMBDA (n: nat):
                     sin_coef(1 + 4 * n) * c ^ (1 + 4 * n) +
                      sin_coef(3 + 4 * n) * c ^ (3 + 4 * n)") (("1" (assert) (("1" (case "(FORALL (n_1: nat):
           sin_coef(1 + 4 * n_1) * c ^ (1 + 4 * n_1) +
            sin_coef(3 + 4 * n_1) * c ^ (3 + 4 * n_1)
            > 0)") (("1" (assert) (("1" (expand "conv_series?") (("1" (replaces -1 -2) (("1" (assert) (("1" (expand "inf_sum") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem 1 "n") (("2" (expand "sin_coef") (("2" (expand "altsign") (("2" (expand "even?") (("2" (case "(2 + 4 * n) / 2 = 1 + 2*n AND 4 * n / 2 = 2*n") (("1" (flatten) (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "1 + 2 * n") (("1" (inst -2 "2 * n") (("1" (expand "even?") (("1" (case "(EXISTS j: 2 * n = 2 * j)") (("1" (replaces -1 -3) (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (move-terms 1 l 1) (("1" (case "0 - -1 / factorial(3 + 4 * n) * c ^ (3 + 4 * n) = 1 / factorial(3 + 4 * n) * c ^ (3 + 4 * n)") (("1" (replaces -1 1) (("1" (case "1 / factorial(3 + 4 * n) = (1/factorial(1+4*n)) * (1/((3+4*n)*(2+4*n)))") (("1" (replaces -1 1) (("1" (case "c ^ (3 + 4 * n) = c ^ (1 + 4 * n) * c^2") (("1" (replaces -1 1) (("1" (cross-mult 1) (("1" (factor 1 l) (("1" (name "F" "factorial(1 + 4 * n)") (("1" (name "P" "c ^ (1 + 4 * n)") (("1" (replace -1 1) (("1" (replace -2 1) (("1" (cancel-by 1 "F") (("1" (assert) (("1" (factor 1) (("1" (case "(P * (c ^ 2)) = P * c^2") (("1" (replaces -1 1) (("1" (case "2 * P * (3 + 10 * n + 8 * n * n) = P * (2 * (3 + 10 * n + 8 * n * n))") (("1" (replaces -1 1) (("1" (cancel-by 1 "P") (("1" (replace -3 -1 rl) (("1" (hide-all-but -1) (("1" (case "FORALL (n:nat): c^(1+4*n) > 0") (("1" (inst -1 "n") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (induct "n") (("1" (assert) nil nil) ("2" (skeep) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (assert) (("2" (case "c * (c * (c * (c * expt(c, 1 + 4 * j)))) = (c*c*c*c) * expt(c, 1 + 4 * j)") (("1" (replaces -1 1) (("1" (case "(c*c*c*c) > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "c") (("2" (mult-ineq -1 -1) (("2" (mult-ineq -1 -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "(2 * (3 + 10 * n + 8 * n * n)) > 4 AND 4 > c^2") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split) (("1" (assert) nil nil) ("2" (typepred "c") (("2" (mult-ineq -2 -2) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -2 2 rl) (("3" (hide-all-but 2) (("3" (case "FORALL (n:nat): c ^ (1 + 4 * n) > 0") (("1" (inst -1 "n") nil nil) ("2" (hide 2) (("2" (induct "n") (("1" (assert) nil nil) ("2" (skeep) (("2" (assert) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (case "(c*c*c*c) > 0") (("1" (mult-ineq -1 -2) (("1" (case "c * (c * (c * (c * expt(c, 1 + 4 * j)))) = (c*c*c*c)*expt(c, 1 + 4 * j)") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide - 2) (("2" (typepred "c") (("2" (mult-ineq -1 -1) (("2" (mult-ineq -1 -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "^") (("2" (expand "expt" 1 1) (("2" (expand "expt" 1 1) (("2" (expand "expt" 1 3) (("2" (expand "expt" 1 3) (("2" (expand "expt" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "factorial" 1 1) (("2" (expand "factorial" 1 1) (("2" (expand "factorial" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem 1 "k") (("2" (split) (("1" (assert) nil nil) ("2" (expand "sin_coef") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inf_sum_even_0 formula-decl nil pi_def nil) (powerseq const-decl "sequence[real]" power_series series) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sequence type-eq-decl nil sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sin_coef const-decl "real" sincos_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (conv_powerseries? const-decl "bool" power_series_conv series) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (inf_sum_gt_0 formula-decl nil series series) (even_plus_even_is_even application-judgement "even_int" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even? const-decl "bool" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (not_even_m1_pow formula-decl nil exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_45 skolem-const-decl "real" pi_def nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_neg_le1_imp formula-decl nil extra_real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_neg_le1 formula-decl nil real_props nil) (zero_times1 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (lt_times_lt_any1 formula-decl nil extra_real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (expt def-decl "real" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (times_div2 formula-decl nil real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (even_m1_pow formula-decl nil exponentiation nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (altsign const-decl "{i: int | i = -1 OR i = 1}" sincos_def nil) (conv_series? const-decl "bool" series series) (> const-decl "bool" reals nil) (infsum_by2s formula-decl nil series series) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (powerseries const-decl "sequence[real]" power_series series) (sin_conv formula-decl nil sincos_def nil) (inf_sum const-decl "real" series series) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sin const-decl "real" sincos_def nil)) shostak)) (cos_mondecr_from1to2 0 (cos_mondecr_from1to2-4 nil 3706443163 ("" (lemma "mean_value") (("" (skeep) (("" (inst -1 "s" "t" "cos") (("" (split) (("1" (skeep) (("1" (move-terms -3 r 2) (("1" (case "FORALL (a,b:real): (EXISTS (x:real): x > 0 AND a+x=b) IMPLIES a < b") (("1" (inst - "cos(t)" "cos(s)") (("1" (case "(EXISTS (x: real): x > 0 AND cos(t) + x = cos(s))") (("1" (replaces -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (move-terms -1 l 1) (("2" (case "cos(t) - deriv(cos, c) * (t - s) = cos(t) + (- deriv(cos, c) * (t - s))") (("1" (replaces -1 -2) (("1" (inst 1 "(-deriv(cos, c) * (t - s))") (("1" (split) (("1" (hide -1) (("1" (cancel-by 1 "(t-s)") (("1" (hide 1) (("1" (reveal -9) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "deriv_cos") (("2" (inst - "c") (("2" (expand "deriv" -1) (("2" (replaces -1 1) (("2" (case "--sin(c) = sin(c)") (("1" (replaces -1 1) (("1" (lemma "cos_mondecr_from1to2_prep") (("1" (inst - "c") (("1" (reveal (-16 -17)) (("1" (typepred "t") (("1" (typepred "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 2) (("3" (reveal -13) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "derivable_cos") (("2" (propax) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (derivable? const-decl "bool" derivatives_def analysis) (deriv const-decl "real" derivatives_def analysis) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (c skolem-const-decl "real" pi_def nil) (cos_mondecr_from1to2_prep formula-decl nil pi_def nil) (sin const-decl "real" sincos_def nil) (deriv const-decl "[T -> real]" derivatives analysis) (deriv_cos formula-decl nil sincos_def nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (neg_one_times formula-decl nil extra_tegies nil) (zero_div formula-decl nil extra_tegies nil) (nil application-judgement "above(n)" exp2 nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (zero_times1 formula-decl nil real_props nil) (div_mult_neg_le1 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_neg_le1_imp formula-decl nil extra_real_props nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (div_47 skolem-const-decl "real" pi_def nil) (/= const-decl "boolean" notequal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (derivable_cos formula-decl nil sincos_def nil) (cos const-decl "real" sincos_def nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (mean_value formula-decl nil derivative_props analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil) (cos_mondecr_from1to2-3 nil 3705946897 ("" (assert) (("" (lemma "negative_derivative") (("" (skeep) (("" (typepred "s") (("" (typepred "t") (("" (inst?) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (cos_mondecr_from1to2-2 nil 3705944393 ("" (skeep) (("" (lemma "cos_simp2") (("" (inst-cp -1 "s") (("" (inst -1 "t") (("" (assert) (("" (flatten) (("" (replaces -2 1) (("" (replaces -3 1) (("" (move-terms 1 r 1) (("" (case "inf_sum(LAMBDA (n: nat):
                                       s ^ (4 * n) / factorial(4 * n) -
                                        (s ^ (2 + 4 * n)) / factorial(2 + 4 * n))
                              -
                              inf_sum(LAMBDA (n: nat):
                                        t ^ (4 * n) / factorial(4 * n) -
                                         (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)) = inf_sum(LAMBDA (n: nat):
                                       s ^ (4 * n) / factorial(4 * n) -
                                        (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)) +
                              -(inf_sum(LAMBDA (n: nat):
                                        t ^ (4 * n) / factorial(4 * n) -
                                         (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)))") (("1" (replaces -1 1) (("1" (expand "inf_sum") (("1" (lemma "limit_neg") (("1" (inst -1 "series(LAMBDA (n: nat):
                               t ^ (4 * n) / factorial(4 * n) -
                                (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "limit_sum") (("1" (inst -1 "series(LAMBDA (n: nat):
                             s ^ (4 * n) / factorial(4 * n) -
                              (s ^ (2 + 4 * n)) / factorial(2 + 4 * n))" "-series(LAMBDA (n: nat):
                               t ^ (4 * n) / factorial(4 * n) -
                                (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_neg") (("1" (inst -1 "LAMBDA (n: nat):
                               t ^ (4 * n) / factorial(4 * n) -
                                (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_sum") (("1" (inst -1 "LAMBDA (n: nat):
                             s ^ (4 * n) / factorial(4 * n) -
                              (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)" "-(LAMBDA (n: nat):
                                t ^ (4 * n) / factorial(4 * n) -
                                 (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replaces -1 1 rl) (("1" (case "((LAMBDA (n: nat):
                                         s ^ (4 * n) / factorial(4 * n) -
                                          (s ^ (2 + 4 * n)) / factorial(2 + 4 * n))
                                       +
                                       -(LAMBDA (n: nat):
                                           t ^ (4 * n) / factorial(4 * n) -
                                            (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))) =
                   (LAMBDA (n:nat): s ^ (4 * n) / factorial(4 * n) -
                                          (s ^ (2 + 4 * n)) / factorial(2 + 4 * n) - t ^ (4 * n) / factorial(4 * n) +
                                            (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replaces -1 1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "LAMBDA (n: nat):
                                  s ^ (4 * n) / factorial(4 * n) -
                                   (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                   - t ^ (4 * n) / factorial(4 * n)
                                   + (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)") (("1" (case "conv_series?(LAMBDA (n: nat):
                                            s ^ (4 * n) / factorial(4 * n) -
                                             (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                             - t ^ (4 * n) / factorial(4 * n)
                                             + (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (case "(FORALL (n_1: nat):
                                     s ^ (4 * n_1) / factorial(4 * n_1) -
                                      (s ^ (2 + 4 * n_1)) / factorial(2 + 4 * n_1)
                                      - t ^ (4 * n_1) / factorial(4 * n_1)
                                      + (t ^ (2 + 4 * n_1)) / factorial(2 + 4 * n_1)
                                      > 0)") (("1" (assert) (("1" (hide -2 -4 -5 -6) (("1" (case "inf_sum(LAMBDA (n: nat):
                                               s ^ (4 * n) / factorial(4 * n) +
                                                (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                                - (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                                - t ^ (4 * n) / factorial(4 * n))
                                      > 0") (("1" (expand "inf_sum") (("1" (propax) nil))) ("2" (hide 2) (("2" (assert) nil))))))))) ("2" (hide - 2) (("2" (induct "n") (("1" (assert) (("1" (mult-by 1 "factorial(2)") (("1" (reveal -8) (("1" (assert) (("1" (case "FORALL (x:real): factorial(2) * ((x^(2)) / factorial(2)) = x^2") (("1" (inst-cp -1 "t") (("1" (inst -1 "s") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (field) (("1" (lemma "poly_monincr_quad1") (("1" (inst -1 "1" "t" "s") (("1" (assert) nil))))))))))))))) ("2" (assert) nil))))))))))) ("2" (skeep) (("2" (postpone) nil))))))))) ("2" (hide -1 -4 2) (("2" (lemma "series_sum_conv") (("2" (expand "conv_series?") (("2" (reveal -4) (("2" (assert) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (reveal -6) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (inst -1 "LAMBDA (n: nat):
                                           s ^ (4 * n) / factorial(4 * n) -
                                            (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)" "-(LAMBDA (n: nat):
                                              t ^ (4 * n) / factorial(4 * n) -
                                               (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("2" (assert) (("2" (hide -2 2) (("2" (lemma "seq_neg_conv") (("2" (inst -1 "series(LAMBDA (n: nat):
                                   t ^ (4 * n) / factorial(4 * n) -
                                    (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("2" (assert) (("2" (hide -2) (("2" (reveal -12) (("2" (replace -1 -2 rl) (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))))))))) ("2" (hide - 2) (("2" (postpone) nil))))))))))))))))))))))))))))))))))))))) ("2" (hide -1 2) (("2" (assert) nil))) ("3" (propax) nil) ("4" (propax) nil)))))))))))))))))))) nil) nil nil) (cos_mondecr_from1to2-1 nil 3705927575 ("" (skeep) (("" (lemma "cos_simp2") (("" (inst-cp -1 "s") (("" (inst -1 "t") (("" (assert) (("" (flatten) (("" (replaces -2 1) (("" (replaces -3 1) (("" (move-terms 1 r 1) (("" (case "inf_sum(LAMBDA (n: nat):
                                s ^ (4 * n) / factorial(4 * n) -
                                 (s ^ (2 + 4 * n)) / factorial(2 + 4 * n))
                       -
                       inf_sum(LAMBDA (n: nat):
                                 t ^ (4 * n) / factorial(4 * n) -
                                  (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)) = inf_sum(LAMBDA (n: nat):
                                s ^ (4 * n) / factorial(4 * n) -
                                 (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)) +
                       -(inf_sum(LAMBDA (n: nat):
                                 t ^ (4 * n) / factorial(4 * n) -
                                  (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)))") (("1" (replaces -1 1) (("1" (expand "inf_sum") (("1" (lemma "limit_neg") (("1" (inst -1 "series(LAMBDA (n: nat):
                           t ^ (4 * n) / factorial(4 * n) -
                            (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "limit_sum") (("1" (inst -1 "series(LAMBDA (n: nat):
                         s ^ (4 * n) / factorial(4 * n) -
                          (s ^ (2 + 4 * n)) / factorial(2 + 4 * n))" "-series(LAMBDA (n: nat):
                           t ^ (4 * n) / factorial(4 * n) -
                            (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_neg") (("1" (inst -1 "LAMBDA (n: nat):
                           t ^ (4 * n) / factorial(4 * n) -
                            (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_sum") (("1" (inst -1 "LAMBDA (n: nat):
                         s ^ (4 * n) / factorial(4 * n) -
                          (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)" "-(LAMBDA (n: nat):
                            t ^ (4 * n) / factorial(4 * n) -
                             (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replaces -1 1 rl) (("1" (case "((LAMBDA (n: nat):
                                s ^ (4 * n) / factorial(4 * n) -
                                 (s ^ (2 + 4 * n)) / factorial(2 + 4 * n))
                              +
                              -(LAMBDA (n: nat):
                                  t ^ (4 * n) / factorial(4 * n) -
                                   (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))) =
          (LAMBDA (n:nat): s ^ (4 * n) / factorial(4 * n) -
                                 (s ^ (2 + 4 * n)) / factorial(2 + 4 * n) - t ^ (4 * n) / factorial(4 * n) +
                                   (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (replaces -1 1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "LAMBDA (n: nat):
                            s ^ (4 * n) / factorial(4 * n) -
                             (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                             - t ^ (4 * n) / factorial(4 * n)
                             + (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)") (("1" (case "conv_series?(LAMBDA (n: nat):
                                 s ^ (4 * n) / factorial(4 * n) -
                                  (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                  - t ^ (4 * n) / factorial(4 * n)
                                  + (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("1" (case "(FORALL (n_1: nat):
                        s ^ (4 * n_1) / factorial(4 * n_1) -
                         (s ^ (2 + 4 * n_1)) / factorial(2 + 4 * n_1)
                         - t ^ (4 * n_1) / factorial(4 * n_1)
                         + (t ^ (2 + 4 * n_1)) / factorial(2 + 4 * n_1)
                         > 0)") (("1" (assert) (("1" (hide -2 -4 -5 -6) (("1" (case "inf_sum(LAMBDA (n: nat):
                                s ^ (4 * n) / factorial(4 * n) +
                                 (t ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                 - (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)
                                 - t ^ (4 * n) / factorial(4 * n))
                       > 0") (("1" (expand "inf_sum") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (induct "n") (("1" (assert) (("1" (mult-by 1 "factorial(2)") (("1" (reveal -8) (("1" (assert) (("1" (case "FORALL (x:real): factorial(2) * ((x^(2)) / factorial(2)) = x^2") (("1" (inst-cp -1 "t") (("1" (inst -1 "s") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (field) (("1" (lemma "poly_monincr_quad1") (("1" (inst -1 "1" "t" "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 2) (("2" (lemma "series_sum_conv") (("2" (expand "conv_series?") (("2" (reveal -4) (("2" (assert) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (reveal -6) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (inst -1 "LAMBDA (n: nat):
                                   s ^ (4 * n) / factorial(4 * n) -
                                    (s ^ (2 + 4 * n)) / factorial(2 + 4 * n)" "-(LAMBDA (n: nat):
                                      t ^ (4 * n) / factorial(4 * n) -
                                       (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("2" (assert) (("2" (hide -2 2) (("2" (lemma "series_neg_conv") (("2" (inst -1 "series(LAMBDA (n: nat):
                           t ^ (4 * n) / factorial(4 * n) -
                            (t ^ (2 + 4 * n)) / factorial(2 + 4 * n))") (("2" (assert) (("2" (hide -2) (("2" (reveal -12) (("2" (replace -1 -2 rl) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (assert) nil nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (pi_bound_prep 0 (pi_bound_prep-1 nil 3706462288 ("" (split) (("1" (name "plb2" "1/2 * pi_lb_new") (("1" (replace -1 1) (("1" (lemma "series_first_aux") (("1" (expand "cos") (("1" (expand "inf_sum") (("1" (expand "powerseq") (("1" (lemma "inf_sum_odd_0") (("1" (inst -1 "LAMBDA (k: nat): cos_coef(k) * plb2 ^ k" "LAMBDA (k:nat): cos_coef(2*k)*plb2^(2*k)") (("1" (case "(convergent?(series(LAMBDA (k: nat): cos_coef(k) * plb2 ^ k)) AND
        (FORALL (k_1: nat):
           cos_coef(2 * k_1 + 1) * plb2 ^ (2 * k_1 + 1) = 0))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (inst-cp -2 "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("1" (replace -1 -3) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n: nat):
                      cos_coef(2 * (n + 1)) * plb2 ^ (2 * (n + 1))") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(2 * (n + 1)) * plb2 ^ (2 * (n + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n_1: nat):
                        cos_coef(2 * (n_1 + 1 + 1)) *
                         plb2 ^ (2 * (n_1 + 1 + 1))") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(2 * (n_1 + 1 + 1)) *
                            plb2 ^ (2 * (n_1 + 1 + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n: nat):
                          cos_coef(2 * (n + 1 + 1 + 1)) *
                           plb2 ^ (2 * (n + 1 + 1 + 1))") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(2 * (n + 1 + 1 + 1)) *
                            plb2 ^ (2 * (n + 1 + 1 + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n_1: nat):
                            cos_coef(2 * (n_1 + 1 + 1 + 1 + 1)) *
                             plb2 ^ (2 * (n_1 + 1 + 1 + 1 + 1))") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(2 * (n_1 + 1 + 1 + 1 + 1)) *
                            plb2 ^ (2 * (n_1 + 1 + 1 + 1 + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n: nat):
                              cos_coef(2 * (n + 1 + 1 + 1 + 1 + 1)) *
                               plb2 ^ (2 * (n + 1 + 1 + 1 + 1 + 1))") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(2 * (n + 1 + 1 + 1 + 1 + 1)) *
                            plb2 ^ (2 * (n + 1 + 1 + 1 + 1 + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n_1: nat):
                                cos_coef(2 * (n_1 + 1 + 1 + 1 + 1 + 1 + 1))
                                 *
                                 plb2 ^
                                  (2 *
                                    (n_1 + 1 + 1 + 1 + 1 + 1 + 1))") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(2 * (n_1 + 1 + 1 + 1 + 1 + 1 + 1)) *
                            plb2 ^ (2 * (n_1 + 1 + 1 + 1 + 1 + 1 + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (inst-cp -2 "LAMBDA (n: nat):
                                  cos_coef(2
                                           *
                                           (n + 1 + 1 + 1 + 1 + 1 + 1 + 1))
                                   *
                                   plb2 ^
                                    (2
                                     *
                                     (n + 1 + 1 + 1 + 1 + 1 + 1
                                      +
                                      1))") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(2 * (n + 1 + 1 + 1 + 1 + 1 + 1 + 1)) *
                            plb2 ^ (2 * (n + 1 + 1 + 1 + 1 + 1 + 1 + 1))))") (("1" (replaces -1 -4) (("1" (replaces -3 1) (("1" (assert) (("1" (case " cos_coef(0) +
       limit(series(LAMBDA (n_1: nat):
                      cos_coef(16 + 2 * n_1) * plb2 ^ (16 + 2 * n_1)))
       + cos_coef(2) * plb2 ^ (2)
       + cos_coef(4) * plb2 ^ (4)
       + cos_coef(6) * plb2 ^ (6)
       + cos_coef(8) * plb2 ^ (8)
       + cos_coef(10) * plb2 ^ (10)
       + cos_coef(12) * plb2 ^ (12)
       + cos_coef(14) * plb2 ^ (14) =  cos_coef(0) +
        cos_coef(2) * plb2 ^ (2)
       + cos_coef(4) * plb2 ^ (4)
       + cos_coef(6) * plb2 ^ (6)
       + cos_coef(8) * plb2 ^ (8)
       + cos_coef(10) * plb2 ^ (10)
       + cos_coef(12) * plb2 ^ (12)
       + cos_coef(14) * plb2 ^ (14) + (limit(series(LAMBDA (n_1: nat):
                      cos_coef(16 + 2 * n_1) * plb2 ^ (16 + 2 * n_1))))") (("1" (replaces -1 1) (("1" (name "FRONT" " cos_coef(0) + cos_coef(2) * plb2 ^ (2) + cos_coef(4) * plb2 ^ (4) +
       cos_coef(6) * plb2 ^ (6)
       + cos_coef(8) * plb2 ^ (8)
       + cos_coef(10) * plb2 ^ (10)
       + cos_coef(12) * plb2 ^ (12)
       + cos_coef(14) * plb2 ^ (14)") (("1" (replace -1 1) (("1" (hide-all-but 1) (("1" (lemma "infsum_by2s") (("1" (inst -1 "LAMBDA (n_1: nat):
                       cos_coef(16 + 2 * n_1) * plb2 ^ (16 + 2 * n_1)" "LAMBDA (n_1:nat):  cos_coef(16 + 4 * n_1) * plb2 ^ (16 + 4 * n_1) +  cos_coef(18 + 4 * n_1) * plb2 ^ (18 + 4 * n_1)") (("1" (case " (convergent?(series(LAMBDA (n_1: nat):
                            cos_coef(16 + 2 * n_1) *
                             plb2 ^ (16 + 2 * n_1)))
        AND
        (FORALL k:
           cos_coef(16 + 4 * k) * plb2 ^ (16 + 4 * k) +
            cos_coef(18 + 4 * k) * plb2 ^ (18 + 4 * k)
            =
            cos_coef(16 + 2 * (2 * k)) * plb2 ^ (16 + 2 * (2 * k)) +
             cos_coef(16 + 2 * (2 * k + 1)) *
              plb2 ^ (16 + 2 * (2 * k + 1))))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "LAMBDA (n_1: nat):
                      cos_coef(16 + 4 * n_1) * plb2 ^ (16 + 4 * n_1) +
                       cos_coef(18 + 4 * n_1) * plb2 ^ (18 + 4 * n_1)") (("1" (case "(conv_series?(LAMBDA (n_1: nat):
                      cos_coef(16 + 4 * n_1) * plb2 ^ (16 + 4 * n_1) +
                       cos_coef(18 + 4 * n_1) * plb2 ^ (18 + 4 * n_1))
        AND
        (FORALL (n: nat):
           cos_coef(16 + 4 * n) * plb2 ^ (16 + 4 * n) +
            cos_coef(18 + 4 * n) * plb2 ^ (18 + 4 * n)
            > 0))") (("1" (replaces -1 -2) (("1" (case "FRONT > 0") (("1" (case "FORALL (x,y:real): (x>0 AND y>0) IMPLIES x+y>0") (("1" (inst -1 "FRONT" "inf_sum(LAMBDA (n_1: nat):
                cos_coef(16 + 4 * n_1) * plb2 ^ (16 + 4 * n_1) +
                 cos_coef(18 + 4 * n_1) * plb2 ^ (18 + 4 * n_1))") (("1" (replace -2 -1) (("1" (replace -3 -1) (("1" (case "FRONT +
       limit(series(LAMBDA (n_1: nat):
                      cos_coef(16 + 4 * n_1) * plb2 ^ (16 + 4 * n_1) +
                       cos_coef(18 + 4 * n_1) * plb2 ^ (18 + 4 * n_1))) = FRONT +
       inf_sum(LAMBDA (n_1: nat):
                 cos_coef(16 + 4 * n_1) * plb2 ^ (16 + 4 * n_1) +
                  cos_coef(18 + 4 * n_1) * plb2 ^ (18 + 4 * n_1))") (("1" (replaces -1 1) nil nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (expand "inf_sum") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand "conv_series?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "conv_series?") (("2" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal (-8 -11)) (("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (expand "pi_lb_new") (("2" (expand "^" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (expand "^") (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (expand "factorial" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "conv_series?") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (skeep) (("2" (case "even?((16 + 4 * n) / 2) AND NOT even?((18 + 4 * n) / 2)") (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "(18 + 4 * n) / 2") (("1" (inst -2 "(16 + 4 * n) / 2") (("1" (flatten) (("1" (replaces -3 -2) (("1" (replaces 1 -1) (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (move-terms 1 l 2) (("1" (assert) (("1" (case "-1 * (-1 / factorial(18 + 4 * n) * plb2 ^ (18 + 4 * n)) = 1 / factorial(18 + 4 * n) * plb2 ^ (18 + 4 * n)") (("1" (replaces -1 1) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (expand "expt" 1 2) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 3) (("1" (factor 1 l) (("1" (cancel-by 1 "factorial(16 + 4 * n)") (("1" (hide-all-but 1) (("1" (case "2 * (expt(plb2, (16 + 4 * n)) * (153 + 70 * n + 8 * n * n)) = expt(plb2, 16 + 4 * n) * 2 * (153 + 70 * n + 8 * n * n)") (("1" (replaces -1 1) (("1" (cancel-by 1 "expt(plb2, 16 + 4 * n)") (("1" (hide-all-but 1) (("1" (expand "plb2") (("1" (expand "pi_lb_new") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "(16 + 4 * n) / 2 = 8 + 2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case-replace "(18 + 4 * n) / 2 = 9+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "even?") (("2" (inst 1 "4+n") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (case-replace "(18 + 4 * n) / 2 = 9+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (case-replace "(16 + 4 * n) / 2 = 8+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (split) (("1" (reveal -21) (("1" (assert) (("1" (lemma "tail_series_conv") (("1" (inst -1 "7" "LAMBDA (n: nat):
                           cos_coef(2 + 2 * n) * plb2 ^ (2 + 2 * n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "tail_series_conv") (("2" (assert) (("2" (inst -1 "7" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "tail_series_conv") (("2" (assert) (("2" (inst -1 "6" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "tail_series_conv") (("2" (inst -1 "5" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "4" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "3" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "2" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "1" "LAMBDA (k: nat): cos_coef(2 * k) * plb2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but 1) (("1" (lemma "cos_conv") (("1" (expand "conv_powerseries?") (("1" (inst -1 "plb2") (("1" (expand "powerseries") (("1" (expand "powerseq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "cos_coef") (("2" (expand "even?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "pub2" "1/2 * pi_ub_new") (("2" (replace -1 1) (("2" (hide -1) (("2" (expand "cos") (("2" (expand "powerseq") (("2" (lemma "inf_sum_odd_0") (("2" (inst -1 "LAMBDA (k: nat): cos_coef(k) * pub2 ^ k" "LAMBDA (k:nat): cos_coef(2*k)*pub2^(2*k)") (("2" (case "(convergent?(series(LAMBDA (k: nat): cos_coef(k) * pub2 ^ k)) AND
        (FORALL (k_1: nat):
           cos_coef(2 * k_1 + 1) * pub2 ^ (2 * k_1 + 1) = 0))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (replaces -2 1) (("1" (lemma "series_first_aux") (("1" (expand "inf_sum") (("1" (inst-cp -1 "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("1" (assert) (("1" (replaces -2 1) (("1" (inst-cp -1 "LAMBDA (n: nat):
                      cos_coef(2 + 2 * n) * pub2 ^ (2 + 2 * n)") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(2 + 2 * n) * pub2 ^ (2 + 2 * n)))") (("1" (assert) (("1" (replaces -3 1) (("1" (hide -1) (("1" (inst-cp -1 "LAMBDA (n_1: nat):
                       cos_coef(4 + 2 * n_1) * pub2 ^ (4 + 2 * n_1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(4 + 2 * n_1) * pub2 ^ (4 + 2 * n_1)))") (("1" (assert) (("1" (replaces -3 1) (("1" (hide -1) (("1" (inst-cp -1 "LAMBDA (n: nat):
                       cos_coef(6 + 2 * n) * pub2 ^ (6 + 2 * n)") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(6 + 2 * n) * pub2 ^ (6 + 2 * n)))") (("1" (assert) (("1" (replaces -3 1) (("1" (hide -1) (("1" (inst-cp -1 "LAMBDA (n_1: nat):
                       cos_coef(8 + 2 * n_1) * pub2 ^ (8 + 2 * n_1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(8 + 2 * n_1) * pub2 ^ (8 + 2 * n_1)))") (("1" (assert) (("1" (replaces -3 1) (("1" (hide -1) (("1" (inst-cp -1 "LAMBDA (n: nat):
                       cos_coef(10 + 2 * n) * pub2 ^ (10 + 2 * n)") (("1" (case "convergent?(series(LAMBDA (n: nat):
                           cos_coef(10 + 2 * n) * pub2 ^ (10 + 2 * n)))") (("1" (assert) (("1" (replaces -3 1) (("1" (hide -1) (("1" (inst -1 "LAMBDA (n_1: nat):
                       cos_coef(12 + 2 * n_1) * pub2 ^ (12 + 2 * n_1)") (("1" (case "convergent?(series(LAMBDA (n_1: nat):
                           cos_coef(12 + 2 * n_1) * pub2 ^ (12 + 2 * n_1)))") (("1" (assert) (("1" (replaces -2 1) (("1" (hide -1) (("1" (case "cos_coef(0) +
       (limit(series(LAMBDA (n: nat):
                       cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n)))
         + cos_coef(12) * pub2 ^ (12))
       + cos_coef(2) * pub2 ^ (2)
       + cos_coef(4) * pub2 ^ (4)
       + cos_coef(6) * pub2 ^ (6)
       + cos_coef(8) * pub2 ^ (8)
       + cos_coef(10) * pub2 ^ (10) = cos_coef(0) + cos_coef(2) * pub2 ^ (2)
       + cos_coef(4) * pub2 ^ (4)
       + cos_coef(6) * pub2 ^ (6)
       + cos_coef(8) * pub2 ^ (8)
       + cos_coef(10) * pub2 ^ (10) + cos_coef(12) * pub2 ^ (12) + limit(series(LAMBDA (n: nat):
                       cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n)))") (("1" (replaces -1 1) (("1" (name-replace "FIRST" "cos_coef(0) + cos_coef(2) * pub2 ^ (2) + cos_coef(4) * pub2 ^ (4) +
       cos_coef(6) * pub2 ^ (6)
       + cos_coef(8) * pub2 ^ (8)
       + cos_coef(10) * pub2 ^ (10)
       + cos_coef(12) * pub2 ^ (12)") (("1" (case "FIRST < 0") (("1" (case "limit(series(LAMBDA (n: nat):
                      cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n))) < 0") (("1" (case "FORALL (x,y:real): (x<0 AND y<0) IMPLIES x+y<0") (("1" (inst -1 "FIRST" "limit(series(LAMBDA (n: nat):
                     cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n)))") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "-limit(series(LAMBDA (n: nat):
                     cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n)))
       > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "infsum_by2s") (("2" (inst -1 "LAMBDA (n: nat):
                      cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n)" "LAMBDA (n:nat): cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) + cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n)") (("2" (case "(convergent?(series(LAMBDA (n: nat):
                            cos_coef(14 + 2 * n) * pub2 ^ (14 + 2 * n)))
        AND
        (FORALL k:
           cos_coef(14 + 4 * k) * pub2 ^ (14 + 4 * k) +
            cos_coef(16 + 4 * k) * pub2 ^ (16 + 4 * k)
            =
            cos_coef(14 + 2 * (2 * k)) * pub2 ^ (14 + 2 * (2 * k)) +
             cos_coef(14 + 2 * (2 * k + 1)) *
              pub2 ^ (14 + 2 * (2 * k + 1))))") (("1" (replaces -1 -2) (("1" (flatten) (("1" (expand "inf_sum") (("1" (replaces -2 1) (("1" (lemma "limit_neg") (("1" (inst -1 "series(LAMBDA (n: nat):
                      cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                       cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n))") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "series_neg") (("1" (inst -1 "LAMBDA (n: nat):
                      cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                       cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n)") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "inf_sum_gt_0") (("1" (inst -1 "-(LAMBDA (n: nat):
                       cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                        cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n))") (("1" (case "(conv_series?(-(LAMBDA (n: nat):
                        cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                         cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n)))
        AND
        (FORALL (n_1: nat):
           (-(LAMBDA (n: nat):
                cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                 cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n)))
               (n_1)
            > 0))") (("1" (replaces -1 -2) (("1" (expand "inf_sum") (("1" (propax) nil nil)) nil)) nil) ("2" (split 1) (("1" (expand "conv_series?") (("1" (lemma "series_neg") (("1" (inst -1 "LAMBDA (n: nat):
                             cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                              cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n)") (("1" (replaces -1 1) (("1" (lemma "convergent_neg") (("1" (inst -1 "series(LAMBDA (n: nat):
                           cos_coef(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
                            cos_coef(16 + 4 * n) * pub2 ^ (16 + 4 * n))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "-") (("2" (expand "cos_coef") (("2" (expand "altsign") (("2" (skolem 1 "n") (("2" (lemma "even_m1_pow") (("2" (lemma "not_even_m1_pow") (("2" (case "even?((16 + 4 * n) / 2) AND NOT even?((14 + 4 * n) / 2)") (("1" (flatten) (("1" (inst -2 "(14 + 4 * n) / 2") (("1" (inst -3 "(16 + 4 * n) / 2") (("1" (replaces -1 -3) (("1" (replaces 1 -1) (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (case "-(-1 / factorial(14 + 4 * n) * pub2 ^ (14 + 4 * n) +
         1 / factorial(16 + 4 * n) * pub2 ^ (16 + 4 * n)) = 1 / factorial(14 + 4 * n) * pub2 ^ (14 + 4 * n) -
         1 / factorial(16 + 4 * n) * pub2 ^ (16 + 4 * n)") (("1" (replaces -1 1) (("1" (move-terms 1 l 2) (("1" (assert) (("1" (cross-mult) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (expand "expt" 1 2) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 3) (("1" (factor 1 l) (("1" (cancel-by 1 "factorial(14+4*n)") (("1" (hide - 2) (("1" (case "4 * (expt(pub2, (14 + 4 * n)) * (60 + 31 * n + 4 * n * n)) = expt(pub2, 14 + 4 * n) * 4 * (60 + 31 * n + 4 * n * n)") (("1" (replaces -1 1) (("1" (cancel-by 1 "expt(pub2, 14 + 4 * n)") (("1" (hide - 2) (("1" (expand "pub2") (("1" (expand "pi_ub_new") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "(16 + 4 * n) / 2 = 8+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case-replace "(14 + 4 * n) / 2 = 7+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "even?") (("2" (inst 1 "4+n") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (case-replace "(14 + 4 * n) / 2 = 7+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (case-replace "(16 + 4 * n) / 2 = 8+2*n") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (split) (("1" (reveal -4) (("1" (lemma "tail_series_conv") (("1" (inst -1 "7" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "FIRST") (("2" (expand "cos_coef") (("2" (expand "pub2") (("2" (expand "altsign") (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "factorial") (("2" (expand "pi_ub_new") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "6" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "5" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "4" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "3" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "2" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tail_series_conv") (("2" (inst -1 "1" "LAMBDA (k: nat): cos_coef(2 * k) * pub2 ^ (2 * k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (split) (("1" (lemma "cos_conv") (("1" (expand "conv_powerseries?") (("1" (inst - "pub2") (("1" (expand "powerseries") (("1" (expand "powerseq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cos_coef") (("2" (expand "even?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_ub_new const-decl "posreal" pi_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FIRST skolem-const-decl "real" pi_def nil) (minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[T -> real]" real_fun_ops reals) (convergent_neg formula-decl nil convergence_ops analysis) (n skolem-const-decl "nat" pi_def nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posint nonempty-type-eq-decl nil integers nil) (pub2 skolem-const-decl "posreal" pi_def nil) (series_neg formula-decl nil series series) (limit_neg formula-decl nil convergence_ops analysis) (< const-decl "bool" reals nil) (pi_lb_new const-decl "posreal" pi_def nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (series_first_aux formula-decl nil pi_def nil) (inf_sum const-decl "real" series series) (inf_sum_odd_0 formula-decl nil pi_def nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (convergent? const-decl "bool" convergence_sequences analysis) (series const-decl "sequence[real]" series series) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_exp application-judgement "posreal" exponentiation nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt_x0 formula-decl nil exponentiation nil) (infsum_by2s formula-decl nil series series) (even_m1_pow formula-decl nil exponentiation nil) (n skolem-const-decl "nat" pi_def nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div2 formula-decl nil real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (not_even_m1_pow formula-decl nil exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (expt def-decl "real" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (altsign const-decl "{i: int | i = -1 OR i = 1}" sincos_def nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (factorial def-decl "posnat" factorial ints) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nil application-judgement "above(n)" exp2 nil) (factorial_0 formula-decl nil factorial ints) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posrat_expt application-judgement "posrat" exponentiation nil) (plb2 skolem-const-decl "posreal" pi_def nil) (conv_series? const-decl "bool" series series) (inf_sum_gt_0 formula-decl nil series series) (tail_series_conv formula-decl nil series series) (limit const-decl "real" convergence_sequences analysis) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (conv_powerseries? const-decl "bool" power_series_conv series) (powerseries const-decl "sequence[real]" power_series series) (cos_conv formula-decl nil sincos_def nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sequence type-eq-decl nil sequences nil) (cos_coef const-decl "real" sincos_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (powerseq const-decl "sequence[real]" power_series series) (cos const-decl "real" sincos_def nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)) shostak)) (piby2_prep 0 (piby2_prep-1 nil 3704806676 ("" (lemma "intermediate2") (("" (inst -1 "1" "2" "cos" "0") (("1" (lemma "cos1_gt_0") (("1" (lemma "cos2_lt_0") (("1" (assert) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (skeep) (("1" (inst -6 "c") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "derivable_cos") (("2" (lemma "derivable_cont_fun") (("2" (inst -1 "cos") (("2" (replaces -2 -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cos const-decl "real" sincos_def nil) (continuous? const-decl "bool" continuous_functions analysis) (bool nonempty-type-eq-decl nil booleans nil) (cos2_lt_0 formula-decl nil pi_def nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cos1_gt_0 formula-decl nil pi_def nil) (derivable_cos formula-decl nil sincos_def nil) (derivable_cont_fun formula-decl nil derivatives analysis) (intermediate2 formula-decl nil continuous_functions_props analysis) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) shostak)) (pi_unique 0 (pi_unique-1 nil 3704806685 ("" (expand "singleton?") (("" (lemma "piby2_prep") (("" (expand "nonempty?") (("" (expand "empty?") (("" (skolem 1 "pi") (("" (inst 1 "pi") (("1" (skeep) (("1" (lemma "cos_mondecr_from1to2") (("1" (inst-cp -1 "pi" "y") (("1" (inst -1 "y" "pi") (("1" (split) (("1" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((piby2_prep formula-decl nil pi_def nil) (empty? const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cos const-decl "real" sincos_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (pi skolem-const-decl "real" pi_def nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cos_mondecr_from1to2 formula-decl nil pi_def nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (singleton? const-decl "bool" sets nil)) shostak)) (pi_TCC1 0 (pi_TCC1-3 nil 3706605863 ("" (lemma "piby2_prep") (("" (inst + "choose[real]({x: real | x > 2 AND x < 4 AND cos(x/2) = 0})") (("" (assert) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skosimp*) (("" (inst - "2*x!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (member const-decl "bool" sets nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (piby2_prep formula-decl nil pi_def nil)) nil (pi existence "" "{x: reals.real | booleans.AND(reals.>(x, 2), booleans.AND(reals.<(x, 4), sincos_def.cos(number_fields./(x, 2)) = 0))}")) (pi_TCC1-2 nil 3706605602 ("" (lemma "piby2_prep") (("" (inst + "choose[real]({x: real | x > 2 AND x < 2 AND cos(x/2) = 0})") (("1" (assert) nil nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skosimp*) (("2" (inst - "2*x!1") (("2" (mult-by -1 "2") (("2" (mult-by -2 "2") (("2" (replace -3) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (pi existence "" "{x: reals.real | booleans.AND(reals.>(x, 2), booleans.AND(reals.<(x, 4), sincos_def.cos(number_fields./(x, 2)) = 0))}")) (pi_TCC1-1 nil 3706605559 ("" (existence-tcc) nil nil) nil nil (pi existence "" "{x: reals.real | booleans.AND(reals.>(x, 2), booleans.AND(reals.<(x, 4), sincos_def.cos(number_fields./(x, 2)) = 0))}"))) (pi_bound 0 (pi_bound-1 nil 3704716057 ("" (typepred "pi") (("" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (mult-by 1 "1/2") (("3" (assert) (("3" (flip-ineq 1) (("3" (lemma "cos_mondecr_from1to2") (("3" (inst -1 "pi/2" "1/2 * pi_lb_new") (("1" (assert) (("1" (case "cos(pi/2) = 0") (("1" (replaces -1 -2) (("1" (hide -2) (("1" (expand "pi_lb_new") (("1" (flip-ineq -1) (("1" (lemma "pi_bound_prep") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "pi_lb_new") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (mult-by 1 "1/2") (("4" (assert) (("4" (flip-ineq 1) (("4" (lemma "cos_mondecr_from1to2") (("4" (inst -1 "1/2 * pi_ub_new" "pi/2") (("1" (assert) (("1" (case "cos(pi/2)=0") (("1" (replaces -1 -2) (("1" (hide -2) (("1" (expand "pi_ub_new") (("1" (flip-ineq -1) (("1" (lemma "pi_bound_prep") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "pi_ub_new") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cos_mondecr_from1to2 formula-decl nil pi_def nil) (TRUE const-decl "bool" booleans nil) (pi_bound_prep formula-decl nil pi_def nil) (nil application-judgement "above(n)" exp2 nil) (<= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (pi_lb_new const-decl "posreal" pi_def nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (pi_ub_new const-decl "posreal" pi_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def nil)) nil (pi_bound subtype "pi_def.pi" "{r: real_types.posreal | booleans.AND(reals.<=(pi_def.pi_lb_new, r), reals.<=(r, pi_def.pi_ub_new))}"))) (sin_pi2_pos 1 (sin_pi2_pos-2 "" 3882922858 ("" (trigsimp "sin" 1) (("" (lemma "infsum_by2s") (("" (inst -1 "(LAMBDA (n: nat):
                          sin_coef(1 + 2 * n) * (pi / 2) ^ (1 + 2 * n))" "(LAMBDA (n: nat):
                          sin_coef(1 + 4 * n) * (pi / 2) ^ (1 + 4 * n) +
                          sin_coef(3 + 4 * n) * (pi / 2) ^ (3 + 4 * n))") (("" (assert) (("" (flatten) (("" (expand "inf_sum") (("" (replaces -2 1) (("" (lemma "inf_sum_gt_0") (("" (inst -1 "(LAMBDA (n: nat):
                          sin_coef(1 + 4 * n) * (pi / 2) ^ (1 + 4 * n) +
                           sin_coef(3 + 4 * n) * (pi / 2) ^ (3 + 4 * n))") (("" (expand "conv_series?") (("" (assert) (("" (split) (("1" (expand "inf_sum") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skolem 1 "n") (("2" (expand "sin_coef") (("2" (expand "altsign") (("2" (expand "even?") (("2" (case-replace "(2 + 4 * n) / 2 = 1+2*n") (("1" (case-replace "4 * n / 2 = 2 * n") (("1" (hide-all-but 1) (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "1+2*n") (("1" (inst -2 "2*n") (("1" (assert) (("1" (expand "even?") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (move-terms 1 l 1) (("1" (assert) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (expand "expt" 1 2) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 3) (("1" (factor 1) (("1" (cancel-by 1 "factorial(1+4*n)") (("1" (cancel-by 1 "expt((pi / 2), (1 + 4 * n))") (("1" (hide-all-but 1) (("1" (typepred "pi") (("1" (mult-by -4 "1/2") (("1" (mult-ineq -1 -1) (("1" (case "(2 * (3 + 10 * n + 8 * n * n)) > (pi_ub_new * (1 / 2)) * (pi_ub_new * (1 / 2))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "pi_ub_new") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (sin_pi2_pos-1 nil 3707555038 ("" (trigsimp "sin" 1) (("" (lemma "infsum_by2s") (("" (inst -1 "(LAMBDA (n: nat):
                          sin_coef(1 + 2 * n) * (pi / 2) ^ (1 + 2 * n))" "(LAMBDA (n: nat):
                          sin_coef(1 + 4 * n) * (pi / 2) ^ (1 + 4 * n) +
                          sin_coef(3 + 4 * n) * (pi / 2) ^ (3 + 4 * n))") (("" (assert) (("" (flatten) (("" (expand "inf_sum") (("" (replaces -2 1) (("" (lemma "inf_sum_gt_0") (("" (inst -1 "(LAMBDA (n: nat):
                          sin_coef(1 + 4 * n) * (pi / 2) ^ (1 + 4 * n) +
                           sin_coef(3 + 4 * n) * (pi / 2) ^ (3 + 4 * n))") (("" (expand "conv_series?") (("" (assert) (("" (split) (("1" (expand "inf_sum") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skolem 1 "n") (("2" (expand "sin_coef") (("2" (expand "altsign") (("2" (expand "even?") (("2" (case-replace "(2 + 4 * n) / 2 = 1+2*n") (("1" (case-replace "4 * n / 2 = 2 * n") (("1" (hide-all-but 1) (("1" (lemma "even_m1_pow") (("1" (lemma "not_even_m1_pow") (("1" (inst -1 "1+2*n") (("1" (inst -2 "2*n") (("1" (assert) (("1" (expand "even?") (("1" (replaces -1 1) (("1" (replaces -1 1) (("1" (move-terms 1 l 1) (("1" (assert) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (expand "expt" 1 2) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 1) (("1" (expand "factorial" 1 3) (("1" (factor 1) (("1" (cancel-by 1 "factorial(1+4*n)") (("1" (cancel-by 1 "expt((pi / 2), (1 + 4 * n))") (("1" (hide-all-but 1) (("1" (typepred "pi") (("1" (mult-by -7 "1/2") (("1" (mult-ineq -1 -1) (("1" (case "(2 * (3 + 10 * n + 8 * n * n)) > (pi_ub_new * (1 / 2)) * (pi_ub_new * (1 / 2))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "pi_ub_new") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sin const-decl "real" sincos_def nil) (powerseq const-decl "sequence[real]" power_series series) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (inf_sum_even_0 formula-decl nil pi_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def nil) (cos const-decl "real" sincos_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (sin_coef const-decl "real" sincos_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (TRUE const-decl "bool" booleans nil) (posreal_exp application-judgement "posreal" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (conv_powerseries? const-decl "bool" power_series_conv series) (powerseries const-decl "sequence[real]" power_series series) (sin_conv formula-decl nil sincos_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inf_sum const-decl "real" series series) (real_plus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even? const-decl "bool" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (even_m1_pow formula-decl nil exponentiation nil) (nil application-judgement "above(n)" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (times_div2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (times_div1 formula-decl nil real_props nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (expt def-decl "real" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (odd? const-decl "bool" integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (le_times_le_any1 formula-decl nil extra_real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (pi_ub_new const-decl "posreal" pi_def nil) (pi_lb_new const-decl "posreal" pi_def nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (not_even_m1_pow formula-decl nil exponentiation nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (altsign const-decl "{i: int | i = -1 OR i = 1}" sincos_def nil) (conv_series? const-decl "bool" series series) (inf_sum_gt_0 formula-decl nil series series) (infsum_by2s formula-decl nil series series)) nil)))
