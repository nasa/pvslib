(complex_props
 (add_eq_0 0
  (add_eq_0-1 nil 3744902909
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (decompose-equality 1)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (decompose-equality 1)
          (("1" (isolate 1 l 1)
            (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
           ("2" (isolate 1 l 1)
            (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((Im_neg1 formula-decl nil complex_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (Re_neg1 formula-decl nil complex_types nil)
    (- const-decl "complex" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (+ const-decl "complex" complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (Im_add1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_add1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (minus_eq_0 0
  (minus_eq_0-1 nil 3743433899
   ("" (skeep)
    (("" (split 1)
      (("1" (flatten)
        (("1" (decompose-equality 1)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil)
       ("2" (flatten) (("2" (decompose-equality 1) nil nil)) nil))
      nil))
    nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "complex" complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Im_sub1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (Re_sub1 formula-decl nil complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (complex_mult_unity 0
  (complex_mult_unity-1 nil 3744904614
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (Im_mul1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Re_mul1 formula-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (* const-decl "complex" complex_types nil))
   shostak))
 (complex_mult_unity2 0
  (complex_mult_unity2-1 nil 3744904661
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (Im_mul1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Re_mul1 formula-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (* const-decl "complex" complex_types nil))
   shostak))
 (complex_div_unity_TCC1 0
  (complex_div_unity_TCC1-1 nil 3743433417 ("" (subtype-tcc) nil nil)
   ((complex_ const-decl "complex" complex_types nil)) nil))
 (complex_div_unity 0
  (complex_div_unity-1 nil 3744904708
   ("" (skeep)
    (("" (rewrite "complex_div_cancel3")
      (("" (rewrite "complex_mult_unity") nil nil)) nil))
    nil)
   ((complex_div_cancel3 formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_mult_unity formula-decl nil complex_props nil))
   shostak))
 (complex_add_unity 0
  (complex_add_unity-1 nil 3744904807
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (Im_add1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_add1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (+ const-decl "complex" complex_types nil))
   shostak))
 (complex_minus_unity 0
  (complex_minus_unity-1 nil 3744904842
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Im_sub1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_sub1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (- const-decl "complex" complex_types nil))
   shostak))
 (real_complex_minus 0
  (real_complex_minus-1 nil 3744905014
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (Im_neg1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_neg1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (- const-decl "complex" complex_types nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (real_times_real 0
  (real_times_real-1 nil 3744905667
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (Im_mul1 formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Re_mul1 formula-decl nil complex_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (* const-decl "complex" complex_types nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (complex_div_eq 0
  (complex_div_eq-1 nil 3744903233
   ("" (skeep)
    (("" (rewrite "complex_div_cancel3")
      (("" (rewrite "complex_mult_unity2") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((complex_div_cancel3 formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_mult_unity2 formula-decl nil complex_props nil))
   shostak))
 (complex_div_eq2 0
  (complex_div_eq2-1 nil 3744904967
   ("" (skeep)
    (("" (rewrite "complex_div_cancel3")
      (("" (rewrite "real_complex_minus")
        (("" (case "-complex_(1, 0) * n0y = -(complex_(1, 0) * n0y)")
          (("1" (replace -1)
            (("1" (rewrite "complex_mult_unity2")
              (("1" (assert) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (complex_div_cancel3 formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "complex" complex_types nil)
    (- const-decl "complex" complex_types nil)
    (complex_mult_unity2 formula-decl nil complex_props nil)
    (neg_nzcomplex application-judgement "nzcomplex" complex_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_complex_minus formula-decl nil complex_props nil))
   shostak))
 (add_div1 0
  (add_div1-1 nil 3744905573
   ("" (skeep)
    (("" (rewrite "complex_div_cancel4")
      (("" (lemma "complex_commutative_mult")
        (("" (inst -1 "(x / n0x) + (y / n0y)" "n0x * n0y")
          (("" (replace -1 :hide? t)
            (("" (rewrite "complex_mult_distrib_plus")
              (("" (case "n0x * n0y * (x / n0x) = x * n0y")
                (("1" (replace -1 :hide? t)
                  (("1" (case "n0x * n0y * (y / n0y) = y * n0x")
                    (("1" (replace -1 :hide? t)
                      (("1" (propax) nil nil)) nil)
                     ("2" (hide 2)
                      (("2" (rewrite "complex_associative_mult")
                        (("2" (rewrite "complex_div_cancel1")
                          (("2" (rewrite "complex_commutative_mult") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (rewrite "complex_commutative_mult")
                    (("2" (rewrite "complex_associative_mult")
                      (("2" (rewrite "complex_div_cancel1")
                        (("2" (rewrite "complex_commutative_mult") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mul_nzcomplex1 application-judgement "nzcomplex" complex_types
     nil)
    (complex_div_cancel4 formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (* const-decl "complex" complex_types nil)
    (+ const-decl "complex" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (complex_mult_distrib_plus formula-decl nil complex_types nil)
    (complex_div_cancel1 formula-decl nil complex_types nil)
    (complex_associative_mult formula-decl nil complex_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mult_commutes formula-decl nil fundamental_algebra nil))
   shostak))
 (add_div2 0
  (add_div2-1 nil 3745074907
   ("" (skeep)
    (("" (rewrite "complex_div_cancel4")
      (("" (rewrite "complex_commutative_mult")
        (("" (rewrite "complex_mult_distrib_plus")
          (("" (case "n0y * x = x * n0y")
            (("1" (replace -1 :dir rl :hide? t)
              (("1" (case "n0y * (y / n0y) = y")
                (("1" (replace -1 :hide? t) (("1" (propax) nil nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (rewrite "complex_div_cancel1") nil nil)) nil))
                nil))
              nil)
             ("2" (rewrite "complex_commutative_mult") nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_cancel4 formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (+ const-decl "complex" complex_types nil)
    (* const-decl "complex" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (complex_mult_distrib_plus formula-decl nil complex_types nil)
    (complex_div_cancel1 formula-decl nil complex_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mult_commutes formula-decl nil fundamental_algebra nil))
   shostak))
 (minus_div1 0
  (minus_div1-1 nil 3745074666
   ("" (skeep)
    (("" (case "(x / n0x) - (y / n0y) = (x / n0x) + -(y / n0y)")
      (("1" (replace -1 :hide? t)
        (("1" (case "-(y / n0y) = (-y / n0y)")
          (("1" (replace -1 :hide? t)
            (("1" (rewrite "add_div1")
              (("1" (case "x * n0y + -y * n0x = x * n0y - y * n0x")
                (("1" (replace -1 :hide? t) (("1" (propax) nil nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (name-replace "A" "x * n0y")
                    (("2" (name-replace "B" "y")
                      (("2" (name-replace "C" "n0x")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((- const-decl "complex" complex_types nil)
    (+ const-decl "complex" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "complex" complex_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (add_div1 formula-decl nil complex_props nil)
    (mul_nzcomplex1 application-judgement "nzcomplex" complex_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (* const-decl "complex" complex_types nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sq_abs const-decl "nnreal" complex_types nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nz_sq_abs_pos application-judgement "posreal" complex_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak))
 (minus_div2 0
  (minus_div2-1 nil 3745075339
   ("" (skeep)
    (("" (case "x - (y / n0y) = x + -(y / n0y)")
      (("1" (replace -1 :hide? t)
        (("1" (case "-(y / n0y) = -y / n0y")
          (("1" (replace -1 :hide? t)
            (("1" (rewrite "add_div2")
              (("1" (case "x * n0y + -y = x * n0y - y")
                (("1" (replace -1 :hide? t) (("1" (propax) nil nil))
                  nil)
                 ("2" (hide 2) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((- const-decl "complex" complex_types nil)
    (+ const-decl "complex" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "complex" complex_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (add_div2 formula-decl nil complex_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (* const-decl "complex" complex_types nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sq_abs const-decl "nnreal" complex_types nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nz_sq_abs_pos application-judgement "posreal" complex_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak))
 (cross_mult 0
  (cross_mult-1 nil 3744909143
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "complex_div_cancel3")
          (("1" (replace -1 :hide? t)
            (("1" (lemma "complex_commutative_mult")
              (("1" (inst -1 "y / n0y * n0x" "n0y")
                (("1" (replace -1 :hide? t)
                  (("1" (rewrite "complex_associative_mult" :dir rl)
                    (("1" (rewrite "complex_div_cancel1") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (rewrite "complex_div_cancel3" :dir rl)
          (("2" (rewrite "complex_div_def" :dir rl)
            (("2" (lemma "complex_commutative_mult")
              (("2" (inst -1 "x * n0y" "complex_(1, 0) / n0x")
                (("2" (replace -1 :hide? t)
                  (("2" (rewrite "complex_associative_mult" :dir rl)
                    (("2" (rewrite "complex_commutative_mult")
                      (("2" (rewrite "complex_div_def")
                        (("2" (rewrite "complex_div_cancel4" :dir rl)
                          nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_cancel3 formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (complex_div_cancel1 formula-decl nil complex_types nil)
    (complex_associative_mult formula-decl nil complex_types nil)
    (* const-decl "complex" complex_types nil)
    (complex_div_cancel4 formula-decl nil complex_types nil)
    (complex_div_def formula-decl nil complex_types nil))
   shostak))
 (separate_div 0
  (separate_div-1 nil 3744908797
   ("" (skeep)
    (("" (rewrite "complex_div_def")
      (("" (rewrite "cross_mult")
        (("" (lemma "complex_commutative_mult")
          (("" (inst -1 "n0x" "n0y")
            (("" (replace -1 :hide? t)
              (("" (lemma "complex_commutative_mult")
                (("" (inst -1 "x / n0x" "n0y * n0x")
                  (("" (replace -1 :hide? t)
                    (("" (rewrite "complex_associative_mult")
                      (("" (rewrite "complex_div_cancel1")
                        (("" (rewrite "complex_commutative_mult") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_def formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (complex_associative_mult formula-decl nil complex_types nil)
    (complex_div_cancel1 formula-decl nil complex_types nil)
    (* const-decl "complex" complex_types nil)
    (cross_mult formula-decl nil complex_props nil)
    (mul_nzcomplex1 application-judgement "nzcomplex" complex_types
     nil))
   shostak))
 (div_div_complex 0
  (div_div_complex-1 nil 3744908365
   ("" (skeep)
    (("" (lemma "complex_div_def")
      (("" (inst -1 "n0y" "x/n0x")
        (("" (replace -1 :dir rl :hide? t)
          (("" (rewrite "separate_div") nil nil)) nil))
        nil))
      nil))
    nil)
   ((complex_div_def formula-decl nil complex_types nil)
    (separate_div formula-decl nil complex_props nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (boolean nonempty-type-decl nil booleans nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (real_complex 0
  (real_complex-1 nil 3744910108
   ("" (skeep)
    (("" (expand "real_?")
      (("" (replace -1 1 :dir rl :hide? t)
        (("" (decompose-equality 1) nil nil)) nil))
      nil))
    nil)
   ((real_? const-decl "bool" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (real_div_mult1 0
  (real_div_mult1-1 nil 3744905858
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak))
 (real_div_mult2_TCC1 0
  (real_div_mult2_TCC1-1 nil 3743433417
   ("" (skeep)
    (("" (use "mul_nzcomplex2")
      (("" (expand "/=") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((mul_nzcomplex2 judgement-tcc nil complex_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (* const-decl "complex" complex_types nil))
   nil))
 (real_div_mult2 0
  (real_div_mult2-1 nil 3744906128
   ("" (skeep)
    (("" (lemma "complex_div_real_def")
      (("" (inst -1 "n0r" "real_(r)")
        (("" (assert)
          (("" (rewrite "zero_div")
            (("" (replace -1 1 :dir rl :hide? t)
              (("" (rewrite "div_div_complex")
                (("" (rewrite "complex_commutative_mult") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_real_def formula-decl nil complex_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (Re_rew formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (div_div_complex formula-decl nil complex_props nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (zero_div formula-decl nil extra_tegies nil)
    (complex_ const-decl "complex" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (real_frac_times_complex_TCC1 0
  (real_frac_times_complex_TCC1-1 nil 3743433417
   ("" (subtype-tcc) nil nil)
   ((complex_ const-decl "complex" complex_types nil)) nil))
 (real_frac_times_complex 0
  (real_frac_times_complex-1 nil 3744906809
   ("" (skeep)
    (("" (rewrite "complex_div_real" :dir rl)
      (("" (rewrite "complex_commutative_mult")
        (("" (lemma "complex_commutative_mult")
          (("" (inst -1 "real_(r)" "x")
            (("" (replace -1 :hide? t)
              (("" (rewrite "complex_associative_mult_div") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_real formula-decl nil complex_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (complex_associative_mult_div formula-decl nil complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (mult_commutes formula-decl nil fundamental_algebra nil))
   shostak))
 (expr_div_complex 0
  (expr_div_complex-1 nil 3744920600
   ("" (skeep)
    (("" (rewrite "cross_mult")
      (("" (rewrite "complex_commutative_mult")
        (("" (rewrite "complex_associative_mult") nil nil)) nil))
      nil))
    nil)
   ((mul_nzcomplex1 application-judgement "nzcomplex" complex_types
     nil)
    (cross_mult formula-decl nil complex_props nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (* const-decl "complex" complex_types nil)
    (complex_associative_mult formula-decl nil complex_types nil)
    (mult_commutes formula-decl nil fundamental_algebra nil))
   shostak))
 (inv_div 0
  (inv_div-1 nil 3744911329
   ("" (skeep)
    (("" (rewrite "cross_mult")
      (("" (rewrite "complex_div_cancel1")
        (("" (rewrite "complex_mult_unity2") nil nil)) nil))
      nil))
    nil)
   ((div_nzcomplex1 application-judgement "nzcomplex" complex_types
     nil)
    (cross_mult formula-decl nil complex_props nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (mul_nzcomplex1 application-judgement "nzcomplex" complex_types
     nil)
    (complex_mult_unity2 formula-decl nil complex_props nil)
    (complex_div_cancel1 formula-decl nil complex_types nil))
   shostak))
 (complex_cancel 0
  (complex_cancel-1 nil 3744911429
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "cross_mult")
          (("1" (lemma "complex_div_cancel3")
            (("1" (inst -1 "n0x" "x*n0x" "y")
              (("1" (assert)
                (("1" (rewrite "complex_commutative_mult" -1)
                  (("1"
                    (rewrite "complex_associative_mult_div" :dir rl)
                    (("1" (rewrite "complex_div_cancel1") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1 1 :dir rl :hide? t) (("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((cross_mult formula-decl nil complex_props nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (* const-decl "complex" complex_types nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (complex_div_cancel1 formula-decl nil complex_types nil)
    (complex_associative_mult_div formula-decl nil complex_types nil)
    (complex_div_cancel3 formula-decl nil complex_types nil))
   shostak))
 (complex_mult_cancel 0
  (complex_mult_cancel-1 nil 3745073319
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (lemma "complex_div_cancel1")
          (("1" (inst -1 "n0x" "x")
            (("1" (rewrite "complex_associative_mult_div")
              (("1" (rewrite "complex_commutative_mult")
                (("1" (replace -1 1 :dir rl :hide? t)
                  (("1" (lemma "complex_div_cancel1")
                    (("1" (inst -1 "n0x" "y")
                      (("1" (rewrite "complex_associative_mult_div")
                        (("1" (rewrite "complex_commutative_mult")
                          (("1" (replace -1 1 :dir rl :hide? t)
                            (("1" (rewrite "complex_cancel") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1 1 :dir rl :hide? t) (("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_cancel1 formula-decl nil complex_types nil)
    (complex_associative_mult_div formula-decl nil complex_types nil)
    (* const-decl "complex" complex_types nil)
    (complex_cancel formula-decl nil complex_props nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (boolean nonempty-type-decl nil booleans nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (sq_abs_def 0
  (sq_abs_def-1 nil 3744911724
   ("" (skeep)
    (("" (expand "conjugate") (("" (decompose-equality 1) nil nil))
      nil))
    nil)
   ((conjugate const-decl "complex" complex_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (* const-decl "complex" complex_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Re_mul1 formula-decl nil complex_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Re_rew formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Im_mul1 formula-decl nil complex_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil))
   shostak))
 (cpow_inv_TCC1 0
  (cpow_inv_TCC1-1 nil 3744921279
   ("" (skeep)
    (("" (rewrite "cpow_0")
      (("" (case "n = 0")
        (("1" (replace -1 :hide? t)
          (("1" (expand "cpow") (("1" (grind) nil nil)) nil)) nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cpow_0 formula-decl nil fundamental_algebra nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cpow def-decl "complex" fundamental_algebra nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (cpow_inv 0
  (cpow_inv-1 nil 3744921348
   ("" (induct "n")
    (("1" (skeep)
      (("1" (expand "cpow")
        (("1" (rewrite "complex_div_unity") nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (insteep)
          (("2" (expand "cpow" +)
            (("2" (replace -1 :hide? t)
              (("2" (rewrite "complex_div_def")
                (("2" (rewrite "div_div_complex") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (expand "/=")
      (("3" (hide 2)
        (("3" (skeep)
          (("3" (typepred "n0x")
            (("3" (case "n = 0")
              (("1" (replace -1 :hide? t)
                (("1" (expand "cpow") (("1" (grind) nil nil)) nil))
                nil)
               ("2" (rewrite "cpow_0") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cpow_0 formula-decl nil fundamental_algebra nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (div_div_complex formula-decl nil complex_props nil)
    (complex_div_def formula-decl nil complex_types nil)
    (complex_div_unity formula-decl nil complex_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (/ const-decl "complex" complex_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (complex type-eq-decl nil complex_types nil)
    (/= const-decl "boolean" notequal nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (cpow def-decl "complex" fundamental_algebra nil))
   shostak))
 (cpow_div 0
  (cpow_div-1 nil 3744920678
   ("" (skeep)
    (("" (rewrite "complex_div_def" :dir rl)
      (("" (rewrite "cpow_mult")
        (("" (case "cpow(complex_(1, 0) / n0x)(n) = 1/cpow(n0x)(n)")
          (("1" (replace -1 :hide? t)
            (("1" (rewrite "complex_div_def") nil nil)) nil)
           ("2" (hide 2) (("2" (rewrite "cpow_inv") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_def formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (cpow def-decl "complex" fundamental_algebra nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpow_inv formula-decl nil complex_props nil)
    (/ const-decl "complex" complex_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (cpow_mult formula-decl nil fundamental_algebra nil))
   shostak))
 (c_root_inv_TCC1 0
  (c_root_inv_TCC1-1 nil 3744922608
   ("" (skeep) (("" (rewrite "c_root_zero") nil nil)) nil)
   ((c_root_zero formula-decl nil complex_root nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (complex type-eq-decl nil complex_types nil)
    (/= const-decl "boolean" notequal nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil))
   nil))
 (c_root_inv 0
  (c_root_inv-1 nil 3745070135
   ("" (skeep)
    ((""
      (case "(complex_(1, 0) / c_root(n0x, n0)) * c_root(n0x, n0) = real_(1)")
      (("1"
        (case " real_(1) = c_root((complex_(1, 0) / n0x) * n0x, n0)")
        (("1" (name-replace "A" "(complex_(1, 0) / c_root(n0x, n0))")
          (("1" (replace -1 -2 :hide? t)
            (("1" (expand "A")
              (("1" (lemma "c_root_mult")
                (("1" (inst -1 "n0" "complex_(1, 0) / n0x" "n0x")
                  (("1" (skeep)
                    (("1" (lemma "roots_of_unity_inverses")
                      (("1" (inst?)
                        (("1" (skeep)
                          (("1"
                            (case "c_root(complex_(1, 0) / n0x * n0x, n0) = root_of_unity(n0)(n2) * c_root(complex_(1, 0) / n0x, n0) * c_root(n0x, n0)")
                            (("1" (replace -1 -4 :hide? t)
                              (("1"
                                (hide-all-but (-3 1))
                                (("1"
                                  (inst 1 "n2")
                                  (("1"
                                    (name-replace
                                     "L"
                                     "complex_(1, 0) / c_root(n0x, n0)")
                                    (("1"
                                      (name-replace
                                       "R"
                                       "c_root(complex_(1, 0) / n0x, n0)")
                                      (("1"
                                        (name-replace
                                         "K"
                                         "root_of_unity(n0)(n2)")
                                        (("1"
                                          (name-replace
                                           "M"
                                           "c_root(n0x, n0)")
                                          (("1"
                                            (rewrite
                                             "complex_mult_cancel")
                                            (("1"
                                              (expand "/=")
                                              (("1"
                                                (expand "M")
                                                (("1"
                                                  (rewrite
                                                   "c_root_zero")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (-1 -2 1))
                              (("2"
                                (rewrite "complex_associative_mult" 1)
                                (("2"
                                  (replace -2 :hide? t)
                                  (("2"
                                    (rewrite
                                     "complex_associative_mult"
                                     1
                                     :dir
                                     rl)
                                    (("2"
                                      (rewrite "complex_commutative_mult" -1)
                                      (("2"
                                        (replace -1 :hide? t)
                                        (("2"
                                          (rewrite
                                           "complex_mult_unity2")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (case "(complex_(1, 0) / n0x) * n0x = real_(1)")
            (("1" (replace -1 :hide? t)
              (("1" (rewrite "c_root_real_root")
                (("1" (rewrite "root_1n") nil nil)) nil))
              nil)
             ("2" (hide 2)
              (("2" (lemma "complex_div_cancel1")
                (("2" (inst?)
                  (("2" (rewrite "complex_commutative_mult" -1) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rewrite "complex_commutative_mult")
          (("2" (rewrite "complex_div_def")
            (("2" (rewrite "complex_div_cancel3")
              (("2" (rewrite "complex_mult_unity2") nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (expand "/=") (("3" (rewrite "c_root_zero") nil nil)) nil))
      nil))
    nil)
   ((c_root const-decl
     "{x: complex | x ^ n = z AND ((Im(z) = 0 AND odd?(n)) IMPLIES Im(x) = 0)}"
     complex_root nil)
    (odd? const-decl "bool" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (^ def-decl "complex" complex_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "complex" complex_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex_div_cancel1 formula-decl nil complex_types nil)
    (root_1n formula-decl nil root "power/")
    (c_root_real_root formula-decl nil complex_root nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (A skolem-const-decl "complex" complex_props nil)
    (roots_of_unity_inverses formula-decl nil fundamental_algebra nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (complex_mult_unity2 formula-decl nil complex_props nil)
    (complex_associative_mult formula-decl nil complex_types nil)
    (c_root_zero formula-decl nil complex_root nil)
    (M skolem-const-decl "{x: complex |
         x ^ n0 = n0x AND ((Im(n0x) = 0 AND odd?(n0)) IMPLIES Im(x) = 0)}"
     complex_props nil)
    (complex_mult_cancel formula-decl nil complex_props nil)
    (root_of_unity const-decl "complex" fundamental_algebra nil)
    (<= const-decl "bool" reals nil)
    (c_root_mult formula-decl nil complex_root nil)
    (complex_div_cancel3 formula-decl nil complex_types nil)
    (complex_div_def formula-decl nil complex_types nil))
   shostak))
 (c_root_div 0
  (c_root_div-1 nil 3744921724
   ("" (skeep)
    (("" (rewrite "complex_div_def" :dir rl)
      (("1"
        (case " EXISTS (m: nat | m <= n0): complex_(1, 0) / c_root(n0x, n0) = root_of_unity(n0)(m) * c_root(1/n0x, n0)")
        (("1" (skeep)
          (("1" (replace -1 :hide? t)
            (("1" (rewrite "complex_associative_mult" :dir rl)
              (("1" (rewrite "complex_commutative_mult")
                (("1" (lemma "c_root_mult")
                  (("1" (inst -1 "n0" "x" "complex_(1, 0) / n0x")
                    (("1" (rewrite "complex_div_def")
                      (("1" (skeep)
                        (("1" (rewrite "complex_associative_mult")
                          (("1" (replace -1 :hide? t)
                            (("1"
                              (rewrite "complex_associative_mult" :dir
                               rl)
                              (("1"
                                (lemma "roots_of_unity_closed")
                                (("1"
                                  (inst -1 "n0" "m" "m!1")
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1" (inst 1 "n3") nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case "m!1 = 0")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (inst 2 "m")
                                        (("1"
                                          (name-replace
                                           "A"
                                           "root_of_unity(n0)(m)")
                                          (("1"
                                            (expand "root_of_unity")
                                            (("1"
                                              (case
                                               "complex_(2, 0) * complex_i * complex_(pi, 0) * complex_(0, 0) /
                                                          complex_(n0, 0) = real_(0)")
                                              (("1"
                                                (replace -1 :hide? t)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (case
                                                     "exp(complex_(0, 0)) = real_(1)")
                                                    (("1"
                                                      (replace
                                                       -1
                                                       :hide?
                                                       t)
                                                      (("1"
                                                        (rewrite
                                                         "complex_mult_unity")
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide-all-but 1)
                                                      (("2"
                                                        (grind)
                                                        (("1"
                                                          (lemma
                                                           "sin_k_pi")
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "0")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (lemma
                                                           "cos_2k_pi")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "0")
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (lemma "c_root_inv")
            (("2" (inst -1 "n0" "n0x") nil nil)) nil))
          nil)
         ("3" (skeep) (("3" (rewrite "c_root_zero") nil nil)) nil))
        nil)
       ("2" (expand "/=")
        (("2" (typepred "n0x") (("2" (rewrite "c_root_zero") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((complex_div_def formula-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (^ def-decl "complex" complex_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (odd? const-decl "bool" integers nil)
    (c_root const-decl
     "{x: complex | x ^ n = z AND ((Im(z) = 0 AND odd?(n)) IMPLIES Im(x) = 0)}"
     complex_root nil)
    (c_root_zero formula-decl nil complex_root nil)
    (c_root_inv formula-decl nil complex_props nil)
    (complex_associative_mult formula-decl nil complex_types nil)
    (c_root_mult formula-decl nil complex_root nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (n0 skolem-const-decl "posnat" complex_props nil)
    (m!1 skolem-const-decl "{m: nat | m <= n0}" complex_props nil)
    (complex_i const-decl "nzcomplex" complex_types nil)
    (< const-decl "bool" reals nil)
    (cos const-decl "real" sincos_def "trig/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (cos_2k_pi formula-decl nil sincos "trig/")
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sin_k_pi formula-decl nil sincos "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (integer nonempty-type-from-decl nil integers nil)
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (exp_0 formula-decl nil ln_exp "lnexp_fnd/")
    (complex_mult_unity formula-decl nil complex_props nil)
    (exp const-decl "nzcomplex" complex_lnexp nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sq_abs const-decl "nnreal" complex_types nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (roots_of_unity_closed formula-decl nil fundamental_algebra nil)
    (mult_commutes formula-decl nil fundamental_algebra nil)
    (<= const-decl "bool" reals nil)
    (/ const-decl "complex" complex_types nil)
    (* const-decl "complex" complex_types nil)
    (root_of_unity const-decl "complex" fundamental_algebra nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak)))

