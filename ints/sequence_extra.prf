(|sequence_extra|
 (|infinite_set_nat_enum_TCC1| 0
  (|infinite_set_nat_enum_TCC1-1| NIL 3945634222 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   NIL
   (|infinite_set_nat_enum| SUBTYPE "(number_fields.-)(sequence_extra.n, 1)"
    "nat")))
 (|infinite_set_nat_enum_TCC2| 0
  (|infinite_set_nat_enum_TCC2-1| NIL 3945634222 ("" (TERMINATION-TCC) NIL NIL)
   NIL NIL
   (|infinite_set_nat_enum| TERMINATION
    "sequence_extra.infinite_set_nat_enum((number_fields.-)(sequence_extra.n, 1), sequence_extra.s)"
    "NIL")))
 (|infinite_set_nat_enum_TCC3| 0
  (|infinite_set_nat_enum_TCC3-1| NIL 3945634222
   ("" (SKEEP)
    (("" (CASE "is_finite(s)")
      (("1" (TYPEPRED "s") (("1" (PROPAX) NIL NIL)) NIL)
       ("2" (EXPAND "nonempty?")
        (("2" (EXPAND "is_finite")
          (("2" (INST 1 "v1(n - 1, s)+1" "LAMBDA(i:(s)):i")
            (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)
             ("2" (SKEEP)
              (("2" (EXPAND "empty?")
                (("2" (INST -1 "i")
                  (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                NIL))
              NIL)
             ("3" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|v1| SKOLEM-CONST-DECL
     "[d1: {z: [nat, {s: set[nat] | NOT is_finite(s)}] | z`1 < n} -> (d1`2)]"
     |sequence_extra| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|s| SKOLEM-CONST-DECL "{s: set[nat] | NOT is_finite(s)}" |sequence_extra|
     NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|infinite_set_nat_enum| SUBTYPE
    "{v: (sequence_extra.s) | reals.>(v, sequence_extra.infinite_set_nat_enum((number_fields.-)(sequence_extra.n, 1), sequence_extra.s))}"
    "(sets[(sequence_extra.s)].nonempty?)")))
 (|inf_set_nat_strict_incr| 0
  (|inf_set_nat_strict_incr-1| NIL 3945634224
   ("" (SKEEP)
    (("" (EXPAND "infinite_set_nat_enum" 1 2)
      ((""
        (NAME-REPLACE "x" " min({v: (s) | v > infinite_set_nat_enum(n, s)})")
        (("1" (TYPEPRED "x") (("1" (ASSERT) NIL NIL)) NIL)
         ("2" (CASE "is_finite(s)")
          (("1" (TYPEPRED "s") (("1" (PROPAX) NIL NIL)) NIL)
           ("2" (EXPAND "nonempty?")
            (("2" (HIDE 2)
              (("2" (EXPAND "is_finite")
                (("2"
                  (INST 1 "infinite_set_nat_enum(n, s)+1" "LAMBDA(i:(s)):i")
                  (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)
                   ("2" (SKEEP)
                    (("2" (EXPAND "empty?")
                      (("2" (INST -1 "i")
                        (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|infinite_set_nat_enum| DEF-DECL "(s)" |sequence_extra| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|n| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|s| SKOLEM-CONST-DECL "{s: set[nat] | NOT is_finite(s)}" |sequence_extra|
     NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   SHOSTAK))
 (|inf_set_nat_below_existence| 0
  (|inf_set_nat_below_existence-1| NIL 3946814747
   ("" (SKEEP)
    (("" (PROP)
      (("1" (EXPAND "is_finite")
        (("1" (INST 1 "n+1" "LAMBDA(i:({k: nat | s(k) AND k <= n})): i")
          (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)) NIL))
        NIL)
       ("2" (EXPAND "empty?")
        (("2" (INST -1 "min(s)")
          (("2" (EXPAND "member") (("2" (PROPAX) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   SHOSTAK))
 (|inf_set_nat_below_n_TCC1| 0
  (|inf_set_nat_below_n_TCC1-1| NIL 3946814427
   ("" (LEMMA "inf_set_nat_below_existence") (("" (PROPAX) NIL NIL)) NIL)
   ((|inf_set_nat_below_existence| FORMULA-DECL NIL |sequence_extra| NIL)) NIL
   (|inf_set_nat_below_n| SUBTYPE
    "{k: naturalnumbers.nat | booleans.AND(sequence_extra.s(k), reals.<=(k, sequence_extra.n))}"
    "non_empty_finite_set[nat]")))
 (|inf_set_nat_below_surj| 0
  (|inf_set_nat_below_surj-1| NIL 3946814504
   ("" (SKEEP)
    (("" (MEASURE-INDUCT "n" "n")
      (("" (SKEEP)
        (("" (CASE-REPLACE "x = min(s)")
          (("1" (INST 1 "0")
            (("1" (HIDE -2)
              (("1" (EXPAND "infinite_set_nat_enum")
                (("1" (EXPAND "inf_set_nat_below_n")
                  (("1"
                    (TYPEPRED
                     "max_finite_set_nat.max({k: nat | s(k) AND k <= min(s)})")
                    (("1" (INST -3 "min(s)") (("1" (ASSERT) NIL NIL)) NIL)
                     ("2" (REWRITE "inf_set_nat_below_existence") NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (INST -1 "x-1")
            (("1" (ASSERT)
              (("1" (SKEEP)
                (("1" (CASE "s(x)")
                  (("1" (INST 2 "i+1")
                    (("1" (EXPAND "infinite_set_nat_enum" 2)
                      (("1" (CASE-REPLACE "inf_set_nat_below_n(s, x) = x")
                        (("1"
                          (TYPEPRED
                           "min({v: (s) | v > infinite_set_nat_enum(i, s)})")
                          (("1" (INST -3 "x")
                            (("1" (SPLIT)
                              (("1"
                                (NAME-REPLACE "next_s"
                                 "min({v: (s) | v > infinite_set_nat_enum(i, s)})")
                                (("1" (EXPAND "<=")
                                  (("1" (ASSERT)
                                    (("1" (REPLACES -6)
                                      (("1" (HIDE -4)
                                        (("1" (EXPAND "inf_set_nat_below_n")
                                          (("1"
                                            (TYPEPRED
                                             "max_finite_set_nat.max({k: nat | s(k) AND k <= x - 1})")
                                            (("1" (INST -3 "next_s")
                                              (("1" (ASSERT) NIL NIL)) NIL)
                                             ("2"
                                              (REWRITE
                                               "inf_set_nat_below_existence")
                                              NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (REPLACES -5)
                                (("2" (HIDE-ALL-BUT 1)
                                  (("2" (EXPAND "inf_set_nat_below_n")
                                    (("2"
                                      (TYPEPRED
                                       "max_finite_set_nat.max({k: nat | s(k) AND k <= x - 1})")
                                      (("1" (ASSERT) NIL NIL)
                                       ("2"
                                        (REWRITE "inf_set_nat_below_existence")
                                        NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (EXPAND "nonempty?")
                            (("2" (EXPAND "empty?")
                              (("2" (INST -1 "x")
                                (("2" (EXPAND "member")
                                  (("2" (REPLACES -3)
                                    (("2" (HIDE-ALL-BUT 1)
                                      (("2" (EXPAND "inf_set_nat_below_n")
                                        (("2"
                                          (TYPEPRED
                                           "max_finite_set_nat.max({k: nat | s(k) AND k <= x - 1})")
                                          (("1" (ASSERT) NIL NIL)
                                           ("2"
                                            (REWRITE
                                             "inf_set_nat_below_existence")
                                            NIL NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (HIDE-ALL-BUT (-1 1))
                          (("2" (EXPAND "inf_set_nat_below_n")
                            (("2"
                              (TYPEPRED
                               "max_finite_set_nat.max({k: nat | s(k) AND k <= x})")
                              (("1" (INST -3 "x") (("1" (ASSERT) NIL NIL)) NIL)
                               ("2" (REWRITE "inf_set_nat_below_existence") NIL
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (INST 3 "i")
                    (("2"
                      (CASE-REPLACE
                       "inf_set_nat_below_n(s, x-1) = inf_set_nat_below_n(s, x)")
                      (("2" (HIDE-ALL-BUT (1 2))
                        (("2" (EXPAND "inf_set_nat_below_n")
                          (("2"
                            (NAME-REPLACE "m1"
                             "max_finite_set_nat.max({k: nat | s(k) AND k <= x - 1})")
                            (("1"
                              (NAME-REPLACE "m2"
                               "max_finite_set_nat.max({k: nat | s(k) AND k <= x})")
                              (("1" (TYPEPRED "m1")
                                (("1" (TYPEPRED "m2")
                                  (("1" (EXPAND "<=" -2)
                                    (("1" (PROP)
                                      (("1" (INST -6 "m2")
                                        (("1" (ASSERT)
                                          (("1" (INST -3 "m1")
                                            (("1" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL)
                                       ("2" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (REWRITE "inf_set_nat_below_existence") NIL
                                NIL))
                              NIL)
                             ("2" (REWRITE "inf_set_nat_below_existence") NIL
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|infinite_set_nat_enum| DEF-DECL "(s)" |sequence_extra| NIL)
    (|inf_set_nat_below_n| CONST-DECL "nat" |sequence_extra| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|inf_set_nat_below_existence| FORMULA-DECL NIL |sequence_extra| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (> CONST-DECL "bool" |reals| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|s| SKOLEM-CONST-DECL "{s: set[nat] | NOT is_finite(s)}" |sequence_extra|
     NIL)
    (|x| SKOLEM-CONST-DECL "{n: nat | n >= min(s)}" |sequence_extra| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   SHOSTAK))
 (|inf_set_nat_strict_bij| 0
  (|inf_set_nat_strict_bij-1| NIL 3945635654
   ("" (SKEEP)
    (("" (EXPAND "bijective?")
      (("" (PROP)
        (("1" (EXPAND "injective?")
          (("1" (SKEEP)
            (("1"
              (CASE
                  "FORALL(n: nat): FORALL(k:posnat): infinite_set_nat_enum(n, s) < infinite_set_nat_enum(n+k, s)")
              (("1" (CASE "x1 < x2")
                (("1" (INST -2 "x1")
                  (("1" (INST -2 "x2-x1")
                    (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL))
                  NIL)
                 ("2" (CASE "x1 > x2")
                  (("1" (INST -2 "x2")
                    (("1" (INST -2 "x1-x2")
                      (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL))
                    NIL)
                   ("2" (ASSERT) NIL NIL))
                  NIL))
                NIL)
               ("2" (HIDE -1 2)
                (("2" (SKEEP)
                  (("2" (MEASURE-INDUCT "k" "k")
                    (("2" (SKEEP)
                      (("2" (CASE-REPLACE "x = 1")
                        (("1" (REWRITE "inf_set_nat_strict_incr") NIL NIL)
                         ("2" (INST -1 "x-1")
                          (("1" (ASSERT)
                            (("1" (EXPAND "infinite_set_nat_enum" 2 2)
                              (("1" (ASSERT) NIL NIL)) NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (EXPAND "surjective?")
          (("2" (SKEEP)
            (("2" (LEMMA "inf_set_nat_below_surj")
              (("2" (INST -1 "s" "y")
                (("1" (SKEEP)
                  (("1" (INST 1 "i")
                    (("1" (EXPAND "inf_set_nat_below_n")
                      (("1"
                        (TYPEPRED
                         "max_finite_set_nat.max({k: nat | s(k) AND k <= y})")
                        (("1" (INST -3 "y") (("1" (ASSERT) NIL NIL)) NIL)
                         ("2" (REWRITE "inf_set_nat_below_existence")
                          (("2" (TYPEPRED "min[nat](s)")
                            (("2" (INST -2 "y") (("2" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (TYPEPRED "min[nat](s)")
                  (("2" (INST -2 "y") (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|bijective?| CONST-DECL "bool" |functions| NIL)
    (|surjective?| CONST-DECL "bool" |functions| NIL)
    (|inf_set_nat_below_surj| FORMULA-DECL NIL |sequence_extra| NIL)
    (|inf_set_nat_below_n| CONST-DECL "nat" |sequence_extra| NIL)
    (|inf_set_nat_below_existence| FORMULA-DECL NIL |sequence_extra| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (|s| SKOLEM-CONST-DECL "{s: set[nat] | NOT is_finite(s)}" |sequence_extra|
     NIL)
    (|y| SKOLEM-CONST-DECL "(s)" |sequence_extra| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|infinite_set_nat_enum| DEF-DECL "(s)" |sequence_extra| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|x2| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|x1| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|x| SKOLEM-CONST-DECL "posnat" |sequence_extra| NIL)
    (|inf_set_nat_strict_incr| FORMULA-DECL NIL |sequence_extra| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK))
 (|n_eq_seq_min_idx_TCC1| 0
  (|n_eq_seq_min_idx_TCC1-1| NIL 3945692558 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|sequence| TYPE-EQ-DECL NIL |sequences| NIL)
    (|n_eq_seq?| CONST-DECL "bool" |sequence_extra| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|n_eq_seq_min_idx| SUBTYPE
    "{j: naturalnumbers.nat | sequence_extra.a(sequence_extra.i) = sequence_extra.b(j)}"
    "(sets[nat].nonempty?)")))
 (|n_eq_seq_other_infinite| 0
  (|n_eq_seq_other_infinite-1| NIL 3946847050
   ("" (SKEEP)
    ((""
      (NAME "max_eq"
            "max_finite_set_nat.max({i:nat | EXISTS(j: nat| j <= n): i = n_eq_seq_min_idx(n, a, b, j)})")
      (("1"
        (NAME "max_non_eq"
              "max_finite_set_nat.max(n_eq_seq_other_indices(n, a, b))")
        (("1" (TYPEPRED "max_non_eq")
          (("1" (INST -2 "max(max_non_eq+1, max_eq+1)")
            (("1" (SPLIT)
              (("1" (ASSERT) NIL NIL)
               ("2" (EXPAND "n_eq_seq_other_indices" 1)
                (("2" (SKEEP)
                  (("2" (TYPEPRED "max_eq")
                    (("2" (INST -2 "max(1 + max_non_eq, 1 + max_eq)")
                      (("2" (SPLIT)
                        (("1" (SKEEP) (("1" (ASSERT) NIL NIL)) NIL)
                         ("2" (INST 1 "j") NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (ASSERT)
          (("2" (EXPAND "empty?")
            (("2" (INST -1 "max_eq+1")
              (("2" (EXPAND "member")
                (("2" (EXPAND "n_eq_seq_other_indices")
                  (("2" (SKEEP)
                    (("2" (TYPEPRED "max_eq")
                      (("2" (INST -2 "max_eq+1")
                        (("2" (SPLIT)
                          (("1" (ASSERT) NIL NIL)
                           ("2" (INST 1 "j") (("2" (ASSERT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (HIDE -)
        (("2" (PROP)
          (("1" (EXPAND "is_finite")
            (("1"
              (INST 1 "n+1" "LAMBDA(i:({i: nat |
                     EXISTS (j: nat | j <= n):
                       i = n_eq_seq_min_idx(n, a, b, j)})): min({j:nat| j <= n AND i = n_eq_seq_min_idx(n, a, b, j)})")
              (("1" (EXPAND "injective?")
                (("1" (SKEEP)
                  (("1"
                    (NAME-REPLACE "lhs"
                     "min({j: nat | j <= n AND x1 = n_eq_seq_min_idx(n, a, b, j)})")
                    (("1"
                      (NAME-REPLACE "rhs"
                       "min({j: nat | j <= n AND x2 = n_eq_seq_min_idx(n, a, b, j)})")
                      (("1" (TYPEPRED "rhs")
                        (("1" (TYPEPRED "lhs")
                          (("1" (REPLACES -7)
                            (("1" (REPLACE -5 -2 RL HIDE)
                              (("1" (PROPAX) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (EXPAND "nonempty?")
                        (("2" (EXPAND "empty?")
                          (("2" (EXPAND "member")
                            (("2" (TYPEPRED "x2")
                              (("2" (SKEEP)
                                (("2" (INST -2 "j") (("2" (ASSERT) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (EXPAND "nonempty?")
                      (("2" (EXPAND "empty?")
                        (("2" (EXPAND "member")
                          (("2" (TYPEPRED "x1")
                            (("2" (SKEEP)
                              (("2" (INST -2 "j") (("2" (ASSERT) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)
               ("3" (SKEEP)
                (("3" (EXPAND "nonempty?")
                  (("3" (EXPAND "empty?")
                    (("3" (EXPAND "member")
                      (("3" (TYPEPRED "i")
                        (("3" (SKEEP)
                          (("3" (INST -2 "j") (("3" (ASSERT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (EXPAND "empty?")
            (("2" (EXPAND "member")
              (("2" (INST -1 " n_eq_seq_min_idx(n, a, b, 0)")
                (("2" (INST 1 "0") NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|injective?| CONST-DECL "bool" |functions| NIL)
    (|n_eq_seq_min_idx| CONST-DECL "nat" |sequence_extra| NIL)
    (|n_eq_seq?| CONST-DECL "bool" |sequence_extra| NIL)
    (|sequence| TYPE-EQ-DECL NIL |sequences| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (<= CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|posint_max| APPLICATION-JUDGEMENT "{k: posint | i <= k AND j <= k}"
     |real_defs| NIL)
    (|posrat_max| APPLICATION-JUDGEMENT "{s: posrat | s >= q AND s >= r}"
     |real_defs| NIL)
    (|n_eq_seq_other_indices| CONST-DECL "set[nat]" |sequence_extra| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|a| SKOLEM-CONST-DECL "{a: sequence[real] | injective?(a)}"
     |sequence_extra| NIL)
    (|b| SKOLEM-CONST-DECL "{b: sequence[real] | n_eq_seq?(n, a, b)}"
     |sequence_extra| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL))
   SHOSTAK))
 (|n_eq_perm_TCC1| 0
  (|n_eq_perm_TCC1-1| NIL 3945692558 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|sequence| TYPE-EQ-DECL NIL |sequences| NIL)
    (|n_eq_seq?| CONST-DECL "bool" |sequence_extra| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL
   (|n_eq_perm| SUBTYPE
    "(number_fields.-)((number_fields.-)(sequence_extra.i, sequence_extra.n), 1)"
    "nat")))
 (|n_eq_perm_TCC2| 0
  (|n_eq_perm_TCC2-1| NIL 3945692558
   ("" (SKEEP)
    (("" (LEMMA "n_eq_seq_other_infinite") (("" (INST?) NIL NIL)) NIL)) NIL)
   ((|n_eq_seq_other_infinite| FORMULA-DECL NIL |sequence_extra| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|sequence| TYPE-EQ-DECL NIL |sequences| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|n_eq_seq?| CONST-DECL "bool" |sequence_extra| NIL))
   NIL
   (|n_eq_perm| SUBTYPE
    "sequence_extra.n_eq_seq_other_indices(sequence_extra.n, sequence_extra.a, sequence_extra.b)"
    "{s: sets[nat].set | (booleans.NOT)(finite_sets[nat].is_finite(s))}")))
 (|n_eq_perm_bij| 0
  (|n_eq_perm_bij-1| NIL 3945692560
   ("" (SKEEP)
    (("" (LEMMA "inf_set_nat_strict_bij")
      (("" (INST -1 "n" "n_eq_seq_other_indices(n, a, b)")
        (("1" (EXPAND "bijective?")
          (("1" (PROP)
            (("1" (EXPAND "injective?" 1)
              (("1" (SKEEP)
                (("1" (EXPAND "n_eq_perm")
                  (("1" (LIFT-IF)
                    (("1" (LIFT-IF)
                      (("1" (LIFT-IF)
                        (("1" (PROP)
                          (("1" (EXPAND "n_eq_seq_min_idx")
                            (("1" (TYPEPRED " min({j: nat | a(x1) = b(j)})")
                              (("1" (HIDE -2 -6 -7)
                                (("1" (REPLACES -3)
                                  (("1"
                                    (TYPEPRED "min({j: nat | a(x2) = b(j)})")
                                    (("1" (REPLACE -1 -3 RL HIDE)
                                      (("1" (TYPEPRED "a")
                                        (("1" (EXPAND "injective?")
                                          (("1" (INST -1 "x1" "x2")
                                            (("1" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (EXPAND "nonempty?")
                                      (("2" (TYPEPRED "b")
                                        (("2" (EXPAND "n_eq_seq?")
                                          (("2" (EXPAND "empty?")
                                            (("2" (INST -1 "x2")
                                              (("2" (SKEEP)
                                                (("2" (INST -2 "j")
                                                  (("2" (EXPAND "member")
                                                    (("2" (PROPAX) NIL NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (HIDE-ALL-BUT (-3 1))
                                (("2" (EXPAND "nonempty?")
                                  (("2" (EXPAND "empty?")
                                    (("2" (TYPEPRED "b")
                                      (("2" (EXPAND "n_eq_seq?")
                                        (("2" (INST -1 "x1")
                                          (("2" (SKEEP)
                                            (("2" (INST -2 "j")
                                              (("2" (EXPAND "member")
                                                (("2" (PROPAX) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2"
                            (NAME-REPLACE "v2"
                             "infinite_set_nat_enum(-1 - n + x2, n_eq_seq_other_indices(n, a, b))")
                            (("1" (TYPEPRED "v2")
                              (("1" (EXPAND "n_eq_seq_other_indices")
                                (("1" (INST 1 "x1") (("1" (ASSERT) NIL NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (ASSERT) NIL NIL))
                            NIL)
                           ("3"
                            (NAME-REPLACE "v1"
                             "infinite_set_nat_enum(-1 - n + x1, n_eq_seq_other_indices(n, a, b))")
                            (("1" (TYPEPRED "v1")
                              (("1" (EXPAND "n_eq_seq_other_indices")
                                (("1" (INST 1 "x2") NIL NIL)) NIL))
                              NIL)
                             ("2" (ASSERT) NIL NIL))
                            NIL)
                           ("4" (HIDE -3)
                            (("4" (EXPAND "injective?")
                              (("4" (INST -2 "-1 - n + x1" "-1 - n + x2")
                                (("1" (ASSERT) NIL NIL)
                                 ("2" (TYPEPRED "x2") (("2" (ASSERT) NIL NIL))
                                  NIL)
                                 ("3" (TYPEPRED "x1") (("3" (ASSERT) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND "surjective?")
              (("2" (SKEEP)
                (("2" (INST -2 "y")
                  (("1" (SKEEP)
                    (("1" (INST 1 "n+1+x")
                      (("1" (EXPAND "n_eq_perm") (("1" (PROPAX) NIL NIL)) NIL))
                      NIL))
                    NIL)
                   ("2" (EXPAND "n_eq_seq_other_indices")
                    (("2" (SKEEP)
                      (("2" (INST 1 "j")
                        (("2" (EXPAND "n_eq_perm") (("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (LEMMA "n_eq_seq_other_infinite") (("2" (INST?) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|inf_set_nat_strict_bij| FORMULA-DECL NIL |sequence_extra| NIL)
    (|n_eq_seq_other_infinite| FORMULA-DECL NIL |sequence_extra| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|surjective?| CONST-DECL "bool" |functions| NIL)
    (|y| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|n_eq_perm| CONST-DECL "nat" |sequence_extra| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|x2| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|x1| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|n_eq_seq_min_idx| CONST-DECL "nat" |sequence_extra| NIL)
    (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|infinite_set_nat_enum| DEF-DECL "(s)" |sequence_extra| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|sequence| TYPE-EQ-DECL NIL |sequences| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|n_eq_seq?| CONST-DECL "bool" |sequence_extra| NIL)
    (|n_eq_seq_other_indices| CONST-DECL "set[nat]" |sequence_extra| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |sequence_extra| NIL)
    (|a| SKOLEM-CONST-DECL "{a: sequence[real] | injective?(a)}"
     |sequence_extra| NIL)
    (|b| SKOLEM-CONST-DECL "{b: sequence[real] | n_eq_seq?(n, a, b)}"
     |sequence_extra| NIL))
   SHOSTAK)))

