(|prime_enum|
 (|prime_enumeration_TCC1| 0
  (|prime_enumeration_TCC1-1| NIL 3945367347 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|))
   NIL
   (|prime_enumeration| SUBTYPE "(number_fields.-)(prime_enum.n, 1)" "nat")))
 (|prime_enumeration_TCC2| 0
  (|prime_enumeration_TCC2-1| NIL 3945367347 ("" (TERMINATION-TCC) NIL NIL) NIL
   NIL
   (|prime_enumeration| TERMINATION
    "prime_enum.prime_enumeration((number_fields.-)(prime_enum.n, 1))"
    "NIL")))
 (|prime_enumeration_TCC3| 0
  (|prime_enumeration_TCC3-1| NIL 3945367347 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|prime_enumeration| SUBTYPE "(number_fields.-)(prime_enum.n, 1)" "nat")))
 (|prime_enumeration_TCC4| 0
  (|prime_enumeration_TCC4-1| NIL 3945367347 ("" (TERMINATION-TCC) NIL NIL)
   ((|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|prime_enumeration| TERMINATION
    "prime_enum.prime_enumeration((number_fields.-)(prime_enum.n, 1))"
    "NIL")))
 (|prime_enumeration_TCC5| 0
  (|prime_enumeration_TCC5-1| NIL 3945367347 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   NIL (|prime_enumeration| SUBTYPE "prime_enum.x" "nat")))
 (|prime_enumeration_TCC6| 0
  (|prime_enumeration_TCC6-1| NIL 3945367347 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|prime_enumeration| SUBTYPE
    "{p: (primes.prime?) | reals.>(p, prime_enum.prime_enumeration((number_fields.-)(prime_enum.n, 1)))}"
    "(sets[(primes.prime?)].nonempty?)")))
 (|prime_enumeration_TCC7| 0
  (|prime_enumeration_TCC7-1| NIL 3947075673 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|prime_enumeration| SUBTYPE
    "min_nat[(primes.prime?)].min({p: (primes.prime?) | reals.>(p, prime_enum.prime_enumeration((number_fields.-)(prime_enum.n, 1)))})"
    "nat")))
 (|prime_enum_tail_gen| 0
  (|prime_enum_tail_gen-1| NIL 3946039581
   ("" (SKEEP)
    (("" (MEASURE-INDUCT "k-n" "k")
      (("" (SKEEP)
        (("" (CASE-REPLACE "x = n")
          (("" (INST -1 "x-1")
            (("1" (ASSERT)
              (("1" (EXPAND "prime_enumeration" 2) (("1" (PROPAX) NIL NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|x| SKOLEM-CONST-DECL "{k: nat | k >= n}" |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|prime_enum_zero_tail_TCC1| 0
  (|prime_enum_zero_tail_TCC1-1| NIL 3946039579 ("" (SUBTYPE-TCC) NIL NIL) NIL
   NIL
   (|prime_enum_zero_tail| SUBTYPE "(number_fields.-)(prime_enum.b, 1)"
    "nat")))
 (|prime_enum_zero_tail| 0
  (|prime_enum_zero_tail-1| NIL 3946039598
   ("" (PROP)
    (("1" (SKEEP)
      (("1" (CASE "FORALL(n:nat): prime_enumeration(n) = 0")
        (("1" (INST -1 "0")
          (("1" (EXPAND "prime_enumeration" -1) (("1" (ASSERT) NIL NIL)) NIL))
          NIL)
         ("2" (MEASURE-INDUCT "IF n > a THEN 0 ELSE a-n ENDIF" "n" 1)
          (("1" (SKEEP)
            (("1" (CASE "x >= a")
              (("1" (INST -3 "x") NIL NIL)
               ("2" (INST -1 "x+1")
                (("2" (PROP)
                  (("1" (EXPAND "prime_enumeration" -1)
                    (("1" (LIFT-IF)
                      (("1" (PROP)
                        (("1" (INST 3 "x+1") (("1" (ASSERT) NIL NIL)) NIL)
                         ("2" (HIDE-ALL-BUT (-1 5))
                          (("2"
                            (NAME-REPLACE "m"
                             "min({p: (prime?) | p > prime_enumeration(x)})")
                            (("1" (TYPEPRED "m")
                              (("1" (EXPAND "prime?") (("1" (ASSERT) NIL NIL))
                                NIL))
                              NIL)
                             ("2" (SKOLEM 1 "z")
                              (("2" (TYPEPRED "z")
                                (("2" (EXPAND "prime?")
                                  (("2" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL)
                             ("3" (EXPAND "nonempty?")
                              (("3" (INST 1 "x+1") (("3" (ASSERT) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (ASSERT) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL)
     ("2" (SKEEP)
      (("2" (INST 1 "b")
        (("2" (MEASURE-INDUCT "n-b" "n")
          (("2" (SKEEP)
            (("2" (CASE "x = b")
              (("1" (REPLACES -1)
                (("1" (EXPAND "prime_enumeration" 1)
                  (("1" (LIFT-IF) (("1" (PROP) NIL NIL)) NIL)) NIL))
                NIL)
               ("2" (INST -1 "x-1")
                (("1" (PROP)
                  (("1" (EXPAND "prime_enumeration" 2)
                    (("1" (LIFT-IF) (("1" (PROP) NIL NIL)) NIL)) NIL)
                   ("2" (ASSERT) NIL NIL))
                  NIL)
                 ("2" (ASSERT) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((TRUE CONST-DECL "bool" |booleans| NIL)
    (|b| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|x| SKOLEM-CONST-DECL "{n: nat | n >= b}" |prime_enum| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|x| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|a| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL))
   SHOSTAK))
 (|prime_enum_id| 0
  (|prime_enum_id-1| NIL 3946039627
   ("" (MEASURE-INDUCT "n" "n")
    (("" (SKEEP)
      (("" (CASE-REPLACE "x = 0")
        (("1" (EXPAND "prime_enumeration") (("1" (REWRITE "prime_2") NIL NIL))
          NIL)
         ("2" (INST -1 "x-1")
          (("1" (ASSERT)
            (("1" (PROP)
              (("1" (EXPAND "prime_enumeration" (2 3))
                (("1" (LIFT-IF) (("1" (PROP) NIL NIL)) NIL)) NIL)
               ("2" (EXPAND "prime_enumeration" (2 3))
                (("2" (LIFT-IF) (("2" (PROP) (("2" (ASSERT) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (ASSERT) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|x| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK))
 (|prime_enum_ineq| 0
  (|prime_enum_ineq-1| NIL 3946039655 ("" (GRIND) NIL NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL))
   SHOSTAK))
 (|prime_enum_ineq2| 0
  (|prime_enum_ineq2-1| NIL 3946039676
   ("" (MEASURE-INDUCT "n" "n")
    (("" (SKEEP)
      (("" (CASE-REPLACE "x = 0")
        (("1" (EXPAND "prime_enumeration") (("1" (ASSERT) NIL NIL)) NIL)
         ("2" (INST -1 "x-1")
          (("1" (ASSERT)
            (("1" (PROP)
              (("1" (CASE "prime_enumeration(x-1) < prime_enumeration(x)")
                (("1" (ASSERT) NIL NIL)
                 ("2" (HIDE-ALL-BUT (-2 1))
                  (("2" (NAME-REPLACE "p1" "prime_enumeration(x - 1)")
                    (("2" (EXPAND "prime_enumeration")
                      (("2" (LIFT-IF)
                        (("2" (PROP)
                          (("1" (EXPAND "prime?") (("1" (PROPAX) NIL NIL)) NIL)
                           ("2" (EXPAND "prime?") (("2" (PROPAX) NIL NIL)) NIL)
                           ("3" (EXPAND "prime?") (("3" (PROPAX) NIL NIL)) NIL)
                           ("4" (EXPAND "prime?") (("4" (PROPAX) NIL NIL)) NIL)
                           ("5" (EXPAND "p1")
                            (("5"
                              (TYPEPRED
                               "min({p: (prime?) | p > prime_enumeration(x - 1)})")
                              (("1" (ASSERT) NIL NIL)
                               ("2" (HIDE-ALL-BUT 1)
                                (("2" (SKEEP)
                                  (("2" (TYPEPRED "x!1")
                                    (("2" (EXPAND "prime?")
                                      (("2" (FLATTEN) (("2" (ASSERT) NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("3" (EXPAND "nonempty?")
                                (("3" (PROPAX) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (LEMMA "prime_enum_id")
                (("2" (INST -1 "x-1")
                  (("2" (PROP)
                    (("2" (EXPAND "prime_enumeration" -2)
                      (("2" (PROP)
                        (("1" (EXPAND "prime?") (("1" (PROPAX) NIL NIL)) NIL)
                         ("2" (EXPAND "prime?") (("2" (PROPAX) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (ASSERT) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|x| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|p1| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|prime_enum_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK))
 (|prime_enum_ineq3| 0
  (|prime_enum_ineq3-1| NIL 3946039701
   ("" (SKEEP)
    (("" (LEMMA "prime_enum_id")
      (("" (INST -1 "j")
        (("" (PROP)
          (("1" (REPLACES -1)
            (("1" (EXPAND "prime?")
              (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL))
            NIL)
           ("2" (CASE "i > j")
            (("1" (EXPAND ">")
              (("1"
                (CASE
                    "FORALL(j:nat): FORALL(i:nat| j < i): prime_enumeration(i) /= 0 AND prime_enumeration(j) /= 0 => prime_enumeration(i) > prime_enumeration(j) ")
                (("1" (INST -1 "j")
                  (("1" (INST -1 "i")
                    (("1" (PROP)
                      (("1" (ASSERT) NIL NIL)
                       ("2" (EXPAND "prime?")
                        (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)
                       ("3" (EXPAND "prime?")
                        (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (HIDE-ALL-BUT 1)
                  (("2" (SKOLEM 1 "b")
                    (("2" (MEASURE-INDUCT "i-b-1" "i")
                      (("2" (SKEEP)
                        (("2" (CASE-REPLACE "x = b+1")
                          (("1" (LEMMA "prime_enum_ineq")
                            (("1" (INST -1 "b") (("1" (ASSERT) NIL NIL)) NIL))
                            NIL)
                           ("2" (INST -1 "x-1")
                            (("1" (ASSERT)
                              (("1" (PROP)
                                (("1" (LEMMA "prime_enum_ineq")
                                  (("1" (INST -1 "x-1")
                                    (("1" (ASSERT) NIL NIL)) NIL))
                                  NIL)
                                 ("2" (LEMMA "prime_enum_tail_gen")
                                  (("2" (INST -1 "x-1")
                                    (("2" (ASSERT)
                                      (("2" (INST -1 "x") NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (ASSERT) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_enum_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|prime_enum_ineq| FORMULA-DECL NIL |prime_enum| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|prime_enum_tail_gen| FORMULA-DECL NIL |prime_enum| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|b| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|x| SKOLEM-CONST-DECL "{i: nat | b < i}" |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|i| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|j| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   SHOSTAK))
 (|prime_enum_surj_lem_TCC1| 0
  (|prime_enum_surj_lem_TCC1-1| NIL 3946039579
   ("" (SKEEP)
    (("" (PROP)
      (("1" (EXPAND "is_finite")
        (("1" (INST 1 "n+1" "LAMBDA(i:({p: nat | prime?(p) AND p <= n})):i")
          (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)) NIL))
        NIL)
       ("2" (EXPAND "empty?")
        (("2" (INST -1 "2")
          (("2" (EXPAND "member") (("2" (REWRITE "prime_2") NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|prime_enum_surj_lem| SUBTYPE
    "{p: naturalnumbers.nat | booleans.AND(primes.prime?(p), reals.<=(p, prime_enum.n))}"
    "non_empty_finite_set[nat]")))
 (|prime_enum_surj_lem| 0
  (|prime_enum_surj_lem-1| NIL 3946039768
   (""
    (CASE " FORALL (n: nat | n >= 2):
        is_finite[nat]({p: nat | prime?(p) AND p <= n}) AND
         NOT empty?[nat]({p: nat | prime?(p) AND p <= n})")
    (("1" (MEASURE-INDUCT "n-2" "n")
      (("1" (SKEEP)
        (("1" (CASE-REPLACE "x = 2")
          (("1" (INST 1 "0")
            (("1" (EXPAND "prime_enumeration")
              (("1" (HIDE -1 -2)
                (("1"
                  (TYPEPRED
                   "max_finite_set_nat.max({p: nat | prime?(p) AND p <= 2})")
                  (("1" (INST -3 "2")
                    (("1" (ASSERT) (("1" (REWRITE "prime_2") NIL NIL)) NIL))
                    NIL)
                   ("2" (INST -1 "2") NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (INST -1 "x-1")
            (("1" (ASSERT)
              (("1" (SKEEP)
                (("1"
                  (NAME-REPLACE "m1"
                   "max_finite_set_nat.max({p: nat | prime?(p) AND p <= x - 1})")
                  (("1"
                    (NAME-REPLACE "m2"
                     "max_finite_set_nat.max({p: nat | prime?(p) AND p <= x})")
                    (("1" (CASE "m1 > m2")
                      (("1" (TYPEPRED "m1")
                        (("1" (TYPEPRED "m2")
                          (("1" (INST -3 "m1") (("1" (ASSERT) NIL NIL)) NIL))
                          NIL))
                        NIL)
                       ("2" (CASE "m1 = m2")
                        (("1" (INST 3 "i") (("1" (ASSERT) NIL NIL)) NIL)
                         ("2" (CASE "m1 < m2")
                          (("1" (INST 4 "i+1")
                            (("1" (EXPAND "prime_enumeration" 4)
                              (("1" (LIFT-IF)
                                (("1" (PROP)
                                  (("1" (REPLACE -3 -2 :DIR RL)
                                    (("1" (TYPEPRED "m2")
                                      (("1" (EXPAND "empty?")
                                        (("1" (INST -4 "m2")
                                          (("1" (EXPAND "member")
                                            (("1" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (TYPEPRED "m1")
                                    (("2" (EXPAND "prime?")
                                      (("2" (FLATTEN) (("2" (ASSERT) NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("3"
                                    (NAME-REPLACE "m3"
                                     "min({p: (prime?) | p > prime_enumeration(i)})")
                                    (("1" (CASE "m3 < m2")
                                      (("1" (CASE-REPLACE "m2 = x")
                                        (("1" (TYPEPRED "m1")
                                          (("1" (INST -3 "m3")
                                            (("1" (TYPEPRED "m3")
                                              (("1" (ASSERT) NIL NIL)) NIL)
                                             ("2" (TYPEPRED "m3")
                                              (("2" (EXPAND "prime?")
                                                (("2" (FLATTEN)
                                                  (("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL)
                                         ("2" (CASE "m2 < x")
                                          (("1" (TYPEPRED "m1")
                                            (("1" (INST -3 "m2")
                                              (("1" (ASSERT) NIL NIL)) NIL))
                                            NIL)
                                           ("2" (ASSERT) NIL NIL))
                                          NIL))
                                        NIL)
                                       ("2" (TYPEPRED "m3")
                                        (("2" (INST -3 "m2")
                                          (("2" (ASSERT) NIL NIL)) NIL))
                                        NIL))
                                      NIL)
                                     ("2" (SKEEP)
                                      (("2" (TYPEPRED "x!1")
                                        (("2" (EXPAND "prime?")
                                          (("2" (FLATTEN)
                                            (("2" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("3" (EXPAND "nonempty?")
                                      (("3" (PROPAX) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (INST -2 "x") NIL NIL))
                    NIL)
                   ("2" (INST -2 "x-1") NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL)
     ("2" (HIDE 2)
      (("2" (SKEEP)
        (("2" (PROP)
          (("1" (EXPAND "is_finite")
            (("1" (INST 1 "n+1" "LAMBDA(i:nat| i<=n): i")
              (("1" (EXPAND "injective?")
                (("1" (SKEEP)
                  (("1" (EXPAND "restrict") (("1" (PROPAX) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (EXPAND "empty?")
            (("2" (INST -1 "2")
              (("2" (EXPAND "member") (("2" (REWRITE "prime_2") NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|restrict| CONST-DECL "R" |restrict| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|i| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|m3| SKOLEM-CONST-DECL "{a |
   a > prime_enumeration(i) AND
    FORALL (x: (prime?)): x > prime_enumeration(i) IMPLIES a <= x}"
     |prime_enum| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|x| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (<= CONST-DECL "bool" |reals| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   SHOSTAK))
 (|prime_enum_inj| 0
  (|prime_enum_inj-1| NIL 3946039728
   ("" (SKEEP)
    (("" (LEMMA "prime_enum_ineq3")
      (("" (INST-CP -1 "i" "j")
        (("" (INST -1 "j" "i") (("" (ASSERT) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|prime_enum_ineq3| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   SHOSTAK))
 (|prime_enum_surj| 0
  (|prime_enum_surj-1| NIL 3946039821
   ("" (SKEEP)
    (("" (LEMMA "prime_enum_surj_lem")
      (("" (INST -1 "p")
        (("1" (SKEEP)
          (("1"
            (NAME-REPLACE "mp"
             "max_finite_set_nat.max({p_1: nat | prime?(p_1) AND p_1 <= p})")
            (("1" (TYPEPRED "mp")
              (("1" (INST -3 "p")
                (("1" (INST 1 "i") (("1" (ASSERT) NIL NIL)) NIL)
                 ("2" (TYPEPRED "p")
                  (("2" (EXPAND "prime?")
                    (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE -1 2)
              (("2" (PROP)
                (("1" (EXPAND "is_finite")
                  (("1" (INST 1 "p+1" "LAMBDA(i:nat| i<=p): i")
                    (("1" (EXPAND "injective?")
                      (("1" (SKEEP)
                        (("1" (EXPAND "restrict") (("1" (PROPAX) NIL NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (TYPEPRED "p")
                      (("2" (EXPAND "prime?")
                        (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND "empty?")
                  (("2" (INST -1 "2")
                    (("2" (EXPAND "member")
                      (("2" (REWRITE "prime_2")
                        (("2" (TYPEPRED "p")
                          (("2" (EXPAND "prime?")
                            (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (TYPEPRED "p")
          (("2" (EXPAND "prime?")
            (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_enum_surj_lem| FORMULA-DECL NIL |prime_enum| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|restrict| CONST-DECL "R" |restrict| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (<= CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|p| SKOLEM-CONST-DECL "(prime?)" |prime_enum| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL))
   SHOSTAK))
 (|prime_counting_TCC1| 0
  (|prime_counting_TCC1-1| NIL 3946039404
   ("" (SKEEP)
    (("" (EXPAND "is_finite")
      (("" (INST 1 "n+1" "LAMBDA(i:(primes_le_n(n))):i")
        (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)
         ("2" (SKEEP)
          (("2" (TYPEPRED "i")
            (("2" (EXPAND "primes_le_n")
              (("2" (ASSERT)
                (("2" (EXPAND "prime?") (("2" (PROPAX) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL))
   NIL
   (|prime_counting| SUBTYPE "prime_enum.primes_le_n(prime_enum.n)"
    "finite_set[(prime?)]")))
 (|prime_le_n_is_prime| 0
  (|prime_le_n_is_prime-1| NIL 3946926649 ("" (GRIND) NIL NIL) NIL SHOSTAK))
 (|prime_count_eq_zero| 0
  (|prime_count_eq_zero-1| NIL 3946818394
   ("" (SKEEP)
    (("" (EXPAND "prime_counting")
      (("" (REWRITE "card_is_0")
        (("" (EXPAND "primes_le_n")
          (("" (EXPAND "emptyset")
            (("" (DECOMPOSE-EQUALITY)
              (("" (TYPEPRED "n")
                (("" (TYPEPRED "x!1")
                  (("" (EXPAND "prime?") (("" (PROPAX) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|card_is_0| FORMULA-DECL NIL |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |finite_sets_inductions|
     |finite_sets|)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |seq_extras|
     |structures|)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL))
   SHOSTAK))
 (|prime_count_ge_one| 0
  (|prime_count_ge_one-1| NIL 3950087639
   ("" (SKEEP)
    (("" (EXPAND "prime_counting")
      (("" (LEMMA "card_less_than_equal[nat, (prime?)]")
        (("" (INST -1 "singleton[nat](2)" "primes_le_n(n)")
          (("" (REWRITE "card_singleton")
            (("" (FLATTEN)
              (("" (HIDE -1)
                (("" (ASSERT)
                  (("" (EXPAND "card_le")
                    (("" (INST 1 "LAMBDA(i:(singleton[nat](2))):i")
                      (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)
                       ("2" (SKEEP)
                        (("2" (TYPEPRED "i")
                          (("2" (EXPAND "singleton")
                            (("2" (REPLACES -1)
                              (("2" (REWRITE "prime_2")
                                (("2" (EXPAND "primes_le_n")
                                  (("2" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|singleton?| CONST-DECL "bool" |sets| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[nat]" |max_finite_set_nat| |ints|)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|card_le| CONST-DECL "bool" |card_comp_set| |sets_aux|)
    (|card_singleton| FORMULA-DECL NIL |finite_sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|card_less_than_equal| FORMULA-DECL NIL |card_finite| |sets_aux|))
   SHOSTAK))
 (|prime_enum_count_TCC1| 0
  (|prime_enum_count_TCC1-1| NIL 3946044326
   ("" (LEMMA "prime_count_ge_one")
    (("" (SKEEP) (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|prime_count_ge_one| FORMULA-DECL NIL |prime_enum| NIL))
   NIL
   (|prime_enum_count| SUBTYPE
    "(number_fields.-)(prime_enum.prime_counting(prime_enum.n), 1)" "nat")))
 (|prime_enum_count_TCC2| 0
  (|prime_enum_count_TCC2-1| NIL 3946044326
   ("" (SKEEP)
    (("" (PROP)
      (("1" (SKEEP)
        (("1" (LEMMA "prime_le_n_is_prime")
          (("1" (INST -1 "n" "x")
            (("1" (ASSERT)
              (("1" (EXPAND "prime?") (("1" (PROPAX) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("2" (EXPAND "is_finite")
        (("2" (INST 1 "n+1" "LAMBDA(i:(primes_le_n(n))):i")
          (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)
           ("2" (SKEEP)
            (("2" (TYPEPRED "i")
              (("2" (EXPAND "prime?")
                (("2" (EXPAND "primes_le_n")
                  (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (EXPAND "empty?")
        (("3" (INST -1 "2")
          (("3" (EXPAND "member")
            (("3" (EXPAND "primes_le_n") (("3" (ASSERT) NIL NIL)) NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_le_n_is_prime| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (|x| SKOLEM-CONST-DECL "int" |prime_enum| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL))
   NIL
   (|prime_enum_count| SUBTYPE "prime_enum.primes_le_n(prime_enum.n)"
    "non_empty_finite_set[nat]")))
 (|prime_enum_count| 0
  (|prime_enum_count-1| NIL 3946044327
   ("" (MEASURE-INDUCT "n" "n")
    (("1" (SKEEP)
      (("1" (CASE-REPLACE "x = 2")
        (("1" (HIDE -2)
          (("1" (EXPAND "prime_counting")
            (("1" (CASE-REPLACE "primes_le_n(2) = singleton[(prime?)](2)")
              (("1" (REWRITE "card_singleton")
                (("1" (EXPAND "prime_enumeration")
                  (("1"
                    (TYPEPRED "max_finite_set_nat.max(singleton[(prime?)](2))")
                    (("1" (EXPAND "singleton") (("1" (ASSERT) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (HIDE 2)
                (("2" (EXPAND "primes_le_n")
                  (("2" (EXPAND "singleton")
                    (("2" (DECOMPOSE-EQUALITY)
                      (("2" (IFF)
                        (("2" (PROP)
                          (("1" (TYPEPRED "x!1")
                            (("1" (EXPAND "prime?") (("1" (ASSERT) NIL NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (REWRITE "prime_2") NIL NIL))
              NIL))
            NIL))
          NIL)
         ("2" (INST -1 "x-1")
          (("1" (ASSERT)
            (("1" (EXPAND "prime_counting")
              (("1" (CASE "prime?(x)")
                (("1"
                  (CASE-REPLACE
                   "primes_le_n(x) = union[(prime?)](primes_le_n(x-1), singleton[(prime?)](x))")
                  (("1" (REWRITE "card_disj_union")
                    (("1" (REWRITE "card_singleton")
                      (("1" (ASSERT)
                        (("1" (REPLACE -1 2 RL HIDE)
                          (("1"
                            (CASE-REPLACE
                             "max_finite_set_nat.max(primes_le_n(x)) = x")
                            (("1" (EXPAND "prime_enumeration" 2)
                              (("1" (LIFT-IF)
                                (("1" (PROP)
                                  (("1" (REWRITE "card_is_0")
                                    (("1" (DECOMPOSE-EQUALITY)
                                      (("1"
                                        (INST -1
                                         "max_finite_set_nat.max(primes_le_n(x - 1))")
                                        (("1" (EXPAND "emptyset")
                                          (("1" (PROPAX) NIL NIL)) NIL)
                                         ("2"
                                          (TYPEPRED
                                           "max_finite_set_nat.max(primes_le_n(x - 1))")
                                          (("2" (LEMMA "prime_le_n_is_prime")
                                            (("2"
                                              (INST -1 "x-1"
                                               "max_finite_set_nat.max(primes_le_n(x - 1))")
                                              NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (EXPAND "empty?")
                                    (("2" (INST -1 "x")
                                      (("2" (EXPAND "member")
                                        (("2" (REPLACES -3)
                                          (("2"
                                            (TYPEPRED
                                             "max_finite_set_nat.max(primes_le_n(x - 1))")
                                            (("2" (EXPAND "primes_le_n")
                                              (("2" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("3" (REPLACE -4 -1)
                                    (("3"
                                      (TYPEPRED
                                       "max_finite_set_nat.max(primes_le_n(x - 1))")
                                      (("3" (REPLACES -3)
                                        (("3" (LEMMA "prime_le_n_is_prime")
                                          (("3" (INST -1 "x-1" "0")
                                            (("3" (EXPAND "prime?")
                                              (("3" (PROPAX) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("4"
                                    (NAME-REPLACE "next_prime"
                                     "min({p: (prime?) |
             p > prime_enumeration(card[(prime?)](primes_le_n(x - 1)) - 1)})")
                                    (("1" (TYPEPRED "next_prime")
                                      (("1" (INST -3 "x")
                                        (("1" (SPLIT)
                                          (("1" (REPLACES -6)
                                            (("1" (EXPAND "<=")
                                              (("1" (ASSERT)
                                                (("1"
                                                  (TYPEPRED
                                                   "max_finite_set_nat.max(primes_le_n(x - 1))")
                                                  (("1" (INST -2 "next_prime")
                                                    (("1" (SPLIT)
                                                      (("1" (ASSERT) NIL NIL)
                                                       ("2"
                                                        (EXPAND "primes_le_n")
                                                        (("2" (ASSERT) NIL
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL)
                                           ("2" (REPLACES -5)
                                            (("2"
                                              (TYPEPRED
                                               "max_finite_set_nat.max(primes_le_n(x - 1))")
                                              (("2" (EXPAND "primes_le_n")
                                                (("2" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (HIDE-ALL-BUT 1)
                                      (("2" (SKEEP)
                                        (("2" (TYPEPRED "x!1")
                                          (("2" (EXPAND "prime?")
                                            (("2" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("3" (EXPAND "nonempty?")
                                      (("3" (PROPAX) NIL NIL)) NIL)
                                     ("4" (HIDE-ALL-BUT (1 6))
                                      (("4" (SKEEP)
                                        (("4" (TYPEPRED "x")
                                          (("4" (LEMMA "prime_count_ge_one")
                                            (("4" (INST -1 "x-1")
                                              (("4" (EXPAND "prime_counting")
                                                (("4" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2"
                              (TYPEPRED
                               "max_finite_set_nat.max(primes_le_n(x))")
                              (("2" (EXPAND "primes_le_n")
                                (("2" (INST -2 "x") (("2" (ASSERT) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (HIDE-ALL-BUT 1)
                      (("2" (EXPAND "disjoint?")
                        (("2" (EXPAND "empty?")
                          (("2" (SKEEP)
                            (("2" (EXPAND "member")
                              (("2" (EXPAND "intersection")
                                (("2" (EXPAND "member")
                                  (("2" (FLATTEN)
                                    (("2" (EXPAND "singleton")
                                      (("2" (EXPAND "primes_le_n")
                                        (("2" (ASSERT) NIL NIL)) NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (HIDE-ALL-BUT (-1 1))
                    (("2" (EXPAND "primes_le_n")
                      (("2" (EXPAND "union")
                        (("2" (EXPAND "member")
                          (("2" (DECOMPOSE-EQUALITY)
                            (("2" (IFF)
                              (("2" (PROP)
                                (("1" (EXPAND "singleton")
                                  (("1" (ASSERT) NIL NIL)) NIL)
                                 ("2" (ASSERT) NIL NIL)
                                 ("3" (EXPAND "singleton")
                                  (("3" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (CASE-REPLACE "primes_le_n(x - 1) = primes_le_n(x)")
                  (("2" (HIDE -1 4)
                    (("2" (DECOMPOSE-EQUALITY)
                      (("2" (EXPAND "primes_le_n")
                        (("2" (IFF)
                          (("2" (PROP)
                            (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (ASSERT) NIL NIL))
          NIL))
        NIL))
      NIL)
     ("2" (HIDE 2)
      (("2" (SKEEP)
        (("2" (PROP)
          (("1" (SKEEP)
            (("1" (LEMMA "prime_le_n_is_prime")
              (("1" (INST -1 "n" "x")
                (("1" (ASSERT)
                  (("1" (EXPAND "prime?") (("1" (PROPAX) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL)
           ("2" (EXPAND "is_finite")
            (("2" (INST 1 "n+1" "LAMBDA(i:(primes_le_n(n))):i")
              (("1" (EXPAND "injective?") (("1" (SKEEP) NIL NIL)) NIL)
               ("2" (SKEEP)
                (("2" (TYPEPRED "i")
                  (("2" (EXPAND "prime?")
                    (("2" (EXPAND "primes_le_n")
                      (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (EXPAND "empty?")
            (("3" (INST -1 "2")
              (("3" (EXPAND "member")
                (("3" (EXPAND "primes_le_n") (("3" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL)
     ("3" (SKEEP)
      (("3" (SKEEP)
        (("3" (LEMMA "prime_count_ge_one")
          (("3" (INST -1 "n") (("3" (ASSERT) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (|x| SKOLEM-CONST-DECL "int" |prime_enum| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|x| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|nonempty_union2| APPLICATION-JUDGEMENT "(nonempty?)" |sets| NIL)
    (|intersection| CONST-DECL "set" |sets| NIL)
    (|disjoint?| CONST-DECL "bool" |sets| NIL)
    (|finite_intersection1| APPLICATION-JUDGEMENT "finite_set[T]"
     |finite_sets_inductions| |finite_sets|)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|prime_le_n_is_prime| FORMULA-DECL NIL |prime_enum| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |seq_extras|
     |structures|)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |finite_sets_inductions|
     |finite_sets|)
    (|card_is_0| FORMULA-DECL NIL |finite_sets| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|prime_count_ge_one| FORMULA-DECL NIL |prime_enum| NIL)
    (|card| CONST-DECL "{n: nat | n = Card(S)}" |finite_sets| NIL)
    (|Card| CONST-DECL "nat" |finite_sets| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
     |min_nat| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|card_disj_union| FORMULA-DECL NIL |finite_sets| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[T]" |finite_sets_inductions| |finite_sets|)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[nat]" |max_finite_set_nat| |ints|)
    (|singleton?| CONST-DECL "bool" |sets| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|card_singleton| FORMULA-DECL NIL |finite_sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK))
 (|prime_le_n_surj| 0
  (|prime_le_n_surj-1| NIL 3946039412
   ("" (SKEEP)
    (("" (CASE "n >= 2")
      (("1" (LEMMA "prime_enum_count")
        (("1" (INST -1 "n")
          (("1" (LEMMA "prime_enum_surj")
            (("1" (INST -1 "p")
              (("1" (SKEEP)
                (("1" (TYPEPRED "max_finite_set_nat.max(primes_le_n(n))")
                  (("1" (INST -2 "p")
                    (("1" (ASSERT)
                      (("1" (REPLACE -3 -2 RL)
                        (("1" (REPLACE -4 -2 RL)
                          (("1" (LEMMA "prime_enum_ineq3")
                            (("1" (INST -1 "i" "prime_counting(n) - 1")
                              (("1" (ASSERT) (("1" (INST 1 "i") NIL NIL)) NIL)
                               ("2" (HIDE-ALL-BUT (-5 1))
                                (("2" (EXPAND "prime_counting")
                                  (("2" (EXPAND "primes_le_n")
                                    (("2" (LEMMA "Card_surjection[(prime?)]")
                                      (("2"
                                        (INST -1 "{p: (prime?) | p <= n}" "1")
                                        (("1" (PROP)
                                          (("1" (ASSERT) NIL NIL)
                                           ("2"
                                            (INST 1
                                             "LAMBDA(i:({p: (prime?) | p <= n})): 0")
                                            (("2" (EXPAND "surjective?")
                                              (("2" (SKEEP)
                                                (("2" (INST 1 "2")
                                                  (("2" (REWRITE "prime_2") NIL
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL)
                                         ("2" (EXPAND "is_finite")
                                          (("2"
                                            (INST 1 "n+1"
                                             "LAMBDA(i:({p: (prime?) | p <= n})):i")
                                            (("1" (EXPAND "injective?")
                                              (("1" (SKEEP) NIL NIL)) NIL)
                                             ("2" (SKEEP)
                                              (("2" (TYPEPRED "i!1")
                                                (("2" (EXPAND "prime?")
                                                  (("2" (ASSERT) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (HIDE-ALL-BUT 1)
                      (("2" (TYPEPRED "p")
                        (("2" (EXPAND "prime?") (("2" (ASSERT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "p")
        (("2" (EXPAND "primes_le_n")
          (("2" (CASE "n < 2")
            (("1" (EXPAND "prime?") (("1" (ASSERT) NIL NIL)) NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|Card_surjection| FORMULA-DECL NIL |finite_sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|surjective?| CONST-DECL "bool" |functions| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|prime_enum_ineq3| FORMULA-DECL NIL |prime_enum| NIL)
    (|p| SKOLEM-CONST-DECL "(primes_le_n(n))" |prime_enum| NIL)
    (|prime_enum_surj| FORMULA-DECL NIL |prime_enum| NIL)
    (|prime_enum_count| FORMULA-DECL NIL |prime_enum| NIL))
   SHOSTAK))
 (|prime_index_lt_prime_count| 0
  (|prime_index_lt_prime_count-1| NIL 3950087750
   ("" (SKEEP)
    (("" (LEMMA "prime_enum_count")
      (("" (INST -1 "n")
        (("1" (LEMMA "prime_enum_id")
          (("1" (INST -1 "x")
            (("1" (ASSERT)
              (("1" (LEMMA "prime_enum_tail_gen")
                (("1" (INST -1 "x")
                  (("1" (ASSERT)
                    (("1" (INST -1 "prime_counting(n)-1")
                      (("1" (TYPEPRED "max_finite_set_nat.max(primes_le_n(n))")
                        (("1" (CASE "FORALL(y: (primes_le_n(n))): prime?(y)")
                          (("1" (INST?)
                            (("1"
                              (INST -1
                               "max_finite_set_nat.max(primes_le_n(n))")
                              (("1" (HIDE -2 -3)
                                (("1" (REPLACE -4 -1 RL HIDE)
                                  (("1" (EXPAND "prime?")
                                    (("1" (ASSERT) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (SKEEP)
                            (("2" (TYPEPRED "y") (("2" (PROPAX) NIL NIL)) NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (LEMMA "prime_count_eq_zero")
          (("2" (INST -1 "n") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_enum_count| FORMULA-DECL NIL |prime_enum| NIL)
    (|prime_count_eq_zero| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|prime_enum_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_finite_set_nat| |ints|)
    (|prime_enum_tail_gen| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|n| SKOLEM-CONST-DECL "nat" |prime_enum| NIL))
   SHOSTAK))
 (|one_prime_decomposition_ind| 0
  (|one_prime_decomposition_ind-1| NIL 3947161795
   ("" (MEASURE-INDUCT+ "n" ("n"))
    (("" (CASE "x!1 = 0")
      (("1" (HIDE -2)
        (("1" (INST 2 "2")
          (("1" (GRIND) NIL NIL)
           ("2" (LEMMA "prime_2") (("2" (PROPAX) NIL NIL)) NIL))
          NIL))
        NIL)
       ("2" (CASE "prime?(x!1)")
        (("1" (HIDE -2)
          (("1" (INST 3 "x!1")
            (("1" (EXPAND "divides")
              (("1" (INST 3 "1") (("1" (ASSERT) NIL NIL)) NIL)) NIL))
            NIL))
          NIL)
         ("2" (REWRITE "prime_rew")
          (("2" (PROP)
            (("1" (SKEEP)
              (("1" (INST -4 "j")
                (("1" (ASSERT)
                  (("1" (SKEEP)
                    (("1" (INST 3 "p")
                      (("1" (EXPAND "divides")
                        (("1" (SKEEP)
                          (("1" (SKEEP)
                            (("1" (REPLACE -4 -3)
                              (("1" (INST 3 "x!2 * x") (("1" (ASSERT) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|times_u8_u8| APPLICATION-JUDGEMENT "uint16" |integertypes| NIL)
    (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|prime_rew| FORMULA-DECL NIL |primes| |ints|)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|x!1| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK))
 (|prime_pots_set_TCC1| 0
  (|prime_pots_set_TCC1-1| NIL 3946039404 ("" (SUBTYPE-TCC) NIL NIL)
   ((/= CONST-DECL "boolean" |notequal| NIL)) NIL
   (|prime_pots_set| SUBTYPE "prime_enum.i"
    "{i: integers.int | booleans.OR(prime_enum.prime_enumeration(prime_enum.n) /= 0, reals.>=(i, 0))}")))
 (|max_prime_div_aux_TCC1| 0
  (|max_prime_div_aux_TCC1-1| NIL 3946913621 ("" (SUBTYPE-TCC) NIL NIL)
   ((/= CONST-DECL "boolean" |notequal| NIL)) NIL
   (|max_prime_div_aux| SUBTYPE "prime_enum.i"
    "{i: integers.int | booleans.OR(prime_enum.p /= 0, reals.>=(i, 0))}")))
 (|max_prime_div_aux| 0
  (|max_prime_div_aux-1| NIL 3946913622
   ("" (SKEEP)
    (("" (PROP)
      (("1" (EXPAND "nonempty?")
        (("1" (EXPAND "empty?")
          (("1" (INST -1 "1")
            (("1" (EXPAND "member")
              (("1" (INST 1 "0")
                (("1" (EXPAND "^")
                  (("1" (EXPAND "expt") (("1" (REWRITE "one_divides") NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (INST 1 "n")
        (("2" (SKEEP)
          (("2" (TYPEPRED "y")
            (("2" (SKEEP)
              (("2" (LEMMA "divisor_smaller")
                (("2" (INST -1 "y" "n") (("2" (ASSERT) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|one_divides| FORMULA-DECL NIL |divides| NIL)
    (|expt| DEF-DECL "real" |exponentiation| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|divisor_smaller| FORMULA-DECL NIL |divides| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL))
   SHOSTAK))
 (|max_prime_div_TCC1| 0
  (|max_prime_div_TCC2-1| NIL 3945367347
   ("" (LEMMA "max_prime_div_aux") (("" (PROPAX) NIL NIL)) NIL)
   ((|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)) NIL
   (|max_prime_div| SUBTYPE
    "{m: integers.posnat | EXISTS (i: naturalnumbers.nat): booleans.AND(m = exponentiation.^(prime_enum.p, i), divides.divides(m, prime_enum.n))}"
    "{A: (sets[posnat].nonempty?) | EXISTS UB: FORALL (y: (A)): reals.<=(y, max_bounded_posnat.UB)}")))
 (|max_prime_div_idx_aux| 0
  (|max_prime_div_idx_aux-1| NIL 3946913552
   ("" (SKEEP)
    (("" (EXPAND "singleton?")
      (("" (NAME "a" "max_prime_div(p, n)")
        (("" (EXPAND "max_prime_div")
          ((""
            (TYPEPRED
             "max({m: posnat | EXISTS (i: nat): m = p ^ i AND divides(m, n)})")
            (("1" (SKEEP)
              (("1" (INST 1 "i_1")
                (("1" (SKEEP)
                  (("1" (TYPEPRED "i_1")
                    (("1" (TYPEPRED "y")
                      (("1" (EXPAND "max_prime_div")
                        (("1" (REPLACES -4)
                          (("1" (HIDE-ALL-BUT (-1 1))
                            (("1" (LEMMA "both_sides_expt_gt1_le")
                              (("1" (INST -1 "p" "y" "i_1")
                                (("1" (FLATTEN)
                                  (("1" (HIDE -2)
                                    (("1" (ASSERT)
                                      (("1" (LEMMA "both_sides_expt_gt1_le")
                                        (("1" (INST -1 "p" "i_1" "y")
                                          (("1" (FLATTEN)
                                            (("1" (HIDE -2)
                                              (("1" (ASSERT) NIL NIL)) NIL))
                                            NIL)
                                           ("2" (TYPEPRED "p")
                                            (("2" (EXPAND "prime?")
                                              (("2" (FLATTEN)
                                                (("2" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (TYPEPRED "p")
                                  (("2" (EXPAND "prime?")
                                    (("2" (FLATTEN) (("2" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND "max_prime_div") (("2" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL)
             ("2" (LEMMA "max_prime_div_aux") (("2" (INST?) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|singleton?| CONST-DECL "bool" |sets| NIL)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|both_sides_expt_gt1_le| FORMULA-DECL NIL |exponentiation| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|p| SKOLEM-CONST-DECL "(prime?)" |prime_enum| NIL)
    (|i_1| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   SHOSTAK))
 (|max_prime_div_idx_TCC1| 0
  (|max_prime_div_idx_TCC1-1| NIL 3946911905
   ("" (SKEEP)
    (("" (EXPAND "singleton?")
      (("" (NAME "a" "max_prime_div(p, n)")
        (("" (EXPAND "max_prime_div")
          ((""
            (TYPEPRED
             "max({m: posnat | EXISTS (i: nat): m = p ^ i AND divides(m, n)})")
            (("1" (SKEEP)
              (("1" (INST 1 "i_1")
                (("1" (SKEEP)
                  (("1" (TYPEPRED "i_1")
                    (("1" (TYPEPRED "y")
                      (("1" (EXPAND "max_prime_div")
                        (("1" (REPLACES -4)
                          (("1" (HIDE-ALL-BUT (-1 1))
                            (("1" (LEMMA "both_sides_expt_gt1_le")
                              (("1" (INST -1 "p" "y" "i_1")
                                (("1" (FLATTEN)
                                  (("1" (HIDE -2)
                                    (("1" (ASSERT)
                                      (("1" (LEMMA "both_sides_expt_gt1_le")
                                        (("1" (INST -1 "p" "i_1" "y")
                                          (("1" (FLATTEN)
                                            (("1" (HIDE -2)
                                              (("1" (ASSERT) NIL NIL)) NIL))
                                            NIL)
                                           ("2" (TYPEPRED "p")
                                            (("2" (EXPAND "prime?")
                                              (("2" (FLATTEN)
                                                (("2" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (TYPEPRED "p")
                                  (("2" (EXPAND "prime?")
                                    (("2" (FLATTEN) (("2" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND "max_prime_div") (("2" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL)
             ("2" (PROP)
              (("1" (EXPAND "nonempty?")
                (("1" (EXPAND "empty?")
                  (("1" (INST -1 "1")
                    (("1" (EXPAND "member")
                      (("1" (INST 1 "0")
                        (("1" (EXPAND "^")
                          (("1" (EXPAND "expt")
                            (("1" (REWRITE "one_divides") NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (INST 1 "n")
                (("2" (SKEEP)
                  (("2" (TYPEPRED "y")
                    (("2" (SKEEP)
                      (("2" (LEMMA "divisor_smaller")
                        (("2" (INST -1 "y" "n") (("2" (ASSERT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|singleton?| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|one_divides| FORMULA-DECL NIL |divides| NIL)
    (|expt| DEF-DECL "real" |exponentiation| NIL)
    (|divisor_smaller| FORMULA-DECL NIL |divides| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|both_sides_expt_gt1_le| FORMULA-DECL NIL |exponentiation| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|p| SKOLEM-CONST-DECL "(prime?)" |prime_enum| NIL)
    (|i_1| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   NIL
   (|max_prime_div_idx| SUBTYPE
    "{i: naturalnumbers.nat | exponentiation.^(prime_enum.p, i) = prime_enum.max_prime_div(prime_enum.p, prime_enum.n)}"
    "(sets[nat].singleton?)")))
 (|max_prime_id_TCC1| 0
  (|max_prime_id_TCC1-1| NIL 3946912823 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (> CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|singleton_elt| CONST-DECL "T" |sets| NIL)
    (|max_prime_div_idx| CONST-DECL "nat" |prime_enum| NIL))
   NIL
   (|max_prime_id| SUBTYPE
    "prime_enum.max_prime_div_idx(prime_enum.p, prime_enum.n)"
    "{i: integers.int | booleans.OR(prime_enum.p /= 0, reals.>=(i, 0))}")))
 (|max_prime_id| 0
  (|max_prime_id-1| NIL 3946912823
   ("" (SKEEP)
    (("" (EXPAND "max_prime_div_idx")
      (("" (LEMMA "singleton_elt_def[nat]")
        (("" (INST -1 "{i: nat | p ^ i = max_prime_div(p, n)}")
          (("" (ASSERT)
            (("" (SPLIT)
              (("1" (REPLACES -1)
                (("1"
                  (TYPEPRED "choose({i: nat | p ^ i = max_prime_div(p, n)})")
                  (("1" (PROPAX) NIL NIL)
                   ("2" (EXPAND "nonempty?")
                    (("2" (EXPAND "empty?")
                      (("2" (EXPAND "max_prime_div")
                        (("2"
                          (TYPEPRED
                           " max({m: posnat | EXISTS (i: nat): m = p ^ i AND divides(m, n)})")
                          (("1" (SKEEP)
                            (("1" (INST -5 "i_1")
                              (("1" (EXPAND "member") (("1" (ASSERT) NIL NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (LEMMA "max_prime_div_aux")
                            (("2" (INST?) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (LEMMA "max_prime_div_idx_aux") (("2" (INST?) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|max_prime_div_idx| CONST-DECL "nat" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|max_prime_div_idx_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|singleton_elt_def| FORMULA-DECL NIL |sets| NIL))
   SHOSTAK))
 (|posnat_prime_decomp_TCC1| 0
  (|posnat_prime_decomp_TCC1-1| NIL 3946039404
   ("" (SKEEP)
    (("" (LEMMA "prime_enum_id")
      (("" (INST -1 "i")
        (("" (ASSERT)
          (("" (REPLACES -1) (("" (REWRITE "zero_div_zero") NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_enum_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|zero_div_zero| FORMULA-DECL NIL |divides| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   NIL
   (|posnat_prime_decomp| SUBTYPE
    "prime_enum.prime_enumeration(prime_enum.i)" "(primes.prime?)")))
 (|posnat_prime_decomp_TCC2| 0
  (|posnat_prime_decomp_TCC2-1| NIL 3946039404
   ("" (SKEEP)
    (("" (EXPAND "prime_decomposition")
      (("" (EXPAND "cartesian_product_n")
        (("" (SKEEP)
          (("" (EXPAND "member")
            (("" (EXPAND "finseq_appl")
              (("" (PROP)
                (("1" (EXPAND "prime_pots_set")
                  (("1" (EXPAND "max_prime_div")
                    (("1"
                      (TYPEPRED "max({m_1: posnat |
               EXISTS (i: nat):
                 m_1 = prime_enumeration(i_1) ^ i AND divides(m_1, m)})")
                      (("1" (SKEEP) (("1" (INST 1 "i_2") NIL NIL)) NIL)
                       ("2" (HIDE 2)
                        (("2" (PROP)
                          (("1" (EXPAND "nonempty?")
                            (("1" (EXPAND "empty?")
                              (("1" (INST -1 "1")
                                (("1" (EXPAND "member")
                                  (("1" (INST 1 "0")
                                    (("1" (EXPAND "^")
                                      (("1" (EXPAND "expt")
                                        (("1" (REWRITE "one_divides") NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (INST 1 "m")
                            (("2" (SKEEP)
                              (("2" (LEMMA "divisor_smaller")
                                (("2" (INST -1 "y" "m")
                                  (("2" (TYPEPRED "y")
                                    (("2" (SKEEP) (("2" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND "prime_pots_set")
                  (("2" (INST 2 "0")
                    (("2" (EXPAND "^")
                      (("2" (EXPAND "expt") (("2" (PROPAX) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|prime_pots_set| CONST-DECL "set[nat]" |prime_enum| NIL)
    (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|one_divides| FORMULA-DECL NIL |divides| NIL)
    (|expt| DEF-DECL "real" |exponentiation| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|divisor_smaller| FORMULA-DECL NIL |divides| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cartesian_product_n| CONST-DECL "set[finseq[T]]"
     |cartesian_product_finite| |algebra|))
   NIL
   (|posnat_prime_decomp| SUBTYPE
    "(# length := prime_enum.k, seq := LAMBDA (i: nat_types[prime_enum.k].below): IF divides.divides(prime_enum.prime_enumeration(i), prime_enum.m) THEN prime_enum.max_prime_div(prime_enum.prime_enumeration(i), prime_enum.m) ELSE 1 ENDIF #)"
    "(prime_enum.prime_decomposition(prime_enum.k))")))
 (|posnat_prime_decomp_aux| 0
  (|posnat_prime_decomp_aux-1| NIL 3946916121
   ("" (SKEEP)
    (("" (EXPAND "max_prime_div")
      ((""
        (TYPEPRED
         "max({m: posnat | EXISTS (i: nat): m = p ^ i AND divides(m, n)})")
        (("1" (SKEEP)
          (("1" (REPLACES -2)
            (("1" (EXPAND "divides")
              (("1" (SKEEP)
                (("1" (EXPAND "^" -2)
                  (("1" (EXPAND "expt")
                    (("1" (LIFT-IF)
                      (("1" (PROP)
                        (("1" (REPLACES -1)
                          (("1" (EXPAND "^")
                            (("1" (EXPAND "expt") (("1" (PROPAX) NIL NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (INST 2 " expt(p, i_1 - 1) * x")
                          (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (LEMMA "max_prime_div_aux") (("2" (INST?) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|i_1| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|int_expt| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|expt| DEF-DECL "real" |exponentiation| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL))
   SHOSTAK))
 (|product_prime_decomp_TCC1| 0
  (|product_prime_decomp_TCC1-1| NIL 3946039404 ("" (SUBTYPE-TCC) NIL NIL) NIL
   NIL (|product_prime_decomp| SUBTYPE "0" "T_low[below[k]]")))
 (|product_prime_decomp_TCC2| 0
  (|product_prime_decomp_TCC2-1| NIL 3946039404 ("" (SUBTYPE-TCC) NIL NIL) NIL
   NIL (|product_prime_decomp| SUBTYPE "prime_enum.n" "T_high[below[k]]")))
 (|product_prime_decomp_TCC3| 0
  (|product_prime_decomp_TCC3-1| NIL 3946039404 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|cartesian_product_n| CONST-DECL "set[finseq[T]]"
     |cartesian_product_finite| |algebra|)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|prime_pots_set| CONST-DECL "set[nat]" |prime_enum| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL))
   NIL (|product_prime_decomp| SUBTYPE "prime_enum.i" "below[fs`length]")))
 (|product_prime_decomp_TCC4| 0
  (|product_prime_decomp_TCC4-1| NIL 3946039404 ("" (ASSUMING-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|prime_pots_set| CONST-DECL "set[nat]" |prime_enum| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cartesian_product_n| CONST-DECL "set[finseq[T]]"
     |cartesian_product_finite| |algebra|)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL))
   NIL
   (|product_prime_decomp| ASSUMING "reals@product[below[k]].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (|prime_comp_divides_TCC1| 0
  (|prime_comp_divides_TCC1-1| NIL 3946904364 ("" (SUBTYPE-TCC) NIL NIL)
   ((|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL))
   NIL
   (|prime_comp_divides| SUBTYPE "prime_enum.i"
    "below[posnat_prime_decomp(n, m)`length]")))
 (|prime_comp_divides| 0
  (|prime_comp_divides-1| NIL 3946904368
   ("" (SKEEP)
    (("" (EXPAND "posnat_prime_decomp")
      (("" (LIFT-IF)
        (("" (PROP)
          (("1" (LEMMA "prime_enum_id")
            (("1" (INST -1 "i")
              (("1" (PROP)
                (("1" (REPLACES -1) (("1" (REWRITE "zero_div_zero") NIL NIL))
                  NIL)
                 ("2" (EXPAND "max_prime_div")
                  (("2" (ASSERT)
                    (("2"
                      (TYPEPRED "max({m_1: posnat |
                     EXISTS (i_1: nat):
                       m_1 = prime_enumeration(i) ^ i_1 AND
                        divides(m_1, m)})")
                      (("1" (ASSERT) NIL NIL)
                       ("2" (LEMMA "max_prime_div_aux") (("2" (INST?) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (REWRITE "one_divides") NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|zero_div_zero| FORMULA-DECL NIL |divides| NIL)
    (|prime_enum_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|one_divides| FORMULA-DECL NIL |divides| NIL))
   SHOSTAK))
 (|prime_comp_gcd_one_TCC1| 0
  (|prime_comp_gcd_one_TCC1-1| NIL 3946906071 ("" (SUBTYPE-TCC) NIL NIL)
   ((/= CONST-DECL "boolean" |notequal| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL))
   NIL
   (|prime_comp_gcd_one| SUBTYPE "prime_enum.j"
    "below[posnat_prime_decomp(n, m)`length]")))
 (|prime_comp_gcd_one_TCC2| 0
  (|prime_comp_gcd_one_TCC2-1| NIL 3946906071 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL))
   NIL
   (|prime_comp_gcd_one| SUBTYPE
    "prime_enum.posnat_prime_decomp(prime_enum.n, prime_enum.m)`seq(prime_enum.j)"
    "{jj: integers.int | booleans.=>(prime_enum.posnat_prime_decomp(prime_enum.n, prime_enum.m)`seq(prime_enum.i) = 0, jj /= 0)}")))
 (|prime_comp_gcd_one| 0
  (|prime_comp_gcd_one-1| NIL 3946906073
   ("" (SKEEP)
    (("" (EXPAND "posnat_prime_decomp")
      (("" (LIFT-IF)
        (("" (LIFT-IF)
          (("" (PROP)
            (("1" (CASE "prime?(prime_enumeration(i))")
              (("1" (CASE "prime?(prime_enumeration(j))")
                (("1" (EXPAND "max_prime_div")
                  (("1"
                    (TYPEPRED "max({m_1: posnat |
                 EXISTS (i_1: nat):
                   m_1 = prime_enumeration(i) ^ i_1 AND divides(m_1, m)})")
                    (("1" (SKEEP)
                      (("1" (REPLACES -2)
                        (("1" (HIDE -1 -2 -3)
                          (("1"
                            (TYPEPRED "max({m_1: posnat |
                 EXISTS (i: nat):
                   m_1 = prime_enumeration(j) ^ i AND divides(m_1, m)})")
                            (("1" (SKEEP)
                              (("1" (REPLACES -2)
                                (("1" (HIDE -1 -2 -3)
                                  (("1" (REWRITE "gcd_one_pot_eq_one")
                                    (("1" (REWRITE "gcd_dif_primes_eq_one")
                                      (("1" (EXPAND "/=")
                                        (("1" (LEMMA "prime_enum_inj")
                                          (("1" (INST -1 "i" "j")
                                            (("1" (ASSERT) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (EXPAND "/=")
                                      (("2" (EXPAND "prime?")
                                        (("2" (PROPAX) NIL NIL)) NIL))
                                      NIL)
                                     ("3" (EXPAND "/=")
                                      (("3" (EXPAND "prime?")
                                        (("3" (PROPAX) NIL NIL)) NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (REWRITE "max_prime_div_aux") NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (REWRITE "max_prime_div_aux") NIL NIL))
                    NIL))
                  NIL)
                 ("2" (HIDE-ALL-BUT (-2 1))
                  (("2" (LEMMA "prime_enum_id")
                    (("2" (INST?)
                      (("2" (ASSERT)
                        (("2" (REPLACES -1)
                          (("2" (REWRITE "zero_div_zero") NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (HIDE-ALL-BUT (-2 1))
                (("2" (LEMMA "prime_enum_id")
                  (("2" (INST?)
                    (("2" (ASSERT)
                      (("2" (REPLACES -1)
                        (("2" (REWRITE "zero_div_zero") NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (REWRITE "gcd_one_right") NIL NIL)
             ("3" (REWRITE "gcd_one_left")
              (("3" (PROP)
                (("3" (LEMMA "prime_enum_id")
                  (("3" (INST?)
                    (("3" (ASSERT)
                      (("3" (REPLACES -1)
                        (("3" (REWRITE "zero_div_zero") NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|gcd_one_left| FORMULA-DECL NIL |number_util| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|gcd_one_right| FORMULA-DECL NIL |number_util| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|zero_div_zero| FORMULA-DECL NIL |divides| NIL)
    (|prime_enum_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (|gcd_dif_primes_eq_one| FORMULA-DECL NIL |number_util| NIL)
    (|prime_enum_inj| FORMULA-DECL NIL |prime_enum| NIL)
    (|nzint| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|gcd_one_pot_eq_one| FORMULA-DECL NIL |number_util| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL))
   SHOSTAK))
 (|product_prime_gcd_TCC1| 0
  (|product_prime_gcd_TCC1-1| NIL 3946905305 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|product_prime_gcd| SUBTYPE "prime_enum.j" "below[n]")))
 (|product_prime_gcd_TCC2| 0
  (|product_prime_gcd_TCC2-1| NIL 3946905305 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL))
   NIL
   (|product_prime_gcd| SUBTYPE
    "prime_enum.product_prime_decomp(prime_enum.n, prime_enum.posnat_prime_decomp(prime_enum.n, prime_enum.m), prime_enum.j)"
    "{jj: integers.int | booleans.=>(prime_enum.posnat_prime_decomp(prime_enum.n, prime_enum.m)`seq(prime_enum.i) = 0, jj /= 0)}")))
 (|product_prime_gcd| 0
  (|product_prime_gcd-1| NIL 3946905407
   ("" (SKEEP)
    (("" (MEASURE-INDUCT "j" "j")
      (("1" (SKEEP)
        (("1" (CASE-REPLACE "x = 0")
          (("1" (HIDE -2)
            (("1" (EXPAND "product_prime_decomp")
              (("1" (EXPAND "product")
                (("1" (EXPAND "product")
                  (("1" (REWRITE "prime_comp_gcd_one") NIL NIL)) NIL))
                NIL))
              NIL))
            NIL)
           ("2" (INST -1 "x-1")
            (("1" (ASSERT)
              (("1" (EXPAND "product_prime_decomp")
                (("1" (EXPAND "product" 2)
                  (("1" (LEMMA "gcd_one_prod_eq_one")
                    (("1"
                      (INST -1 "posnat_prime_decomp(n, m)`seq(i)"
                       "posnat_prime_decomp(n, m)`seq(x)" "product(0, x - 1,
                  LAMBDA (i: nat | i < n):
                    posnat_prime_decomp(n, m)`seq(i))")
                      (("1" (ASSERT)
                        (("1" (HIDE-ALL-BUT 1)
                          (("1" (PROP)
                            (("1" (EXPAND "posnat_prime_decomp")
                              (("1" (LIFT-IF)
                                (("1" (ASSERT)
                                  (("1" (PROP)
                                    (("1" (EXPAND "max_prime_div")
                                      (("1" (ASSERT) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (LEMMA "prime_comp_gcd_one")
                              (("2" (INST -1 "n" "m" "i" "x")
                                (("2" (ASSERT) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)
                       ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL)
       ("2" (HIDE 2)
        (("2" (SKEEP)
          (("2" (HIDE -2)
            (("2" (EXPAND "posnat_prime_decomp")
              (("2" (LIFT-IF)
                (("2" (ASSERT)
                  (("2" (PROP)
                    (("2" (EXPAND "max_prime_div") (("2" (ASSERT) NIL NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|n| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|i| SKOLEM-CONST-DECL "below[n]" |prime_enum| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|m| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL)
    (|gcd| CONST-DECL "{k: posnat | divides(k, i) AND divides(k, j)}" |gcd|
     |ints|)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|prime_comp_gcd_one| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|product| DEF-DECL "real" |product| |reals|)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|T_low| TYPE-EQ-DECL NIL |product| |reals|)
    (|T_high| TYPE-EQ-DECL NIL |product| |reals|)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|gcd_one_prod_eq_one| FORMULA-DECL NIL |number_util| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|x| SKOLEM-CONST-DECL "below[i]" |prime_enum| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|product_prime_id_TCC1| 0
  (|product_prime_id_TCC1-1| NIL 3946049789 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|product_prime_id| SUBTYPE "(number_fields.-)(prime_enum.n, 1)"
    "below[n]")))
 (|product_prime_id| 0
  (|product_prime_id-1| NIL 3946049798
   ("" (SKEEP)
    ((""
      (CASE
          "FORALL(k:nat | k < n): FORALL(l:nat): product_prime_decomp(n, posnat_prime_decomp(n, m), k) = l => divides(l, m)")
      (("1" (INST -1 "n-1") (("1" (INST -1 "l") (("1" (ASSERT) NIL NIL)) NIL))
        NIL)
       ("2" (HIDE -1 2)
        (("2" (MEASURE-INDUCT "k" "k")
          (("2" (SKEEP)
            (("2" (CASE-REPLACE "x = 0")
              (("1" (HIDE -2)
                (("1" (SKEEP)
                  (("1" (EXPAND "product_prime_decomp")
                    (("1" (EXPAND "product")
                      (("1" (EXPAND "product")
                        (("1" (EXPAND "posnat_prime_decomp")
                          (("1" (LIFT-IF)
                            (("1" (PROP)
                              (("1" (EXPAND "max_prime_div")
                                (("1"
                                  (TYPEPRED "max({m_1: posnat |
             EXISTS (i: nat):
               m_1 = prime_enumeration(0) ^ i AND divides(m_1, m)})")
                                  (("1" (SKEEP) (("1" (REPLACES -6) NIL NIL))
                                    NIL)
                                   ("2" (HIDE-ALL-BUT 1)
                                    (("2" (REWRITE "max_prime_div_aux")
                                      (("2" (EXPAND "prime_enumeration")
                                        (("2" (REWRITE "prime_2") NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (REPLACE -1 2 RL HIDE)
                                (("2" (REWRITE "one_divides") NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (INST -1 "x-1")
                (("1" (ASSERT)
                  (("1"
                    (INST -1
                     "product_prime_decomp(n, posnat_prime_decomp(n, m), x - 1)")
                    (("1" (SKEEP)
                      (("1" (EXPAND "product_prime_decomp")
                        (("1" (EXPAND "product" -2)
                          (("1" (LEMMA "prime_comp_divides")
                            (("1" (INST -1 "n" "m" "x")
                              (("1" (LEMMA "divides_gcd_one")
                                (("1"
                                  (INST -1 "posnat_prime_decomp(n, m)`seq(x)"
                                   "product(0, x - 1,
                      LAMBDA (i: nat | i < n):
                        posnat_prime_decomp(n, m)`seq(i))"
                                   "m")
                                  (("1" (ASSERT)
                                    (("1" (HIDE-ALL-BUT 1)
                                      (("1" (LEMMA "product_prime_gcd")
                                        (("1" (INST -1 "n" "m" "x" "x-1")
                                          (("1" (EXPAND "product_prime_decomp")
                                            (("1" (PROPAX) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (HIDE-ALL-BUT 1)
                                    (("2" (GRIND) NIL NIL)) NIL)
                                   ("3" (HIDE-ALL-BUT 1)
                                    (("3" (GRIND) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (ASSERT) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|divides| CONST-DECL "bool" |divides| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|product| DEF-DECL "real" |product| |reals|)
    (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|prime_2| FORMULA-DECL NIL |primes| |ints|)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|one_divides| FORMULA-DECL NIL |divides| NIL)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|m| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL)
    (|T_low| TYPE-EQ-DECL NIL |product| |reals|)
    (|T_high| TYPE-EQ-DECL NIL |product| |reals|)
    (|product_prime_gcd| FORMULA-DECL NIL |prime_enum| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|divides_gcd_one| FORMULA-DECL NIL |number_util| NIL)
    (|prime_comp_divides| FORMULA-DECL NIL |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "posnat" |prime_enum| NIL)
    (|x| SKOLEM-CONST-DECL "{k: nat | k < n}" |prime_enum| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL))
   SHOSTAK))
 (|product_prime_inj_TCC1| 0
  (|product_prime_inj_TCC1-1| NIL 3946820643
   ("" (SKEEP)
    (("" (LEMMA "prime_count_ge_one")
      (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL))
    NIL)
   ((|prime_count_ge_one| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   NIL
   (|product_prime_inj| SUBTYPE "prime_enum.prime_counting(prime_enum.n)"
    "posnat")))
 (|product_prime_inj_TCC2| 0
  (|product_prime_inj_TCC1-1| NIL 3946049789
   ("" (SKEEP)
    (("" (ASSERT)
      (("" (LEMMA "prime_count_ge_one")
        (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|prime_count_ge_one| FORMULA-DECL NIL |prime_enum| NIL))
   NIL
   (|product_prime_inj| SUBTYPE
    "(number_fields.-)(prime_enum.prime_counting(prime_enum.n), 1)"
    "below[prime_counting(n)]")))
 (|product_prime_inj| 0
  (|product_prime_inj-1| NIL 3946823220
   ("" (SKEEP)
    (("" (LEMMA "product_prime_id")
      (("" (INST -1 "prime_counting(n)" "m" "l")
        (("" (ASSERT)
          (("" (EXPAND "divides")
            (("" (SKEEP)
              (("" (LEMMA "posnat_divides_posnat")
                (("" (INST -1 "m" "l" "x")
                  (("" (ASSERT)
                    (("" (CASE-REPLACE "x = 1")
                      (("1" (ASSERT) NIL NIL)
                       ("2" (LEMMA "one_prime_decomposition_ind")
                        (("2" (INST -1 "x")
                          (("2" (ASSERT)
                            (("2" (SKEEP)
                              (("2" (EXPAND "divides")
                                (("2" (SKEEP)
                                  (("2" (REPLACES -1)
                                    (("2" (TYPEPRED "m")
                                      (("2" (LEMMA "prime_le_n_surj")
                                        (("2" (INST -1 "n" "p")
                                          (("1" (SKOLEM -1 "i")
                                            (("1"
                                              (EXPAND "product_prime_decomp")
                                              (("1"
                                                (NAME-REPLACE "fs"
                                                 "LAMBDA (i: nat | i < prime_counting(n)):
                posnat_prime_decomp(prime_counting(n), m)`seq(i)")
                                                (("1"
                                                  (CASE
                                                      "FORALL (k:nat| k < prime_counting(n)):
     FORALL(i:nat| i <= k):
      product(0, k, fs) = fs(i) *
            product(0, k, LAMBDA(j:nat| j < prime_counting(n)): IF j = i THEN 1 else fs(j) ENDIF)")
                                                  (("1"
                                                    (INST -1
                                                     "prime_counting(n) - 1")
                                                    (("1" (INST -1 "i")
                                                      (("1" (REPLACES -1)
                                                        (("1" (EXPAND "fs")
                                                          (("1"
                                                            (NAME-REPLACE "v"
                                                             " product(0, prime_counting(n) - 1,
               LAMBDA (j: nat | j < prime_counting(n)):
                 IF j = i THEN 1
                 ELSE posnat_prime_decomp(prime_counting(n), m)`seq(j)
                 ENDIF)")
                                                            (("1"
                                                              (EXPAND
                                                               "posnat_prime_decomp")
                                                              (("1" (LIFT-IF)
                                                                (("1" (PROP)
                                                                  (("1"
                                                                    (REPLACES
                                                                     -3)
                                                                    (("1"
                                                                      (REPLACE
                                                                       -2 -6 RL
                                                                       HIDE)
                                                                      (("1"
                                                                        (TYPEPRED
                                                                         "max_prime_div(p, m)")
                                                                        (("1"
                                                                          (EXPAND
                                                                           "max_prime_div"
                                                                           -6)
                                                                          (("1"
                                                                            (TYPEPRED
                                                                             "max({m_1: posnat |
              EXISTS (i: nat): m_1 = p ^ i AND divides(m_1, m)})")
                                                                            (("1"
                                                                              (HIDE
                                                                               -1)
                                                                              (("1"
                                                                                (SKEEP)
                                                                                (("1"
                                                                                  (REPLACES
                                                                                   -1)
                                                                                  (("1"
                                                                                    (INST
                                                                                     -2
                                                                                     "p ^ (i_1+1)")
                                                                                    (("1"
                                                                                      (PROP)
                                                                                      (("1"
                                                                                        (EXPAND
                                                                                         "^")
                                                                                        (("1"
                                                                                          (EXPAND
                                                                                           "expt"
                                                                                           -1
                                                                                           1)
                                                                                          (("1"
                                                                                            (TYPEPRED
                                                                                             "p")
                                                                                            (("1"
                                                                                              (EXPAND
                                                                                               "prime?")
                                                                                              (("1"
                                                                                                (FLATTEN)
                                                                                                (("1"
                                                                                                  (HIDE-ALL-BUT
                                                                                                   (-2
                                                                                                    -3))
                                                                                                  (("1"
                                                                                                    (LEMMA
                                                                                                     "expt_pos_aux")
                                                                                                    (("1"
                                                                                                      (INST
                                                                                                       -1
                                                                                                       "i_1"
                                                                                                       "p")
                                                                                                      (("1"
                                                                                                        (EXPAND
                                                                                                         ">")
                                                                                                        (("1"
                                                                                                          (LEMMA
                                                                                                           "lt_times_lt_pos1")
                                                                                                          (("1"
                                                                                                            (INST
                                                                                                             -1
                                                                                                             "1"
                                                                                                             "expt(p,i_1)"
                                                                                                             "p"
                                                                                                             "expt(p,i_1)")
                                                                                                            (("1"
                                                                                                              (ASSERT)
                                                                                                              NIL
                                                                                                              NIL)
                                                                                                             ("2"
                                                                                                              (ASSERT)
                                                                                                              NIL
                                                                                                              NIL))
                                                                                                            NIL))
                                                                                                          NIL))
                                                                                                        NIL)
                                                                                                       ("2"
                                                                                                        (ASSERT)
                                                                                                        NIL
                                                                                                        NIL))
                                                                                                      NIL))
                                                                                                    NIL))
                                                                                                  NIL))
                                                                                                NIL))
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL)
                                                                                       ("2"
                                                                                        (INST
                                                                                         1
                                                                                         "i_1+1")
                                                                                        (("2"
                                                                                          (EXPAND
                                                                                           "divides")
                                                                                          (("2"
                                                                                            (INST
                                                                                             1
                                                                                             "v * x_1")
                                                                                            (("2"
                                                                                              (EXPAND
                                                                                               "^")
                                                                                              (("2"
                                                                                                (EXPAND
                                                                                                 "expt"
                                                                                                 1)
                                                                                                (("2"
                                                                                                  (PROPAX)
                                                                                                  NIL
                                                                                                  NIL))
                                                                                                NIL))
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL)
                                                                                     ("2"
                                                                                      (HIDE-ALL-BUT
                                                                                       1)
                                                                                      (("2"
                                                                                        (TYPEPRED
                                                                                         "p")
                                                                                        (("2"
                                                                                          (EXPAND
                                                                                           "prime?")
                                                                                          (("2"
                                                                                            (EXPAND
                                                                                             "^")
                                                                                            (("2"
                                                                                              (LEMMA
                                                                                               "expt_pos_aux")
                                                                                              (("2"
                                                                                                (INST
                                                                                                 -1
                                                                                                 "1+i_1"
                                                                                                 "p")
                                                                                                (("1"
                                                                                                  (ASSERT)
                                                                                                  NIL
                                                                                                  NIL)
                                                                                                 ("2"
                                                                                                  (FLATTEN)
                                                                                                  (("2"
                                                                                                    (ASSERT)
                                                                                                    NIL
                                                                                                    NIL))
                                                                                                  NIL))
                                                                                                NIL))
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL)
                                                                             ("2"
                                                                              (HIDE-ALL-BUT
                                                                               1)
                                                                              (("2"
                                                                                (LEMMA
                                                                                 "max_prime_div_aux")
                                                                                (("2"
                                                                                  (INST?)
                                                                                  NIL
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL)
                                                                   ("2"
                                                                    (REPLACES
                                                                     -2)
                                                                    (("2"
                                                                      (EXPAND
                                                                       "divides")
                                                                      (("2"
                                                                        (INST 1
                                                                         "l * x_1")
                                                                        (("2"
                                                                          (ASSERT)
                                                                          NIL
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL)
                                                             ("2"
                                                              (HIDE-ALL-BUT 1)
                                                              (("2" (GRIND) NIL
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (HIDE-ALL-BUT 1)
                                                    (("2"
                                                      (MEASURE-INDUCT "k" "k")
                                                      (("2" (SKEEP)
                                                        (("2" (SKEEP)
                                                          (("2"
                                                            (CASE-REPLACE
                                                             "x!1 = 0")
                                                            (("1"
                                                              (EXPAND
                                                               "product")
                                                              (("1"
                                                                (EXPAND
                                                                 "product")
                                                                (("1" (ASSERT)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL)
                                                             ("2"
                                                              (INST -1 "x!1-1")
                                                              (("1" (ASSERT)
                                                                (("1"
                                                                  (EXPAND
                                                                   "product" 2)
                                                                  (("1"
                                                                    (LIFT-IF)
                                                                    (("1"
                                                                      (PROP)
                                                                      (("1"
                                                                        (REPLACES
                                                                         -1)
                                                                        (("1"
                                                                          (HIDE
                                                                           -)
                                                                          (("1"
                                                                            (CASE
                                                                                "FORALL(m: nat| m < i!1): product(0, m, fs) =  product(0, m,
                  LAMBDA (j: nat | j < prime_counting(n)):
                    IF j = i!1 THEN 1 ELSE fs(j) ENDIF)")
                                                                            (("1"
                                                                              (INST
                                                                               -1
                                                                               "i!1-1")
                                                                              (("1"
                                                                                (ASSERT)
                                                                                NIL
                                                                                NIL)
                                                                               ("2"
                                                                                (ASSERT)
                                                                                NIL
                                                                                NIL))
                                                                              NIL)
                                                                             ("2"
                                                                              (HIDE
                                                                               2
                                                                               3)
                                                                              (("2"
                                                                                (MEASURE-INDUCT
                                                                                 "m"
                                                                                 "m")
                                                                                (("2"
                                                                                  (SKEEP)
                                                                                  (("2"
                                                                                    (CASE-REPLACE
                                                                                     "x!2 = 0")
                                                                                    (("1"
                                                                                      (EXPAND
                                                                                       "product")
                                                                                      (("1"
                                                                                        (EXPAND
                                                                                         "product")
                                                                                        (("1"
                                                                                          (PROPAX)
                                                                                          NIL
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL)
                                                                                     ("2"
                                                                                      (INST
                                                                                       -1
                                                                                       "x!2-1")
                                                                                      (("1"
                                                                                        (ASSERT)
                                                                                        (("1"
                                                                                          (EXPAND
                                                                                           "product"
                                                                                           2)
                                                                                          (("1"
                                                                                            (REPLACES
                                                                                             -1)
                                                                                            NIL
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL)
                                                                                       ("2"
                                                                                        (ASSERT)
                                                                                        NIL
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL)
                                                                       ("2"
                                                                        (CASE
                                                                            "i!1 < x!1")
                                                                        (("1"
                                                                          (INST
                                                                           -2
                                                                           "i!1")
                                                                          (("1"
                                                                            (REPLACES
                                                                             -2)
                                                                            (("1"
                                                                              (ASSERT)
                                                                              NIL
                                                                              NIL))
                                                                            NIL)
                                                                           ("2"
                                                                            (ASSERT)
                                                                            NIL
                                                                            NIL))
                                                                          NIL)
                                                                         ("2"
                                                                          (ASSERT)
                                                                          NIL
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL)
                                                               ("2" (ASSERT)
                                                                NIL NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (HIDE-ALL-BUT 1)
                                                  (("2" (GRIND) NIL NIL)) NIL))
                                                NIL))
                                              NIL))
                                            NIL)
                                           ("2" (EXPAND "primes_le_n")
                                            (("2" (LEMMA "divisor_smaller")
                                              (("2" (INST -1 "p" "m")
                                                (("1" (ASSERT)
                                                  (("1" (EXPAND "divides")
                                                    (("1" (INST 1 "l * x_1")
                                                      (("1" (ASSERT) NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (TYPEPRED "p")
                                                  (("2" (EXPAND "prime?")
                                                    (("2" (ASSERT) NIL NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|product_prime_id| FORMULA-DECL NIL |prime_enum| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|p| SKOLEM-CONST-DECL "(prime?)" |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (|primes_le_n| CONST-DECL "set[(prime?)]" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|product| DEF-DECL "real" |product| |reals|)
    (|T_high| TYPE-EQ-DECL NIL |product| |reals|)
    (|T_low| TYPE-EQ-DECL NIL |product| |reals|)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|fs| SKOLEM-CONST-DECL "[{i: nat | i < prime_counting(n)} -> nat]"
     |prime_enum| NIL)
    (|max_prime_div_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|expt| DEF-DECL "real" |exponentiation| NIL)
    (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|lt_times_lt_pos1| FORMULA-DECL NIL |real_props| NIL)
    (|int_expt| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|expt_pos_aux| FORMULA-DECL NIL |exponentiation| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|i_1| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|max| CONST-DECL "{a: posnat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}"
     |max_bounded_posnat| |ints|)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|x!1| SKOLEM-CONST-DECL "{k: nat | k < prime_counting(n)}" |prime_enum|
     NIL)
    (|x!2| SKOLEM-CONST-DECL "{m: nat | m < i!1}" |prime_enum| NIL)
    (|i!1| SKOLEM-CONST-DECL "{i: nat | i <= x!1}" |prime_enum| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|divisor_smaller| FORMULA-DECL NIL |divides| NIL)
    (|prime_le_n_surj| FORMULA-DECL NIL |prime_enum| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|one_prime_decomposition_ind| FORMULA-DECL NIL |prime_enum| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posnat_divides_posnat| FORMULA-DECL NIL |number_util| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   SHOSTAK))
 (|prime_decomp_id| 0
  (|prime_decomp_id-1| NIL 3946907575
   ("" (SKEEP)
    (("" (LEMMA "product_prime_inj")
      ((""
        (INST -1 "n" "m" "product_prime_decomp(prime_counting(n),
                             posnat_prime_decomp(prime_counting(n), m),
                             prime_counting(n) - 1)")
        (("1" (ASSERT) NIL NIL)
         ("2" (HIDE 2)
          (("2" (EXPAND "product_prime_decomp")
            (("2"
              (CASE "FORALL(k:below[prime_counting(n)]): product(0, k,
              LAMBDA (i: nat | i < prime_counting(n)):
                posnat_prime_decomp(prime_counting(n), m)`seq(i)) > 0")
              (("1" (INST?)
                (("1" (LEMMA "prime_count_ge_one")
                  (("1" (INST -1 "n") (("1" (ASSERT) NIL NIL)) NIL)) NIL))
                NIL)
               ("2" (HIDE 2)
                (("2" (MEASURE-INDUCT "k" "k")
                  (("1" (SKEEP)
                    (("1" (CASE-REPLACE "x = 0")
                      (("1" (HIDE -2)
                        (("1" (EXPAND "product")
                          (("1" (EXPAND "product")
                            (("1" (EXPAND "posnat_prime_decomp")
                              (("1" (LIFT-IF)
                                (("1" (ASSERT)
                                  (("1" (PROP)
                                    (("1" (EXPAND "max_prime_div")
                                      (("1" (ASSERT) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (INST -1 "x-1")
                        (("1" (ASSERT)
                          (("1" (EXPAND "product" 2)
                            (("1"
                              (CASE
                                  "posnat_prime_decomp(prime_counting(n), m)`seq(x) > 0")
                              (("1" (ASSERT)
                                (("1" (LEMMA "lt_times_lt_pos1")
                                  (("1"
                                    (INST -1 "0"
                                     "posnat_prime_decomp(prime_counting(n), m)`seq(x)"
                                     "product[{i: nat | i < prime_counting(n)}]
           (0, x - 1,
            LAMBDA (i: nat | i < prime_counting(n)):
              posnat_prime_decomp(prime_counting(n), m)`seq(i))"
                                     "posnat_prime_decomp(prime_counting(n), m)`seq(x)")
                                    (("1" (ASSERT) NIL NIL)
                                     ("2" (HIDE-ALL-BUT 1)
                                      (("2" (GRIND) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (ASSERT) NIL NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL)
               ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL)
         ("3" (LEMMA "prime_count_ge_one")
          (("3" (INST -1 "n") (("3" (ASSERT) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|product_prime_inj| FORMULA-DECL NIL |prime_enum| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|product| DEF-DECL "real" |product| |reals|)
    (|T_high| TYPE-EQ-DECL NIL |product| |reals|)
    (|T_low| TYPE-EQ-DECL NIL |product| |reals|)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|prime_count_ge_one| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (|lt_times_lt_pos1| FORMULA-DECL NIL |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|x| SKOLEM-CONST-DECL "below[prime_counting(n)]" |prime_enum| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|m| SKOLEM-CONST-DECL "{m: posnat | m <= n}" |prime_enum| NIL))
   SHOSTAK))
 (|inverse_prime_ineq_TCC1| 0
  (|inverse_prime_ineq_TCC1-1| NIL 3947078464
   ("" (SKEEP)
    (("" (LEMMA "prime_index_lt_prime_count")
      (("" (INST -1 "i" "n")
        (("" (ASSERT) (("" (EXPAND "prime?") (("" (PROPAX) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_index_lt_prime_count| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   NIL
   (|inverse_prime_ineq| SUBTYPE "prime_enum.prime_enumeration(prime_enum.i)"
    "nznum")))
 (|inverse_prime_ineq| 0
  (|inverse_prime_ineq-1| NIL 3947078465
   ("" (SKEEP)
    (("" (LEMMA "prime_index_lt_prime_count")
      (("" (INST -1 "i" "n")
        (("" (ASSERT)
          (("" (EXPAND "prime?")
            (("" (FLATTEN)
              (("" (HIDE -1)
                (("" (PROP)
                  (("1" (LEMMA "lt_div_lt_pos2")
                    (("1"
                      (INST -1 "0" "prime_enumeration(i)"
                       "prime_enumeration(i)" "1")
                      (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL))
                    NIL)
                   ("2" (LEMMA "lt_div_lt_pos1")
                    (("2" (INST -1 "1" "1" "prime_enumeration(i)" "1")
                      (("2" (ASSERT) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|prime_index_lt_prime_count| FORMULA-DECL NIL |prime_enum| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL)
    (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|i| SKOLEM-CONST-DECL "nat" |prime_enum| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|lt_div_lt_pos2| FORMULA-DECL NIL |real_props| NIL)
    (|lt_div_lt_pos1| FORMULA-DECL NIL |real_props| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   SHOSTAK))
 (|inv_prime_decomp_TCC1| 0
  (|inv_prime_decomp_TCC3-1| NIL 3946915662
   ("" (SKEEP)
    (("" (EXPAND "product_prime_decomp")
      (("" (LEMMA "reals@product[below[prime_counting(n)]].product_gt_0")
        (("" (INST?)
          (("1" (ASSERT) (("1" (HIDE -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)
           ("2" (HIDE -1) (("2" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|T_high| TYPE-EQ-DECL NIL |product| |reals|)
    (|T_low| TYPE-EQ-DECL NIL |product| |reals|)
    (|m| SKOLEM-CONST-DECL "{m: posnat | m <= n}" |prime_enum| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|product_gt_0| FORMULA-DECL NIL |product| |reals|))
   NIL
   (|inv_prime_decomp| SUBTYPE
    "prime_enum.product_prime_decomp(prime_enum.prime_counting(prime_enum.n), prime_enum.posnat_prime_decomp(prime_enum.prime_counting(prime_enum.n), prime_enum.m), prime_enum.k)"
    "nznum")))
 (|inv_prime_decomp_TCC2| 0
  (|inv_prime_decomp_TCC4-1| NIL 3946915662 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL))
   NIL (|inv_prime_decomp| SUBTYPE "0" "T_low[below[prime_counting(n)]]")))
 (|inv_prime_decomp_TCC3| 0
  (|inv_prime_decomp_TCC2-1| NIL 3946915662 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL))
   NIL
   (|inv_prime_decomp| SUBTYPE "prime_enum.k"
    "T_high[below[prime_counting(n)]]")))
 (|inv_prime_decomp_TCC4| 0
  (|inv_prime_decomp_TCC6-1| NIL 3946915662
   ("" (SKEEP)
    (("" (TYPEPRED "i")
      (("" (LEMMA "prime_index_lt_prime_count")
        (("" (INST -1 "i" "n") (("" (ASSERT) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime_index_lt_prime_count| FORMULA-DECL NIL |prime_enum| NIL))
   NIL
   (|inv_prime_decomp| SUBTYPE "prime_enum.prime_enumeration(prime_enum.i)"
    "(primes.prime?)")))
 (|inv_prime_decomp_TCC5| 0
  (|inv_prime_decomp_TCC7-1| NIL 3946915662 ("" (ASSUMING-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL))
   NIL
   (|inv_prime_decomp| ASSUMING
    "reals@product[below[prime_counting(n)]].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (|inv_prime_decomp| 0
  (|inv_prime_decomp-1| NIL 3946915662
   ("" (SKEEP)
    (("" (MEASURE-INDUCT "k" "k")
      (("1" (SKEEP)
        (("1" (CASE-REPLACE "x = 0")
          (("1" (HIDE -2)
            (("1" (EXPAND "product_prime_decomp")
              (("1" (EXPAND "product")
                (("1" (EXPAND "product")
                  (("1" (EXPAND "posnat_prime_decomp")
                    (("1" (LIFT-IF)
                      (("1" (PROP)
                        (("1" (EXPAND "prime_enumeration")
                          (("1" (REWRITE "posnat_prime_decomp_aux") NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (INST -1 "x-1")
            (("1" (ASSERT)
              (("1" (EXPAND "product_prime_decomp")
                (("1" (EXPAND "product" 2)
                  (("1" (CASE "FORALL(a,b:nzreal): 1/(a*b) = (1/a) * (1/b)")
                    (("1" (INST?)
                      (("1" (REPLACES -1)
                        (("1" (REPLACES -1)
                          (("1"
                            (CASE-REPLACE
                             "posnat_prime_decomp(prime_counting(n), m)`seq(x) = max_prime_div(prime_enumeration(x), m)")
                            (("1" (HIDE 2 3)
                              (("1" (EXPAND "posnat_prime_decomp")
                                (("1" (LIFT-IF)
                                  (("1" (PROP)
                                    (("1" (REWRITE " posnat_prime_decomp_aux")
                                      NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)
                       ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) NIL NIL)) NIL))
                      NIL)
                     ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (ASSERT) NIL NIL))
            NIL))
          NIL))
        NIL)
       ("2" (HIDE 2)
        (("2" (SKEEP)
          (("2" (TYPEPRED "i")
            (("2" (LEMMA "prime_index_lt_prime_count")
              (("2" (INST -1 "i" "n") (("2" (ASSERT) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("3" (HIDE 2)
        (("3" (SKEEP)
          (("3" (EXPAND "product_prime_decomp")
            (("3"
              (LEMMA "reals@product[below[prime_counting(n)]].product_gt_0")
              (("3" (INST?)
                (("1" (ASSERT) (("1" (HIDE -1) (("1" (GRIND) NIL NIL)) NIL))
                  NIL)
                 ("2" (HIDE -1) (("2" (GRIND) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|prime_counting| CONST-DECL "nat" |prime_enum| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|n| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |prime_enum| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|prime_decomposition| CONST-DECL "set[finseq[nat]]" |prime_enum| NIL)
    (|product_prime_decomp| CONST-DECL "nat" |prime_enum| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|posnat_prime_decomp| CONST-DECL "(prime_decomposition(k))" |prime_enum|
     NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|m| SKOLEM-CONST-DECL "{m: posnat | m <= n}" |prime_enum| NIL)
    (|prime_enumeration| DEF-DECL "nat" |prime_enum| NIL)
    (|prime?| CONST-DECL "bool" |primes| |ints|)
    (|max_prime_div| CONST-DECL "posnat" |prime_enum| NIL)
    (|product| DEF-DECL "real" |product| |reals|)
    (|T_high| TYPE-EQ-DECL NIL |product| |reals|)
    (|T_low| TYPE-EQ-DECL NIL |product| |reals|)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL)
    (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|posnat_prime_decomp_aux| FORMULA-DECL NIL |prime_enum| NIL)
    (|prod_pr| APPLICATION-JUDGEMENT "posreal" |product| |reals|)
    (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL)
    (|prod_nat| APPLICATION-JUDGEMENT "nat" |product| |reals|)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (^ CONST-DECL "real" |exponentiation| NIL)
    (|divides| CONST-DECL "bool" |divides| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types|
     NIL)
    (|nzreal_times_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal"
     |real_types| NIL)
    (|nzreal| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL)
    (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|x| SKOLEM-CONST-DECL "below[prime_counting(n)]" |prime_enum| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|prime_index_lt_prime_count| FORMULA-DECL NIL |prime_enum| NIL)
    (|product_gt_0| FORMULA-DECL NIL |product| |reals|)
    (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|subrange| TYPE-EQ-DECL NIL |integers| NIL))
   SHOSTAK)))

