pvsio_json : THEORY
BEGIN

    IMPORTING structures@Maybe
    IMPORTING structures@for_iterate
    IMPORTING structures@list_lemmas
    IMPORTING pvsio_utils@stdregex

    Token : DATATYPE
    BEGIN
        Lbrace : lbrace? % Left brace
        Rbrace : rbrace? % Right brace
        Lbrack : lbrack? % Left bracket
        Rbrack : rbrack? % Right bracket
        Colon : colon? % Colon
        Comma : comma? % Comma
        Str(str : string) : str? % String
        Num(num : real) : num? % Number
        T : t? % True
        F : f? % False
        N : n? % Null
        Whitespace : whitespace?
    END Token

    IMPORTING pvsio_utils@stdlex[Token]

    JsonParseException : Exception[string] = "JsonParseException"

    token_to_string (t : Token) : string =
        CASES t OF
            Lbrace: "{",
            Rbrace: "}",
            Lbrack: "[",
            Rbrack : "]",
            Colon : ":",
            Comma : ",",
            Str(s) : format("~s",s),
            Num(x) : real2str(x),
            T : "true",
            F : "false",
            N : "null",
            Whitespace : " "
        ENDCASES

    % Performs lexical analysis to seperate a json string into a series of tokens.
    lex_json (s : string) : list[Token] =
        LET
            % The regular language corresponding to real numbers.
            decimal = Literal('.'),
            minus = Literal('-'),
            int_regex = Star(numeral_regex),
            decimal_regex = Times(Plus(minus, Emptystring),
	                          Plus(int_regex, Times(int_regex, Times(decimal, int_regex)))),
            real_regex = Plus(decimal_regex, Times(decimal_regex, Times(Literal('e'), decimal_regex))),

            % The regular language corresponding to strings.
            string_regex = Times(Literal(char(34)), Times(Star(ascii_minus_quote), Literal(char(34)))),

            % Create the list of tokens and their corresponding regular languages.
            token_map = (:
                (Literal(char(123)), LAMBDA(s : string): Lbrace),
                (Literal(char(125)), LAMBDA(s : string): Rbrace),
                (Literal(char(91)), LAMBDA(s : string): Lbrack),
                (Literal(char(93)), LAMBDA(s : string): Rbrack),
                (Literal(char(58)), LAMBDA(s : string): Colon),
                (Literal(char(44)), LAMBDA(s : string): Comma),
                (string_regex, LAMBDA(s : string): Str(substring(s, 1, length(s) - 2))),
                (real_regex, LAMBDA(s : string): Num(str2real(s))),
                (make_regex_word("true"), LAMBDA(s : string): T),
                (make_regex_word("false"), LAMBDA(s : string): F),
                (make_regex_word("null"), LAMBDA(s : string): N),
                (Star(Plus(Literal(char(9)), Plus(Literal(char(10)), Literal(char(32))))), LAMBDA(s : string): Whitespace)
            :)
        IN
        lex (token_map) (s)

    % JSON values can be represented as follows.
    JValue : DATATYPE
    BEGIN
        JObject(jobject : list[[string, JValue]]) : jobject?
        JArray(jarray : list[JValue]) : jarray?
        JNum(jnum : real) : jnum?
        JStr(jstr : string) : jstr?
        JBool(jbool : bool) : jbool?
        JNull : jnull?
    END JValue

    ListTokenLt(l:list[Token]) : TYPE = {nl:list[Token] | length(nl) < length(l)}

    % Parse a Json object of the form ",..., keyn:valn }". Already parsed a prefix of the form "{ key1 : valn ..."
    parse_json_dict(parse_json_f:[l:list[Token]->[JValue,ListTokenLt(l)]])
                   (ll:list[Token],acc:list[[string,JValue]]) :
      RECURSIVE [JValue,ListTokenLt(ll)] =
        IF cons?(ll) THEN
	  LET tokenstr = token_to_string(car(ll)) IN
	  IF rbrace?(car(ll)) THEN  % Closing "}"
	    (JObject(acc),cdr(ll))
	  ELSIF comma?(nth(ll,0)) = cons?(acc) THEN % first token is a comma IFF acc is non-emtpy
            LET restl = IF comma?(nth(ll,0)) THEN cdr(ll) ELSE ll ENDIF IN
	    IF length(restl) > 1 AND
               str?(nth(restl,0)) AND % Next token is <key>
	       colon?(nth(restl,1)) THEN % Next token is ":"
	      LET (jv,rest) = parse_json_f(cdr(cdr(restl))) IN
              parse_json_dict(parse_json_f)(rest,append(acc,(: (str(nth(restl,0)),jv) :)))
	    ELSE
              throw(JsonParseException, tokenstr, format("Parsing dictionary. Expecting <key> : <val> at '~a'",tokenstr))
	    ENDIF
	  ELSE
	    throw(JsonParseException, tokenstr, format("Parsing dictionary. Expecting '}' or ~a instead of '~a'",
	                                 {| IF null?(acc) THEN "<key> : <val>" ELSE "','" ENDIF, tokenstr |}))
	  ENDIF
        ELSE
	  throw(JsonParseException, "Parsing dictionary. Unexpected end of tokens")
	ENDIF
      MEASURE length(ll)

    % Parse a Json object of the form ",..., valn ]". Already parsed a prefix of the form "[ valn ..."
    parse_json_array(parse_json_f:[l:list[Token]->[JValue,ListTokenLt(l)]])(ll:list[Token],acc:list[JValue]) :
      RECURSIVE [JValue,ListTokenLt(ll)] =
        IF cons?(ll) THEN
	  LET tokenstr = token_to_string(car(ll)) IN
	  IF rbrack?(car(ll)) THEN  % Closing "]"
	    (JArray(acc),cdr(ll))
	  ELSIF comma?(nth(ll,0)) = cons?(acc) THEN % first token is a comma IFF acc is non-emtpy
            LET restl = IF comma?(nth(ll,0)) THEN cdr(ll) ELSE ll ENDIF,
	        (jv,rest) = parse_json_f(restl) IN
              parse_json_array(parse_json_f)(rest,append(acc,(: jv :)))
	  ELSE
	    throw(JsonParseException, tokenstr, format("Parsing array. Expecting ']' or ~a instead of '~a'",
	                                 {| IF null?(acc) THEN "<val>" ELSE "','" ENDIF, tokenstr |}))
	  ENDIF
        ELSE
	  throw(JsonParseException, "Parsing array. Unexpected end of tokens")
	ENDIF
      MEASURE length(ll)

    parse_json(ll : list[Token]) : RECURSIVE [JValue, ListTokenLt(ll)] =
      CASES ll OF
        cons(top, tail):
	  LET tokenstr = token_to_string(top) IN
	  CASES top OF
	    Lbrace: parse_json_dict(parse_json)(cdr(ll),null),
	    Lbrack: parse_json_array(parse_json)(cdr(ll),null),
            Str(s): (JStr(s), tail),
            Num(x): (JNum(x), tail),
            T: (JBool(true), tail),
            F: (JBool(false), tail),
            N: (JNull, tail)
            ELSE
	      throw(JsonParseException, tokenstr, format("Unexpected token '~a'",tokenstr))
	  ENDCASES,
        null: throw(JsonParseException, "", "Unexpected end of tokens")
      ENDCASES
      MEASURE length(ll)

    parse_jdoc(ll : list[Token],acc:list[JValue]) : RECURSIVE list[JValue] =
      IF null?(ll) THEN acc
      ELSE
       LET (v,rem) = parse_json(ll) IN
         parse_jdoc(rem,append(acc,(: v :)))
      ENDIF
      MEASURE length(ll)

    remove_whitespace (tokens : list[Token]) : RECURSIVE list[Token] =
      CASES tokens OF
          cons(x, xs): (
              IF whitespace?(x) THEN
                  remove_whitespace(xs)
              ELSE
                  cons(x, remove_whitespace(xs))
              ENDIF
          ),
          null: null
      ENDCASES
      MEASURE tokens BY <<

    % Return first JSON object found in string
    json_from_string(s : string) : JValue =
      LET 
        tokens = remove_whitespace(lex_json(s)),
        (v, rem) = parse_json(tokens) 
      IN
        v

    % Return a list of all JSON objects found in string
    jdoc_from_string(s : string) : list[JValue] =
      LET 
         tokens = remove_whitespace(lex_json(s))
      IN
         parse_jdoc(tokens,null)

    textfile_to_string(filename:string) : string =
      LET s = ref[string]("") IN
        prog(with_openin_file(filename, LAMBDA(f:IStream):
               while(NOT eof?(f),
               set(s, format("~a~a~%",{| val(s), fread_line(f) |})))),
	     val(s))

    % Return first JSON object found in file
    json_from_file(filename:string) : JValue =
      json_from_string(textfile_to_string(filename))

    % Return list of JSON objects found in file
    jdoc_from_file(filename:string) : list[JValue] =
      jdoc_from_string(textfile_to_string(filename))

    jobject_field_value (jobj : (jobject?))(s : string) : Maybe[JValue] =
      LET l = find(LAMBDA(t:[string,JValue]): t`1 = s,jobject(jobj)) IN
        IF null?(l) THEN None
	ELSE car(l)`2
	ENDIF

    jarray_nth_value(jarr: (jarray?))(i:nat) : Maybe[JValue] =
      IF i < length(jarray(jarr)) THEN
        nth(jarray(jarr),i)
      ELSE
        None
      ENDIF

    JIndent : Global[nat,2]

    JValueLt(jval:JValue) : TYPE = {jv:JValue | jv << jval}

    jfield_to_string(jval:JValue,json_to_string_f:[int->[JValueLt(jval)->string]],indent:int)
                    (field:[string,JValueLt(jval)]) : string =
      IF indent < 0 THEN
        format("~s:~a",{| field`1, json_to_string_f(indent)(field`2) |})
      ELSE 
        format("~%~a~s:~a",{| spaces(indent), field`1, json_to_string_f(indent+JIndent)(field`2) |})
      ENDIF

    json_to_string_aux(indent:int)(jval: JValue) : RECURSIVE string =
      CASES jval OF
        JObject(jobj):
          IF indent < 0 THEN
	    LET ll = map(jfield_to_string(jval,json_to_string_aux,indent),jobj) IN
	    format("{~{~a~^,~}}",{| ll |})
	  ELSIF null?(jobj) THEN
	    format("~%~a{}",spaces(indent))
	  ELSE 
	    LET ll  = map(jfield_to_string(jval,json_to_string_aux,indent+JIndent),jobj) IN
	    format("~%~a{~{~a~^,~}~%~a}",{| spaces(indent), {| ll |}, spaces(indent) |})
	  ENDIF,
        JArray(jarr):
	  LET ll = map(json_to_string_aux(indent),jarr) IN
	  IF indent < 0 THEN
	    LET ll = map(json_to_string_aux(indent),jarr) IN
	    format("[~{~a~^,~}]",{| ll |})
	  ELSIF null?(jarr) THEN
	    format("~%~a[]",spaces(indent))
	  ELSE 
	    LET ll = map(json_to_string_aux(indent+JIndent),jarr) IN
	    format("~%~a[~{~a~^,~}~%~a]",{| spaces(indent), {| ll |}, spaces(indent) |})
	  ENDIF,
        JNum(jn) :
	  LET ns = real2str(jn) IN 
	  IF indent < 0 THEN format("~a",ns)
	  ELSE format("~%~a~a",{| spaces(indent), ns |})
          ENDIF,
        JStr(js) :
	  IF indent < 0 THEN format("~s",js)
	  ELSE format("~%~a~s",{| spaces(indent), js |})
          ENDIF,
        JBool(j) : 
	  LET strj = IF j THEN "true" ELSE "false" ENDIF IN
	  IF indent < 0 THEN strj
	  ELSE format("~%~a~a",{| spaces(indent), strj |})
          ENDIF,
        JNull :
	  IF indent < 0 THEN "null"
	  ELSE format("~%~anull",spaces(indent))
          ENDIF
      ENDCASES
      MEASURE jval BY <<
 
    % Json to string. If pp is true, it produces a human-readble string
    json_to_string(jval:JValue,pp:bool) : string =
      json_to_string_aux(IF pp THEN 0 ELSE -1 ENDIF)(jval)

    json_to_string(jval:JValue) : string =
      json_to_string(jval,true)

    % Json to file. If pp is true, it produces a human-readble string
    json_to_file(jval:JValue,mode:(output_mode?),filename:string,pp:bool) : void =
      with_openout_file(mode,filename,LAMBDA(f:OStream):
        fprintf(f,json_to_string(jval,pp)))

    json_to_file(jval:JValue,filename:string,pp:bool) : void =
      with_openout_file(filename,LAMBDA(f:OStream):
        fprintf(f,json_to_string(jval,pp)))

    json_to_file(jval:JValue,filename:string) : void =
      json_to_file(jval,filename,true)

END pvsio_json
