(vertical_WCV_props
 (vertical_entry_tcoa_ge_0_TCC1 0
  (vertical_entry_tcoa_ge_0_TCC1-1 nil 3624981522
   ("" (skosimp*) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (vertical_entry_tcoa_ge_0 0
  (vertical_entry_tcoa_ge_0-1 nil 3624981612
   ("" (skeep)
    (("" (skoletin*)
      (("" (flatten)
        (("" (splash 1)
          (("1" (lemma "vertical_WCV_interval_def[tcoa1,ZTHR]")
            (("1" (lemma "vertical_WCV_interval_def[tcoa2,ZTHR]")
              (("1" (insteep* -)
                (("1" (replaces (-6 -7) :dir rl)
                  (("1" (assert)
                    (("1" (expand "nonempty?")
                      (("1" (inst -1 "interval_tcoa1`entry")
                        (("1" (assert)
                          (("1" (inst -1 "interval_tcoa1`entry")
                            (("1" (assert)
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (expand "vertical_WCV_at")
                                  (("1"
                                    (expand "vertical_WCV")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (flatten)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "vertical_WCV_interval_def[tcoa1,ZTHR]")
            (("2" (lemma "vertical_WCV_interval_def[tcoa2,ZTHR]")
              (("2" (insteep* -)
                (("2" (replaces (-5 -6) :dir rl)
                  (("2" (assert)
                    (("2" (rewrite "nonempty_def" -)
                      (("2" (skeep -3)
                        (("2" (insteep -2)
                          (("2" (assert)
                            (("2" (expand "nonempty?")
                              (("2"
                                (insteep)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (hide -2)
                                    (("2"
                                      (split -1)
                                      (("1"
                                        (flatten)
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (-1 1))
                                        (("2"
                                          (expand "vertical_WCV_at")
                                          (("2"
                                            (expand "vertical_WCV")
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vertical_WCV_at const-decl "bool" vertical_WCV nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vertical_WCV const-decl "bool" vertical_WCV nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (vertical_WCV_interval_def formula-decl nil vertical_WCV nil)
    (nonempty_def formula-decl nil EntryExit_interval nil))
   nil))
 (vertical_entry_tcoa_singleton_TCC1 0
  (vertical_entry_tcoa_singleton_TCC1-1 nil 3625261551
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (vertical_entry_tcoa_singleton 0
  (vertical_entry_tcoa_singleton-1 nil 3625258753
   ("" (skeep)
    (("" (skoletin*)
      (("" (flatten)
        (("" (expand "singleton?")
          (("" (expand "nonempty?")
            (("" (lemma "vertical_WCV_interval_def[tcoa1,ZTHR]")
              (("" (lemma "vertical_WCV_interval_def[tcoa2,ZTHR]")
                (("" (insteep* -)
                  (("" (assert)
                    (("" (replaces (-5 -6) :dir rl)
                      (("" (inst-cp -2 "interval_tcoa1`entry")
                        (("" (inst -2 "interval_tcoa1`exit")
                          (("" (assert)
                            (("" (inst-cp -1 "interval_tcoa1`entry")
                              ((""
                                (inst -1 "interval_tcoa1`exit")
                                ((""
                                  (expand "vertical_WCV_at")
                                  ((""
                                    (flatten)
                                    ((""
                                      (hide -2 -4)
                                      ((""
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (split -3)
                                            (("1"
                                              (flatten)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2"
                                              (hide-all-but (-4 -8 1))
                                              (("2"
                                                (expand "vertical_WCV")
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide-all-but (-2 -7 1))
                                          (("2"
                                            (expand "vertical_WCV")
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (singleton? const-decl "bool" EntryExit_interval nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vertical_WCV_interval_def formula-decl nil vertical_WCV nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (vertical_WCV_at const-decl "bool" vertical_WCV nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vertical_WCV const-decl "bool" vertical_WCV nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (Theta_H_ge2 0
  (Theta_H_ge2-1 nil 3624909604
   ("" (skeep)
    (("" (expand "Theta_H")
      (("" (case "nzvz > 0")
        (("1" (cross-mult 1)
          (("1" (cancel-by 1 "nzvz")
            (("1" (assert)
              (("1" (expand "sign") (("1" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (cross-mult 2)
          (("2" (cancel-by 2 "nzvz")
            (("2" (expand "sign") (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (div_mult_neg_ge1 formula-decl nil real_props nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (div_mult_neg_le1 formula-decl nil real_props nil)
    (div_mult_neg_lt1 formula-decl nil real_props nil)
    (both_sides_times_neg_ge1 formula-decl nil real_props nil)
    (CBD_3 skolem-const-decl "nzreal" vertical_WCV_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (sign const-decl "Sign" sign "reals/")
    (Sign type-eq-decl nil sign "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nzvz skolem-const-decl "nzreal" vertical_WCV_props nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (times_div2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (div_mult_pos_ge2 formula-decl nil real_props nil)
    (neg_one_times formula-decl nil extra_tegies nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (zero_times1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pos_div_gt formula-decl nil real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (CBD_2 skolem-const-decl "nzreal" vertical_WCV_props nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil))
   nil))
 (vertical_entry_tcoa_vz_eq_0 0
  (vertical_entry_tcoa_vz_eq_0-1 nil 3625249886
   ("" (skeep)
    (("" (skoletin*)
      (("" (flatten)
        (("" (replaces -2)
          (("" (expand "vertical_WCV_interval")
            (("" (case-replace "abs(sz) <= ZTHR")
              (("1" (replaces (-4 -5)) (("1" (assert) nil nil)) nil)
               ("2" (replaces 1)
                (("2" (replaces -4)
                  (("2" (expand "nonempty?") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (vertical_entry_tcoa_leq_a_TCC1 0
  (vertical_entry_tcoa_leq_a_TCC1-1 nil 3624987458
   ("" (skosimp*) (("" (assert) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil))
   nil))
 (vertical_entry_tcoa_leq_a_TCC2 0
  (vertical_entry_tcoa_leq_a_TCC2-1 nil 3625249885
   ("" (subtype-tcc) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   nil))
 (vertical_entry_tcoa_leq_a 0
  (vertical_entry_tcoa_leq_a-1 nil 3624987571
   ("" (skeep)
    ((""
      (case "max(ZTHR, abs(nzvz) * tcoa1) > 0 AND max(ZTHR, abs(nzvz) * tcoa2) > 0")
      (("1" (flatten)
        (("1" (skoletin*)
          (("1" (flatten)
            (("1" (lemma "vertical_entry_tcoa_ge_0")
              (("1" (insteep -1 :but (("vz" "nzvz")))
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (copy -12)
                      (("1" (mult-by -1 "abs(nzvz)")
                        (("1" (hide -3)
                          (("1" (replaces (-7 -8) :dir rl :hide? nil)
                            (("1" (expand "vertical_WCV_interval")
                              (("1"
                                (lift-if)
                                (("1"
                                  (expand "coalt_entry_exit")
                                  (("1"
                                    (split -7)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (replaces -2)
                                        (("1"
                                          (hide-all-but -3)
                                          (("1"
                                            (expand "nonempty?")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split -8)
                                        (("1" (flatten) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (hide -4 -5)
                                            (("2"
                                              (replaces (-1 -2))
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (lemma "Theta_H_ge2")
                                                  (("2"
                                                    (inst
                                                     -1
                                                     "nzvz"
                                                     "sz"
                                                     "max(ZTHR, abs(nzvz) * tcoa1)"
                                                     "max(ZTHR, abs(nzvz) * tcoa2)")
                                                    (("2"
                                                      (replaces
                                                       -4
                                                       :dir
                                                       rl)
                                                      (("2"
                                                        (min_max)
                                                        (("2"
                                                          (expand
                                                           "max")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide-all-but 1) (("2" (min_max) nil nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign "reals/")
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vertical_entry_tcoa_ge_0 formula-decl nil vertical_WCV_props nil)
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (Theta_H_ge2 formula-decl nil vertical_WCV_props nil)
    (max_le formula-decl nil real_defs nil)
    (max_gt formula-decl nil real_defs nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil))
   nil))
 (vertical_entry_tcoa_leq_b_TCC1 0
  (vertical_entry_tcoa_leq_b_TCC1-1 nil 3625249168
   ("" (subtype-tcc) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   nil))
 (vertical_entry_tcoa_leq_b 0
  (vertical_entry_tcoa_leq_b-1 nil 3624984514
   ("" (skeep)
    ((""
      (case "max(ZTHR, abs(nzvz) * tcoa1) > 0 AND max(ZTHR, abs(nzvz) * tcoa2) > 0")
      (("1" (flatten)
        (("1" (skoletin*)
          (("1" (flatten)
            (("1" (lemma "vertical_entry_tcoa_ge_0")
              (("1" (insteep -1 :but (("vz" "nzvz")))
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (copy -13)
                      (("1" (mult-by -1 "abs(nzvz)")
                        (("1" (hide -3)
                          (("1" (replaces (-8 -9) :dir rl :hide? nil)
                            (("1" (expand "vertical_WCV_interval")
                              (("1"
                                (lift-if)
                                (("1"
                                  (expand "coalt_entry_exit")
                                  (("1"
                                    (split -8)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (replaces -2)
                                        (("1"
                                          (hide-all-but -3)
                                          (("1"
                                            (expand "nonempty?")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (replace 2)
                                        (("2"
                                          (split -9)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (replaces -2)
                                              (("1"
                                                (hide-all-but -5)
                                                (("1"
                                                  (expand "nonempty?")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (hide -4 -5)
                                              (("2"
                                                (replaces (-1 -2))
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (lemma
                                                     "Theta_H_ge2")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "nzvz"
                                                       "sz"
                                                       "max(ZTHR, abs(nzvz) * tcoa1)"
                                                       "max(ZTHR, abs(nzvz) * tcoa2)")
                                                      (("2"
                                                        (replaces
                                                         (-4 -5)
                                                         :dir
                                                         rl)
                                                        (("2"
                                                          (min_max)
                                                          (("2"
                                                            (expand
                                                             "max")
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide-all-but 1) (("2" (min_max) nil nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign "reals/")
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vertical_entry_tcoa_ge_0 formula-decl nil vertical_WCV_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (max_gt formula-decl nil real_defs nil)
    (max_le formula-decl nil real_defs nil)
    (Theta_H_ge2 formula-decl nil vertical_WCV_props nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil))
   nil))
 (vertical_entry_tcoa_leq_c 0
  (vertical_entry_tcoa_leq_c-1 nil 3624987784
   ("" (skeep)
    ((""
      (case "max(ZTHR, abs(nzvz) * tcoa1) > 0 AND max(ZTHR, abs(nzvz) * tcoa2) > 0")
      (("1" (flatten)
        (("1" (skoletin*)
          (("1" (flatten)
            (("1" (lemma "vertical_entry_tcoa_ge_0")
              (("1" (insteep -1 :but (("vz" "nzvz")))
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (copy -14)
                      (("1" (mult-by -1 "abs(nzvz)")
                        (("1" (hide -3)
                          (("1" (replaces (-9 -10) :dir rl :hide? nil)
                            (("1" (expand "vertical_WCV_interval")
                              (("1"
                                (lift-if)
                                (("1"
                                  (expand "coalt_entry_exit")
                                  (("1"
                                    (split -9)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (replaces -2)
                                        (("1"
                                          (hide-all-but -3)
                                          (("1"
                                            (expand "nonempty?")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split -10)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (replaces -2)
                                            (("1"
                                              (hide-all-but -5)
                                              (("1"
                                                (expand "nonempty?")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (hide -4 -5)
                                            (("2"
                                              (replaces (-1 -2))
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (lemma "Theta_H_ge2")
                                                  (("2"
                                                    (inst
                                                     -1
                                                     "nzvz"
                                                     "sz"
                                                     "max(ZTHR, abs(nzvz) * tcoa1)"
                                                     "max(ZTHR, abs(nzvz) * tcoa2)")
                                                    (("2"
                                                      (replaces
                                                       (-5 -6)
                                                       :dir
                                                       rl)
                                                      (("2"
                                                        (min_max)
                                                        (("2"
                                                          (expand
                                                           "max")
                                                          (("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide-all-but 1) (("2" (min_max) nil nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign "reals/")
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vertical_entry_tcoa_ge_0 formula-decl nil vertical_WCV_props nil)
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (Theta_H_ge2 formula-decl nil vertical_WCV_props nil)
    (max_le formula-decl nil real_defs nil)
    (max_gt formula-decl nil real_defs nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil))
   nil))
 (Theta_H_sub2 0
  (Theta_H_sub2-1 nil 3624986986
   ("" (skeep)
    (("" (expand "Theta_H")
      (("" (case "nzvz > 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (sign const-decl "Sign" sign "reals/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil))
   nil))
 (vertical_entry_tcoa_leq_TCC1 0
  (vertical_entry_tcoa_leq_TCC1-1 nil 3625249885
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (vertical_entry_tcoa_leq 0
  (vertical_entry_tcoa_leq-1 "" 3625256580
   ("" (skeep)
    ((""
      (case "max(ZTHR, abs(vz) * tcoa1) > 0 AND max(ZTHR, abs(vz) * tcoa2) > 0")
      (("1" (flatten)
        (("1" (skoletin*)
          (("1" (flatten)
            (("1" (case-replace "vz=0")
              (("1" (lemma "vertical_entry_tcoa_vz_eq_0")
                (("1" (insteep) (("1" (assert) nil nil)) nil)) nil)
               ("2" (replace 1)
                (("2" (lemma "vertical_entry_tcoa_ge_0")
                  (("2" (insteep)
                    (("2" (assert)
                      (("2" (flatten)
                        (("2" (assert)
                          (("2" (lemma "Theta_H_sub2")
                            (("2"
                              (inst -1 "vz" "sz"
                               "max(ZTHR, abs(vz) * tcoa1)"
                               "max(ZTHR, abs(vz) * tcoa2)")
                              (("2"
                                (replaces (-6 -7) :dir rl :hide? nil)
                                (("2"
                                  (replaces -1 :dir rl :hide? nil)
                                  (("2"
                                    (case
                                     "Theta_H[max(ZTHR, abs(vz) * tcoa1)](sz, vz, -1) <= B")
                                    (("1"
                                      (lemma
                                       "vertical_entry_tcoa_leq_a")
                                      (("1"
                                        (insteep :but (("nzvz" "vz")))
                                        (("1"
                                          (assert)
                                          (("1"
                                            (case-replace "delta = 0")
                                            (("1"
                                              (mult-by -14 "abs(vz)")
                                              (("1"
                                                (lemma "Theta_H_ge2")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "vz"
                                                   "sz"
                                                   "max(ZTHR, abs(vz) * tcoa1)"
                                                   "max(ZTHR, abs(vz) * tcoa2)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (min_max)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (case
                                       "Theta_H[max(ZTHR, abs(vz) * tcoa2)](sz, vz, -1) > B")
                                      (("1"
                                        (lemma
                                         "vertical_entry_tcoa_leq_b")
                                        (("1"
                                          (insteep
                                           :but
                                           (("nzvz" "vz")))
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (lemma
                                         "vertical_entry_tcoa_leq_c")
                                        (("2"
                                          (insteep
                                           :but
                                           (("nzvz" "vz")))
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2) (("2" (min_max) nil nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (/= const-decl "boolean" notequal nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (abs_0 formula-decl nil abs_lems "reals/")
    (vertical_entry_tcoa_vz_eq_0 formula-decl nil vertical_WCV_props
     nil)
    (vertical_entry_tcoa_ge_0 formula-decl nil vertical_WCV_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (vertical_entry_tcoa_leq_b formula-decl nil vertical_WCV_props nil)
    (vertical_entry_tcoa_leq_c formula-decl nil vertical_WCV_props nil)
    (vertical_entry_tcoa_leq_a formula-decl nil vertical_WCV_props nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (max_le formula-decl nil real_defs nil)
    (Theta_H_ge2 formula-decl nil vertical_WCV_props nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (Sign type-eq-decl nil sign "reals/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Theta_H_sub2 formula-decl nil vertical_WCV_props nil)
    (max_gt formula-decl nil real_defs nil))
   nil)
  (vertical_entry_tcoa_leq-5 "" 3624988114
   ("" (skeep)
    ((""
      (case "max(ZTHR, abs(nzvz) * tcoa1) > 0 AND max(ZTHR, abs(nzvz) * tcoa2) > 0")
      (("1" (flatten)
        (("1" (skoletin*)
          (("1" (flatten)
            (("1" (lemma "vertical_entry_tcoa_ge_0")
              (("1" (insteep -1 :but (("vz" "nzvz")))
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (lemma "Theta_H_sub2")
                        (("1"
                          (inst -1 "nzvz" "sz"
                           "max(ZTHR, abs(nzvz) * tcoa1)"
                           "max(ZTHR, abs(nzvz) * tcoa2)")
                          (("1" (replaces (-6 -7) :dir rl :hide? nil)
                            (("1" (replaces -1 :dir rl :hide? nil)
                              (("1"
                                (case
                                 "Theta_H[max(ZTHR, abs(nzvz) * tcoa1)](sz, nzvz, -1) <= B")
                                (("1"
                                  (lemma "vertical_entry_tcoa_leq_a")
                                  (("1"
                                    (insteep)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (case-replace "delta = 0")
                                        (("1"
                                          (mult-by -14 "abs(nzvz)")
                                          (("1"
                                            (lemma "Theta_H_ge2")
                                            (("1"
                                              (inst
                                               -1
                                               "nzvz"
                                               "sz"
                                               "max(ZTHR, abs(nzvz) * tcoa1)"
                                               "max(ZTHR, abs(nzvz) * tcoa2)")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (min_max)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (case
                                   "Theta_H[max(ZTHR, abs(nzvz) * tcoa2)](sz, nzvz, -1) > B")
                                  (("1"
                                    (lemma "vertical_entry_tcoa_leq_b")
                                    (("1"
                                      (insteep -1)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (lemma "vertical_entry_tcoa_leq_c")
                                    (("2"
                                      (insteep -1)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide-all-but 1) (("2" (min_max) nil nil)) nil))
      nil))
    nil)
   ((vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (Theta_H const-decl "real" vertical "ACCoRD/")
    (Sign type-eq-decl nil sign "reals/"))
   nil))
 (vertical_exit_tcoa_eq_0 0
  (vertical_exit_tcoa_eq_0-1 nil 3625337174
   ("" (skeep)
    (("" (skoletin*)
      (("" (flatten)
        (("" (case-replace "vz=0")
          (("1" (expand "vertical_WCV_interval")
            (("1" (case-replace "abs(sz) <= ZTHR")
              (("1" (replaces -6) (("1" (assert) nil nil)) nil)
               ("2" (replace 1)
                (("2" (replaces -5)
                  (("2" (expand "nonempty?") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "vertical_entry_tcoa_ge_0")
            (("2" (insteep)
              (("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (hide -2)
                      (("2" (expand "nonempty?")
                        (("2" (replace -4 :dir rl)
                          (("2" (expand "vertical_WCV_interval")
                            (("2"
                              (case-replace
                               "T < coalt_entry_exit[tcoa1,ZTHR](sz, vz)`1 OR coalt_entry_exit[tcoa1,ZTHR](sz, vz)`2 < B")
                              (("1"
                                (replaces -6)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (replace 1)
                                (("2"
                                  (case-replace
                                   "T < coalt_entry_exit[tcoa2,ZTHR](sz, vz)`1 OR coalt_entry_exit[tcoa2,ZTHR](sz, vz)`2 < B")
                                  (("1"
                                    (replaces -5)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (replace 1)
                                    (("2"
                                      (replaces (-4 -5))
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replaces -3)
                                          (("2"
                                            (expand
                                             "coalt_entry_exit"
                                             2)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Lookahead type-eq-decl nil Lookahead "ACCoRD/")
    (EntryExit type-eq-decl nil EntryExit_interval nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (vertical_WCV_interval const-decl "EntryExit[B, T]" vertical_WCV
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" EntryExit_interval nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (coalt_entry_exit const-decl
     "{r12: [real, real] | LET (r1, r2) = r12 IN r1 < r2}" vertical_WCV
     nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (vertical_entry_tcoa_ge_0 formula-decl nil vertical_WCV_props nil))
   nil)))

