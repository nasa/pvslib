(|tensor_product| (|not_null| 0 (|not_null-1| |nil| 3615549872 ("" (SKOSIMP*) (("" (GRIND) NIL NIL)) NIL) ((|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nonempty?| CONST-DECL "bool" |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|length| DEF-DECL "nat" |list_props| NIL)) SHOSTAK)) (|mod_int| 0 (|mod_int-1| |nil| 3618130444 ("" (SKEEP) (("" (SPLIT) (("1" (EXPAND "mod") (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT) (("2" (EXPAND "mod") (("2" (CANCEL-BY 1 "n") NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|nnrat_div_posrat_is_nnrat| APPLICATION-JUDGEMENT "nonneg_rat" |rationals| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nonneg_floor_is_nat| APPLICATION-JUDGEMENT "nat" |floor_ceil| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|both_sides_times_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (<= CONST-DECL "bool" |reals| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nnrat_times_nnrat_is_nnrat| APPLICATION-JUDGEMENT "nonneg_rat" |rationals| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (NIL APPLICATION-JUDGEMENT "below(m)" |mod| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (> CONST-DECL "bool" |reals| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL)) SHOSTAK)) (|tensor_fun_TCC1| 0 (|tensor_fun_TCC1-1| |nil| 3614943215 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_fun| SUBTYPE "matrices.rows(tensor_product.B)" "nonzero_integer"))) (|tensor_fun_TCC2| 0 (|tensor_fun_TCC2-3| "" 3883689564 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "rows(B!1) * floor(i!1 / rows(B!1)) / rows(B!1) = floor(i!1 / rows(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("i!1")) (("2" (DIV-BY -1 "rows(B!1)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.i, mod.mod(tensor_product.i, matrices.rows(tensor_product.B)))), matrices.rows(tensor_product.B))" "nat")) (|tensor_fun_TCC2-2| "" 3790097688 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "rows(B!1) * floor(i!1 / rows(B!1)) / rows(B!1) = floor(i!1 / rows(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (I!1)) (("2" (DIV-BY -1 "rows(B!1)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ((|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|div_cancel3| FORMULA-DECL NIL |real_props| NIL) (|nonzero_real| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|both_sides_div_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.i, mod.mod(tensor_product.i, matrices.rows(tensor_product.B)))), matrices.rows(tensor_product.B))" "nat")) (|tensor_fun_TCC2-1| |nil| 3614943215 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "rows(B!1) * floor(i!1 / rows(B!1)) / rows(B!1) = floor(i!1 / rows(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (I!1)) (("2" (DIV-BY -1 "rows(B!1)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.i, mod.mod(tensor_product.i, matrices.rows(tensor_product.B)))), matrices.rows(tensor_product.B))" "nat"))) (|tensor_fun_TCC3| 0 (|tensor_fun_TCC3-1| |nil| 3614943215 ("" (SUBTYPE-TCC) NIL NIL) ((|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_fun| SUBTYPE "matrices.columns(tensor_product.B)" "nonzero_integer"))) (|tensor_fun_TCC4| 0 (|tensor_fun_TCC4-7| "" 3883689589 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "columns(B!1) * floor(j!1 / columns(B!1)) / columns(B!1) = floor(j!1 / columns(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("j!1")) (("2" (DIV-BY -1 "columns(B!1)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC4-6| "" 3790097688 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "columns(B!1) * floor(j!1 / columns(B!1)) / columns(B!1) = floor(j!1 / columns(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (J!1)) (("2" (DIV-BY -1 "columns(B!1)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ((|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|div_cancel3| FORMULA-DECL NIL |real_props| NIL) (|nonzero_real| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|both_sides_div_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC4-5| |nil| 3614947199 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "columns(B!1) * floor(j!1 / columns(B!1)) / columns(B!1) = floor(j!1 / columns(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (J!1)) (("2" (DIV-BY -1 "columns(B!1)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC4-4| |nil| 3614947172 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "columns(B!1) * floor(j!1 / columns(B!1)) / columns(B!1) = floor(j!1 / columns(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL) ("2" (GROUND) (("2" (TYPEPRED (I!1)) (("2" (DIV-BY -1 "columns(B!1)") (("2" (GROUND) NIL))))))))) ("2" (CROSS-MULT 1) NIL) ("3" (GROUND) NIL)))))) NIL) NIL NIL (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC4-3| |nil| 3614947143 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "columns(B!1) * floor(i!1 / columns(B!1)) / columns(B!1) = floor(j!1 / columns(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL) ("2" (GROUND) (("2" (TYPEPRED (I!1)) (("2" (DIV-BY -1 "columns(B!1)") (("2" (GROUND) NIL))))))))) ("2" (CROSS-MULT 1) NIL) ("3" (GROUND) NIL)))))) NIL) NIL NIL (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC4-2| |nil| 3614947074 ("" (SKOSIMP*) (("" (EXPAND "mod") (("" (CASE-REPLACE "columns(B!1) * floor(i!1 / columns(B!1)) / columns(B!1) = floor(i!1 / columns(B!1))") (("1" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (I!1)) (("2" (DIV-BY -1 "columns(B!1)") (("2" (GROUND) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC4-1| |nil| 3614943215 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|tensor_fun| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.j, mod.mod(tensor_product.j, matrices.columns(tensor_product.B)))), matrices.columns(tensor_product.B))" "nat"))) (|tensor_fun_TCC5| 0 (|tensor_fun_TCC5-2| "" 3790097688 ("" (SKOSIMP*) (("" (LEMMA "mod_pos") (("" (INST?) (("" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ((|mod_pos| FORMULA-DECL NIL |mod| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) SHOSTAK (|tensor_fun| SUBTYPE "mod.mod(tensor_product.i, matrices.rows(tensor_product.B))" "nat")) (|tensor_fun_TCC5-1| |nil| 3614943215 ("" (SKOSIMP*) (("" (LEMMA "mod_pos") (("" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|tensor_fun| SUBTYPE "mod.mod(tensor_product.i, matrices.rows(tensor_product.B))" "nat"))) (|tensor_fun_TCC6| 0 (|tensor_fun_TCC6-2| "" 3790097689 ("" (SKOSIMP*) (("" (LEMMA "mod_pos") (("" (INST?) (("" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ((|mod_pos| FORMULA-DECL NIL |mod| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) SHOSTAK (|tensor_fun| SUBTYPE "mod.mod(tensor_product.j, matrices.columns(tensor_product.B))" "nat")) (|tensor_fun_TCC6-1| |nil| 3614943215 ("" (SKOSIMP*) (("" (LEMMA "mod_pos") (("" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL (|tensor_fun| SUBTYPE "mod.mod(tensor_product.j, matrices.columns(tensor_product.B))" "nat"))) (|tensor_prod_TCC1| 0 (|tensor_prod_TCC1-1| |nil| 3615032070 ("" (SKEEP) (("" (REWRITE "rows_form_matrix") (("" (LEMMA "columns_form_matrix") (("" (INST?) (("" (TYPEPRED (A)) (("" (TYPEPRED (B)) (("" (MULT-INEQ -7 -3) (("" (MULT-INEQ -9 -5) (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|rows_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|gt_times_gt_any1| FORMULA-DECL NIL |extra_real_props| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|columns_form_matrix| FORMULA-DECL NIL |matrices| NIL)) NIL (|tensor_prod| SUBTYPE "matrices.form_matrix(tensor_product.tensor_fun(tensor_product.A, tensor_product.B), number_fields.*(matrices.rows(tensor_product.A), matrices.rows(tensor_product.B)), number_fields.*(matrices.columns(tensor_product.A), matrices.columns(tensor_product.B)))" "PosFullMatrix"))) (|entry_tensor_prod| 0 (|entry_tensor_prod-1| |nil| 3618677832 ("" (SKEEP) (("" (EXPAND "tensor_prod") (("" (DECOMPOSE-EQUALITY) (("" (REWRITE "entry_form_matrix") (("" (LIFT-IF) (("" (GROUND) (("1" (EXPAND "tensor_fun") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "tensor_fun") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|entry_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL)) SHOSTAK)) (|tensor_rows| 0 (|tensor_rows-1| |nil| 3615042678 ("" (SKOSIMP*) (("" (LEMMA "rows_form_matrix") (("" (INST -1 "rows(A!1) * rows(B!1)" "columns(A!1) * columns(B!1)" "tensor_fun(A!1, B!1)") (("" (EXPAND "tensor_prod") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|rows_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (|tensor_cols| 0 (|tensor_cols-1| |nil| 3615042993 ("" (SKOSIMP*) (("" (LEMMA "columns_form_matrix") (("" (EXPAND "tensor_prod") (("" (INST -1 "rows(A!1)*rows(B!1)" "columns(A!1)*columns(B!1)" "tensor_fun(A!1, B!1)") (("" (SPLIT) (("1" (LEMMA "zero_times3") (("1" (INST -1 "rows(A!1)" "rows(B!1)") (("1" (FLATTEN) (("1" (HIDE -2) (("1" (PROP) (("1" (TYPEPRED (A!1)) (("1" (GROUND) NIL NIL)) NIL) ("2" (TYPEPRED (B!1)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|columns_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|zero_times3| FORMULA-DECL NIL |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL)) SHOSTAK)) (|tensor_mult_entry_TCC1| 0 (|tensor_mult_entry_TCC1-1| |nil| 3615558345 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_mult_entry| SUBTYPE "matrices.rows(tensor_product.B)" "nonzero_integer"))) (|tensor_mult_entry_TCC2| 0 (|tensor_mult_entry_TCC2-1| |nil| 3615558345 ("" (SKEEP) (("" (GRIND) (("" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|rows| CONST-DECL "nat" |matrices| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (B SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL (|tensor_mult_entry| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.m1, mod.mod(tensor_product.m1, matrices.rows(tensor_product.B)))), matrices.rows(tensor_product.B))" "nat"))) (|tensor_mult_entry_TCC3| 0 (|tensor_mult_entry_TCC3-1| |nil| 3615558345 ("" (SUBTYPE-TCC) NIL NIL) ((|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_mult_entry| SUBTYPE "matrices.columns(tensor_product.B2)" "nonzero_integer"))) (|tensor_mult_entry_TCC4| 0 (|tensor_mult_entry_TCC4-1| |nil| 3615558345 ("" (SKEEP) (("" (GRIND) (("" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ((|rows| CONST-DECL "nat" |matrices| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL (|tensor_mult_entry| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.n1, mod.mod(tensor_product.n1, matrices.columns(tensor_product.B2)))), matrices.columns(tensor_product.B2))" "nat"))) (|tensor_mult_entry_TCC5| 0 (|tensor_mult_entry_TCC5-1| |nil| 3615558345 ("" (SKEEP) (("" (LEMMA "mod_pos") (("" (INST?) (("" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ((|mod_pos| FORMULA-DECL NIL |mod| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|tensor_mult_entry| SUBTYPE "mod.mod(tensor_product.m1, matrices.rows(tensor_product.B))" "nat"))) (|tensor_mult_entry_TCC6| 0 (|tensor_mult_entry_TCC6-1| |nil| 3615558345 ("" (SKEEP) (("" (LEMMA "mod_pos") (("" (INST?) (("" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ((|mod_pos| FORMULA-DECL NIL |mod| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|tensor_mult_entry| SUBTYPE "mod.mod(tensor_product.n1, matrices.columns(tensor_product.B2))" "nat"))) (|tensor_mult_entry| 0 (|tensor_mult_entry-3| "" 3883690055 ("" (SKEEP) (("" (LEMMA "entry_mult") (("" (INST-CP -1 "tensor_prod(A,B)" "tensor_prod(A2, B2)" "m1" "n1") (("" (CASE "m1<rows(tensor_prod(A,B)) AND n1<columns(tensor_prod(A2, B2))") (("1" (LIFT-IF -3) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (HIDE (-1 -2)) (("1" (LEMMA "form_matrix_mult") (("1" (INST -1 "tensor_fun(A,B)" "tensor_fun(A2, B2)" "rows(A)*rows(B)" "columns(A)*columns(B)" "columns(A2)*columns(B2)") (("1" (EXPAND "tensor_prod" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (REPLACE -7 1 :DIR RL) (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (LEMMA "entry_form_matrix") (("1" (INST -1 "LAMBDA (i, j: nat):
                          IF i > rows(A) * rows(B) OR
                              j > columns(A2) * columns(B2)
                            THEN 0
                          ELSE sigma(0,
                                     columns(A) * columns(B) - 1,
                                     LAMBDA
                                     (d: nat):
                                     tensor_fun(A, B)(i, d)
                                     *
                                     tensor_fun(A2, B2)(d, j))
                          ENDIF" "m1" "n1" "rows(A)*rows(B)" "columns(A2)*columns(B2)") (("1" (LEMMA "tensor_rows") (("1" (INST -1 "A" "B") (("1" (LEMMA "tensor_cols") (("1" (INST -1 "A2" "B2") (("1" (REPLACE -2 -6) (("1" (REPLACE -1 -7) (("1" (CASE-REPLACE "IF m1 < rows(A) * rows(B) AND n1 < columns(A2) * columns(B2)
         THEN IF m1 > rows(A) * rows(B) OR n1 > columns(A2) * columns(B2)
                THEN 0
              ELSE sigma(0, columns(A) * columns(B) - 1,
                         LAMBDA (d: nat):
                           tensor_fun(A, B)(m1, d) *
                            tensor_fun(A2, B2)(d, n1))
              ENDIF
       ELSE 0
       ENDIF = sigma(0, columns(A) * columns(B) - 1,
                         LAMBDA (d: nat):
                           tensor_fun(A, B)(m1, d) *
                            tensor_fun(A2, B2)(d, n1))") (("1" (REPLACE -4) (("1" (HIDE (-1 -4 -5)) (("1" (EXPAND "tensor_fun") (("1" (LEMMA "sigma_eq") (("1" (INST -1 "LAMBDA (d: nat):
              IF m1 < rows(A) * rows(B)
                THEN IF d < columns(A) * columns(B)
                       THEN entry(A)
                                 ((m1 - mod(m1, rows(B))) / rows(B),
                                  (d - mod(d, columns(B))) / columns(B))
                             *
                             entry(B)(mod(m1, rows(B)), mod(d, columns(B)))
                     ELSE 0
                     ENDIF
              ELSE 0
              ENDIF
               *
               IF d < rows(A2) * rows(B2)
                 THEN IF n1 < columns(A2) * columns(B2)
                        THEN entry(A2)
                                  ((d - mod(d, rows(B2))) / rows(B2),
                                   (n1 - mod(n1, columns(B2))) /
                                    columns(B2))
                              *
                              entry(B2)
                                   (mod(d, rows(B2)), mod(n1, columns(B2)))
                      ELSE 0
                      ENDIF
               ELSE 0
               ENDIF" "LAMBDA (d: nat):
               entry(A)
                                 ((m1 - mod(m1, rows(B))) / rows(B),
                                  (d - mod(d, columns(B))) / columns(B))
                             *
                             entry(B)(mod(m1, rows(B)), mod(d, columns(B)))
                     
               *
                entry(A2)
                                  ((d - mod(d, rows(B2))) / rows(B2),
                                   (n1 - mod(n1, columns(B2))) /
                                    columns(B2))
                              *
                              entry(B2)
                                   (mod(d, rows(B2)), mod(n1, columns(B2)))
                      " "columns(A)*columns(B)-1" "0") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (LEMMA "sigma_product2") (("1" (HIDE -2) (("1" (REPLACE -9 1 :DIR RL) (("1" (INST -1 "LAMBDA (d:nat): entry(A)
                   ((m1 - mod(m1, rows(B))) / rows(B),
                    d)* entry(A2)
                    (d,
                     (n1 - mod(n1, columns(B2))) / columns(B2))" "LAMBDA (d:nat): 
entry(B)(mod(m1, rows(B)), d)*entry(B2)(d, mod(n1, columns(B2)))" "columns(A)" "columns(B)") (("1" (REPLACE -1 :DIR RL) (("1" (LEMMA "matrix2array") (("1" (CASE "FORALL (M, M2: PosFullMatrix, r, c:nat): columns(M) =rows(M2) AND r<rows(M) AND c<columns(M2) IMPLIES
              entry(M*M2)(r,c) = sigma(0, columns(M)-1, LAMBDA(d:nat): entry(M)(r,d)*entry(M2)(d, c))") (("1" (INST -1 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE (-1 -3 -9)) (("1" (REVEAL -4) (("1" (INST -1 "B" "B2" "mod(m1, rows(B))" "mod(n1, columns(B2))") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST -1 "n1" "columns(B2)") (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (HIDE-ALL-BUT (1 -6)) (("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) (("3" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 -7)) (("4" (CROSS-MULT 1) (("4" (LEMMA "mod_pos") (("4" (INST -1 "n1" "columns(B2)") (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (SKEEP) (("2" (INST-CP -4 "M") (("2" (INST -4 "M2") (("2" (CASE-REPLACE "M*M2 = form_matrix(entry(M), rows(M), columns(M))* form_matrix(entry(M2), rows(M2), columns(M2))") (("1" (LEMMA "form_matrix_mult") (("1" (INST -1 "entry(M)" "entry(M2)" "rows(M)" "columns(M)" "columns(M2)") (("1" (SPLIT -1) (("1" (REPLACE -3) (("1" (REPLACE -1) (("1" (LEMMA "entry_form_matrix2") (("1" (INST -1 "LAMBDA (i, j: nat):
                          IF i > rows(M) OR j > columns(M2) THEN 0
                          ELSE sigma(0,
                                     rows(M2) - 1,
                                     LAMBDA
                                     (d: nat):
                                     entry(M)(i, d) * entry(M2)(d, j))
                          ENDIF" "r" "c" "rows(M)" "columns(M2)") (("1" (HIDE (-2 -3)) (("1" (PROP) (("1" (LIFT-IF -1) (("1" (PROP) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (GRIND) (("4" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT 1) (("5" (GRIND) (("5" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (TYPEPRED ("n")) (("2" (CASE "n<columns(A)*columns(B) AND n<rows(A2)*rows(B2)") (("1" (LIFT-IF 1) (("1" (PROP) (("1" (LIFT-IF 1) (("1" (PROP) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-3 -4 -5 -8 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (LEMMA "mod_pos") (("3" (INST -1 "d" "rows(B2)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (GRIND) (("4" (CROSS-MULT) (("4" (CASE "n1/columns(B2)>=0") (("1" (GROUND) NIL NIL) ("2" (GRIND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT 1) (("5" (SKEEP) (("5" (GRIND) (("5" (CASE "d/rows(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (HIDE-ALL-BUT 1) (("6" (SKEEP) (("6" (LEMMA "mod_pos") (("6" (INST -1 "d" "columns(B)") (("6" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (HIDE-ALL-BUT 1) (("7" (LEMMA "mod_pos") (("7" (INST -1 "m1" "rows(B)") (("7" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("8" (HIDE-ALL-BUT 1) (("8" (SKEEP) (("8" (GRIND) (("8" (CASE "d/columns(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (HIDE-ALL-BUT 1) (("9" (GRIND) (("9" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (HIDE-ALL-BUT 1) (("10" (SKEEP) (("10" (LEMMA "mod_pos") (("10" (INST -1 "n1" "columns(B2)") (("10" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (HIDE-ALL-BUT 1) (("11" (SKEEP) (("11" (LEMMA "mod_pos") (("11" (INST -1 "d" "rows(B2)") (("11" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (HIDE-ALL-BUT 1) (("12" (SKEEP) (("12" (GRIND) (("12" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (HIDE-ALL-BUT 1) (("13" (SKEEP) (("13" (GRIND) (("13" (CASE "d/rows(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("14" (HIDE-ALL-BUT 1) (("14" (SKEEP) (("14" (LEMMA "mod_pos") (("14" (INST -1 "d" "columns(B)") (("14" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("15" (HIDE-ALL-BUT 1) (("15" (SKEEP) (("15" (LEMMA "mod_pos") (("15" (INST -1 "m1" "rows(B)") (("15" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("16" (HIDE-ALL-BUT 1) (("16" (SKEEP) (("16" (GRIND) (("16" (CASE "d/columns(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("17" (HIDE-ALL-BUT 1) (("17" (SKEEP) (("17" (GRIND) (("17" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-6 -7 1)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (TYPEPRED ("A")) (("2" (TYPEPRED ("B")) (("2" (HIDE-ALL-BUT (-4 -8 1)) (("2" (MULT-INEQ -1 -2) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (TYPEPRED ("A")) (("3" (TYPEPRED ("B")) (("3" (HIDE-ALL-BUT (-3 -7 1)) (("3" (MULT-INEQ -1 -2) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF -2) (("2" (SPLIT -2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (HIDE 2) (("2" (SPLIT 1) (("1" (INST -2 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (1 -1)) (("1" (LEMMA "tensor_rows") (("1" (INST -1 "A" "B") (("1" (REPLACE -1) (("1" (HIDE -1) (("1" (CASE "FORALL (a,b:nat): a<b IMPLIES a<=b-1") (("1" (INST -1 "(m1 - mod(m1, rows(B))) / rows(B)" "rows(A)") (("1" (PROP) (("1" (CROSS-MULT -1) (("1" (LEMMA "mod_pos") (("1" (INST -1 "m1" "rows(B)") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("B2")) (("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (-2 1)) (("1" (CASE "FORALL (a,b:nat): a<b IMPLIES a<=b-1") (("1" (INST -1 "(n1 - mod(n1, columns(B2))) / columns(B2) " " columns(A2)") (("1" (PROP) (("1" (LEMMA "tensor_cols") (("1" (INST -1 "A2" "B2") (("1" (REPLACE -1) (("1" (CROSS-MULT -2) (("1" (LEMMA "mod_pos") (("1" (INST -1 "n1" "columns(B2)") (("1" (FLATTEN) (("1" (HIDE -3) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|tensor_mult_entry-2| "" 3790097701 ("" (SKEEP) (("" (LEMMA "entry_mult") (("" (INST-CP -1 "tensor_prod(A,B)" "tensor_prod(A2, B2)" "m1" "n1") (("" (CASE "m1<rows(tensor_prod(A,B)) AND n1<columns(tensor_prod(A2, B2))") (("1" (LIFT-IF -3) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (HIDE (-1 -2)) (("1" (LEMMA "form_matrix_mult") (("1" (INST -1 "tensor_fun(A,B)" "tensor_fun(A2, B2)" "rows(A)*rows(B)" "columns(A)*columns(B)" "columns(A2)*columns(B2)") (("1" (EXPAND "tensor_prod" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (REPLACE -7 1 :DIR RL) (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (LEMMA "entry_form_matrix") (("1" (INST -1 "LAMBDA (i, j: nat):
                          IF i > rows(A) * rows(B) OR
                              j > columns(A2) * columns(B2)
                            THEN 0
                          ELSE sigma(0,
                                     columns(A) * columns(B) - 1,
                                     LAMBDA
                                     (d: nat):
                                     tensor_fun(A, B)(i, d)
                                     *
                                     tensor_fun(A2, B2)(d, j))
                          ENDIF" "m1" "n1" "rows(A)*rows(B)" "columns(A2)*columns(B2)") (("1" (LEMMA "tensor_rows") (("1" (INST -1 "A" "B") (("1" (LEMMA "tensor_cols") (("1" (INST -1 "A2" "B2") (("1" (REPLACE -2 -6) (("1" (REPLACE -1 -7) (("1" (CASE-REPLACE "IF m1 < rows(A) * rows(B) AND n1 < columns(A2) * columns(B2)
         THEN IF m1 > rows(A) * rows(B) OR n1 > columns(A2) * columns(B2)
                THEN 0
              ELSE sigma(0, columns(A) * columns(B) - 1,
                         LAMBDA (d: nat):
                           tensor_fun(A, B)(m1, d) *
                            tensor_fun(A2, B2)(d, n1))
              ENDIF
       ELSE 0
       ENDIF = sigma(0, columns(A) * columns(B) - 1,
                         LAMBDA (d: nat):
                           tensor_fun(A, B)(m1, d) *
                            tensor_fun(A2, B2)(d, n1))") (("1" (REPLACE -4) (("1" (HIDE (-1 -4 -5)) (("1" (EXPAND "tensor_fun") (("1" (LEMMA "sigma_eq") (("1" (INST -1 "LAMBDA (d: nat):
              IF m1 < rows(A) * rows(B)
                THEN IF d < columns(A) * columns(B)
                       THEN entry(A)
                                 ((m1 - mod(m1, rows(B))) / rows(B),
                                  (d - mod(d, columns(B))) / columns(B))
                             *
                             entry(B)(mod(m1, rows(B)), mod(d, columns(B)))
                     ELSE 0
                     ENDIF
              ELSE 0
              ENDIF
               *
               IF d < rows(A2) * rows(B2)
                 THEN IF n1 < columns(A2) * columns(B2)
                        THEN entry(A2)
                                  ((d - mod(d, rows(B2))) / rows(B2),
                                   (n1 - mod(n1, columns(B2))) /
                                    columns(B2))
                              *
                              entry(B2)
                                   (mod(d, rows(B2)), mod(n1, columns(B2)))
                      ELSE 0
                      ENDIF
               ELSE 0
               ENDIF" "LAMBDA (d: nat):
               entry(A)
                                 ((m1 - mod(m1, rows(B))) / rows(B),
                                  (d - mod(d, columns(B))) / columns(B))
                             *
                             entry(B)(mod(m1, rows(B)), mod(d, columns(B)))
                     
               *
                entry(A2)
                                  ((d - mod(d, rows(B2))) / rows(B2),
                                   (n1 - mod(n1, columns(B2))) /
                                    columns(B2))
                              *
                              entry(B2)
                                   (mod(d, rows(B2)), mod(n1, columns(B2)))
                      " "columns(A)*columns(B)-1" "0") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (LEMMA "sigma_product2") (("1" (HIDE -2) (("1" (REPLACE -9 1 :DIR RL) (("1" (INST -1 "LAMBDA (d:nat): entry(A)
                   ((m1 - mod(m1, rows(B))) / rows(B),
                    d)* entry(A2)
                    (d,
                     (n1 - mod(n1, columns(B2))) / columns(B2))" "LAMBDA (d:nat): 
entry(B)(mod(m1, rows(B)), d)*entry(B2)(d, mod(n1, columns(B2)))" "columns(A)" "columns(B)") (("1" (REPLACE -1 :DIR RL) (("1" (LEMMA "matrix2array") (("1" (CASE "FORALL (M, M2: PosFullMatrix, r, c:nat): columns(M) =rows(M2) AND r<rows(M) AND c<columns(M2) IMPLIES
              entry(M*M2)(r,c) = sigma(0, columns(M)-1, LAMBDA(d:nat): entry(M)(r,d)*entry(M2)(d, c))") (("1" (INST -1 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE (-1 -3 -9)) (("1" (REVEAL -4) (("1" (INST -1 "B" "B2" "mod(m1, rows(B))" "mod(n1, columns(B2))") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST -1 "n1" "columns(B2)") (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (HIDE-ALL-BUT (1 -6)) (("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) (("3" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 -7)) (("4" (CROSS-MULT 1) (("4" (LEMMA "mod_pos") (("4" (INST -1 "n1" "columns(B2)") (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (SKEEP) (("2" (INST-CP -4 "M") (("2" (INST -4 "M2") (("2" (CASE-REPLACE "M*M2 = form_matrix(entry(M), rows(M), columns(M))* form_matrix(entry(M2), rows(M2), columns(M2))") (("1" (LEMMA "form_matrix_mult") (("1" (INST -1 "entry(M)" "entry(M2)" "rows(M)" "columns(M)" "columns(M2)") (("1" (SPLIT -1) (("1" (REPLACE -3) (("1" (REPLACE -1) (("1" (LEMMA "entry_form_matrix2") (("1" (INST -1 "LAMBDA (i, j: nat):
                          IF i > rows(M) OR j > columns(M2) THEN 0
                          ELSE sigma(0,
                                     rows(M2) - 1,
                                     LAMBDA
                                     (d: nat):
                                     entry(M)(i, d) * entry(M2)(d, j))
                          ENDIF" "r" "c" "rows(M)" "columns(M2)") (("1" (HIDE (-2 -3)) (("1" (PROP) (("1" (LIFT-IF -1) (("1" (PROP) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (GRIND) (("4" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT 1) (("5" (GRIND) (("5" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (TYPEPRED (N)) (("2" (CASE "n<columns(A)*columns(B) AND n<rows(A2)*rows(B2)") (("1" (LIFT-IF 1) (("1" (PROP) (("1" (LIFT-IF 1) (("1" (PROP) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-3 -4 -5 -8 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (LEMMA "mod_pos") (("3" (INST -1 "d" "rows(B2)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (GRIND) (("4" (CROSS-MULT) (("4" (CASE "n1/columns(B2)>=0") (("1" (GROUND) NIL NIL) ("2" (GRIND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT 1) (("5" (SKEEP) (("5" (GRIND) (("5" (CASE "d/rows(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (HIDE-ALL-BUT 1) (("6" (SKEEP) (("6" (LEMMA "mod_pos") (("6" (INST -1 "d" "columns(B)") (("6" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (HIDE-ALL-BUT 1) (("7" (LEMMA "mod_pos") (("7" (INST -1 "m1" "rows(B)") (("7" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("8" (HIDE-ALL-BUT 1) (("8" (SKEEP) (("8" (GRIND) (("8" (CASE "d/columns(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (HIDE-ALL-BUT 1) (("9" (GRIND) (("9" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (HIDE-ALL-BUT 1) (("10" (SKEEP) (("10" (LEMMA "mod_pos") (("10" (INST -1 "n1" "columns(B2)") (("10" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (HIDE-ALL-BUT 1) (("11" (SKEEP) (("11" (LEMMA "mod_pos") (("11" (INST -1 "d" "rows(B2)") (("11" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (HIDE-ALL-BUT 1) (("12" (SKEEP) (("12" (GRIND) (("12" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (HIDE-ALL-BUT 1) (("13" (SKEEP) (("13" (GRIND) (("13" (CASE "d/rows(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("14" (HIDE-ALL-BUT 1) (("14" (SKEEP) (("14" (LEMMA "mod_pos") (("14" (INST -1 "d" "columns(B)") (("14" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("15" (HIDE-ALL-BUT 1) (("15" (SKEEP) (("15" (LEMMA "mod_pos") (("15" (INST -1 "m1" "rows(B)") (("15" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("16" (HIDE-ALL-BUT 1) (("16" (SKEEP) (("16" (GRIND) (("16" (CASE "d/columns(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("17" (HIDE-ALL-BUT 1) (("17" (SKEEP) (("17" (GRIND) (("17" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-6 -7 1)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (TYPEPRED (A)) (("2" (TYPEPRED (B)) (("2" (HIDE-ALL-BUT (-4 -8 1)) (("2" (MULT-INEQ -1 -2) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (TYPEPRED (A)) (("3" (TYPEPRED (B)) (("3" (HIDE-ALL-BUT (-3 -7 1)) (("3" (MULT-INEQ -1 -2) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF -2) (("2" (SPLIT -2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (HIDE 2) (("2" (SPLIT 1) (("1" (INST -2 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (1 -1)) (("1" (LEMMA "tensor_rows") (("1" (INST -1 "A" "B") (("1" (REPLACE -1) (("1" (HIDE -1) (("1" (CASE "FORALL (a,b:nat): a<b IMPLIES a<=b-1") (("1" (INST -1 "(m1 - mod(m1, rows(B))) / rows(B)" "rows(A)") (("1" (PROP) (("1" (CROSS-MULT -1) (("1" (LEMMA "mod_pos") (("1" (INST -1 "m1" "rows(B)") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (B2)) (("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (-2 1)) (("1" (CASE "FORALL (a,b:nat): a<b IMPLIES a<=b-1") (("1" (INST -1 "(n1 - mod(n1, columns(B2))) / columns(B2) " " columns(A2)") (("1" (PROP) (("1" (LEMMA "tensor_cols") (("1" (INST -1 "A2" "B2") (("1" (REPLACE -1) (("1" (CROSS-MULT -2) (("1" (LEMMA "mod_pos") (("1" (INST -1 "n1" "columns(B2)") (("1" (FLATTEN) (("1" (HIDE -3) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|entry_mult| FORMULA-DECL NIL |matrices| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|entry_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|sigma_eq| FORMULA-DECL NIL |sigma| |reals|) (|sigma_product2| FORMULA-DECL NIL |sigma_nat| |reals|) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|entry_form_matrix2| FORMULA-DECL NIL |matrices| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|matrix2array| FORMULA-DECL NIL |matrices| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|subrange| TYPE-EQ-DECL NIL |integers| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (A2 SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (B2 SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|n1| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|m1| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (A SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (B SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|sigma| DEF-DECL "real" |sigma| |reals|) (|T_high| TYPE-EQ-DECL NIL |sigma| |reals|) (|T_low| TYPE-EQ-DECL NIL |sigma| |reals|) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|gt_times_gt_any1| FORMULA-DECL NIL |extra_real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|form_matrix_mult| FORMULA-DECL NIL |matrices| NIL) (|div_mult_pos_le1| FORMULA-DECL NIL |real_props| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK) (|tensor_mult_entry-1| |nil| 3615627026 ("" (SKEEP) (("" (LEMMA "entry_mult") (("" (INST-CP -1 "tensor_prod(A,B)" "tensor_prod(A2, B2)" "m1" "n1") (("" (CASE "m1<rows(tensor_prod(A,B)) AND n1<columns(tensor_prod(A2, B2))") (("1" (LIFT-IF -3) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (HIDE (-1 -2)) (("1" (LEMMA "form_matrix_mult") (("1" (INST -1 "tensor_fun(A,B)" "tensor_fun(A2, B2)" "rows(A)*rows(B)" "columns(A)*columns(B)" "columns(A2)*columns(B2)") (("1" (EXPAND "tensor_prod" 1) (("1" (REPLACE -6 1 :DIR RL) (("1" (REPLACE -7 1 :DIR RL) (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (LEMMA "entry_form_matrix") (("1" (INST -1 "LAMBDA (i, j: nat):
                          IF i > rows(A) * rows(B) OR
                              j > columns(A2) * columns(B2)
                            THEN 0
                          ELSE sigma(0,
                                     columns(A) * columns(B) - 1,
                                     LAMBDA
                                     (d: nat):
                                     tensor_fun(A, B)(i, d)
                                     *
                                     tensor_fun(A2, B2)(d, j))
                          ENDIF" "m1" "n1" "rows(A)*rows(B)" "columns(A2)*columns(B2)") (("1" (LEMMA "tensor_rows") (("1" (INST -1 "A" "B") (("1" (LEMMA "tensor_cols") (("1" (INST -1 "A2" "B2") (("1" (REPLACE -2 -6) (("1" (REPLACE -1 -7) (("1" (CASE-REPLACE "IF m1 < rows(A) * rows(B) AND n1 < columns(A2) * columns(B2)
         THEN IF m1 > rows(A) * rows(B) OR n1 > columns(A2) * columns(B2)
                THEN 0
              ELSE sigma(0, columns(A) * columns(B) - 1,
                         LAMBDA (d: nat):
                           tensor_fun(A, B)(m1, d) *
                            tensor_fun(A2, B2)(d, n1))
              ENDIF
       ELSE 0
       ENDIF = sigma(0, columns(A) * columns(B) - 1,
                         LAMBDA (d: nat):
                           tensor_fun(A, B)(m1, d) *
                            tensor_fun(A2, B2)(d, n1))") (("1" (REPLACE -4) (("1" (HIDE (-1 -4 -5)) (("1" (EXPAND "tensor_fun") (("1" (LEMMA "sigma_eq") (("1" (INST -1 "LAMBDA (d: nat):
              IF m1 < rows(A) * rows(B)
                THEN IF d < columns(A) * columns(B)
                       THEN entry(A)
                                 ((m1 - mod(m1, rows(B))) / rows(B),
                                  (d - mod(d, columns(B))) / columns(B))
                             *
                             entry(B)(mod(m1, rows(B)), mod(d, columns(B)))
                     ELSE 0
                     ENDIF
              ELSE 0
              ENDIF
               *
               IF d < rows(A2) * rows(B2)
                 THEN IF n1 < columns(A2) * columns(B2)
                        THEN entry(A2)
                                  ((d - mod(d, rows(B2))) / rows(B2),
                                   (n1 - mod(n1, columns(B2))) /
                                    columns(B2))
                              *
                              entry(B2)
                                   (mod(d, rows(B2)), mod(n1, columns(B2)))
                      ELSE 0
                      ENDIF
               ELSE 0
               ENDIF" "LAMBDA (d: nat):
               entry(A)
                                 ((m1 - mod(m1, rows(B))) / rows(B),
                                  (d - mod(d, columns(B))) / columns(B))
                             *
                             entry(B)(mod(m1, rows(B)), mod(d, columns(B)))
                     
               *
                entry(A2)
                                  ((d - mod(d, rows(B2))) / rows(B2),
                                   (n1 - mod(n1, columns(B2))) /
                                    columns(B2))
                              *
                              entry(B2)
                                   (mod(d, rows(B2)), mod(n1, columns(B2)))
                      " "columns(A)*columns(B)-1" "0") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (LEMMA "sigma_product2") (("1" (HIDE -2) (("1" (REPLACE -9 1 :DIR RL) (("1" (INST -1 "LAMBDA (d:nat): entry(A)
                   ((m1 - mod(m1, rows(B))) / rows(B),
                    d)* entry(A2)
                    (d,
                     (n1 - mod(n1, columns(B2))) / columns(B2))" "LAMBDA (d:nat): 
entry(B)(mod(m1, rows(B)), d)*entry(B2)(d, mod(n1, columns(B2)))" "columns(A)" "columns(B)") (("1" (REPLACE -1 :DIR RL) (("1" (LEMMA "matrix2array") (("1" (CASE "FORALL (M, M2: PosFullMatrix, r, c:nat): columns(M) =rows(M2) AND r<rows(M) AND c<columns(M2) IMPLIES
              entry(M*M2)(r,c) = sigma(0, columns(M)-1, LAMBDA(d:nat): entry(M)(r,d)*entry(M2)(d, c))") (("1" (INST -1 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE (-1 -3 -9)) (("1" (REVEAL -4) (("1" (INST -1 "B" "B2" "mod(m1, rows(B))" "mod(n1, columns(B2))") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST -1 "n1" "columns(B2)") (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (HIDE-ALL-BUT (1 -6)) (("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) (("3" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT (1 -7)) (("4" (CROSS-MULT 1) (("4" (LEMMA "mod_pos") (("4" (INST -1 "n1" "columns(B2)") (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (SKEEP) (("2" (INST-CP -4 "M") (("2" (INST -4 "M2") (("2" (CASE-REPLACE "M*M2 = form_matrix(entry(M), rows(M), columns(M))* form_matrix(entry(M2), rows(M2), columns(M2))") (("1" (LEMMA "form_matrix_mult") (("1" (INST -1 "entry(M)" "entry(M2)" "rows(M)" "columns(M)" "columns(M2)") (("1" (SPLIT -1) (("1" (REPLACE -3) (("1" (REPLACE -1) (("1" (LEMMA "entry_form_matrix2") (("1" (INST -1 "LAMBDA (i, j: nat):
                          IF i > rows(M) OR j > columns(M2) THEN 0
                          ELSE sigma(0,
                                     rows(M2) - 1,
                                     LAMBDA
                                     (d: nat):
                                     entry(M)(i, d) * entry(M2)(d, j))
                          ENDIF" "r" "c" "rows(M)" "columns(M2)") (("1" (HIDE (-2 -3)) (("1" (PROP) (("1" (LIFT-IF -1) (("1" (PROP) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (LEMMA "mod_pos") (("3" (INST -1 "m1" "rows(B)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (GRIND) (("4" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT 1) (("5" (GRIND) (("5" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (TYPEPRED (N)) (("2" (CASE "n<columns(A)*columns(B) AND n<rows(A2)*rows(B2)") (("1" (LIFT-IF 1) (("1" (PROP) (("1" (LIFT-IF 1) (("1" (PROP) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-3 -4 -5 -8 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (LEMMA "mod_pos") (("3" (INST -1 "d" "rows(B2)") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (GRIND) (("4" (CROSS-MULT) (("4" (CASE "n1/columns(B2)>=0") (("1" (GROUND) NIL NIL) ("2" (GRIND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE-ALL-BUT 1) (("5" (SKEEP) (("5" (GRIND) (("5" (CASE "d/rows(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (HIDE-ALL-BUT 1) (("6" (SKEEP) (("6" (LEMMA "mod_pos") (("6" (INST -1 "d" "columns(B)") (("6" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (HIDE-ALL-BUT 1) (("7" (LEMMA "mod_pos") (("7" (INST -1 "m1" "rows(B)") (("7" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("8" (HIDE-ALL-BUT 1) (("8" (SKEEP) (("8" (GRIND) (("8" (CASE "d/columns(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (HIDE-ALL-BUT 1) (("9" (GRIND) (("9" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (HIDE-ALL-BUT 1) (("10" (SKEEP) (("10" (LEMMA "mod_pos") (("10" (INST -1 "n1" "columns(B2)") (("10" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (HIDE-ALL-BUT 1) (("11" (SKEEP) (("11" (LEMMA "mod_pos") (("11" (INST -1 "d" "rows(B2)") (("11" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (HIDE-ALL-BUT 1) (("12" (SKEEP) (("12" (GRIND) (("12" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (HIDE-ALL-BUT 1) (("13" (SKEEP) (("13" (GRIND) (("13" (CASE "d/rows(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("14" (HIDE-ALL-BUT 1) (("14" (SKEEP) (("14" (LEMMA "mod_pos") (("14" (INST -1 "d" "columns(B)") (("14" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("15" (HIDE-ALL-BUT 1) (("15" (SKEEP) (("15" (LEMMA "mod_pos") (("15" (INST -1 "m1" "rows(B)") (("15" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("16" (HIDE-ALL-BUT 1) (("16" (SKEEP) (("16" (GRIND) (("16" (CASE "d/columns(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("17" (HIDE-ALL-BUT 1) (("17" (SKEEP) (("17" (GRIND) (("17" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-6 -7 1)) (("2" (GROUND) NIL NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (TYPEPRED (A)) (("3" (TYPEPRED (B)) (("3" (MULT-INEQ -4 -8) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE-ALL-BUT 1) (("4" (TYPEPRED (A)) (("4" (TYPEPRED (B)) (("4" (MULT-INEQ -4 -8) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (TYPEPRED (B)) (("2" (TYPEPRED (A)) (("2" (MULT-INEQ -4 -8) (("2" (HIDE-ALL-BUT (-1 3)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (TYPEPRED (A)) (("2" (TYPEPRED (B)) (("2" (HIDE-ALL-BUT (-4 -8 1)) (("2" (MULT-INEQ -1 -2) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (TYPEPRED (A)) (("3" (TYPEPRED (B)) (("3" (HIDE-ALL-BUT (-3 -7 1)) (("3" (MULT-INEQ -1 -2) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF -2) (("2" (SPLIT -2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (HIDE 2) (("2" (SPLIT 1) (("1" (INST -2 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (1 -1)) (("1" (LEMMA "tensor_rows") (("1" (INST -1 "A" "B") (("1" (REPLACE -1) (("1" (HIDE -1) (("1" (CASE "FORALL (a,b:nat): a<b IMPLIES a<=b-1") (("1" (INST -1 "(m1 - mod(m1, rows(B))) / rows(B)" "rows(A)") (("1" (PROP) (("1" (CROSS-MULT -1) (("1" (LEMMA "mod_pos") (("1" (INST -1 "m1" "rows(B)") (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (B2)) (("2" (LEMMA "mod_pos") (("2" (INST -1 "n1" "columns(B2)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "A" "A2" "(m1 - mod(m1, rows(B))) / rows(B)" "
             (n1 - mod(n1, columns(B2))) / columns(B2)") (("1" (LIFT-IF -2) (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (-2 1)) (("1" (CASE "FORALL (a,b:nat): a<b IMPLIES a<=b-1") (("1" (INST -1 "(n1 - mod(n1, columns(B2))) / columns(B2) " " columns(A2)") (("1" (PROP) (("1" (LEMMA "tensor_cols") (("1" (INST -1 "A2" "B2") (("1" (REPLACE -1) (("1" (CROSS-MULT -2) (("1" (LEMMA "mod_pos") (("1" (INST -1 "n1" "columns(B2)") (("1" (FLATTEN) (("1" (HIDE -3) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) (("2" (CASE "n1/columns(B2)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (GRIND) (("3" (CASE "m1/rows(B)>=0") (("1" (CROSS-MULT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (CROSS-MULT 1) NIL NIL) ("3" (CROSS-MULT 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|invertible_tensor_TCC1| 0 (|invertible_tensor_TCC1-1| |nil| 3615032070 ("" (SKEEP) (("" (LEMMA "tensor_rows") (("" (INST?) (("" (REPLACE -1) (("" (LEMMA "tensor_cols") (("" (INST?) (("" (REPLACE -1) (("" (TYPEPRED (AA)) (("" (REPLACE -5) (("" (TYPEPRED (BB)) (("" (REPLACE -5) (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL (|invertible_tensor| SUBTYPE "tensor_product.tensor_prod(tensor_product.AA, tensor_product.BB)" "Square"))) (|invertible_tensor_TCC2| 0 (|invertible_tensor_TCC2-1| |nil| 3615032070 ("" (SKEEP) (("" (SPLIT 1) (("1" (LEMMA "tensor_rows" ("A" "AA" "B" "BB")) (("1" (LEMMA "tensor_cols" ("A" "AA" "B" "BB")) (("1" (TYPEPRED (AA)) (("1" (REPLACE -5) (("1" (TYPEPRED (BB)) (("1" (REPLACE -5) (("1" (REPLACE -11) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL) ((|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL)) NIL (|invertible_tensor| SUBTYPE "tensor_product.tensor_prod(tensor_product.AA, tensor_product.BB)" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|invertible_tensor_TCC3| 0 (|invertible_tensor_TCC3-1| |nil| 3615032070 ("" (SKEEP) NIL NIL) NIL NIL (|invertible_tensor| SUBTYPE "tensor_product.AA" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|invertible_tensor_TCC4| 0 (|invertible_tensor_TCC4-1| |nil| 3615032070 ("" (SKEEP) NIL NIL) NIL NIL (|invertible_tensor| SUBTYPE "tensor_product.BB" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|invertible_tensor| 0 (|invertible_tensor-2| "" 3883690282 ("" (SKEEP) (("" (EXPAND "invertible?") (("" (SKOLEM -1 "AAinv") (("" (SKOLEM -2 "BBinv") (("" (LEMMA "inverse_unique") (("" (INST-CP -1 "AAinv" "AA") (("" (INST -1 "BBinv" "BB") (("" (LEMMA "inverse_unique") (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (SPLIT -6) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (INST -9 "tensor_prod(AAinv, BBinv)" "tensor_prod(AA, BB)") (("1" (SPLIT -9) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (EXPAND "invertible?") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 4) (("2" (REWRITE "tensor_rows") (("2" (REWRITE "tensor_rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE 4) (("3" (CASE "tensor_prod(AA, BB) * tensor_prod(AAinv, BBinv) =
                                     Id(rows(tensor_prod(AA, BB)))") (("1" (GROUND) NIL NIL) ("2" (HIDE 2) (("2" (LEMMA "full_matrix_eq") (("2" (INST -1 "tensor_prod(AA, BB) * tensor_prod(AAinv, BBinv) " "       Id(rows(tensor_prod(AA, BB)))") (("2" (FLATTEN) (("2" (HIDE -1) (("2" (LEMMA "rows_mult") (("2" (INST -1 "tensor_prod(AA, BB) " " tensor_prod(AAinv, BBinv)") (("2" (REPLACE -1) (("2" (LEMMA "rows_Id") (("2" (INST -1 "rows(tensor_prod(AA,BB))") (("2" (REPLACE -1) (("2" (HIDE (-1 -2)) (("2" (LEMMA "columns_mult") (("2" (INST -1 "tensor_prod(AA, BB) " " tensor_prod(AAinv, BBinv)") (("2" (SPLIT -1) (("1" (LEMMA "columns_Id") (("1" (INST -1 "rows(tensor_prod(AA,BB))") (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (LEMMA "tensor_cols") (("1" (INST -1 "AAinv" "BBinv") (("1" (TYPEPRED ("AAinv")) (("1" (REPLACE -5 :DIR RL) (("1" (HIDE (-1 -2 -3 -4 -5)) (("1" (TYPEPRED ("BBinv")) (("1" (REPLACE -5 :DIR RL) (("1" (HIDE (-1 -2 -3 -4 -5)) (("1" (LEMMA "tensor_rows") (("1" (INST? -1) (("1" (REPLACE -14) (("1" (REPLACE -17) (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (SPLIT -5) (("1" (PROPAX) NIL NIL) ("2" (SKEEP) (("2" (LEMMA "tensor_mult_entry") (("2" (INST -1 "AA" "AAinv" "BB" "BBinv" "i" "j") (("2" (TYPEPRED ("AA")) (("2" (REPLACE -5 -6 :DIR RL) (("2" (HIDE (-1 -2 -3 -4 -5)) (("2" (TYPEPRED ("BB")) (("2" (REPLACE -5 -6 :DIR RL) (("2" (HIDE (-1 -2 -3 -4 -5)) (("2" (SPLIT -1) (("1" (REPLACE -1 1) (("1" (TYPEPRED ("BBinv")) (("1" (REPLACE -5 1 :DIR RL) (("1" (HIDE (-1 -2 -3 -4 -5)) (("1" (REPLACE -17 1) (("1" (REPLACE -9 1) (("1" (REPLACE -13 1) (("1" (LEMMA "entry_Id") (("1" (INST-CP -1 "i" "j" "rows(AA)*rows(BB)") (("1" (INST-CP -1 "(i - mod(i, rows(BB))) / rows(BB)" "(j - mod(j, rows(BB))) / rows(BB)" "rows(AA)") (("1" (INST -1 "mod(i, rows(BB))" "mod(j, rows(BB))" "rows(BB)") (("1" (CASE "mod(i, rows(BB))<rows(BB) AND mod(j, rows(BB))<rows(BB)") (("1" (CASE "(i - mod(i, rows(BB))) / rows(BB) < rows(AA) AND (j - mod(j, rows(BB))) / rows(BB) < rows(AA)") (("1" (CASE-REPLACE "mod(i, rows(BB)) = mod(j, rows(BB))") (("1" (CASE-REPLACE "i=j") (("1" (LIFT-IF -4) (("1" (SPLIT -4) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (LIFT-IF -8) (("2" (SPLIT -8) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (LIFT-IF -8) (("2" (SPLIT -8) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "(i - mod(j, rows(BB))) / rows(BB) /= (j - mod(j, rows(BB))) / rows(BB)") (("1" (LIFT-IF -5) (("1" (SPLIT -5) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (LIFT-IF -8) (("2" (SPLIT -8) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (LIFT-IF -9) (("3" (SPLIT -9) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-4 -5 -6)) (("2" (SIMPLIFY 1) (("2" (EXPAND "/=") (("2" (CROSS-MULT -1) (("2" (CANCEL-BY -1 "rows(BB)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF -3) (("2" (SPLIT -3) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (CASE "i/=j") (("1" (LIFT-IF -9) (("1" (SPLIT -9) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (SIMPLIFY 4) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (EXPAND "/=") (("2" (REPLACE -1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (SPLIT 1) (("1" (TYPEPRED ("i")) (("1" (LEMMA "rows_mult") (("1" (INST -1 "tensor_prod(AA, BB)" "tensor_prod(AAinv, BBinv)") (("1" (REPLACE -1) (("1" (REPLACE -8 -2) (("1" (CROSS-MULT 1) (("1" (LEMMA "mod_pos") (("1" (INST -1 "i" "rows(BB)") (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (-1 -2 -4 1)) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("j")) (("2" (REPLACE -10 -1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT (-1 -2 -3 1)) (("2" (CROSS-MULT 1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (SPLIT 1) (("1" (INST -1 "i" "rows(BB)") (("1" (FLATTEN) NIL NIL)) NIL) ("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "i" "rows(BB)") (("3" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 -2 2 3 4)) (("2" (TYPEPRED ("j")) (("2" (REPLACE -5) (("2" (LEMMA "mod_pos") (("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT (-1 -2 -3 1)) (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (CROSS-MULT) (("2" (EXPAND "mod") (("2" (CASE "j>=0") (("1" (DIV-BY -1 "rows(BB)") (("1" (GROUND) (("1" (TYPEPRED ("rows(BB)")) (("1" (CASE "floor(j/rows(BB))>=0") (("1" (MULT-INEQ -1 -2) (("1" (GROUND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "i" "rows(BB)") (("3" (TYPEPRED ("i")) (("3" (REVEAL -18) (("3" (REPLACE -1) (("3" (HIDE-ALL-BUT (-2 -3 1)) (("3" (FLATTEN) (("3" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (CASE "i>=0") (("1" (EXPAND "mod") (("1" (CROSS-MULT 1) (("1" (TYPEPRED ("rows(BB)")) (("1" (DIV-BY -2 "rows(BB)") (("1" (CASE "floor(i/rows(BB))>=0") (("1" (MULT-INEQ -1 -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "i/rows(BB)>=0") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "nonempty?(tensor_prod(AA, BB))") (("1" (NAME-REPLACE "TP" "tensor_prod(AA, BB)") (("1" (HIDE-ALL-BUT (-1 -2)) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (LEMMA "tensor_rows") (("2" (INST? -1) (("2" (TYPEPRED ("AA")) (("2" (TYPEPRED ("BB")) (("2" (HIDE (-1 -2 -6 -7)) (("2" (LEMMA "tensor_cols") (("2" (INST? -1) (("2" (MULT-INEQ -6 -3) (("2" (MULT-INEQ -6 -3) (("2" (EXPAND "nonempty?") (("2" (REPLACE -3) (("2" (REPLACE -10) (("2" (HIDE-ALL-BUT (-1 -2 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (LEMMA "tensor_rows") (("2" (INST?) (("2" (REPLACE -1) (("2" (LEMMA "tensor_cols") (("2" (INST?) (("2" (REPLACE -1) (("2" (TYPEPRED ("AA")) (("2" (REPLACE -5) (("2" (HIDE -) (("2" (TYPEPRED ("BB")) (("2" (REPLACE -5) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (LEMMA "tensor_rows") (("3" (INST?) (("3" (REPLACE -1) (("3" (LEMMA "tensor_cols") (("3" (INST?) (("3" (REPLACE -1) (("3" (TYPEPRED ("AAinv")) (("3" (REPLACE -5) (("3" (HIDE -) (("3" (TYPEPRED ("BBinv")) (("3" (REPLACE -5) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|invertible_tensor-1| |nil| 3615040307 ("" (SKEEP) (("" (EXPAND "invertible?") (("" (SKOLEM -1 "AAinv") (("" (SKOLEM -2 "BBinv") (("" (LEMMA "inverse_unique") (("" (INST-CP -1 "AAinv" "AA") (("" (INST -1 "BBinv" "BB") (("" (LEMMA "inverse_unique") (("" (FLATTEN) (("" (SPLIT -2) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (SPLIT -6) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (INST -9 "tensor_prod(AAinv, BBinv)" "tensor_prod(AA, BB)") (("1" (SPLIT -9) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (EXPAND "invertible?") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 4) (("2" (REWRITE "tensor_rows") (("2" (REWRITE "tensor_rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE 4) (("3" (CASE "tensor_prod(AA, BB) * tensor_prod(AAinv, BBinv) =
                                     Id(rows(tensor_prod(AA, BB)))") (("1" (GROUND) NIL NIL) ("2" (HIDE 2) (("2" (LEMMA "full_matrix_eq") (("2" (INST -1 "tensor_prod(AA, BB) * tensor_prod(AAinv, BBinv) " "       Id(rows(tensor_prod(AA, BB)))") (("2" (FLATTEN) (("2" (HIDE -1) (("2" (LEMMA "rows_mult") (("2" (INST -1 "tensor_prod(AA, BB) " " tensor_prod(AAinv, BBinv)") (("2" (REPLACE -1) (("2" (LEMMA "rows_Id") (("2" (INST -1 "rows(tensor_prod(AA,BB))") (("2" (REPLACE -1) (("2" (HIDE (-1 -2)) (("2" (LEMMA "columns_mult") (("2" (INST -1 "tensor_prod(AA, BB) " " tensor_prod(AAinv, BBinv)") (("2" (SPLIT -1) (("1" (LEMMA "columns_Id") (("1" (INST -1 "rows(tensor_prod(AA,BB))") (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (LEMMA "tensor_cols") (("1" (INST -1 "AAinv" "BBinv") (("1" (TYPEPRED (AAINV)) (("1" (REPLACE -5 :DIR RL) (("1" (HIDE (-1 -2 -3 -4 -5)) (("1" (TYPEPRED (BBINV)) (("1" (REPLACE -5 :DIR RL) (("1" (HIDE (-1 -2 -3 -4 -5)) (("1" (LEMMA "tensor_rows") (("1" (INST? -1) (("1" (REPLACE -14) (("1" (REPLACE -17) (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (SPLIT -5) (("1" (PROPAX) NIL NIL) ("2" (SKEEP) (("2" (LEMMA "tensor_mult_entry") (("2" (INST -1 "AA" "AAinv" "BB" "BBinv" "i" "j") (("2" (TYPEPRED (AA)) (("2" (REPLACE -5 -6 :DIR RL) (("2" (HIDE (-1 -2 -3 -4 -5)) (("2" (TYPEPRED (BB)) (("2" (REPLACE -5 -6 :DIR RL) (("2" (HIDE (-1 -2 -3 -4 -5)) (("2" (SPLIT -1) (("1" (REPLACE -1 1) (("1" (TYPEPRED (BBINV)) (("1" (REPLACE -5 1 :DIR RL) (("1" (HIDE (-1 -2 -3 -4 -5)) (("1" (REPLACE -17 1) (("1" (REPLACE -9 1) (("1" (REPLACE -13 1) (("1" (LEMMA "entry_Id") (("1" (INST-CP -1 "i" "j" "rows(AA)*rows(BB)") (("1" (INST-CP -1 "(i - mod(i, rows(BB))) / rows(BB)" "(j - mod(j, rows(BB))) / rows(BB)" "rows(AA)") (("1" (INST -1 "mod(i, rows(BB))" "mod(j, rows(BB))" "rows(BB)") (("1" (CASE "mod(i, rows(BB))<rows(BB) AND mod(j, rows(BB))<rows(BB)") (("1" (CASE "(i - mod(i, rows(BB))) / rows(BB) < rows(AA) AND (j - mod(j, rows(BB))) / rows(BB) < rows(AA)") (("1" (CASE-REPLACE "mod(i, rows(BB)) = mod(j, rows(BB))") (("1" (CASE-REPLACE "i=j") (("1" (LIFT-IF -4) (("1" (SPLIT -4) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (LIFT-IF -8) (("2" (SPLIT -8) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (LIFT-IF -8) (("2" (SPLIT -8) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "(i - mod(j, rows(BB))) / rows(BB) /= (j - mod(j, rows(BB))) / rows(BB)") (("1" (LIFT-IF -5) (("1" (SPLIT -5) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACE -2) (("2" (LIFT-IF -8) (("2" (SPLIT -8) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (LIFT-IF -9) (("3" (SPLIT -9) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-4 -5 -6)) (("2" (SIMPLIFY 1) (("2" (EXPAND "/=") (("2" (CROSS-MULT -1) (("2" (CANCEL-BY -1 "rows(BB)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF -3) (("2" (SPLIT -3) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (CASE "i/=j") (("1" (LIFT-IF -9) (("1" (SPLIT -9) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (REPLACE -2) (("3" (SIMPLIFY 4) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (EXPAND "/=") (("2" (REPLACE -1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (SPLIT 1) (("1" (TYPEPRED (I)) (("1" (LEMMA "rows_mult") (("1" (INST -1 "tensor_prod(AA, BB)" "tensor_prod(AAinv, BBinv)") (("1" (REPLACE -1) (("1" (REPLACE -8 -2) (("1" (CROSS-MULT 1) (("1" (LEMMA "mod_pos") (("1" (INST -1 "i" "rows(BB)") (("1" (FLATTEN) (("1" (HIDE-ALL-BUT (-1 -2 -4 1)) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (J)) (("2" (REPLACE -10 -1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT (-1 -2 -3 1)) (("2" (CROSS-MULT 1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (SPLIT 1) (("1" (INST -1 "i" "rows(BB)") (("1" (FLATTEN) NIL NIL)) NIL) ("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "i" "rows(BB)") (("3" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 -2 2 3 4)) (("2" (TYPEPRED (J)) (("2" (REPLACE -5) (("2" (LEMMA "mod_pos") (("2" (INST -1 "j" "rows(BB)") (("2" (FLATTEN) (("2" (HIDE-ALL-BUT (-1 -2 -3 1)) (("2" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (CROSS-MULT) (("2" (EXPAND "mod") (("2" (CASE "j>=0") (("1" (DIV-BY -1 "rows(BB)") (("1" (GROUND) (("1" (TYPEPRED ("rows(BB)")) (("1" (CASE "floor(j/rows(BB))>=0") (("1" (MULT-INEQ -1 -2) (("1" (GROUND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST -1 "i" "rows(BB)") (("3" (TYPEPRED (I)) (("3" (REVEAL -18) (("3" (REPLACE -1) (("3" (HIDE-ALL-BUT (-2 -3 1)) (("3" (FLATTEN) (("3" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (CASE "i>=0") (("1" (EXPAND "mod") (("1" (CROSS-MULT 1) (("1" (TYPEPRED ("rows(BB)")) (("1" (DIV-BY -2 "rows(BB)") (("1" (CASE "floor(i/rows(BB))>=0") (("1" (MULT-INEQ -1 -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "i/rows(BB)>=0") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "nonempty?(tensor_prod(AA, BB))") (("1" (NAME-REPLACE "TP" "tensor_prod(AA, BB)") (("1" (HIDE-ALL-BUT (-1 -2)) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (LEMMA "tensor_rows") (("2" (INST? -1) (("2" (TYPEPRED (AA)) (("2" (TYPEPRED (BB)) (("2" (HIDE (-1 -2 -6 -7)) (("2" (LEMMA "tensor_cols") (("2" (INST? -1) (("2" (MULT-INEQ -6 -3) (("2" (MULT-INEQ -6 -3) (("2" (EXPAND "nonempty?") (("2" (REPLACE -3) (("2" (REPLACE -10) (("2" (HIDE-ALL-BUT (-1 -2 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (LEMMA "tensor_rows") (("2" (INST?) (("2" (REPLACE -1) (("2" (LEMMA "tensor_cols") (("2" (INST?) (("2" (REPLACE -1) (("2" (TYPEPRED (AA)) (("2" (REPLACE -5) (("2" (HIDE -) (("2" (TYPEPRED (BB)) (("2" (REPLACE -5) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (LEMMA "tensor_rows") (("3" (INST?) (("3" (REPLACE -1) (("3" (LEMMA "tensor_cols") (("3" (INST?) (("3" (REPLACE -1) (("3" (TYPEPRED (AAINV)) (("3" (REPLACE -5) (("3" (HIDE -) (("3" (TYPEPRED (BBINV)) (("3" (REPLACE -5) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|BBinv| SKOLEM-CONST-DECL "Square" |tensor_product| NIL) (|AAinv| SKOLEM-CONST-DECL "Square" |tensor_product| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (BB SKOLEM-CONST-DECL "Square" |tensor_product| NIL) (AA SKOLEM-CONST-DECL "Square" |tensor_product| NIL) (|rows_Id| FORMULA-DECL NIL |matrices| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (|ge_times_ge_any1| FORMULA-DECL NIL |extra_real_props| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|both_sides_div_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|rat_times_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|both_sides_times1_imp| FORMULA-DECL NIL |extra_real_props| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|div_cancel4| FORMULA-DECL NIL |real_props| NIL) (|times_div2| FORMULA-DECL NIL |real_props| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nonzero_real| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (|div_cancel3| FORMULA-DECL NIL |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|j| SKOLEM-CONST-DECL "below(columns(tensor_prod(AA, BB) * tensor_prod(AAinv, BBinv)))" |tensor_product| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|i| SKOLEM-CONST-DECL "below(rows(tensor_prod(AA, BB) * tensor_prod(AAinv, BBinv)))" |tensor_product| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|entry_Id| FORMULA-DECL NIL |matrices| NIL) (|tensor_mult_entry| FORMULA-DECL NIL |tensor_product| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|columns_Id| FORMULA-DECL NIL |matrices| NIL) (|gt_times_gt_any1| FORMULA-DECL NIL |extra_real_props| NIL) (|nonempty?| CONST-DECL "bool" |matrices| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|full_matrix_eq| FORMULA-DECL NIL |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|inverse_unique| FORMULA-DECL NIL |matrix_inv| NIL)) SHOSTAK)) (|TQMat_TCC1| 0 (|TQMat_TCC1-2| "" 3750629688 ("" (GROUND) (("1" (GRIND) (("1" (EXPAND "length") (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) (("1" (EXPAND "nth" -1) (("1" (LIFT-IF) (("1" (HIDE-ALL-BUT (-1 -2)) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1 3) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT (-1 -3)) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT (-1 -2)) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT (-1 -3)) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1 3) (("2" (EXPAND "length") (("2" (EXPAND "nth") (("2" (LIFT-IF) (("2" (PROP) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF) (("2" (PROP) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (PROP) (("1" (EXPAND "nth") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "nth" -1) (("2" (LIFT-IF) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF) (("2" (GRIND) (("1" (EXPAND "length" 2) (("1" (EXPAND "nth" 2) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "nth" -1) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "length" 3) (("3" (LIFT-IF) (("3" (PROP) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "nth" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (EXPAND "length") (("2" (EXPAND "length") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL) ((|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL)) SHOSTAK (|TQMat| SUBTYPE "(: (: 1, 1, 1 :), (: 0, 1, -1 :), (: 0, 1, 1 :) :)" "Square")) (|TQMat_TCC1-1| |nil| 3615032070 ("" (GROUND) (("1" (GRIND) (("1" (EXPAND "length") (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) (("1" (EXPAND "nth" -1) (("1" (LIFT-IF) (("1" (HIDE-ALL-BUT (-1 -2)) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1 3) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT (-1 -3)) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT (-1 -2)) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT (-1 -3)) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1 3) (("2" (EXPAND "length") (("2" (EXPAND "nth") (("2" (LIFT-IF) (("2" (PROP) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) NIL NIL) ("2" (LIFT-IF) (("2" (PROP) (("1" (ASSERT) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("2" (EXPAND "nth" 1) (("2" (LIFT-IF) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF) (("2" (PROP) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (PROP) (("1" (EXPAND "nth") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "nth" -1) (("2" (LIFT-IF) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LIFT-IF) (("2" (GRIND) (("1" (EXPAND "length" 2) (("1" (EXPAND "nth" 2) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "nth" -1) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "length" 3) (("3" (LIFT-IF) (("3" (PROP) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "nth" 1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "nth" 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (EXPAND "length") (("2" (EXPAND "length") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL) NIL NIL (|TQMat| SUBTYPE "(: (: 1, 1, 1 :), (: 0, 1, -1 :), (: 0, 1, 1 :) :)" "Square"))) (|TQMatInv_TCC1| 0 (|TQMatInv_TCC1-2| "" 3750629716 ("" (GRIND) (("" (HIDE 1) (("" (EXPAND "length") (("" (GRIND) (("1" (HIDE 1) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (HIDE 1) (("2" (EXPAND "nth") (("2" (GRIND) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 1 2) (("3" (EXPAND "length" 1) (("3" (EXPAND "nth") (("3" (LIFT-IF) (("3" (LIFT-IF) (("3" (PROP) (("1" (GRIND) NIL NIL) ("2" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (GRIND) (("2" (EXPAND "nth" 3) (("2" (GRIND) (("2" (EXPAND "nth" 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LIFT-IF) (("3" (PROP) (("1" (HIDE 1) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE 1) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -1) (("1" (LIFT-IF) (("1" (PROP) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL) ("2" (LIFT-IF) (("2" (ASSERT) (("2" (PROP) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (HIDE 2 3) (("3" (EXPAND "nth") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|even_plus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|odd_plus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|nprat_div_posrat_is_nprat| APPLICATION-JUDGEMENT "nprat" |rationals| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|length| DEF-DECL "nat" |list_props| NIL)) SHOSTAK (|TQMatInv| SUBTYPE "(: (: 1, 0, -1 :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./(-1, 2), number_fields./(1, 2) :) :)" "Square")) (|TQMatInv_TCC1-1| |nil| 3615032070 ("" (GRIND) (("" (HIDE 1) (("" (EXPAND "length") (("" (GRIND) (("1" (HIDE 1) (("1" (EXPAND "nth") (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (HIDE 1) (("2" (EXPAND "nth") (("2" (GRIND) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 1 2) (("3" (EXPAND "length" 1) (("3" (EXPAND "nth") (("3" (LIFT-IF) (("3" (LIFT-IF) (("3" (PROP) (("1" (GRIND) NIL NIL) ("2" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "length") (("2" (GRIND) (("2" (EXPAND "nth" 3) (("2" (HIDE 4) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LIFT-IF) (("3" (PROP) (("1" (HIDE 1) (("1" (GRIND) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE 1) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "length") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -1) (("1" (LIFT-IF) (("1" (PROP) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL) ("2" (LIFT-IF) (("2" (ASSERT) (("2" (PROP) (("1" (EXPAND "nth") (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 1) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (HIDE 2 3) (("3" (EXPAND "nth") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "nth") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|TQMatInv| SUBTYPE "(: (: 1, 0, -1 :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./(-1, 2), number_fields./(1, 2) :) :)" "Square"))) (|invTQ| 0 (|invTQ-1| |nil| 3615032864 ("" (EXPAND "invertible?") (("" (INST 1 "TQMatInv") (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|TQMatInv| CONST-DECL "Square" |tensor_product| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|mult| CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|dot| DEF-DECL "real" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|array2list_it| DEF-DECL "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" |array2list| |structures|) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|access| CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nprat_div_posrat_is_nprat| APPLICATION-JUDGEMENT "nprat" |rationals| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|TQMat| CONST-DECL "Square" |tensor_product| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL)) SHOSTAK)) (|is_invTQ_TCC1| 0 (|is_invTQ_TCC1-1| |nil| 3615033026 ("" (FLATTEN) (("" (EXPAND "invertible?") (("" (INST 1 "TQMatInv") (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|TQMat| CONST-DECL "Square" |tensor_product| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|nprat_div_posrat_is_nprat| APPLICATION-JUDGEMENT "nprat" |rationals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|access| CONST-DECL "real" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|array2list_it| DEF-DECL "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" |array2list| |structures|) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|dot| DEF-DECL "real" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|mult| CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|TQMatInv| CONST-DECL "Square" |tensor_product| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL (|is_invTQ| SUBTYPE "tensor_product.TQMat" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|is_invTQ| 0 (|is_invTQ-1| |nil| 3615033027 ("" (LEMMA "inverse_unique") (("" (CASE "TQMat*TQMatInv = Id(rows(TQMat))") (("1" (INST -2 "TQMatInv" "TQMat") (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (HIDE (-1 2)) (("2" (GRIND) NIL NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (HIDE (-1 2)) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE (-1 2)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|TQMat| CONST-DECL "Square" |tensor_product| NIL) (|TQMatInv| CONST-DECL "Square" |tensor_product| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|nprat_div_posrat_is_nprat| APPLICATION-JUDGEMENT "nprat" |rationals| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_plus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|mult| CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|dot| DEF-DECL "real" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|array2list_it| DEF-DECL "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" |array2list| |structures|) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|access| CONST-DECL "real" |matrices| NIL) (|inverse_unique| FORMULA-DECL NIL |matrix_inv| NIL)) SHOSTAK)) (|tensor_power_TCC1| 0 (|tensor_power_TCC1-1| |nil| 3615903379 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|tensor_power| SUBTYPE "(number_fields.-)(tensor_product.n, 1)" "posnat"))) (|tensor_power_TCC2| 0 (|tensor_power_TCC2-1| |nil| 3615903379 ("" (TERMINATION-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|tensor_power| TERMINATION "tensor_product.tensor_power(tensor_product.A, (number_fields.-)(tensor_product.n, 1))" "NIL"))) (|invertible_tensor_power_TCC1| 0 (|invertible_tensor_power_TCC1-1| |nil| 3615903379 ("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (CASE-REPLACE "j=0") (("1" (EXPAND "tensor_power") (("1" (TYPEPRED (A)) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (CASE-REPLACE "tensor_power(A, j+1) = tensor_prod(A, tensor_power(A,j))") (("1" (REWRITE "tensor_rows") (("1" (REWRITE "tensor_cols") (("1" (SPLIT -2) (("1" (INST?) (("1" (PROP) (("1" (TYPEPRED (A)) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 3)) (("2" (NAME-REPLACE "TPj" "tensor_power(A, j)") (("2" (EXPAND "tensor_power") (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) (("2" (EXPAND "TPj") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|TPj| SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|tensor_power| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (> CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL (|invertible_tensor_power| SUBTYPE "tensor_product.tensor_power(tensor_product.A, tensor_product.n)" "Square"))) (|invertible_tensor_power_TCC2| 0 (|invertible_tensor_power_TCC2-1| |nil| 3615903379 ("" (LEMMA "invertible_tensor_power_TCC1") (("" (SKEEP) (("" (INST?) (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|invertible_tensor_power_TCC1| SUBTYPE-TCC NIL |tensor_product| NIL)) NIL (|invertible_tensor_power| SUBTYPE "tensor_product.tensor_power(tensor_product.A, tensor_product.n)" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|invertible_tensor_power_TCC3| 0 (|invertible_tensor_power_TCC3-1| |nil| 3615903379 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|mult| CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|rows| CONST-DECL "nat" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|invertible_tensor_power| SUBTYPE "tensor_product.A" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|invertible_tensor_power| 0 (|invertible_tensor_power-1| |nil| 3615911176 ("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (CASE-REPLACE "j=0") (("1" (SKEEP) (("1" (EXPAND "tensor_power") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE-REPLACE "tensor_power(A, j+1) = tensor_prod(A, tensor_power(A, j))") (("1" (CASE-REPLACE "tensor_power(inverse(A), j+1) = tensor_prod(inverse(A), tensor_power(inverse(A), j))") (("1" (CASE "invertible?(inverse(A))") (("1" (SPLIT -4) (("1" (INST-CP -1 "A") (("1" (SPLIT -2) (("1" (FLATTEN) (("1" (REPLACE -2 :DIR RL) (("1" (LEMMA "invertible_tensor") (("1" (INST -1 "A" "tensor_power(A, j)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (EXPAND "invertible?" 1) (("2" (EXPAND "invertible?") (("2" (SKEEP -5) (("2" (CASE "IQ= inverse(A)") (("1" (INST 1 "A") (("1" (REPLACE -1) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (LEMMA "inverse_unique") (("2" (INST -1 "IQ" "A") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (NAME-REPLACE "TP" "tensor_power(inverse(A),j)") (("2" (EXPAND "tensor_power") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (EXPAND "TP") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (NAME-REPLACE "TP" "tensor_power(A,j)") (("2" (EXPAND "tensor_power") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (GROUND) NIL NIL) ("2" (GROUND) (("1" (EXPAND "TP") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "TP") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) NIL NIL)) NIL) ("5" (LEMMA "invertible_tensor_power_TCC2") (("5" (SKEEP) (("5" (INST?) NIL NIL)) NIL)) NIL) ("6" (LEMMA "invertible_tensor_power_TCC1") (("6" (SKEEP) (("6" (INST?) NIL NIL)) NIL)) NIL)) NIL) ((|invertible_tensor_power_TCC1| SUBTYPE-TCC NIL |tensor_product| NIL) (|n| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (|invertible_tensor_power_TCC2| SUBTYPE-TCC NIL |tensor_product| NIL) (|n| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (TP SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|inverse_unique| FORMULA-DECL NIL |matrix_inv| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|invertible_tensor| FORMULA-DECL NIL |tensor_product| NIL) (TP SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (> CONST-DECL "bool" |reals| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|tensor_power| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK)) (|tensor_power_rows_TCC1| 0 (|tensor_power_rows_TCC1-1| |nil| 3618074804 ("" (SUBTYPE-TCC) NIL NIL) ((|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_power_rows| SUBTYPE "tensor_product.n" "{i: integers.int | booleans.OR(matrices.rows(tensor_product.A) /= 0, reals.>=(i, 0))}"))) (|tensor_power_rows| 0 (|tensor_power_rows-1| |nil| 3618074805 ("" (SKOLEM 1 ("A" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (SPLIT -1) (("1" (EXPAND "tensor_power" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "tensor_rows") (("2" (EXPAND "^") (("2" (EXPAND "expt" 2) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE-REPLACE "j=0") (("1" (EXPAND "tensor_power") (("1" (EXPAND "^") (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "tensor_power") (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (> CONST-DECL "bool" |reals| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|tensor_power| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|tensor_power_columns_TCC1| 0 (|tensor_power_columns_TCC1-1| |nil| 3618075082 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|tensor_power_columns| SUBTYPE "tensor_product.n" "{i: integers.int | booleans.OR(matrices.columns(tensor_product.A) /= 0, reals.>=(i, 0))}"))) (|tensor_power_columns| 0 (|tensor_power_columns-3| |nil| 3618075244 ("" (SKOLEM 1 ("A" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (SPLIT -1) (("1" (EXPAND "tensor_power" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "tensor_cols") (("2" (EXPAND "^") (("2" (EXPAND "expt" 2) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE-REPLACE "j=0") (("1" (EXPAND "tensor_power") (("1" (EXPAND "^") (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "tensor_power") (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (> CONST-DECL "bool" |reals| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|tensor_power| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL) (|tensor_power_columns-2| |nil| 3618075185 ("" (SKOLEM 1 ("A" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL))) ("3" (SKEEP) (("3" (SPLIT -1) (("1" (EXPAND "tensor_power" 1) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL))))) ("2" (FLATTEN) (("2" (REWRITE "tensor_columns") (("2" (EXPAND "^") (("2" (EXPAND "expt" 2) (("2" (GROUND) NIL))))))))))))))) ("2" (CASE-REPLACE "j=0") (("1" (EXPAND "tensor_power") (("1" (EXPAND "^") (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (PROPAX) NIL))))))))) ("2" (EXPAND "tensor_power") (("2" (LIFT-IF 3) (("2" (SPLIT 3) (("1" (FLATTEN) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL)))))))))))))))))) NIL) NIL NIL) (|tensor_power_columns-1| |nil| 3618075083 ("" (POSTPONE) NIL NIL) NIL SHOSTAK)) (|mod_eq_lem_alt_TCC1| 0 (|mod_eq_lem_alt_TCC1-1| |nil| 3618745682 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|nonneg_floor_is_nat| APPLICATION-JUDGEMENT "nat" |floor_ceil| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nnrat_div_posrat_is_nnrat| APPLICATION-JUDGEMENT "nonneg_rat" |rationals| NIL)) NIL (|mod_eq_lem_alt| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.i, mod.mod(tensor_product.i, tensor_product.n))), tensor_product.n)" "int"))) (|mod_eq_lem_alt| 0 (|mod_eq_lem_alt-1| |nil| 3618745689 ("" (SKEEP) (("" (LEMMA "mod_sum") (("" (INST - "mod(i,n)" "n" "mod((i - mod(i, n)) / n, m)") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (ASSERT) (("1" (CASE "mod(mod(i,n),n) = mod(i,n)") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (LEMMA "mod_of_mod") (("2" (INST - "0" "i" "n") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mod_sum| FORMULA-DECL NIL |mod| NIL) (|mod_int_quot| FORMULA-DECL NIL |mod_lems| |ints|) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|mod_of_mod| FORMULA-DECL NIL |mod| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (NIL APPLICATION-JUDGEMENT "below(m)" |mod| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|i| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|n| SKOLEM-CONST-DECL "posnat" |tensor_product| NIL)) NIL)) (|tensor_prod_assoc| 0 (|tensor_prod_assoc-1| |nil| 3618677717 ("" (SKEEP) (("" (REWRITE "full_matrix_eq") (("" (CASE "NOT (rows(tensor_prod(A, tensor_prod(B, C))) =
               rows(tensor_prod(tensor_prod(A, B), C))
               AND
               columns(tensor_prod(A, tensor_prod(B, C))) =
                columns(tensor_prod(tensor_prod(A, B), C)))") (("1" (HIDE 2) (("1" (SPLIT) (("1" (REWRITE "tensor_rows") (("1" (REWRITE "tensor_rows") (("1" (REWRITE "tensor_rows") (("1" (REWRITE "tensor_rows") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "tensor_cols") (("2" (REWRITE "tensor_cols") (("2" (REWRITE "tensor_cols") (("2" (REWRITE "tensor_cols") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (REWRITE "entry_tensor_prod") (("2" (REWRITE "entry_tensor_prod") (("2" (TYPEPRED "i") (("2" (TYPEPRED "j") (("2" (COPY -2) (("2" (COPY -2) (("2" (REWRITE "tensor_cols" -1) (("2" (REWRITE "tensor_cols" -1) (("2" (REWRITE "tensor_rows" -2) (("2" (REWRITE "tensor_rows" -2) (("2" (ASSERT) (("2" (EXPAND "tensor_fun" +) (("2" (REWRITE "tensor_rows" 1) (("2" (REWRITE "tensor_rows" 1) (("2" (REWRITE "tensor_cols" 1) (("2" (REWRITE "tensor_cols" 1) (("2" (ASSERT) (("2" (REWRITE "entry_tensor_prod" 1) (("2" (REWRITE "entry_tensor_prod" 1) (("2" (EXPAND "tensor_fun" +) (("2" (LABEL "igz" 1) (("2" (HIDE "igz") (("2" (CASE "NOT FORALL (MN:Matrix,ii,jj,kk,pp:nat): (ii=kk AND jj=pp) IMPLIES entry(MN)(ii,jj) = entry(MN)(kk,pp)") (("1" (SKEEP) (("1" (ASSERT) NIL NIL)) NIL) ("2" (CASE "NOT FORALL (aa,bb,cc,dd,ee,ff:real): (aa=dd AND bb=ee AND cc=ff) IMPLIES aa*(bb*cc)=(dd*ee)*ff") (("1" (SKEEP) (("1" (ASSERT) NIL NIL)) NIL) ("2" (LABEL "ski" -1) (("2" (REVEAL "igz") (("2" (LIFT-IF) (("2" (ASSERT) (("2" (LIFT-IF) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "ski" 1) (("1" (HIDE 2) (("1" (COPY -6) (("1" (INST? -1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (REWRITE "mod_mult_quot") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REWRITE "mod_mult_quot") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (LEMMA "mod_int_quot") (("2" (REWRITE -1 1) (("2" (REWRITE "mod_int_quot" 1) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int_quot") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (HIDE 2) (("4" (REWRITE "mod_int_quot" 1) (("4" (REWRITE "mod_int_quot" 1) NIL NIL)) NIL)) NIL) ("5" (LEMMA "mod_int_quot") (("5" (INST?) (("5" (ASSERT) NIL NIL)) NIL)) NIL) ("6" (REWRITE "mod_int_quot" 1) NIL NIL) ("7" (REWRITE "mod_int_quot" 1) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (COPY -6) (("2" (INST? -1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT 1) (("1" (REWRITE "mod_mult_quot") (("1" (ASSERT) (("1" (REWRITE "mod_eq_lem_alt") NIL NIL)) NIL)) NIL) ("2" (REWRITE "mod_mult_quot" 1) (("2" (ASSERT) (("2" (REWRITE "mod_eq_lem_alt") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) (("2" (LEMMA "mod_pos") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (LEMMA "mod_int_quot") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("4" (HIDE 2) (("4" (LEMMA "mod_pos") (("4" (INST?) (("1" (ASSERT) NIL NIL) ("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE 2) (("5" (LEMMA "mod_int_quot") (("5" (INST?) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("6" (REWRITE "mod_int_quot") (("6" (LEMMA "mod_pos") (("6" (INST?) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("7" (REWRITE "mod_int_quot") (("7" (LEMMA "mod_pos") (("7" (INST?) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (COPY -6) (("3" (INST? -1) (("1" (ASSERT) (("1" (HIDE 2) (("1" (SPLIT) (("1" (REWRITE "mod_mult_quot") (("1" (LEMMA "mod_sum") (("1" (INST - "mod(i,rows(C))" "rows(C)" "mod((i - mod(i, rows(C))) / rows(C), rows(B))") (("1" (REPLACES -1) (("1" (LEMMA "mod_of_mod") (("1" (INST - "0" "i" "rows(C)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "mod_mult_quot") (("2" (LEMMA "mod_sum") (("2" (INST - "mod(j,columns(C))" "columns(C)" "mod((j - mod(j, columns(C))) / columns(C), columns(B))") (("1" (REPLACES -1) (("1" (LEMMA "mod_of_mod") (("1" (INST - "0" "j" "columns(C)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST?) (("4" (ASSERT) NIL NIL)) NIL)) NIL) ("5" (LEMMA "mod_pos") (("5" (INST?) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE 2) (("4" (LEMMA "mod_pos") (("4" (INST?) (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (LEMMA "mod_pos") (("5" (INST?) (("5" (ASSERT) NIL NIL)) NIL)) NIL) ("6" (LEMMA "mod_pos") (("6" (INST?) (("1" (ASSERT) NIL NIL) ("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (LEMMA "mod_pos") (("7" (INST?) (("1" (ASSERT) NIL NIL) ("2" (LEMMA "mod_int_quot") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("8" (LEMMA "mod_int_quot") (("8" (INST?) (("8" (LEMMA "mod_int_quot") (("8" (INST?) NIL NIL)) NIL)) NIL)) NIL) ("9" (ASSERT) (("9" (LEMMA "mod_int_quot") (("9" (INST?) (("9" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("10" (REWRITE "mod_int_quot") (("10" (REWRITE "mod_int_quot") NIL NIL)) NIL) ("11" (LEMMA "mod_int_quot") (("11" (INST?) (("11" (ASSERT) NIL NIL)) NIL)) NIL) ("12" (HIDE 2) (("12" (LEMMA "mod_pos") (("12" (INST?) (("12" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("13" (HIDE 2) (("13" (LEMMA "mod_pos") (("13" (INST?) (("13" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("14" (HIDE 2) (("14" (REWRITE "mod_int_quot") (("14" (LEMMA "mod_pos") (("14" (INST?) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("15" (HIDE 2) (("15" (REWRITE "mod_int_quot") (("15" (LEMMA "mod_pos") (("15" (INST?) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("16" (HIDE 2) (("16" (REWRITE "mod_int_quot") NIL NIL)) NIL) ("17" (HIDE 2) (("17" (REWRITE "mod_int_quot") NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (CROSS-MULT 1) (("3" (LEMMA "mod_pos") (("3" (INST?) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE 1) (("4" (LEMMA "mod_pos") (("4" (INST - "j" "columns(B)*columns(C)") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("5" (HIDE 1) (("5" (LEMMA "mod_pos") (("5" (HIDE-ALL-BUT (-1 1)) (("5" (INST?) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (LEMMA "posreal_times_posreal_is_posreal") (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|full_matrix_eq| FORMULA-DECL NIL |matrices| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|mod_of_mod| FORMULA-DECL NIL |mod| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|mod_sum| FORMULA-DECL NIL |mod| NIL) (|mod_eq_lem_alt| FORMULA-DECL NIL |tensor_product| NIL) (NIL APPLICATION-JUDGEMENT "below(m)" |mod| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|mod_mult_quot| FORMULA-DECL NIL |mod_lems| |ints|) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|mod_int_quot| FORMULA-DECL NIL |mod_lems| |ints|) (|j| SKOLEM-CONST-DECL "below(columns(tensor_prod(A, tensor_prod(B, C))))" |tensor_product| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (A SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (B SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (C SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|i| SKOLEM-CONST-DECL "below(rows(tensor_prod(A, tensor_prod(B, C))))" |tensor_product| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|posreal_times_posreal_is_posreal| JUDGEMENT-TCC NIL |real_types| NIL) (|rat_minus_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|entry_tensor_prod| FORMULA-DECL NIL |tensor_product| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)) SHOSTAK)) (|power_assoc| 0 (|power_assoc-2| "" 3790097772 ("" (CASE "FORALL (A: PosFullMatrix, k,i:nat):i<=k IMPLIES
        tensor_power(A, i+1) = tensor_power_alt(A, i+1)") (("1" (SKEEP) (("1" (INST - "A" "n-1" "n-1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (ASSERT) (("1" (SKEEP) (("1" (CASE "NOT i = 0") (("1" (ASSERT) NIL NIL) ("2" (REPLACES -1) (("2" (ASSERT) (("2" (HIDE -1) (("2" (EXPAND "tensor_power") (("2" (EXPAND "tensor_power_alt") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE "j = 0") (("1" (ASSERT) (("1" (SKEEP) (("1" (CASE "i = 0") (("1" (INST - "A" "0") (("1" (ASSERT) NIL NIL)) NIL) ("2" (CASE "NOT i = 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE -1) (("2" (ASSERT) (("2" (INST - "A" "0") (("2" (ASSERT) (("2" (HIDE (-1 -2)) (("2" (HIDE 1) (("2" (EXPAND "tensor_power_alt") (("2" (EXPAND "tensor_power_alt") (("2" (EXPAND "tensor_power") (("2" (EXPAND "tensor_power") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE "NOT i = j+1") (("1" (ASSERT) (("1" (INST - "A" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1) (("2" (ASSERT) (("2" (EXPAND "tensor_power" +) (("2" (INST-CP - "A" "j") (("2" (ASSERT) (("2" (REPLACE -3 +) (("2" (EXPAND "tensor_power_alt" + 1) (("2" (INST-CP - "A" "j-1") (("2" (ASSERT) (("2" (REPLACE -3 + :DIR RL) (("2" (EXPAND "tensor_power_alt" +) (("2" (REPLACE -4 + :DIR RL) (("2" (EXPAND "tensor_power" + 2) (("2" (REWRITE "tensor_prod_assoc") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|tensor_prod_assoc| FORMULA-DECL NIL |tensor_product| NIL) (|odd_plus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|tensor_power_alt| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|tensor_power| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) SHOSTAK) (|power_assoc-1| |nil| 3618676254 ("" (CASE "FORALL (A: PosFullMatrix, k,i:nat):i<=k IMPLIES
        tensor_power(A, i+1) = tensor_power_alt(A, i+1)") (("1" (SKEEP) (("1" (INST - "A" "n-1" "n-1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (ASSERT) (("1" (SKEEP) (("1" (CASE "NOT i = 0") (("1" (ASSERT) NIL NIL) ("2" (REPLACES -1) (("2" (ASSERT) (("2" (ASSERT) (("2" (HIDE -1) (("2" (EXPAND "tensor_power") (("2" (EXPAND "tensor_power_alt") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE "j = 0") (("1" (ASSERT) (("1" (SKEEP) (("1" (CASE "i = 0") (("1" (INST - "A" "0") (("1" (ASSERT) NIL NIL)) NIL) ("2" (CASE "NOT i = 1") (("1" (ASSERT) NIL NIL) ("2" (REPLACE -1) (("2" (ASSERT) (("2" (INST - "A" "0") (("2" (ASSERT) (("2" (HIDE (-1 -2)) (("2" (HIDE 1) (("2" (EXPAND "tensor_power_alt") (("2" (EXPAND "tensor_power_alt") (("2" (EXPAND "tensor_power") (("2" (EXPAND "tensor_power") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE "NOT i = j+1") (("1" (ASSERT) (("1" (INST - "A" "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACE -1) (("2" (ASSERT) (("2" (EXPAND "tensor_power" +) (("2" (INST-CP - "A" "j") (("2" (ASSERT) (("2" (REPLACE -3 +) (("2" (EXPAND "tensor_power_alt" + 1) (("2" (INST-CP - "A" "j-1") (("2" (ASSERT) (("2" (REPLACE -3 + :DIR RL) (("2" (EXPAND "tensor_power_alt" +) (("2" (REPLACE -4 + :DIR RL) (("2" (EXPAND "tensor_power" + 2) (("2" (REWRITE "tensor_prod_assoc") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|tensor_power_rows_alt| 0 (|tensor_power_rows_alt-1| |nil| 3618751580 ("" (SKEEP) (("" (LEMMA "power_assoc" ("A" "A" "n" "n")) (("" (REPLACE -1 :DIR RL) (("" (REWRITE "tensor_power_rows") NIL NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|power_assoc| FORMULA-DECL NIL |tensor_product| NIL) (|tensor_power_rows| FORMULA-DECL NIL |tensor_product| NIL)) SHOSTAK)) (|tensor_power_columns_alt| 0 (|tensor_power_columns_alt-1| |nil| 3618751702 ("" (SKEEP) (("" (LEMMA "power_assoc" ("A" "A" "n" "n")) (("" (REPLACE -1 :DIR RL) (("" (REWRITE "tensor_power_columns") NIL NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|power_assoc| FORMULA-DECL NIL |tensor_product| NIL) (|tensor_power_columns| FORMULA-DECL NIL |tensor_product| NIL)) SHOSTAK)) (TQXL_TCC1 0 (TQXL_TCC1-1 |nil| 3618049647 ("" (EVAL-FORMULA) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (TQXL SUBTYPE "(: (: 1, 1, 1, 0, 0, 0 :), (: 0, 1, -1, 0, 0, 0 :), (: 0, 1, 1, 0, 0, 0 :), (: 0, -1, -1, 1, 0, 0 :), (: -1, -1, 0, 0, 1, 0 :), (: -1, 0, -1, 0, 0, 1 :) :)" "Square"))) (|TQXLinv_TCC1| 0 (|TQXLinv_TCC1-1| |nil| 3618049647 ("" (EVAL-FORMULA) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|TQXLinv| SUBTYPE "(: (: 1, 0, -1, 0, 0, 0 :), (: 0, number_fields./(1, 2), number_fields./(1, 2), 0, 0, 0 :), (: 0, number_fields./(-1, 2), number_fields./(1, 2), 0, 0, 0 :), (: 0, 0, 1, 1, 0, 0 :), (: 1, number_fields./(1, 2), number_fields./(-1, 2), 0, 1, 0 :), (: 1, number_fields./(-1, 2), number_fields./(-1, 2), 0, 0, 1 :) :)" "Square"))) (|invTQXL| 0 (|invTQXL-1| |nil| 3618050460 ("" (SPLIT) (("1" (EXPAND "invertible?") (("1" (INST 1 "TQXLinv") (("1" (EVAL-FORMULA) NIL NIL)) NIL)) NIL) ("2" (EXPAND "invertible?") (("2" (INST 1 "TQXL") (("2" (EVAL-FORMULA) NIL NIL)) NIL)) NIL)) NIL) ((TQXL CONST-DECL "Square" |tensor_product| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|TQXLinv| CONST-DECL "Square" |tensor_product| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (|is_invTQXL_TCC1| 0 (|is_invTQXL_TCC1-1| |nil| 3618049647 ("" (LEMMA "invTQXL") (("" (GROUND) NIL NIL)) NIL) ((|invTQXL| FORMULA-DECL NIL |tensor_product| NIL)) NIL (|is_invTQXL| SUBTYPE "tensor_product.TQXL" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|is_invTQXL_TCC2| 0 (|is_invTQXL_TCC2-1| |nil| 3618049647 ("" (FLATTEN) (("" (LEMMA "invTQXL") (("" (GROUND) NIL NIL)) NIL)) NIL) ((|invTQXL| FORMULA-DECL NIL |tensor_product| NIL)) NIL (|is_invTQXL| SUBTYPE "tensor_product.TQXLinv" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|is_invTQXL| 0 (|is_invTQXL-1| |nil| 3618050673 ("" (EVAL-FORMULA) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) SHOSTAK)) (|RowToMat_TCC1| 0 (|RowToMat_TCC1-2| "" 3883690382 ("" (SKEEP) (("" (SPLIT) (("1" (FLATTEN) (("1" (CASE "length[list[real]]((: row(M)(k) :)) = 1") (("1" (SKEEP) (("1" (CASE-REPLACE "i=0") (("1" (CASE-REPLACE "j=0") (("1" (TYPEPRED ("j")) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED ("i")) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL) ("2" (GROUND) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (CASE-REPLACE "columns((: row(M)(k) :)) = columns(M)") (("1" (TYPEPRED ("M")) (("1" (PROPAX) NIL NIL)) NIL) ("2" (LEMMA "matrices.length_row") (("2" (INST-CP -1 "M" "k") (("2" (SPLIT -2) (("1" (REPLACE -1 :DIR RL) (("1" (INST -2 "(: row(M)(k) :)" "0") (("1" (SPLIT -2) (("1" (CASE-REPLACE "row((: row(M)(k) :))(0) = row(M)(k)") (("1" (REPLACE -2 :DIR RL) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (CASE-REPLACE "length[list[real]]((: row(M)(k) :)) = 1") (("1" (SKEEP) (("1" (CASE-REPLACE "i=0") (("1" (CASE-REPLACE "j=0") (("1" (TYPEPRED ("j")) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED ("i")) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("k")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|RowToMat| SUBTYPE "(: matrices.row(tensor_product.M)(tensor_product.k) :)" "PosFullMatrix")) (|RowToMat_TCC1-1| |nil| 3618069795 ("" (SKEEP) (("" (SPLIT) (("1" (FLATTEN) (("1" (CASE "length[list[real]]((: row(M)(k) :)) = 1") (("1" (SKEEP) (("1" (CASE-REPLACE "i=0") (("1" (CASE-REPLACE "j=0") (("1" (TYPEPRED (J)) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED (I)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL) ("2" (GROUND) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL) ("3" (CASE-REPLACE "columns((: row(M)(k) :)) = columns(M)") (("1" (TYPEPRED (M)) (("1" (PROPAX) NIL NIL)) NIL) ("2" (LEMMA "matrices.length_row") (("2" (INST-CP -1 "M" "k") (("2" (SPLIT -2) (("1" (REPLACE -1 :DIR RL) (("1" (INST -2 "(: row(M)(k) :)" "0") (("1" (SPLIT -2) (("1" (CASE-REPLACE "row((: row(M)(k) :))(0) = row(M)(k)") (("1" (REPLACE -2 :DIR RL) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (CASE-REPLACE "length[list[real]]((: row(M)(k) :)) = 1") (("1" (SKEEP) (("1" (CASE-REPLACE "i=0") (("1" (CASE-REPLACE "j=0") (("1" (TYPEPRED (J)) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED (I)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (K)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|length_row| FORMULA-DECL NIL |matrices| NIL) (|k| SKOLEM-CONST-DECL "below(rows(M))" |tensor_product| NIL) (M SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) NIL (|RowToMat| SUBTYPE "(: matrices.row(tensor_product.M)(tensor_product.k) :)" "PosFullMatrix"))) (|RtM| 0 (|RtM-1| |nil| 3621071529 ("" (SKEEP) (("" (EXPAND "RowToMat") (("" (EXPAND "row2mat") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ((|RowToMat| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|row2mat| CONST-DECL "PosFullMatrix" |linear_dependence| NIL)) SHOSTAK)) (|RowToMat_rows| 0 (|RowToMat_rows-1| |nil| 3618157882 ("" (SKEEP) (("" (EXPAND "RowToMat") (("" (GROUND) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|RowToMat| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL)) SHOSTAK)) (|RowToMat_columns| 0 (|RowToMat_columns-2| "" 3883690418 ("" (SKEEP) (("" (TYPEPRED ("k")) (("" (GRIND) (("" (LEMMA "matrices.length_row") (("" (INST -1 "M" "k") (("" (SPLIT -1) (("1" (EXPAND "row") (("1" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|RowToMat_columns-1| |nil| 3618157905 ("" (SKEEP) (("" (TYPEPRED (K)) (("" (GRIND) (("" (LEMMA "matrices.length_row") (("" (INST -1 "M" "k") (("" (SPLIT -1) (("1" (EXPAND "row") (("1" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (< CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|length_row| FORMULA-DECL NIL |matrices| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|RowToMat| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|row| CONST-DECL "Vector" |matrices| NIL)) SHOSTAK)) (|RowToMat_entry| 0 (|RowToMat_entry-2| "" 3883690610 ("" (SKEEP) (("" (EXPAND "entry") (("" (EXPAND "access") (("" (LEMMA "RowToMat_columns") (("" (LEMMA "RowToMat_rows") (("" (INST -2 "M" "k") (("" (LIFT-IF 1) (("" (LIFT-IF 1) (("" (LIFT-IF 1) (("" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (NAME-REPLACE "RK" "row(M)(k)") (("1" (EXPAND "RowToMat") (("1" (EXPAND "row") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) (("2" (TYPEPRED ("k")) (("2" (GROUND) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "nth((: nth(M, k) :), 0) = nth(M,k)") (("1" (EXPAND "RK") (("1" (EXPAND "row") (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED ("n")) (("2" (NAME-REPLACE "NMK" "nth(M, k)") (("2" (EXPAND "nth") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "length_row" -1) (("1" (REWRITE "length_row" 1) (("1" (GROUND) NIL NIL) ("2" (TYPEPRED ("k")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST?) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (REWRITE "length_row" 2) (("1" (REWRITE "length_row" -1) (("1" (GROUND) NIL NIL)) NIL) ("2" (INST?) (("2" (GROUND) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|RowToMat_entry-1| |nil| 3618668435 ("" (SKEEP) (("" (EXPAND "entry") (("" (EXPAND "access") (("" (LEMMA "RowToMat_columns") (("" (LEMMA "RowToMat_rows") (("" (INST -2 "M" "k") (("" (LIFT-IF 1) (("" (LIFT-IF 1) (("" (LIFT-IF 1) (("" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (NAME-REPLACE "RK" "row(M)(k)") (("1" (EXPAND "RowToMat") (("1" (EXPAND "row") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) (("2" (TYPEPRED (K)) (("2" (GROUND) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "nth((: nth(M, k) :), 0) = nth(M,k)") (("1" (EXPAND "RK") (("1" (EXPAND "row") (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (NAME-REPLACE "NMK" "nth(M, k)") (("2" (EXPAND "nth") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "length_row" -1) (("1" (REWRITE "length_row" 1) (("1" (GROUND) NIL NIL) ("2" (TYPEPRED (K)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST?) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (REWRITE "length_row" 2) (("1" (REWRITE "length_row" -1) (("1" (GROUND) NIL NIL)) NIL) ("2" (INST?) (("2" (GROUND) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|entry| CONST-DECL "real" |matrices| NIL) (|RowToMat_columns| FORMULA-DECL NIL |tensor_product| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (RK SKOLEM-CONST-DECL "Vector" |tensor_product| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|RowToMat| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|length_row| FORMULA-DECL NIL |matrices| NIL) (|RowToMat_rows| FORMULA-DECL NIL |tensor_product| NIL) (|access| CONST-DECL "real" |matrices| NIL)) SHOSTAK)) (|RowToMat_tensor_prod_TCC1| 0 (|RowToMat_tensor_prod_TCC1-1| |nil| 3618142292 ("" (SKEEP) (("" (REWRITE "tensor_rows") (("" (GROUND) NIL NIL)) NIL)) NIL) ((|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|RowToMat_tensor_prod| SUBTYPE "tensor_product.k" "below(matrices.rows(tensor_product.tensor_prod(tensor_product.M, tensor_product.N)))"))) (|RowToMat_tensor_prod_TCC2| 0 (|RowToMat_tensor_prod_TCC2-1| |nil| 3618142292 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|RowToMat_tensor_prod| SUBTYPE "matrices.rows(tensor_product.N)" "nonzero_integer"))) (|RowToMat_tensor_prod_TCC3| 0 (|RowToMat_tensor_prod_TCC3-2| "" 3883690632 ("" (SKEEP) (("" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("" (PROP) (("" (CROSS-MULT 1) (("" (TYPEPRED ("k")) (("" (LEMMA "mod_pos") (("" (INST?) (("" (FLATTEN) (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|RowToMat_tensor_prod| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.k, mod.mod(tensor_product.k, matrices.rows(tensor_product.N)))), matrices.rows(tensor_product.N))" "below(matrices.rows(tensor_product.M))")) (|RowToMat_tensor_prod_TCC3-1| |nil| 3618142292 ("" (SKEEP) (("" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("" (PROP) (("" (CROSS-MULT 1) (("" (TYPEPRED (K)) (("" (LEMMA "mod_pos") (("" (INST?) (("" (FLATTEN) (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|mod_int| FORMULA-DECL NIL |tensor_product| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)) NIL (|RowToMat_tensor_prod| SUBTYPE "number_fields./(((number_fields.-)(tensor_product.k, mod.mod(tensor_product.k, matrices.rows(tensor_product.N)))), matrices.rows(tensor_product.N))" "below(matrices.rows(tensor_product.M))"))) (|RowToMat_tensor_prod_TCC4| 0 (|RowToMat_tensor_prod_TCC4-1| |nil| 3618142292 ("" (SKEEP) (("" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("" (PROPAX) NIL NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|RowToMat_tensor_prod| SUBTYPE "mod.mod(tensor_product.k, matrices.rows(tensor_product.N))" "below(matrices.rows(tensor_product.N))"))) (|RowToMat_tensor_prod| 0 (|RowToMat_tensor_prod-3| "" 3883692951 ("" (SKEEP) (("" (LEMMA "more_list_props[list[real]].list_extensionality") (("" (INST?) (("1" (FLATTEN) (("1" (HIDE -1) (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "tensor_rows") (("2" (INST -1 "RowToMat(M, (k - mod(k, rows(N))) / rows(N))" "
                          RowToMat(N, mod(k, rows(N)))") (("1" (EXPAND "rows") (("1" (REPLACE -1) (("1" (CASE "FORALL (A:PosFullMatrix, kk:below(rows(A))): length(RowToMat(A, kk))=1") (("1" (INST-CP -1 "tensor_prod(M, N)" " k") (("1" (INST-CP -1 "M" " (k - mod(k, length(N))) / length(N)") (("1" (INST -1 "N" " mod(k, length(N))") (("1" (GROUND) NIL NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (TYPEPRED ("N")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED ("n")) (("3" (CASE-REPLACE "length(RowToMat(tensor_prod(M, N), k))=1") (("1" (CASE-REPLACE "n=0") (("1" (EXPAND "nth") (("1" (CASE "FORALL(A:PosFullMatrix, kk:below(rows(A))): rows(RowToMat(A, kk)) = 1") (("1" (CASE "rows(tensor_prod(RowToMat(M, (k - mod(k, rows(N))) / rows(N)),
                       RowToMat(N, mod(k, rows(N))))) = 1") (("1" (HIDE 2) (("1" (INST -2 "tensor_prod(M,N)" "k") (("1" (EXPAND "rows") (("1" (LEMMA "more_list_props[real].list_extensionality") (("1" (INST?) (("1" (FLATTEN) (("1" (HIDE -1) (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (LEMMA "tensor_cols") (("2" (INST -1 "RowToMat(M,
                                       (k - mod(k, length(N)))
                                       /
                                       length(N))" "
                              RowToMat(N, mod(k, length(N)))") (("1" (CASE-REPLACE "length(car(RowToMat(tensor_prod(M, N), k))) = columns(RowToMat(tensor_prod(M, N), k))") (("1" (REWRITE "RowToMat_columns") (("1" (REWRITE "RowToMat_columns") (("1" (REWRITE "RowToMat_columns") (("1" (CASE "FORALL (A:PosFullMatrix, kk:below(rows(A))): length(car(A)) = columns(A)") (("1" (INST -1 "tensor_prod(RowToMat(M,
                                       (k - mod(k, length(N)))
                                       /
                                       length(N)),
                              RowToMat(N, mod(k, length(N))))" "0") (("1" (REPLACE -1) (("1" (REPLACE -3) (("1" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (LEMMA "mod_pos" ("i" "k" "m" "length[list[real]](N)")) (("1" (TYPEPRED ("n")) (("1" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED ("N")) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "k" "n" "length[list[real]](N)")) (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "matrices.length_row") (("2" (INST -1 "A" "0") (("2" (SPLIT -1) (("1" (REPLACE -1 :DIR RL) (("1" (EXPAND "row") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) (("2" (EXPAND "nth") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED ("A")) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED ("A")) (("3" (GROUND) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "length[list[real]](N)")) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("N")) (("2" (GROUND) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "length[list[real]](N)")) (("1" (PROPAX) NIL NIL) ("2" (TYPEPRED ("N")) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 2)) (("2" (EXPAND "columns") (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "RowToMat") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "RowToMat") (("2" (EXPAND "columns") (("2" (EXPAND "max") (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (CASE "FORALL (A:PosFullMatrix, n:below(columns(A))): 
             nth(car(A), n) = entry(A)(0,n)") (("1" (CASE "FORALL (A:PosFullMatrix): columns(A) = length(car(A))") (("1" (INST-CP -2 "RowToMat(tensor_prod(M, N), k)" " n!1") (("1" (INST-CP -2 "tensor_prod(RowToMat(M,
                                    (k - mod(k, length(N))) / length(N)),
                           RowToMat(N, mod(k, length(N))))" "
           n!1") (("1" (REPLACE -3) (("1" (REPLACE -4) (("1" (HIDE 2) (("1" (REWRITE "RowToMat_entry") (("1" (HIDE (-3 -4 -6 -7 -8 -9)) (("1" (EXPAND "tensor_prod") (("1" (REWRITE "entry_form_matrix2") (("1" (LEMMA "mod_pos" ("i" "k" "m" "length(N)")) (("1" (LEMMA "mod_int" ("k" "k" "n" "length(N)")) (("1" (REWRITE "entry_form_matrix2") (("1" (EXPAND "tensor_fun") (("1" (CASE-REPLACE "(n!1<columns(M)*columns(N)) = TRUE") (("1" (CASE-REPLACE "(0 <
           rows(RowToMat(M, (k - mod(k, length(N))) / length(N))) *
            rows(RowToMat(N, mod(k, length(N))))) = TRUE") (("1" (CASE-REPLACE "(n!1 <
           columns(RowToMat(M, (k - mod(k, length(N))) / length(N))) *
            columns(RowToMat(N, mod(k, length(N))))) = TRUE") (("1" (REWRITE "mod_zero") (("1" (REWRITE "RowToMat_columns" 1) (("1" (CASE-REPLACE "-1 * 0 / rows(RowToMat(N, mod(k, length(N)))) = 0") (("1" (REWRITE "RowToMat_entry") (("1" (REWRITE "RowToMat_entry") (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "n!1" "m" "columns(N)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "n!1" "n" "columns(N)")) (("2" (LEMMA "mod_int" ("k" "n!1" "n" "columns(N)")) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos" ("i" "n!1" "m" "columns(N)")) (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (REWRITE "RowToMat_columns" 1) (("2" (REWRITE "RowToMat_columns" 1) NIL NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED "RowToMat(M, (k - mod(k, length(N))) / length(N))") (("2" (TYPEPRED "RowToMat(N, mod(k, length(N)))") (("2" (MULT-INEQ -7 -3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (HIDE (-5 2)) (("2" (TYPEPRED ("n!1")) (("2" (INST -4 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -4 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "RowToMat_columns") (("2" (TYPEPRED ("n!1")) (("2" (INST -4 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -4 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("N")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("n!1")) (("2" (INST -2 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("n!1")) (("2" (INST -2 "RowToMat(tensor_prod(M,N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns" -1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("n!1")) (("2" (INST -2 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns" -1) (("2" (HIDE (2 3)) (("2" (REWRITE "tensor_cols" 1) (("1" (REWRITE "RowToMat_columns" 1) (("1" (REWRITE "RowToMat_columns" 1) (("1" (REWRITE "tensor_cols" -1) NIL NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("N")) (("2" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST?) (("2" (TYPEPRED ("N")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("N")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int") (("3" (INST?) (("3" (TYPEPRED ("N")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("N")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (LEMMA "mod_int") (("4" (INST?) (("4" (TYPEPRED ("N")) (("4" (EXPAND "rows") (("4" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED ("n!1")) (("2" (INST?) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (LEMMA "columns_mn") (("2" (INST -1 "rows(A)" "length(car(A))" "A") (("2" (TYPEPRED ("A")) (("2" (SPLIT 1) (("1" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -2) (("1" (GRIND) NIL NIL) ("2" (INST -1 "_" "0") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (TYPEPRED ("A")) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (2 3)) (("2" (HIDE -) (("2" (SKEEP) (("2" (EXPAND "entry") (("2" (EXPAND "row") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED ("A")) (("1" (GROUND) (("1" (GRIND) NIL NIL) ("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "access") (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED ("n!2")) (("2" (GROUND) (("2" (GRIND) (("2" (LEMMA "columns_mn") (("2" (INST -1 "rows(A)" "length(car(A))" "A") (("1" (GROUND) NIL NIL) ("2" (TYPEPRED ("A")) (("2" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (INST -1 "_" "0") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (TYPEPRED ("A")) (("3" (TYPEPRED ("n!2")) (("3" (LEMMA "columns_mn") (("3" (INST -1 "rows(A)" "length(car(A))" "A") (("1" (CASE-REPLACE "length[real](car[list[real]](A)) = length(car(A))") (("1" (GROUND) NIL NIL)) NIL) ("2" (SPLIT 1) (("1" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -3) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -1 "_" "0") (("1" (EXPAND "nth") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (GROUND) (("4" (HIDE (2 3)) (("4" (HIDE (-1 -2 -4)) (("4" (GRIND) (("4" (TYPEPRED ("A")) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "tensor_rows") (("2" (INST-CP -1 "M" " (k - mod(k, rows(N))) / rows(N)") (("1" (INST -1 "N" " mod(k, rows(N))") (("1" (GROUND) NIL NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("3" (FLATTEN) NIL NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("4" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 3)) (("2" (GROUND) (("2" (EXPAND "RowToMat") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|RowToMat_tensor_prod-2| "" 3750609144 ("" (SKEEP) (("" (LEMMA "more_list_props[list[real]].list_extensionality") (("" (INST?) (("1" (FLATTEN) (("1" (HIDE -1) (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "tensor_rows") (("2" (INST -1 "RowToMat(M, (k - mod(k, rows(N))) / rows(N))" "
                          RowToMat(N, mod(k, rows(N)))") (("1" (EXPAND "rows") (("1" (REPLACE -1) (("1" (CASE "FORALL (A:PosFullMatrix, kk:below(rows(A))): length(RowToMat(A, kk))=1") (("1" (INST-CP -1 "tensor_prod(M, N)" " k") (("1" (INST-CP -1 "M" " (k - mod(k, length(N))) / length(N)") (("1" (INST -1 "N" " mod(k, length(N))") (("1" (GROUND) NIL NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (N)) (("3" (CASE-REPLACE "length(RowToMat(tensor_prod(M, N), k))=1") (("1" (CASE-REPLACE "n=0") (("1" (EXPAND "nth") (("1" (CASE "FORALL(A:PosFullMatrix, kk:below(rows(A))): rows(RowToMat(A, kk)) = 1") (("1" (CASE "rows(tensor_prod(RowToMat(M, (k - mod(k, rows(N))) / rows(N)),
                       RowToMat(N, mod(k, rows(N))))) = 1") (("1" (HIDE 2) (("1" (INST -2 "tensor_prod(M,N)" "k") (("1" (EXPAND "rows") (("1" (LEMMA "more_list_props[real].list_extensionality") (("1" (INST?) (("1" (FLATTEN) (("1" (HIDE -1) (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (LEMMA "tensor_cols") (("2" (INST -1 "RowToMat(M,
                                       (k - mod(k, length(N)))
                                       /
                                       length(N))" "
                              RowToMat(N, mod(k, length(N)))") (("1" (CASE-REPLACE "length(car(RowToMat(tensor_prod(M, N), k))) = columns(RowToMat(tensor_prod(M, N), k))") (("1" (REWRITE "RowToMat_columns") (("1" (REWRITE "RowToMat_columns") (("1" (REWRITE "RowToMat_columns") (("1" (CASE "FORALL (A:PosFullMatrix, kk:below(rows(A))): length(car(A)) = columns(A)") (("1" (INST -1 "tensor_prod(RowToMat(M,
                                       (k - mod(k, length(N)))
                                       /
                                       length(N)),
                              RowToMat(N, mod(k, length(N))))" "0") (("1" (REPLACE -1) (("1" (REPLACE -3) (("1" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (LEMMA "mod_pos" ("i" "k" "m" "length[list[real]](N)")) (("1" (TYPEPRED (N)) (("1" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "k" "n" "length[list[real]](N)")) (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "matrices.length_row") (("2" (INST -1 "A" "0") (("2" (SPLIT -1) (("1" (REPLACE -1 :DIR RL) (("1" (EXPAND "row") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) (("2" (EXPAND "nth") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED (A)) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (A)) (("3" (GROUND) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "length[list[real]](N)")) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (GROUND) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "length[list[real]](N)")) (("1" (PROPAX) NIL NIL) ("2" (TYPEPRED (N)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 2)) (("2" (EXPAND "columns") (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "RowToMat") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "RowToMat") (("2" (EXPAND "columns") (("2" (EXPAND "max") (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (CASE "FORALL (A:PosFullMatrix, n:below(columns(A))): 
             nth(car(A), n) = entry(A)(0,n)") (("1" (CASE "FORALL (A:PosFullMatrix): columns(A) = length(car(A))") (("1" (INST-CP -2 "RowToMat(tensor_prod(M, N), k)" " n!1") (("1" (INST-CP -2 "tensor_prod(RowToMat(M,
                                    (k - mod(k, length(N))) / length(N)),
                           RowToMat(N, mod(k, length(N))))" "
           n!1") (("1" (REPLACE -3) (("1" (REPLACE -4) (("1" (HIDE 2) (("1" (REWRITE "RowToMat_entry") (("1" (HIDE (-3 -4 -6 -7 -8 -9)) (("1" (EXPAND "tensor_prod") (("1" (REWRITE "entry_form_matrix2") (("1" (LEMMA "mod_pos" ("i" "k" "m" "length(N)")) (("1" (LEMMA "mod_int" ("k" "k" "n" "length(N)")) (("1" (REWRITE "entry_form_matrix2") (("1" (EXPAND "tensor_fun") (("1" (CASE-REPLACE "(n!1<columns(M)*columns(N)) = TRUE") (("1" (CASE-REPLACE "(0 <
           rows(RowToMat(M, (k - mod(k, length(N))) / length(N))) *
            rows(RowToMat(N, mod(k, length(N))))) = TRUE") (("1" (CASE-REPLACE "(n!1 <
           columns(RowToMat(M, (k - mod(k, length(N))) / length(N))) *
            columns(RowToMat(N, mod(k, length(N))))) = TRUE") (("1" (REWRITE "mod_zero") (("1" (REWRITE "RowToMat_columns" 1) (("1" (CASE-REPLACE "-1 * 0 / rows(RowToMat(N, mod(k, length(N)))) = 0") (("1" (REWRITE "RowToMat_entry") (("1" (REWRITE "RowToMat_entry") (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "n!1" "m" "columns(N)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "n!1" "n" "columns(N)")) (("2" (LEMMA "mod_int" ("k" "n!1" "n" "columns(N)")) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos" ("i" "n!1" "m" "columns(N)")) (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (REWRITE "RowToMat_columns" 1) (("2" (REWRITE "RowToMat_columns" 1) NIL NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED "RowToMat(M, (k - mod(k, length(N))) / length(N))") (("2" (TYPEPRED "RowToMat(N, mod(k, length(N)))") (("2" (MULT-INEQ -7 -3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (HIDE (-5 2)) (("2" (TYPEPRED (N!1)) (("2" (INST -4 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -4 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "RowToMat_columns") (("2" (TYPEPRED (N!1)) (("2" (INST -4 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -4 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST -2 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST -2 "RowToMat(tensor_prod(M,N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns" -1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST -2 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns" -1) (("2" (HIDE (2 3)) (("2" (REWRITE "tensor_cols" 1) (("1" (REWRITE "RowToMat_columns" 1) (("1" (REWRITE "RowToMat_columns" 1) (("1" (REWRITE "tensor_cols" -1) NIL NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST?) (("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int") (("3" (INST?) (("3" (TYPEPRED (N)) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (LEMMA "mod_int") (("4" (INST?) (("4" (TYPEPRED (N)) (("4" (EXPAND "rows") (("4" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST?) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (LEMMA "columns_mn") (("2" (INST -1 "rows(A)" "length(car(A))" "A") (("2" (TYPEPRED (A)) (("2" (SPLIT 1) (("1" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -2) (("1" (GRIND) NIL NIL) ("2" (INST -1 "_" "0") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (TYPEPRED (A)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (2 3)) (("2" (HIDE -) (("2" (SKEEP) (("2" (EXPAND "entry") (("2" (EXPAND "row") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED (A)) (("1" (GROUND) (("1" (GRIND) NIL NIL) ("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "access") (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED (N!2)) (("2" (GROUND) (("2" (GRIND) (("2" (LEMMA "columns_mn") (("2" (INST -1 "rows(A)" "length(car(A))" "A") (("1" (GROUND) NIL NIL) ("2" (TYPEPRED (A)) (("2" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (INST -1 "_" "0") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (TYPEPRED (A)) (("3" (TYPEPRED (N!2)) (("3" (LEMMA "columns_mn") (("3" (INST -1 "rows(A)" "length(car(A))" "A") (("1" (CASE-REPLACE "length[real](car[list[real]](A)) = length(car(A))") (("1" (GROUND) NIL NIL)) NIL) ("2" (SPLIT 1) (("1" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -3) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -1 "_" "0") (("1" (EXPAND "nth") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (GROUND) (("4" (HIDE (2 3)) (("4" (HIDE (-1 -2 -4)) (("4" (GRIND) (("4" (TYPEPRED (A)) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "tensor_rows") (("2" (INST-CP -1 "M" " (k - mod(k, rows(N))) / rows(N)") (("1" (INST -1 "N" " mod(k, rows(N))") (("1" (GROUND) NIL NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("3" (FLATTEN) NIL NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("4" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 3)) (("2" (GROUND) (("2" (EXPAND "RowToMat") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list_extensionality| FORMULA-DECL NIL |more_list_props| |structures|) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|mod_int| FORMULA-DECL NIL |tensor_product| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|tensor_rows| FORMULA-DECL NIL |tensor_product| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (A SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|access| CONST-DECL "real" |matrices| NIL) (A SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|RowToMat_entry| FORMULA-DECL NIL |tensor_product| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|gt_times_gt_any1| FORMULA-DECL NIL |extra_real_props| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|mod_0| FORMULA-DECL NIL |mod_lems| |ints|) (|mod_zero| FORMULA-DECL NIL |mod| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|entry_form_matrix2| FORMULA-DECL NIL |matrices| NIL) (|n!1| SKOLEM-CONST-DECL "below(length(car(RowToMat(tensor_prod(M, N), k))))" |tensor_product| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (A SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|columns_mn| FORMULA-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (|RowToMat_columns| FORMULA-DECL NIL |tensor_product| NIL) (|length_row| FORMULA-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|tensor_cols| FORMULA-DECL NIL |tensor_product| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (M SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (N SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|k| SKOLEM-CONST-DECL "below(rows(M) * rows(N))" |tensor_product| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|tensor_prod| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|RowToMat| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL)) SHOSTAK) (|RowToMat_tensor_prod-1| |nil| 3618143199 ("" (SKEEP) (("" (LEMMA "more_list_props[list[real]].list_extensionality") (("" (INST?) (("1" (FLATTEN) (("1" (HIDE -1) (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "tensor_rows") (("2" (INST -1 "RowToMat(M, (k - mod(k, rows(N))) / rows(N))" "
                          RowToMat(N, mod(k, rows(N)))") (("1" (EXPAND "rows") (("1" (REPLACE -1) (("1" (CASE "FORALL (A:PosFullMatrix, kk:below(rows(A))): length(RowToMat(A, kk))=1") (("1" (INST-CP -1 "tensor_prod(M, N)" " k") (("1" (INST-CP -1 "M" " (k - mod(k, length(N))) / length(N)") (("1" (INST -1 "N" " mod(k, length(N))") (("1" (GROUND) NIL NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (N)) (("3" (CASE-REPLACE "length(RowToMat(tensor_prod(M, N), k))=1") (("1" (CASE-REPLACE "n=0") (("1" (EXPAND "nth") (("1" (CASE "FORALL(A:PosFullMatrix, kk:below(rows(A))): rows(RowToMat(A, kk)) = 1") (("1" (CASE "rows(tensor_prod(RowToMat(M, (k - mod(k, rows(N))) / rows(N)),
                       RowToMat(N, mod(k, rows(N))))) = 1") (("1" (HIDE 2) (("1" (INST -2 "tensor_prod(M,N)" "k") (("1" (EXPAND "rows") (("1" (LEMMA "more_list_props[real].list_extensionality") (("1" (INST?) (("1" (FLATTEN) (("1" (HIDE -1) (("1" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (HIDE 2) (("2" (LEMMA "tensor_cols") (("2" (INST -1 "RowToMat(M,
                                       (k - mod(k, length(N)))
                                       /
                                       length(N))" "
                              RowToMat(N, mod(k, length(N)))") (("1" (CASE-REPLACE "length(car(RowToMat(tensor_prod(M, N), k))) = columns(RowToMat(tensor_prod(M, N), k))") (("1" (REWRITE "RowToMat_columns") (("1" (REWRITE "RowToMat_columns") (("1" (REWRITE "RowToMat_columns") (("1" (CASE "FORALL (A:PosFullMatrix, kk:below(rows(A))): length(car(A)) = columns(A)") (("1" (INST -1 "tensor_prod(RowToMat(M,
                                       (k - mod(k, length(N)))
                                       /
                                       length(N)),
                              RowToMat(N, mod(k, length(N))))" "0") (("1" (REPLACE -1) (("1" (REPLACE -3) (("1" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (LEMMA "mod_pos" ("i" "k" "m" "length[list[real]](N)")) (("1" (TYPEPRED (N)) (("1" (GRIND) NIL NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "k" "n" "length[list[real]](N)")) (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "matrices.length_row") (("2" (INST -1 "A" "0") (("2" (SPLIT -1) (("1" (REPLACE -1 :DIR RL) (("1" (EXPAND "row") (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) (("2" (EXPAND "nth") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED (A)) (("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (A)) (("3" (GROUND) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "length[list[real]](N)")) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (GROUND) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "length[list[real]](N)")) (("1" (PROPAX) NIL NIL) ("2" (TYPEPRED (N)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 2)) (("2" (EXPAND "columns") (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "RowToMat") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "RowToMat") (("2" (EXPAND "columns") (("2" (EXPAND "max") (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (CASE "FORALL (A:PosFullMatrix, n:below(columns(A))): 
             nth(car(A), n) = entry(A)(0,n)") (("1" (CASE "FORALL (A:PosFullMatrix): columns(A) = length(car(A))") (("1" (INST-CP -2 "RowToMat(tensor_prod(M, N), k)" " n!1") (("1" (INST-CP -2 "tensor_prod(RowToMat(M,
                                    (k - mod(k, length(N))) / length(N)),
                           RowToMat(N, mod(k, length(N))))" "
           n!1") (("1" (REPLACE -3) (("1" (REPLACE -4) (("1" (HIDE 2) (("1" (REWRITE "RowToMat_entry") (("1" (HIDE (-3 -4 -6 -7 -8 -9)) (("1" (EXPAND "tensor_prod") (("1" (REWRITE "entry_form_matrix2") (("1" (LEMMA "mod_pos" ("i" "k" "m" "length(N)")) (("1" (LEMMA "mod_int" ("k" "k" "n" "length(N)")) (("1" (REWRITE "entry_form_matrix2") (("1" (EXPAND "tensor_fun") (("1" (CASE-REPLACE "(n!1<columns(M)*columns(N)) = TRUE") (("1" (CASE-REPLACE "(0 <
           rows(RowToMat(M, (k - mod(k, length(N))) / length(N))) *
            rows(RowToMat(N, mod(k, length(N))))) = TRUE") (("1" (CASE-REPLACE "(n!1 <
           columns(RowToMat(M, (k - mod(k, length(N))) / length(N))) *
            columns(RowToMat(N, mod(k, length(N))))) = TRUE") (("1" (REWRITE "mod_zero") (("1" (REWRITE "RowToMat_columns" 1) (("1" (CASE-REPLACE "-1 * 0 / rows(RowToMat(N, mod(k, length(N)))) = 0") (("1" (REWRITE "RowToMat_entry") (("1" (REWRITE "RowToMat_entry") (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "n!1" "m" "columns(N)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "n!1" "n" "columns(N)")) (("2" (LEMMA "mod_int" ("k" "n!1" "n" "columns(N)")) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos" ("i" "n!1" "m" "columns(N)")) (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (REWRITE "RowToMat_columns" 1) (("2" (REWRITE "RowToMat_columns" 1) NIL NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED "RowToMat(M, (k - mod(k, length(N))) / length(N))") (("2" (TYPEPRED "RowToMat(N, mod(k, length(N)))") (("2" (MULT-INEQ -7 -3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (GROUND) NIL NIL)) NIL) ("2" (HIDE (-5 2)) (("2" (TYPEPRED (N!1)) (("2" (INST -4 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -4 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "RowToMat_columns") (("2" (TYPEPRED (N!1)) (("2" (INST -4 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -4 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST -2 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns") (("2" (REWRITE "tensor_cols") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST -2 "RowToMat(tensor_prod(M,N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns" -1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST -2 "RowToMat(tensor_prod(M, N), k)") (("2" (REPLACE -2 :DIR RL) (("2" (REWRITE "RowToMat_columns" -1) (("2" (HIDE (2 3)) (("2" (REWRITE "tensor_cols" 1) (("1" (REWRITE "RowToMat_columns" 1) (("1" (REWRITE "RowToMat_columns" 1) (("1" (REWRITE "tensor_cols" -1) NIL NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST?) (("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos") (("2" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int") (("3" (INST?) (("3" (TYPEPRED (N)) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("1" (FLATTEN) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (N)) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (LEMMA "mod_int") (("4" (INST?) (("4" (TYPEPRED (N)) (("4" (EXPAND "rows") (("4" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N!1)) (("2" (INST?) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (LEMMA "columns_mn") (("2" (INST -1 "rows(A)" "length(car(A))" "A") (("2" (TYPEPRED (A)) (("2" (SPLIT 1) (("1" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -2) (("1" (GRIND) NIL NIL) ("2" (INST -1 "_" "0") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (TYPEPRED (A)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (2 3)) (("2" (HIDE -) (("2" (SKEEP) (("2" (EXPAND "entry") (("2" (EXPAND "row") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (TYPEPRED (A)) (("1" (GROUND) (("1" (GRIND) NIL NIL) ("2" (EXPAND "rows") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "access") (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED (N!2)) (("2" (GROUND) (("2" (GRIND) (("2" (LEMMA "columns_mn") (("2" (INST -1 "rows(A)" "length(car(A))" "A") (("1" (GROUND) NIL NIL) ("2" (TYPEPRED (A)) (("2" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (INST -1 "_" "0") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (TYPEPRED (A)) (("3" (TYPEPRED (N!2)) (("3" (LEMMA "columns_mn") (("3" (INST -1 "rows(A)" "length(car(A))" "A") (("1" (CASE-REPLACE "length[real](car[list[real]](A)) = length(car(A))") (("1" (GROUND) NIL NIL)) NIL) ("2" (SPLIT 1) (("1" (GROUND) (("1" (EXPAND "rows") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (SPLIT -3) (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -1 "_" "0") (("1" (EXPAND "nth") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (GROUND) (("4" (HIDE (2 3)) (("4" (HIDE (-1 -2 -4)) (("4" (GRIND) (("4" (TYPEPRED (A)) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) (("2" (EXPAND "rows") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (EXPAND "rows") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "tensor_rows") (("2" (INST-CP -1 "M" " (k - mod(k, rows(N))) / rows(N)") (("1" (INST -1 "N" " mod(k, rows(N))") (("1" (GROUND) NIL NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("3" (FLATTEN) NIL NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("4" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 3)) (("2" (GROUND) (("2" (EXPAND "RowToMat") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(N)")) (("2" (FLATTEN) NIL NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(N)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|RowTensor_TCC1| 0 (|RowTensor_TCC1-1| |nil| 3618069795 ("" (SKEEP) (("" (TYPEPRED (L)) (("" (GROUND) (("" (EXPAND "length") (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL (|RowTensor| SUBTYPE "tensor_product.L" "(list_adt[below(matrices.rows(tensor_product.M))].cons?)"))) (|RowTensor_TCC2| 0 (|RowTensor_TCC2-1| |nil| 3618069795 ("" (SKEEP) (("" (TYPEPRED (L)) (("" (EXPAND "length") (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL (|RowTensor| SUBTYPE "tensor_product.L" "(list_adt[below(matrices.rows(tensor_product.M))].cons?)"))) (|RowTensor_TCC3| 0 (|RowTensor_TCC3-2| "" 3790097787 ("" (SKEEP) (("" (TYPEPRED (L)) (("" (GROUND) (("" (EXPAND "length") (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) SHOSTAK (|RowTensor| SUBTYPE "list_adt[below(matrices.rows(tensor_product.M))].cdr(tensor_product.L)" "{LL: list_adt[below(matrices.rows(tensor_product.M))].list | list_props[below(matrices.rows(tensor_product.M))].length(LL) = (number_fields.-)(tensor_product.n, 1)}")) (|RowTensor_TCC3-1| |nil| 3618069795 ("" (SKEEP) (("" (TYPEPRED (L)) (("" (GROUND) (("" (EXPAND "length") (("" (GROUND) (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|RowTensor| SUBTYPE "list_adt[below(matrices.rows(tensor_product.M))].cdr(tensor_product.L)" "{LL: list_adt[below(matrices.rows(tensor_product.M))].list | list_props[below(matrices.rows(tensor_product.M))].length(LL) = (number_fields.-)(tensor_product.n, 1)}"))) (|RowTensors_same_TCC1| 0 (|RowTensors_same_TCC1-1| |nil| 3621082527 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|RowTensors_same| SUBTYPE "matrices.rows(tensor_product.M)" "{x: naturalnumbers.nat | reals.>(x, 1)}"))) (|RowTensors_same_TCC2| 0 (|RowTensors_same_TCC2-1| |nil| 3621082527 ("" (SKEEP) (("" (SKEEP) (("" (LEMMA "base_n_lt_n") (("" (INST?) NIL NIL)) NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (> CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|base_n_lt_n| FORMULA-DECL NIL |base_repr| |reals|)) NIL (|RowTensors_same| SUBTYPE "base_repr.base_n(matrices.rows(tensor_product.M), tensor_product.k)" "[nat -> below(matrices.rows(tensor_product.M))]"))) (|RowTensors_same| 0 (|RowTensors_same-2| "" 3883693179 ("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "RowTensor" 1) (("3" (EXPAND "RowTensorAlt" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "RtM" 1) (("1" (CASE "car(base_list(rows(M), k, 1 + j)) = base_n(rows(M), k)(0)") (("1" (GROUND) NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "car(base_list(rows(M), k, 1 + j)) = base_n(rows(M), k)(0)") (("1" (REWRITE "base_list_cdr") (("1" (EXPAND "base_n" 2 2) (("1" (CASE-REPLACE "(LAMBDA (j_1: nat):
                                          IF k < rows(M) THEN 0
                                          ELSE base_n
                                               (rows(M),
                                                (k - mod(k, rows(M))) / rows(M))
                                               (j_1)
                                          ENDIF) = base_n
                                               (rows(M),
                                                (k - mod(k, rows(M))) / rows(M))") (("1" (SPLIT -3) (("1" (INST -1 "M" "(k-mod(k, rows(M)))/rows(M)") (("1" (GROUND) (("1" (REWRITE "RtM" 2) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LEMMA "mod_int") (("2" (INST?) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST?) (("2" (TYPEPRED ("k")) (("2" (EXPAND "^") (("2" (EXPAND "expt" -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (HIDE (-1 -2)) (("2" (CASE-REPLACE "(k<rows(M)) = TRUE") (("1" (SIMPLIFY -1) (("1" (LEMMA "mod_int") (("1" (INST?) (("1" (CASE-REPLACE "(k - mod(k, rows(M))) / rows(M) =0") (("1" (EXPAND "base_n") (("1" (PROPAX) NIL NIL)) NIL) ("2" (DIV-BY -2 "rows(M)") (("2" (EXPAND "mod") (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (DECOMPOSE-EQUALITY 2) (("2" (LEMMA "mod_int") (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int") (("3" (INST?) NIL NIL)) NIL) ("4" (LEMMA "mod_int") (("4" (INST?) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (SKEEP) (("4" (REWRITE "base_n_lt_n") NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|RowTensors_same-1| |nil| 3621082529 ("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "RowTensor" 1) (("3" (EXPAND "RowTensorAlt" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "RtM" 1) (("1" (CASE "car(base_list(rows(M), k, 1 + j)) = base_n(rows(M), k)(0)") (("1" (GROUND) NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "car(base_list(rows(M), k, 1 + j)) = base_n(rows(M), k)(0)") (("1" (REWRITE "base_list_cdr") (("1" (EXPAND "base_n" 2 2) (("1" (CASE-REPLACE "(LAMBDA (j_1: nat):
                                          IF k < rows(M) THEN 0
                                          ELSE base_n
                                               (rows(M),
                                                (k - mod(k, rows(M))) / rows(M))
                                               (j_1)
                                          ENDIF) = base_n
                                               (rows(M),
                                                (k - mod(k, rows(M))) / rows(M))") (("1" (SPLIT -3) (("1" (INST -1 "M" "(k-mod(k, rows(M)))/rows(M)") (("1" (GROUND) (("1" (REWRITE "RtM" 2) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LEMMA "mod_int") (("2" (INST?) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST?) (("2" (TYPEPRED (K)) (("2" (EXPAND "^") (("2" (EXPAND "expt" -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (HIDE (-1 -2)) (("2" (CASE-REPLACE "(k<rows(M)) = TRUE") (("1" (SIMPLIFY -1) (("1" (LEMMA "mod_int") (("1" (INST?) (("1" (CASE-REPLACE "(k - mod(k, rows(M))) / rows(M) =0") (("1" (EXPAND "base_n") (("1" (PROPAX) NIL NIL)) NIL) ("2" (DIV-BY -2 "rows(M)") (("2" (EXPAND "mod") (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (DECOMPOSE-EQUALITY 2) (("2" (LEMMA "mod_int") (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int") (("3" (INST?) NIL NIL)) NIL) ("4" (LEMMA "mod_int") (("4" (INST?) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (SKEEP) (("4" (REWRITE "base_n_lt_n") NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|base_n_lt_n| FORMULA-DECL NIL |base_repr| |reals|) (|base_list_cdr| FORMULA-DECL NIL |base_repr| |reals|) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|k| SKOLEM-CONST-DECL "below(rows(M) ^ (1 + j))" |tensor_product| NIL) (|j| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (M SKOLEM-CONST-DECL "{AA: PosFullMatrix | rows(AA) > 1}" |tensor_product| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|mod_int| FORMULA-DECL NIL |tensor_product| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|both_sides_div_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|nonzero_real| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (|div_simp| FORMULA-DECL NIL |real_props| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|array2list_it| DEF-DECL "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" |array2list| |structures|) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|RtM| FORMULA-DECL NIL |tensor_product| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (> CONST-DECL "bool" |reals| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|base_n| DEF-DECL "nat" |base_repr| |reals|) (|RowTensorAlt| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|base_list| CONST-DECL "listn[below(n)](digits)" |base_repr| |reals|) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|RowTensor| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK)) (|RowTensor_is_TensorRow_TCC1| 0 (|RowTensor_is_TensorRow_TCC1-1| |nil| 3618069795 ("" (LEMMA "tensor_power_rows_alt") (("" (SKEEP) (("" (INST?) (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ((|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|tensor_power_rows_alt| FORMULA-DECL NIL |tensor_product| NIL)) NIL (|RowTensor_is_TensorRow| SUBTYPE "tensor_product.k" "below(matrices.rows(tensor_product.tensor_power_alt(tensor_product.M, tensor_product.n)))"))) (|RowTensor_is_TensorRow| 0 (|RowTensor_is_TensorRow-4| "" 3883693239 ("" (SKOLEM 1 ("M" "_" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (CASE-REPLACE "j=0") (("1" (HIDE -2) (("1" (SKEEP) (("1" (EXPAND "tensor_power_alt") (("1" (EXPAND "RowTensor") (("1" (CASE-REPLACE "base_list(rows(M), k, 1) = (: k :)") (("1" (CASE-REPLACE "car((: k :)) = k") (("1" (GROUND) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "base_list") (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "array2list_it") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "array2list_it") (("2" (EXPAND "mod") (("2" (TYPEPRED ("k")) (("2" (REPLACE -2) (("2" (EXPAND "^") (("2" (EXPAND "expt") (("2" (EXPAND "expt") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "RowTensor" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "car(base_list(rows(M), k, 1+j)) = mod(k, rows(M))") (("1" (REWRITE "base_list_cdr") (("1" (EXPAND "tensor_power_alt" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (REWRITE "RowToMat_tensor_prod") (("1" (SPLIT -2) (("1" (INST -1 "(k - mod(k, rows(M))) / rows(M)") (("1" (PROP) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(M)")) (("2" (TYPEPRED ("k")) (("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(M)")) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (EXPAND "^") (("2" (EXPAND "expt" -3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (LEMMA "tensor_power_rows_alt" ("A" "M" "n" "j")) (("2" (REPLACE -1 :DIR RL) (("2" (TYPEPRED ("k")) (("2" (EXPAND "^") (("2" (EXPAND "expt" -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "base_list") (("2" (HIDE 3) (("2" (HIDE -1) (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (CANCEL-BY 1 "rows(M)") (("1" (DIV-BY -1 "rows(M)") (("1" (GROUND) (("1" (CASE "k/rows(M)>=0") (("1" (LEMMA "floor_0") (("1" (INST?) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (LEMMA "tensor_power_rows_alt") (("4" (INST -1 "M" "n") (("4" (REPLACE -1 :DIR RL) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|RowTensor_is_TensorRow-3| "" 3790097791 ("" (SKOLEM 1 ("M" "_" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (CASE-REPLACE "j=0") (("1" (HIDE -2) (("1" (SKEEP) (("1" (EXPAND "tensor_power_alt") (("1" (EXPAND "RowTensor") (("1" (CASE-REPLACE "base_list(rows(M), k, 1) = (: k :)") (("1" (CASE-REPLACE "car((: k :)) = k") (("1" (GROUND) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "base_list") (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "array2list_it") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "array2list_it") (("2" (EXPAND "mod") (("2" (TYPEPRED (K)) (("2" (REPLACE -2) (("2" (EXPAND "^") (("2" (EXPAND "expt") (("2" (EXPAND "expt") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "RowTensor" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "car(base_list(rows(M), k, 1+j)) = mod(k, rows(M))") (("1" (REWRITE "base_list_cdr") (("1" (EXPAND "tensor_power_alt" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (REWRITE "RowToMat_tensor_prod") (("1" (SPLIT -2) (("1" (INST -1 "(k - mod(k, rows(M))) / rows(M)") (("1" (PROP) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(M)")) (("2" (TYPEPRED (K)) (("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(M)")) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (EXPAND "^") (("2" (EXPAND "expt" -3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (LEMMA "tensor_power_rows_alt" ("A" "M" "n" "j")) (("2" (REPLACE -1 :DIR RL) (("2" (TYPEPRED (K)) (("2" (EXPAND "^") (("2" (EXPAND "expt" -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "base_list") (("2" (HIDE 3) (("2" (HIDE -1) (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (CANCEL-BY 1 "rows(M)") (("1" (DIV-BY -1 "rows(M)") (("1" (GROUND) (("1" (CASE "k/rows(M)>=0") (("1" (LEMMA "floor_0") (("1" (INST?) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (LEMMA "tensor_power_rows_alt") (("4" (INST -1 "M" "n") (("4" (REPLACE -1 :DIR RL) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|RowToMat| CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|RowTensor| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|base_list| CONST-DECL "listn[below(n)](digits)" |base_repr| |reals|) (|tensor_power_alt| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (M SKOLEM-CONST-DECL "PosFullMatrix" |tensor_product| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|base_n| DEF-DECL "nat" |base_repr| |reals|) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|array2list_it| DEF-DECL "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" |array2list| |structures|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|even_plus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|RowToMat_tensor_prod| FORMULA-DECL NIL |tensor_product| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|k| SKOLEM-CONST-DECL "below(rows(M) ^ (1 + j))" |tensor_product| NIL) (|j| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|mod_int| FORMULA-DECL NIL |tensor_product| NIL) (|tensor_power_rows_alt| FORMULA-DECL NIL |tensor_product| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|base_list_cdr| FORMULA-DECL NIL |base_repr| |reals|) (|bijective?| CONST-DECL "bool" |functions| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|nonzero_real| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (|both_sides_times1| FORMULA-DECL NIL |real_props| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|rat_times_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|neg_one_times| FORMULA-DECL NIL |extra_tegies| NIL) (|zero_div| FORMULA-DECL NIL |extra_tegies| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|floor_0| FORMULA-DECL NIL |floor_ceil| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|div_simp| FORMULA-DECL NIL |real_props| NIL) (|both_sides_div_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL)) SHOSTAK) (|RowTensor_is_TensorRow-2| |nil| 3618676989 ("" (SKOLEM 1 ("M" "_" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (CASE-REPLACE "j=0") (("1" (HIDE -2) (("1" (SKEEP) (("1" (EXPAND "tensor_power_alt") (("1" (EXPAND "RowTensor") (("1" (CASE-REPLACE "base_list(rows(M), k, 1) = (: k :)") (("1" (CASE-REPLACE "car((: k :)) = k") (("1" (GROUND) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "base_list") (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "array2list_it") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "array2list_it") (("2" (EXPAND "mod") (("2" (TYPEPRED (K)) (("2" (REPLACE -2) (("2" (EXPAND "^") (("2" (EXPAND "expt") (("2" (EXPAND "expt") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "RowTensor" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "car(base_list(rows(M), k, 1+j)) = mod(k, rows(M))") (("1" (REWRITE "base_list_cdr") (("1" (EXPAND "tensor_power_alt" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (REWRITE "RowToMat_tensor_prod") (("1" (SPLIT -2) (("1" (INST -1 "(k - mod(k, rows(M))) / rows(M)") (("1" (PROP) (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (LEMMA "mod_int" ("k" "k" "n" "rows(M)")) (("2" (TYPEPRED (K)) (("2" (LEMMA "mod_pos" ("i" "k" "m" "rows(M)")) (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (EXPAND "^") (("2" (EXPAND "expt" -3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (LEMMA "tensor_power_rows_alt" ("A" "M" "n" "j")) (("2" (REPLACE -1 :DIR RL) (("2" (TYPEPRED (K)) (("2" (EXPAND "^") (("2" (EXPAND "expt" -1) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "base_list") (("2" (HIDE 3) (("2" (HIDE -1) (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (CANCEL-BY 1 "rows(M)") (("1" (GROUND) (("1" (DIV-BY -1 "rows(M)") (("1" (GROUND) (("1" (CASE "k/rows(M)>=0") (("1" (LEMMA "floor_0") (("1" (INST?) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (LEMMA "tensor_power_rows_alt") (("4" (INST -1 "M" "n") (("4" (REPLACE -1 :DIR RL) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|RowTensor_is_TensorRow-1| |nil| 3618074348 ("" (SKOLEM 1 ("M" "_" "_")) (("" (INDUCT "n") (("1" (GROUND) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (CASE-REPLACE "j=0") (("1" (HIDE -2) (("1" (SKEEP) (("1" (EXPAND "tensor_power") (("1" (EXPAND "RowTensor") (("1" (CASE-REPLACE "base_list(rows(M), k, 1) = (: k :)") (("1" (CASE-REPLACE "car((: k :)) = k") (("1" (GROUND) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "base_list") (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) (("1" (EXPAND "array2list_it") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "array2list_it") (("2" (EXPAND "mod") (("2" (TYPEPRED (K)) (("2" (REPLACE -2) (("2" (EXPAND "^") (("2" (EXPAND "expt") (("2" (EXPAND "expt") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "RowTensor" 2) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "car(base_list(rows(M), k, 1+j)) = mod(k, rows(M))") (("1" (REWRITE "base_list_cdr") (("1" (EXPAND "tensor_power" 2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (REWRITE "RowToMat_tensor_prod") (("1" (POSTPONE) NIL NIL) ("2" (LEMMA "tensor_power_rows" ("A" "M" "n" "j")) (("2" (REPLACE -1 :DIR RL) (("2" (TYPEPRED (K)) (("2" (EXPAND "^") (("2" (EXPAND "expt" -1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "base_list") (("2" (HIDE 3) (("2" (HIDE -1) (("2" (EXPAND "base_n") (("2" (EXPAND "array2list") (("2" (EXPAND "array2list_it") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (CANCEL-BY 1 "rows(M)") (("1" (GROUND) (("1" (DIV-BY -1 "rows(M)") (("1" (GROUND) (("1" (CASE "k/rows(M)>=0") (("1" (LEMMA "floor_0") (("1" (INST?) (("1" (FLATTEN) (("1" (SPLIT -2) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CROSS-MULT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (LEMMA "tensor_power_rows") (("4" (INST -1 "M" "n") (("4" (REPLACE -1 :DIR RL) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|RowTensor_is_TensorRow2_TCC1| 0 (|RowTensor_is_TensorRow2_TCC1-2| "" 3883693263 ("" (SKEEP) (("" (TYPEPRED ("k")) (("" (REWRITE "tensor_power_rows" :DIR RL) NIL NIL)) NIL)) NIL) NIL SHOSTAK (|RowTensor_is_TensorRow2| SUBTYPE "tensor_product.k" "below(matrices.rows(tensor_product.tensor_power(tensor_product.M, tensor_product.n)))")) (|RowTensor_is_TensorRow2_TCC1-1| |nil| 3621086484 ("" (SKEEP) (("" (TYPEPRED (K)) (("" (REWRITE "tensor_power_rows" :DIR RL) NIL NIL)) NIL)) NIL) ((|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (< CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|tensor_power_rows| FORMULA-DECL NIL |tensor_product| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL)) NIL (|RowTensor_is_TensorRow2| SUBTYPE "tensor_product.k" "below(matrices.rows(tensor_product.tensor_power(tensor_product.M, tensor_product.n)))"))) (|RowTensor_is_TensorRow2| 0 (|RowTensor_is_TensorRow2-1| |nil| 3621086485 ("" (SKEEP) (("" (REWRITE "power_assoc") (("" (REWRITE "RtM" :DIR RL) (("" (REWRITE "RowTensor_is_TensorRow") (("" (REWRITE "RowTensors_same") NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|power_assoc| FORMULA-DECL NIL |tensor_product| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|RowTensor_is_TensorRow| FORMULA-DECL NIL |tensor_product| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|RowTensors_same| FORMULA-DECL NIL |tensor_product| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|tensor_power_alt| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|RtM| FORMULA-DECL NIL |tensor_product| NIL)) SHOSTAK)) (|tensor_entry_TCC1| 0 (|tensor_entry_TCC1-1| |nil| 3618739186 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_entry| SUBTYPE "matrices.rows(tensor_product.A)" "{x: naturalnumbers.nat | reals.>(x, 1)}"))) (|tensor_entry_TCC2| 0 (|tensor_entry_TCC2-1| |nil| 3618739186 ("" (SUBTYPE-TCC) NIL NIL) ((|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_entry| SUBTYPE "matrices.columns(tensor_product.A)" "{x: naturalnumbers.nat | reals.>(x, 1)}"))) (|tensor_entry_TCC3| 0 (|tensor_entry_TCC3-1| |nil| 3618739186 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_entry| SUBTYPE "matrices.rows(tensor_product.A)" "posnat"))) (|tensor_entry_TCC4| 0 (|tensor_entry_TCC4-1| |nil| 3618739186 ("" (SUBTYPE-TCC) NIL NIL) ((|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_entry| SUBTYPE "matrices.columns(tensor_product.A)" "posnat"))) (|tensor_entry_TCC5| 0 (|tensor_entry_TCC5-1| |nil| 3618739186 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|tensor_entry| ASSUMING "reals@product[nat].product" "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))"))) (|tensor_entry| 0 (|tensor_entry-5| "" 3883694014 ("" (SKOLEM 1 ("A" "_" "_" "_")) (("" (INDUCT "n" 1 "NAT_induction") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "tensor_power_alt" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (SIMPLIFY 1) (("1" (REWRITE "product_eq_arg[nat]") (("1" (EXPAND "entry_pick") (("1" (EXPAND "base_n") (("1" (TYPEPRED ("k")) (("1" (TYPEPRED ("m")) (("1" (REPLACE -3) (("1" (EXPAND "^") (("1" (HIDE -4) (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "entry_tensor_prod") (("2" (EXPAND "tensor_fun") (("2" (REWRITE "tensor_power_rows_alt" :DIR RL) (("2" (REWRITE "tensor_power_columns_alt" :DIR RL) (("2" (TYPEPRED ("k")) (("2" (TYPEPRED ("m")) (("2" (CASE "(rows(A) ^ (j - 1)) * rows(A) = rows(A)^j AND (columns(A) ^ (j - 1)) * columns(A) = columns(A)^j") (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "product_first") (("1" (EXPAND "entry_pick") (("1" (CASE-REPLACE "entry(A)(mod(k, rows(A)), mod(m, columns(A)))
                   =
                   entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (CANCEL-BY 1 "entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (HIDE -1) (("1" (LEMMA "product_shift_T[nat]") (("1" (INST -1 "LAMBDA (i: nat):
                                entry(A)
                                     (base_n(rows(A), k)(i), base_n(columns(A), m)(i))" "j-2" "0" "1") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE 1) (("1" (EXPAND "base_n" 1) (("1" (CASE "FORALL (kk:nat, nn:posnat): kk<nn IMPLIES (kk-mod(kk, nn))/nn = 0") (("1" (INST -9 "j-1") (("1" (HIDE (-2 -3 -4)) (("1" (SPLIT -6) (("1" (INST -1 "(k - mod(k, rows(A))) / rows(A)" "(m - mod(m, columns(A))) / columns(A)") (("1" (REPLACE -1) (("1" (REWRITE "product_eq") (("1" (HIDE 2) (("1" (SKEEP) (("1" (LIFT-IF 1) (("1" (CASE "FORALL (nn:nat, mm: {x:nat | x>1}): base_n(mm, 0)(nn) = 0") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (INST-CP -5 "k" "rows(A)") (("1" (INST -5 "m" "columns(A)") (("1" (INST-CP -3 "n" "rows(A)") (("1" (INST -3 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (INST -4 "k" "rows(A)") (("2" (INST -2 "n" "rows(A)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (INST -4 "m" "columns(A)") (("1" (INST -2 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKOLEM 1 ("_" "mm")) (("2" (INDUCT "nn" 1) (("1" (EXPAND "base_n") (("1" (PROPAX) NIL NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "base_n" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("4" (PROPAX) NIL NIL)) NIL) ("5" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("5" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST -1 "m" "columns(A)") (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "m" "columns(A)") (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (GROUND) (("3" (CROSS-MULT 1) (("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(A)")) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 -8)) (("2" (SKEEP) (("2" (CROSS-MULT 1) (("2" (EXPAND "mod") (("2" (CANCEL-BY 1 "nn") (("2" (DIV-BY -1 "nn") (("2" (CASE "kk/nn>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (EXPAND "base_n") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (DIV-BY -1 "columns(A)") (("1" (DIV-BY -2 "rows(A)") (("1" (GROUND) (("1" (CASE-REPLACE "floor(k / rows(A)) = 0") (("1" (CASE-REPLACE "floor(m / columns(A)) = 0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED ("k")) (("2" (TYPEPRED ("m")) (("2" (HIDE 2) (("2" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "mod(k, rows(A)) = k") (("2" (HIDE 3) (("2" (EXPAND "mod") (("2" (DIV-BY -1 "rows(A)") (("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE-REPLACE "mod(m, columns(A)) = m") (("1" (EXPAND "mod") (("1" (DIV-BY -1 "columns(A)") (("1" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST?) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-4 2 1)) (("2" (EXPAND "^") (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "expt" 1 2) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "expt" 1 2) (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|tensor_entry-4| "" 3804282481 ("" (SKOLEM 1 ("A" "_" "_" "_")) (("" (INDUCT "n" 1 NAT_INDUCTION) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "tensor_power_alt" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (SIMPLIFY 1) (("1" (REWRITE "product_eq_arg[nat]") (("1" (EXPAND "entry_pick") (("1" (EXPAND "base_n") (("1" (TYPEPRED (K)) (("1" (TYPEPRED (M)) (("1" (REPLACE -3) (("1" (EXPAND "^") (("1" (HIDE -4) (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "entry_tensor_prod") (("2" (EXPAND "tensor_fun") (("2" (REWRITE "tensor_power_rows_alt" :DIR RL) (("2" (REWRITE "tensor_power_columns_alt" :DIR RL) (("2" (TYPEPRED (K)) (("2" (TYPEPRED (M)) (("2" (CASE "(rows(A) ^ (j - 1)) * rows(A) = rows(A)^j AND (columns(A) ^ (j - 1)) * columns(A) = columns(A)^j") (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "product_first") (("1" (EXPAND "entry_pick") (("1" (CASE-REPLACE "entry(A)(mod(k, rows(A)), mod(m, columns(A)))
                   =
                   entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (CANCEL-BY 1 "entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (HIDE -1) (("1" (LEMMA "product_shift_T[nat]") (("1" (INST -1 "LAMBDA (i: nat):
                                entry(A)
                                     (base_n(rows(A), k)(i), base_n(columns(A), m)(i))" "j-2" "0" "1") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE 1) (("1" (EXPAND "base_n" 1) (("1" (CASE "FORALL (kk:nat, nn:posnat): kk<nn IMPLIES (kk-mod(kk, nn))/nn = 0") (("1" (INST -9 "j-1") (("1" (HIDE (-2 -3 -4)) (("1" (SPLIT -6) (("1" (INST -1 "(k - mod(k, rows(A))) / rows(A)" "(m - mod(m, columns(A))) / columns(A)") (("1" (REPLACE -1) (("1" (REWRITE "product_eq") (("1" (HIDE 2) (("1" (SKEEP) (("1" (LIFT-IF 1) (("1" (CASE "FORALL (nn:nat, mm: {x:nat | x>1}): base_n(mm, 0)(nn) = 0") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (INST-CP -5 "k" "rows(A)") (("1" (INST -5 "m" "columns(A)") (("1" (INST-CP -3 "n" "rows(A)") (("1" (INST -3 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (INST -4 "k" "rows(A)") (("2" (INST -2 "n" "rows(A)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (INST -4 "m" "columns(A)") (("1" (INST -2 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKOLEM 1 ("_" "mm")) (("2" (INDUCT "nn" 1) (("1" (EXPAND "base_n") (("1" (PROPAX) NIL NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "base_n" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("4" (PROPAX) NIL NIL)) NIL) ("5" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("5" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST -1 "m" "columns(A)") (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "m" "columns(A)") (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (GROUND) (("3" (CROSS-MULT 1) (("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(A)")) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 -8)) (("2" (SKEEP) (("2" (CROSS-MULT 1) (("2" (EXPAND "mod") (("2" (CANCEL-BY 1 "nn") (("2" (DIV-BY -1 "nn") (("2" (CASE "kk/nn>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (EXPAND "base_n") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (DIV-BY -1 "columns(A)") (("1" (DIV-BY -2 "rows(A)") (("1" (GROUND) (("1" (CASE-REPLACE "floor(k / rows(A)) = 0") (("1" (CASE-REPLACE "floor(m / columns(A)) = 0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (K)) (("2" (TYPEPRED (M)) (("2" (HIDE 2) (("2" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "mod(k, rows(A)) = k") (("2" (HIDE 3) (("2" (EXPAND "mod") (("2" (DIV-BY -1 "rows(A)") (("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE-REPLACE "mod(m, columns(A)) = m") (("1" (EXPAND "mod") (("1" (DIV-BY -1 "columns(A)") (("1" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST?) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-4 2 1)) (("2" (EXPAND "^") (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "expt" 1 2) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "expt" 1 2) (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP*) (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|tensor_power_alt| DEF-DECL "PosFullMatrix" |tensor_product| NIL) (|T_low| TYPE-EQ-DECL NIL |product| |reals|) (|T_high| TYPE-EQ-DECL NIL |product| |reals|) (|product| DEF-DECL "real" |product| |reals|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|entry_pick| CONST-DECL "real" |tensor_product| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (|base_n| DEF-DECL "nat" |base_repr| |reals|) (A SKOLEM-CONST-DECL "{M: PosFullMatrix | rows(M) > 1 AND columns(M) > 1}" |tensor_product| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|NAT_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|tensor_fun| CONST-DECL "[[nat, nat] -> real]" |tensor_product| NIL) (|tensor_power_columns_alt| FORMULA-DECL NIL |tensor_product| NIL) (|rat_times_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|nzrat_div_nzrat_is_nzrat| APPLICATION-JUDGEMENT "nzrat" |rationals| NIL) (|minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nat_expt| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|product_first| FORMULA-DECL NIL |product| |reals|) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_plus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|nonzero_integer| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_real| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (- CONST-DECL "[numfield -> numfield]" |number_fields| NIL) (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL) (|mod| CONST-DECL "{k | abs(k) < abs(j)}" |mod| NIL) (|odd_minus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|even_minus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|div_cancel3| FORMULA-DECL NIL |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nnrat_div_posrat_is_nnrat| APPLICATION-JUDGEMENT "nonneg_rat" |rationals| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|div_mult_pos_ge1| FORMULA-DECL NIL |real_props| NIL) (|div_simp| FORMULA-DECL NIL |real_props| NIL) (|both_sides_div_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (|nonneg_floor_is_nat| APPLICATION-JUDGEMENT "nat" |floor_ceil| NIL) (|mod_pos| FORMULA-DECL NIL |mod| NIL) (|posreal| NONEMPTY-TYPE-EQ-DECL NIL |real_types| NIL) (|div_mult_pos_lt1| FORMULA-DECL NIL |real_props| NIL) (NIL APPLICATION-JUDGEMENT "below(m)" |mod| NIL) (|mod_int| FORMULA-DECL NIL |tensor_product| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|subrange| TYPE-EQ-DECL NIL |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|product_eq| FORMULA-DECL NIL |product| |reals|) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|product_shift_T| FORMULA-DECL NIL |product| |reals|) (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|both_sides_times1| FORMULA-DECL NIL |real_props| NIL) (|nonzero_real| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (|m| SKOLEM-CONST-DECL "below(columns(A) ^ j)" |tensor_product| NIL) (|k| SKOLEM-CONST-DECL "below(rows(A) ^ j)" |tensor_product| NIL) (DIV_68 SKOLEM-CONST-DECL "real" |tensor_product| NIL) (|j| SKOLEM-CONST-DECL "nat" |tensor_product| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|int_times_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nnrat_times_nnrat_is_nnrat| APPLICATION-JUDGEMENT "nonneg_rat" |rationals| NIL) (|nnrat_exp| APPLICATION-JUDGEMENT "nnrat" |exponentiation| NIL) (|tensor_power_rows_alt| FORMULA-DECL NIL |tensor_product| NIL) (|entry_tensor_prod| FORMULA-DECL NIL |tensor_product| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|expt| DEF-DECL "real" |exponentiation| NIL) (|product_eq_arg| FORMULA-DECL NIL |product| |reals|)) SHOSTAK) (|tensor_entry-3| "" 3790097800 ("" (SKOLEM 1 ("A" "_" "_" "_")) (("" (INDUCT "n" 1 NAT_INDUCTION) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "tensor_power_alt" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (SIMPLIFY 1) (("1" (REWRITE "product_eq_arg[nat]") (("1" (EXPAND "entry_pick") (("1" (EXPAND "base_n") (("1" (TYPEPRED (K)) (("1" (TYPEPRED (M)) (("1" (REPLACE -3) (("1" (EXPAND "^") (("1" (HIDE -4) (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "entry_tensor_prod") (("2" (EXPAND "tensor_fun") (("2" (REWRITE "tensor_power_rows_alt" :DIR RL) (("2" (REWRITE "tensor_power_columns_alt" :DIR RL) (("2" (TYPEPRED (K)) (("2" (TYPEPRED (M)) (("2" (CASE "(rows(A) ^ (j - 1)) * rows(A) = rows(A)^j AND (columns(A) ^ (j - 1)) * columns(A) = columns(A)^j") (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "product_first") (("1" (EXPAND "entry_pick") (("1" (CASE-REPLACE "entry(A)(mod(k, rows(A)), mod(m, columns(A)))
       =
       entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (CANCEL-BY 1 "entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (HIDE -1) (("1" (LEMMA "product_shift_T[nat]") (("1" (INST -1 "LAMBDA (i: nat):
                  entry(A)
                       (base_n(rows(A), k)(i), base_n(columns(A), m)(i))" "j-2" "0" "1") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE 1) (("1" (EXPAND "base_n" 1) (("1" (CASE "FORALL (kk:nat, nn:posnat): kk<nn IMPLIES (kk-mod(kk, nn))/nn = 0") (("1" (INST -9 "j-1") (("1" (HIDE (-2 -3 -4)) (("1" (SPLIT -6) (("1" (INST -1 "(k - mod(k, rows(A))) / rows(A)" "(m - mod(m, columns(A))) / columns(A)") (("1" (REPLACE -1) (("1" (REWRITE "product_eq") (("1" (HIDE 2) (("1" (SKEEP) (("1" (LIFT-IF 1) (("1" (CASE "FORALL (nn:nat, mm: {x:nat | x>1}): base_n(mm, 0)(nn) = 0") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (INST-CP -5 "k" "rows(A)") (("1" (INST -5 "m" "columns(A)") (("1" (INST-CP -3 "n" "rows(A)") (("1" (INST -3 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (INST -4 "k" "rows(A)") (("2" (INST -2 "n" "rows(A)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (INST -4 "m" "columns(A)") (("1" (INST -2 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKOLEM 1 ("_" "mm")) (("2" (INDUCT "nn" 1) (("1" (EXPAND "base_n") (("1" (PROPAX) NIL NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "base_n" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("4" (PROPAX) NIL NIL)) NIL) ("5" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("5" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST -1 "m" "columns(A)") (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "m" "columns(A)") (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (GROUND) (("3" (CROSS-MULT 1) (("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(A)")) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 -8)) (("2" (SKEEP) (("2" (CROSS-MULT 1) (("2" (EXPAND "mod") (("2" (CANCEL-BY 1 "nn") (("2" (DIV-BY -1 "nn") (("2" (CASE "kk/nn>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (EXPAND "base_n") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (DIV-BY -1 "columns(A)") (("1" (DIV-BY -2 "rows(A)") (("1" (GROUND) (("1" (CASE-REPLACE "floor(k / rows(A)) = 0") (("1" (CASE-REPLACE "floor(m / columns(A)) = 0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (K)) (("2" (TYPEPRED (M)) (("2" (HIDE 2) (("2" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "mod(k, rows(A)) = k") (("2" (HIDE 3) (("2" (EXPAND "mod") (("2" (DIV-BY -1 "rows(A)") (("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE-REPLACE "mod(m, columns(A)) = m") (("1" (EXPAND "mod") (("1" (DIV-BY -1 "columns(A)") (("1" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST?) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-4 2 1)) (("2" (EXPAND "^") (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "expt" 1 2) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "expt" 1 2) (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|tensor_entry-2| |nil| 3620127918 ("" (SKOLEM 1 ("A" "_" "_" "_")) (("" (INDUCT "n" 1 NAT_INDUCTION) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "tensor_power_alt" 1) (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (SIMPLIFY 1) (("1" (REWRITE "product_eq_arg[nat]") (("1" (EXPAND "entry_pick") (("1" (EXPAND "base_n") (("1" (TYPEPRED (K)) (("1" (TYPEPRED (M)) (("1" (REPLACE -3) (("1" (EXPAND "^") (("1" (HIDE -4) (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "entry_tensor_prod") (("2" (EXPAND "tensor_fun") (("2" (REWRITE "tensor_power_rows_alt" :DIR RL) (("2" (REWRITE "tensor_power_columns_alt" :DIR RL) (("2" (TYPEPRED (K)) (("2" (TYPEPRED (M)) (("2" (CASE "(rows(A) ^ (j - 1)) * rows(A) = rows(A)^j AND (columns(A) ^ (j - 1)) * columns(A) = columns(A)^j") (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (REPLACE -2) (("1" (LIFT-IF 2) (("1" (SPLIT 2) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "product_first") (("1" (EXPAND "entry_pick") (("1" (CASE-REPLACE "entry(A)(mod(k, rows(A)), mod(m, columns(A)))
       =
       entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (CANCEL-BY 1 "entry(A)(base_n(rows(A), k)(0), base_n(columns(A), m)(0))") (("1" (HIDE -1) (("1" (LEMMA "product_shift_T[nat]") (("1" (INST -1 "LAMBDA (i: nat):
                  entry(A)
                       (base_n(rows(A), k)(i), base_n(columns(A), m)(i))" "j-2" "0" "1") (("1" (SPLIT -1) (("1" (REPLACE -1) (("1" (HIDE 1) (("1" (EXPAND "base_n" 1) (("1" (CASE "FORALL (kk:nat, nn:posnat): kk<nn IMPLIES (kk-mod(kk, nn))/nn = 0") (("1" (INST -9 "j-1") (("1" (HIDE (-2 -3 -4)) (("1" (SPLIT -6) (("1" (INST -1 "(k - mod(k, rows(A))) / rows(A)" "(m - mod(m, columns(A))) / columns(A)") (("1" (REPLACE -1) (("1" (REWRITE "product_eq") (("1" (HIDE 2) (("1" (SKEEP) (("1" (LIFT-IF 1) (("1" (CASE "FORALL (nn:nat, mm: {x:nat | x>1}): base_n(mm, 0)(nn) = 0") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (INST-CP -5 "k" "rows(A)") (("1" (INST -5 "m" "columns(A)") (("1" (INST-CP -3 "n" "rows(A)") (("1" (INST -3 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (INST -4 "k" "rows(A)") (("2" (INST -2 "n" "rows(A)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (INST -4 "m" "columns(A)") (("1" (INST -2 "n" "columns(A)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKOLEM 1 ("_" "mm")) (("2" (INDUCT "nn" 1) (("1" (EXPAND "base_n") (("1" (PROPAX) NIL NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "base_n" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (PROPAX) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_int" ("k" "m" "n" "columns(A)")) (("4" (PROPAX) NIL NIL)) NIL) ("5" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("5" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "mod_int") (("2" (INST -1 "m" "columns(A)") (("2" (GROUND) (("2" (CROSS-MULT 1) (("2" (LEMMA "mod_pos") (("2" (INST -1 "m" "columns(A)") (("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_int" ("k" "k" "n" "rows(A)")) (("3" (GROUND) (("3" (CROSS-MULT 1) (("3" (LEMMA "mod_pos" ("i" "k" "m" "rows(A)")) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL) ("3" (GROUND) NIL NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL) ("2" (HIDE (2 -8)) (("2" (SKEEP) (("2" (CROSS-MULT 1) (("2" (EXPAND "mod") (("2" (CANCEL-BY 1 "nn") (("2" (DIV-BY -1 "nn") (("2" (CASE "kk/nn>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-7 2)) (("2" (EXPAND "base_n") (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "mod") (("1" (GROUND) (("1" (DIV-BY -1 "columns(A)") (("1" (DIV-BY -2 "rows(A)") (("1" (GROUND) (("1" (CASE-REPLACE "floor(k / rows(A)) = 0") (("1" (CASE-REPLACE "floor(m / columns(A)) = 0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (TYPEPRED (K)) (("2" (TYPEPRED (M)) (("2" (HIDE 2) (("2" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (GROUND) (("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE-REPLACE "mod(k, rows(A)) = k") (("2" (HIDE 3) (("2" (EXPAND "mod") (("2" (DIV-BY -1 "rows(A)") (("2" (CASE "k/rows(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF 2) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (CASE-REPLACE "mod(m, columns(A)) = m") (("1" (EXPAND "mod") (("1" (DIV-BY -1 "columns(A)") (("1" (CASE "m/columns(A)>=0") (("1" (GROUND) NIL NIL) ("2" (CROSS-MULT 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (LEMMA "mod_pos") (("3" (INST?) (("3" (GROUND) NIL NIL)) NIL)) NIL) ("4" (LEMMA "mod_pos") (("4" (INST?) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-4 2 1)) (("2" (EXPAND "^") (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (SPLIT 1) (("1" (EXPAND "expt" 1 2) (("1" (LIFT-IF 1) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "expt" 1 2) (("2" (LIFT-IF) (("2" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) NIL NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (SKEEP) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|tensor_entry-1| |nil| 3618740800 ("" (SKOLEM 1 ("A" "_" "_" "_")) (("" (INDUCT "n" 1 NAT_INDUCTION) (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (EXPAND "tensor_power_alt") (("3" (LIFT-IF 1) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (REPLACE -1) (("1" (SIMPLIFY 1) (("1" (REWRITE "product_eq_arg[nat]") (("1" (EXPAND "entry_pick") (("1" (EXPAND "base_n") (("1" (TYPEPRED (K)) (("1" (TYPEPRED (M)) (("1" (REPLACE -3) (("1" (EXPAND "^") (("1" (HIDE -4) (("1" (EXPAND "expt") (("1" (EXPAND "expt") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (SKEEP) (("4" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|tensor_entry_alt| 0 (|tensor_entry_alt-1| |nil| 3621245739 ("" (LEMMA "tensor_entry") (("" (PROPAX) NIL NIL)) NIL) ((|tensor_entry| FORMULA-DECL NIL |tensor_product| NIL)) SHOSTAK)))
