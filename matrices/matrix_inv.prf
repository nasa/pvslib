(|matrix_inv| (|left_inv_TCC1| 0 (|left_inv_TCC1-1| |nil| 3615726331 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|left_inv| SUBTYPE "matrices.rows(matrix_inv.S)" "posnat"))) (|left_inv_TCC2| 0 (|left_inv_TCC2-1| |nil| 3615726331 ("" (SKEEP) (("" (SKOSIMP*) NIL NIL)) NIL) NIL NIL (|left_inv| SUBTYPE "matrices.entry(matrices.*(matrix_inv.R, matrix_inv.S))(matrix_inv.i, matrix_inv.i)" "nznum"))) (|left_inv_TCC3| 0 (|left_inv_TCC3-1| NIL 3883680538 ("" (SKEEP*) (("" (TYPEPRED "form_matrix(LAMBDA (i_1: nat, j_1: nat):
                               IF i_1 /= j_1 OR entry(R * S)(i_1, i_1) = 0
                                 THEN 0
                               ELSE 1 / entry(R * S)(i_1, i_1)
                               ENDIF,
                             rows(S), rows(S))") (("1" (REPLACE 1 :HIDE? T) (("1" (INST? -5) NIL NIL)) NIL) ("2" (HIDE 2 3) (("2" (SKEEP) NIL NIL)) NIL)) NIL)) NIL) ((|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|left_inv| SUBTYPE "matrices.form_matrix(LAMBDA (i, j): IF booleans.OR(matrix_inv.i /= matrix_inv.j, matrices.entry(matrices.*(matrix_inv.R, matrix_inv.S))(matrix_inv.i, matrix_inv.i) = 0) THEN 0 ELSE number_fields./(1, matrices.entry(matrices.*(matrix_inv.R, matrix_inv.S))(matrix_inv.i, matrix_inv.i)) ENDIF, matrices.rows(matrix_inv.S), matrices.rows(matrix_inv.S))" "{x: {M: matrices.MatrixMN(matrices.rows(matrix_inv.S), matrices.rows(matrix_inv.S)) | FORALL (i_1: naturalnumbers.below(matrices.rows(matrix_inv.S)), j_1: naturalnumbers.below(matrices.rows(matrix_inv.S))): list_props[real].nth(matrices.row(M)(i_1), j_1) = IF booleans.OR(i_1 /= j_1, matrices.entry(matrices.*(matrix_inv.R, matrix_inv.S))(i_1, i_1) = 0) THEN 0 ELSE number_fields./(1, matrices.entry(matrices.*(matrix_inv.R, matrix_inv.S))(i_1, i_1)) ENDIF} | booleans.OR(list_adt[list[real]].null?(x), FORALL (i, j: naturalnumbers.below(list_props[list[real]].length(x))): list_props[real].length(list_props[list[real]].nth(x, i)) = list_props[real].length(list_props[list[real]].nth(x, j)))}"))) (|left_inv_TCC4| 0 (|left_inv_TCC3-5| "" 3790097199 ("" (SKEEP) (("" (SKEEP) (("" (CASE "diagonal?(dg`ans)") (("1" (LABEL "idz" -1) (("1" (HIDE "idz") (("1" (SKEEP) (("1" (CASE "NOT diagonal?(newT)") (("1" (HIDE 2) (("1" (REPLACE -3 +) (("1" (EXPAND "diagonal?") (("1" (SKOSIMP*) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "diagonal_simple_prod") (("2" (INST - "false" "rows(S)" "newT") (("1" (ASSERT) (("1" (SPLIT) (("1" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "full_matrix_eq") (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1 1) (("1" (EXPAND "length" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL) ("3" (REWRITE "rows_mult") (("3" (REWRITE "columns_mult" 1) (("1" (REPLACE -5 1) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "newT") (("2" (EXPAND "rows") (("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1) (("1" (EXPAND "length" -1 1) (("1" (REWRITE "length_rows" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REWRITE "rows_mult") (("4" (ASSERT) (("4" (REPLACE -5 1) (("4" (REWRITE "rows_form_matrix") (("4" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "full_matrix_eq") (("1" (SPLIT) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (ASSERT) (("1" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "rows") (("2" (EXPAND "length" -2 1) (("2" (REWRITE "length_rows" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_mult") (("3" (LIFT-IF) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "*" + 1) (("1" (REWRITE "dot_eq_sigma") (("1" (REWRITE "length_row") (("1" (REPLACE -4) (("1" (REWRITE "length_col") (("1" (REWRITE "rows_mult") (("1" (EXPAND "min" 1) (("1" (REWRITE "entry_Id") (("1" (ASSERT) (("1" (REWRITE "columns_mult" -2) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "sigma_restrict_eq_0") (("1" (HIDE 3) (("1" (SKOSIMP*) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (CASE "i!1 = i!2") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 :DIR RL) (("1" (REPLACE -3) (("1" (REVEAL "idz") (("1" (EXPAND "diagonal?") (("1" (INST - "i!2" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "diagonal?") (("2" (INST - "i!1" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "j!1") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 1) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (SPLIT +) (("1" (FLATTEN) (("1" (LEMMA "det_upper_triangular_zero") (("1" (INST - "R*S") (("1" (ASSERT) (("1" (INST + "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (TYPEPRED "dg") (("2" (REVEAL "idz") (("2" (EXPAND "diagonal?") (("2" (INST - "i!2" "j!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "columns_mult" 1) (("1" (ASSERT) (("1" (REWRITE "entry_eq_0") (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "rows(newT) = rows(S)") (("1" (CASE "columns(newT) = rows(S)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (LEMMA "form_matrix_square") (("1" (INST?) (("1" (ASSERT) (("1" (SKOSIMP*) (("1" (INST - "i!1" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE -5 +) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REWRITE "rows_form_matrix") (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (TYPEPRED "dg") (("2" (ASSERT) (("2" (EXPAND "diagonal?") (("2" (SKOSIMP*) (("2" (INST - "i!1" "j!1") (("2" (INST - "i!1" "j!1") (("2" (ASSERT) (("2" (REWRITE "entry_eq_0" 3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (FALSE CONST-DECL "bool" |booleans| NIL) (|is_simple_prod?| CONST-DECL "bool" |matrix_det| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|upper_triangular?| CONST-DECL "bool" |matrix_det| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|diagonal?| CONST-DECL "bool" |matrix_det| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|diagonal_simple_prod| FORMULA-DECL NIL |matrix_det| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|entry_eq_0| FORMULA-DECL NIL |matrices| NIL) (|dot_eq_sigma| FORMULA-DECL NIL |matrices| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|entry_Id| FORMULA-DECL NIL |matrices| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|sigma_eq_one_arg2| FORMULA-DECL NIL |sigma| |reals|) (|det_upper_triangular_zero| FORMULA-DECL NIL |matrix_det| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|access_row| FORMULA-DECL NIL |matrices| NIL) (|subrange| TYPE-EQ-DECL NIL |integers| NIL) (|access_col| FORMULA-DECL NIL |matrices| NIL) (|T_low| TYPE-EQ-DECL NIL |sigma| |reals|) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|T_high| TYPE-EQ-DECL NIL |sigma| |reals|) (|access| CONST-DECL "real" |matrices| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|sigma_restrict_eq_0| FORMULA-DECL NIL |sigma| |reals|) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|length_col| FORMULA-DECL NIL |matrices| NIL) (|length_row| FORMULA-DECL NIL |matrices| NIL) (|entry_mult| FORMULA-DECL NIL |matrices| NIL) (|matrix_mult_assoc| FORMULA-DECL NIL |matrices| NIL) (|length_rows| FORMULA-DECL NIL |matrices| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|full_matrix_eq| FORMULA-DECL NIL |matrices| NIL) (|columns_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|rows_form_matrix| FORMULA-DECL NIL |matrices| NIL) (S SKOLEM-CONST-DECL "{S | det(S) /= 0}" |matrix_inv| NIL) (R SKOLEM-CONST-DECL "SquareMatrix(rows(S))" |matrix_inv| NIL) (|newT| SKOLEM-CONST-DECL "{x:
   {M: MatrixMN(rows(S), rows(S)) |
      FORALL (i_1: below(rows(S)), j_1: below(rows(S))):
        nth(row(M)(i_1), j_1) =
         IF i_1 /= j_1 OR entry(R * S)(i_1, i_1) = 0 THEN 0
         ELSE 1 / entry(R * S)(i_1, i_1)
         ENDIF} |
   null?(x) OR
    FORALL (i, j: below(length(x))): length(nth(x, i)) = length(nth(x, j))}" |matrix_inv| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|entry_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL)) SHOSTAK (|left_inv| SUBTYPE "matrices.*(matrix_inv.newT, matrix_inv.R)" "{Q: matrices.SquareMatrix(matrices.rows(matrix_inv.S)) | matrices.*(Q, matrix_inv.S) = matrices.Id(matrices.rows(matrix_inv.S))}")) (|left_inv_TCC3-4| "" 3755410377 ("" (SKEEP) (("" (SKEEP) (("" (CASE "diagonal?(dg`ans)") (("1" (LABEL "idz" -1) (("1" (HIDE "idz") (("1" (SKEEP) (("1" (CASE "NOT diagonal?(newT)") (("1" (HIDE 2) (("1" (REPLACE -3 +) (("1" (EXPAND "diagonal?") (("1" (SKOSIMP*) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "diagonal_simple_prod") (("2" (INST - "false" "rows(S)" "newT") (("1" (ASSERT) (("1" (SPLIT) (("1" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "full_matrix_eq") (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1 1) (("1" (EXPAND "length" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL) ("3" (REWRITE "rows_mult") (("3" (REWRITE "columns_mult" 1) (("1" (REPLACE -5 1) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "newT") (("2" (EXPAND "rows") (("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1) (("1" (EXPAND "length" -1 1) (("1" (REWRITE "length_rows" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REWRITE "rows_mult") (("4" (ASSERT) (("4" (REPLACE -5 1) (("4" (REWRITE "rows_form_matrix") (("4" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "full_matrix_eq") (("1" (SPLIT) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (ASSERT) (("1" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "rows") (("2" (EXPAND "length" -2 1) (("2" (REWRITE "length_rows" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_mult") (("3" (LIFT-IF) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "*" + 1) (("1" (REWRITE "dot_eq_sigma") (("1" (REWRITE "length_row") (("1" (REPLACE -4) (("1" (REWRITE "length_col") (("1" (REWRITE "rows_mult") (("1" (EXPAND "min" 1) (("1" (REWRITE "entry_Id") (("1" (ASSERT) (("1" (REWRITE "columns_mult" -2) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "sigma_restrict_eq_0") (("1" (HIDE 3) (("1" (SKOSIMP*) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (CASE "i!1 = i!2") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 :DIR RL) (("1" (REPLACE -3) (("1" (REVEAL "idz") (("1" (EXPAND "diagonal?") (("1" (INST - "i!2" "j!1") (("1" (ASSERT) (("1" (REWRITE "access_row") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "diagonal?") (("2" (INST - "i!1" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "j!1") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 1) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (SPLIT +) (("1" (FLATTEN) (("1" (LEMMA "det_upper_triangular_zero") (("1" (INST - "R*S") (("1" (ASSERT) (("1" (INST + "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (REWRITE "access_row") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (TYPEPRED "dg") (("2" (REVEAL "idz") (("2" (EXPAND "diagonal?") (("2" (INST - "i!2" "j!1") (("2" (ASSERT) (("2" (INST? -14) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "columns_mult" 1) (("1" (ASSERT) (("1" (REWRITE "entry_eq_0") (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "rows(newT) = rows(S)") (("1" (CASE "columns(newT) = rows(S)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (LEMMA "form_matrix_square") (("1" (INST?) (("1" (ASSERT) (("1" (SKOSIMP*) (("1" (INST - "i!1" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE -5 +) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REWRITE "rows_form_matrix") (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (TYPEPRED "dg") (("2" (ASSERT) (("2" (EXPAND "diagonal?") (("2" (SKOSIMP*) (("2" (INST - "i!1" "j!1") (("2" (INST - "i!1" "j!1") (("2" (ASSERT) (("2" (REWRITE "entry_eq_0" 3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|left_inv| SUBTYPE "matrices.*(matrix_inv.newT, matrix_inv.R)" "{Q: matrices.SquareMatrix(matrices.rows(matrix_inv.S)) | matrices.*(Q, matrix_inv.S) = matrices.Id(matrices.rows(matrix_inv.S))}")) (|left_inv_TCC3-3| "" 3750614367 ("" (SKEEP) (("" (SKEEP) (("" (CASE "diagonal?(dg`ans)") (("1" (LABEL "idz" -1) (("1" (HIDE "idz") (("1" (SKEEP) (("1" (CASE "NOT diagonal?(newT)") (("1" (HIDE 2) (("1" (REPLACE -3 +) (("1" (EXPAND "diagonal?") (("1" (SKOSIMP*) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "diagonal_simple_prod") (("2" (INST - "false" "rows(S)" "newT") (("1" (ASSERT) (("1" (SPLIT) (("1" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "full_matrix_eq") (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REPLACE -5 :DIR RL :HIDE? T) (("2" (TYPEPRED "newT * R") (("2" (HIDE -1) (("2" (TYPEPRED "newT") (("2" (HIDE -1) (("2" (EXPAND "columns" 1) (("2" (SPLIT -7) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL) ("2" (ASSERT) (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (GRIND) NIL NIL) ("2" (FLATTEN) (("2" (INST -6 "0") (("1" (EXPAND "nth" -6) (("1" (REPLACE -6) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REWRITE "rows_mult") (("3" (REWRITE "columns_mult" 1) (("1" (REPLACE -5 1) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "newT") (("2" (EXPAND "rows") (("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1) (("1" (EXPAND "length" -1 1) (("1" (REWRITE "length_rows" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REWRITE "rows_mult") (("4" (REPLACE -5) (("4" (REWRITE "rows_form_matrix") (("4" (HIDE-ALL-BUT 1) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "full_matrix_eq") (("1" (SPLIT) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (ASSERT) (("1" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "rows") (("2" (EXPAND "length" -2 1) (("2" (REWRITE "length_rows" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_mult") (("3" (LIFT-IF) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "*" + 1) (("1" (REWRITE "dot_eq_sigma") (("1" (REWRITE "length_row") (("1" (REPLACE -4) (("1" (REWRITE "length_col") (("1" (REWRITE "rows_mult") (("1" (EXPAND "min" 1) (("1" (REWRITE "entry_Id") (("1" (ASSERT) (("1" (REWRITE "columns_mult" -2) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "sigma_restrict_eq_0") (("1" (HIDE 3) (("1" (SKOSIMP*) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (CASE "i!1 = i!2") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 :DIR RL) (("1" (REPLACE -3) (("1" (REVEAL "idz") (("1" (EXPAND "diagonal?") (("1" (INST - "i!2" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "diagonal?") (("2" (INST - "i!1" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "j!1") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 1) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (SPLIT +) (("1" (FLATTEN) (("1" (LEMMA "det_upper_triangular_zero") (("1" (INST - "R*S") (("1" (ASSERT) (("1" (INST + "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (TYPEPRED "dg") (("2" (REVEAL "idz") (("2" (EXPAND "diagonal?") (("2" (INST - "i!2" "j!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "columns_mult" 1) (("1" (ASSERT) (("1" (REWRITE "entry_eq_0") (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "rows(newT) = rows(S)") (("1" (CASE "columns(newT) = rows(S)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (LEMMA "form_matrix_square") (("1" (INST?) (("1" (ASSERT) (("1" (SKOSIMP*) (("1" (INST - "i!1" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE -5 +) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REWRITE "rows_form_matrix") (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (TYPEPRED "dg") (("2" (ASSERT) (("2" (EXPAND "diagonal?") (("2" (SKOSIMP*) (("2" (INST - "i!1" "j!1") (("2" (INST - "i!1" "j!1") (("2" (ASSERT) (("2" (REWRITE "entry_eq_0" 3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|left_inv| SUBTYPE "matrices.*(matrix_inv.newT, matrix_inv.R)" "{Q: matrices.SquareMatrix(matrices.rows(matrix_inv.S)) | matrices.*(Q, matrix_inv.S) = matrices.Id(matrices.rows(matrix_inv.S))}")) (|left_inv_TCC3-2| |nil| 3615802147 ("" (SKEEP) (("" (SKEEP) (("" (CASE "diagonal?(dg`ans)") (("1" (LABEL "idz" -1) (("1" (HIDE "idz") (("1" (SKEEP) (("1" (CASE "NOT diagonal?(newT)") (("1" (HIDE 2) (("1" (REPLACE -3 +) (("1" (EXPAND "diagonal?") (("1" (SKOSIMP*) (("1" (REWRITE "entry_form_matrix") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE 3) (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "diagonal_simple_prod") (("2" (INST - "false" "rows(S)" "newT") (("1" (ASSERT) (("1" (SPLIT) (("1" (CASE "rows(newT) = rows(S) AND columns(newT) = rows(S)") (("1" (FLATTEN) (("1" (ASSERT) (("1" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "full_matrix_eq") (("1" (SPLIT) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (ASSERT) (("1" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "rows") (("2" (EXPAND "length" -2 1) (("2" (REWRITE "length_rows" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_mult") (("3" (LIFT-IF) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "*" + 1) (("1" (REWRITE "dot_eq_sigma") (("1" (REWRITE "length_row") (("1" (REPLACE -4) (("1" (REWRITE "length_col") (("1" (REWRITE "rows_mult") (("1" (EXPAND "min" 1) (("1" (REWRITE "entry_Id") (("1" (ASSERT) (("1" (REWRITE "columns_mult" -2) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "sigma_restrict_eq_0") (("1" (HIDE 3) (("1" (SKOSIMP*) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (CASE "i!1 = i!2") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 :DIR RL) (("1" (REPLACE -3) (("1" (REVEAL "idz") (("1" (EXPAND "diagonal?") (("1" (INST - "i!2" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "diagonal?") (("2" (INST - "i!1" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "j!1") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (TYPEPRED "dg") (("1" (ASSERT) (("1" (REPLACE -16 1) (("1" (REWRITE "entry_form_matrix") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT +) (("1" (FLATTEN) (("1" (LEMMA "det_upper_triangular_zero") (("1" (INST - "R*S") (("1" (ASSERT) (("1" (INST + "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (TYPEPRED "dg") (("2" (REVEAL "idz") (("2" (EXPAND "diagonal?") (("2" (INST - "i!2" "j!1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REWRITE "columns_mult" 1) (("1" (ASSERT) (("1" (REWRITE "entry_eq_0") (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "R") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "rows_mult") (("2" (ASSERT) (("2" (REPLACE -5 1) (("2" (REWRITE "rows_form_matrix") (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REWRITE "rows_mult") (("3" (REWRITE "columns_mult" 1) (("1" (REPLACE -5 1) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "newT") (("2" (EXPAND "rows") (("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1) (("1" (EXPAND "length" -1 1) (("1" (REWRITE "length_rows" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REWRITE "rows_mult") (("4" (REPLACE -5) (("4" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL) ("5" (REWRITE "columns_mult" 1) (("1" (ASSERT) NIL NIL) ("2" (LEMMA "rows_form_matrix") (("2" (INST?) (("1" (ASSERT) (("1" (EXPAND "rows" -1 1) (("1" (EXPAND "length" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "rows(newT) = rows(S)") (("1" (CASE "columns(newT) = rows(S)") (("1" (ASSERT) (("1" (FLATTEN) (("1" (LEMMA "form_matrix_square") (("1" (INST?) (("1" (ASSERT) (("1" (SKOSIMP*) (("1" (INST - "i!1" "j!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REPLACE -5 +) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("1" (ASSERT) NIL NIL) ("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 1) (("2" (REWRITE "rows_form_matrix") (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (TYPEPRED "dg") (("2" (ASSERT) (("2" (EXPAND "diagonal?") (("2" (SKOSIMP*) (("2" (INST - "i!1" "j!1") (("2" (INST - "i!1" "j!1") (("2" (ASSERT) (("2" (REWRITE "entry_eq_0" 3) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|left_inv| SUBTYPE "matrices.*(matrix_inv.newT, matrix_inv.R)" "{Q: matrices.SquareMatrix(matrices.rows(matrix_inv.S)) | matrices.*(Q, matrix_inv.S) = matrices.Id(matrices.rows(matrix_inv.S))}")) (|left_inv_TCC3-1| |nil| 3615726331 ("" (SKEEP) (("" (SKEEP) (("" (SKEEP) (("" (LABEL "newTname" -3) (("" (SPLIT +) (("1" (REWRITE "matrix_mult_assoc") (("1" (LABEL "Rname" -2) (("1" (TYPEPRED "dg") (("1" (REPLACE "Rname" :DIR RL) (("1" (ASSERT) (("1" (REPLACE -3) (("1" (REWRITE "full_matrix_eq" 1) (("1" (ASSERT) (("1" (CASE "NOT (rows(newT * dg`ans) = rows(Id(rows(S))) AND
        columns(newT * dg`ans) = columns(Id(rows(S))))") (("1" (HIDE 2) (("1" (REWRITE "rows_mult") (("1" (REWRITE "columns_mult") (("1" (ASSERT) (("1" (REPLACE "newTname" 1) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "newT") (("2" (EXPAND "length" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SKEEP) (("2" (TYPEPRED "i") (("2" (TYPEPRED "j") (("2" (ASSERT) (("2" (REWRITE "entry_Id" 1) (("2" (REWRITE "entry_mult" 1) (("2" (ASSERT) (("2" (CASE "NOT rows(newT)=rows(S)") (("1" (REPLACE "newTname" 1) (("1" (REWRITE "rows_form_matrix") (("1" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (EXPAND "*" 1) (("2" (REWRITE "dot_eq_sigma") (("2" (CASE "NOT columns(newT)=columns(S)") (("1" (ASSERT) (("1" (REPLACE "newTname" 1) (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "length_col" 1) (("2" (REWRITE "length_row" 1) (("1" (EXPAND "min") (("1" (ASSERT) (("1" (REPLACE -1) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (REWRITE "sigma_restrict_eq_0") (("1" (HIDE 3) (("1" (SKOSIMP*) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (CASE "i!1 = i") (("1" (INST - "i!1" "j") (("1" (POSTPONE) NIL NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL) ("4" (POSTPONE) NIL NIL) ("5" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (|left_inv| SUBTYPE "matrices.*(matrix_inv.newT, matrix_inv.R)" "{Q: matrices.SquareMatrix(matrices.rows(matrix_inv.S)) | matrices.*(Q, matrix_inv.S) = matrices.Id(matrices.rows(matrix_inv.S))}"))) (|mult_left_inv_right_TCC1| 0 (|mult_left_inv_right_TCC1-1| |nil| 3615802707 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|mult_left_inv_right| SUBTYPE "matrices.rows(matrix_inv.S)" "posnat"))) (|mult_left_inv_right| 0 (|mult_left_inv_right-1| |nil| 3615802708 ("" (SKEEP) (("" (TYPEPRED "left_inv(S)") (("" (CASE "NOT (left_inv(S) * S)*left_inv(S) = Id(rows(S))*left_inv(S)") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "mult_Id_left") (("2" (REWRITE "matrix_mult_assoc") (("1" (CASE "NOT det(left_inv(S))/=0") (("1" (FLATTEN) (("1" (CASE "NOT det(left_inv(S)*S) = det(Id(rows(S)))") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "det_mult") (("2" (REWRITE "det_Id") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "NOT left_inv(left_inv(S))*(left_inv(S) * (S * left_inv(S))) = left_inv(left_inv(S))*left_inv(S)") (("1" (ASSERT) NIL NIL) ("2" (LEMMA "matrix_mult_assoc") (("2" (INST - "S*left_inv(S)" "left_inv(left_inv(S))" "left_inv(S)") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1 :DIR RL) (("1" (TYPEPRED "left_inv(left_inv(S))") (("1" (REPLACE -7) (("1" (REWRITE "mult_Id_left") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL NIL)) NIL) ("3" (REWRITE "rows_mult") (("3" (ASSERT) (("3" (REWRITE "columns_mult") (("3" (TYPEPRED "S") (("3" (EXPAND "rows") (("3" (ASSERT) (("3" (EXPAND "length") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "left_inv(S)") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "S") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|left_inv| CONST-DECL "{Q: SquareMatrix(rows(S)) | Q * S = Id(rows(S))}" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|mult_Id_left| FORMULA-DECL NIL |matrices| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|matrix_mult_assoc| FORMULA-DECL NIL |matrices| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL)) SHOSTAK)) (|invertible?_TCC1| 0 (|invertible?_TCC1-1| |nil| 3615800573 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL)) NIL (|invertible?| SUBTYPE "matrices.rows(matrix_inv.SQ)" "posnat"))) (|invertible_rew| 0 (|invertible_rew-1| |nil| 3615803598 ("" (SKEEP) (("" (EXPAND "invertible?") (("" (GROUND) (("1" (SKOSIMP*) (("1" (INST + "IQ!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (INST + "left_inv(SQ)") (("2" (ASSERT) (("2" (TYPEPRED "left_inv(SQ)") (("2" (ASSERT) (("2" (REWRITE "mult_left_inv_right") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (INST + "IQ!1") (("3" (ASSERT) (("3" (CASE "IQ!1 = left_inv(SQ)") (("1" (REPLACES -1) (("1" (REWRITE "mult_left_inv_right") (("1" (FLATTEN) (("1" (LEMMA "det_mult") (("1" (INST - "SQ" "left_inv(SQ)") (("1" (ASSERT) (("1" (TYPEPRED "left_inv(SQ)") (("1" (REPLACE -7) (("1" (REWRITE "det_Id") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "NOT (IQ!1 * SQ)*left_inv(SQ) = Id(rows(SQ))*left_inv(SQ)") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "matrix_mult_assoc" -1) (("1" (REWRITE "mult_left_inv_right") (("1" (REWRITE "mult_Id_left") (("1" (REWRITE "mult_Id_right") NIL NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "det_mult") (("2" (INST - "SQ" "IQ!1") (("2" (ASSERT) (("2" (LEMMA "det_Id") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "SQ") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (LEMMA "det_mult") (("3" (INST - "SQ" "IQ!1") (("3" (ASSERT) (("3" (LEMMA "det_Id") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (INST + "IQ") (("4" (ASSERT) (("4" (CASE "det(IQ)=0") (("1" (ASSERT) (("1" (LEMMA "det_mult") (("1" (INST - "IQ" "SQ") (("1" (ASSERT) (("1" (LEMMA "det_Id") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "SQ = left_inv(IQ)") (("1" (REPLACES -1) (("1" (REWRITE "mult_left_inv_right") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "NOT left_inv(SQ)*(SQ*IQ) = left_inv(SQ)*Id(rows(SQ))") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "matrix_mult_assoc" :DIR RL) (("1" (TYPEPRED "left_inv(SQ)") (("1" (REPLACE -7) (("1" (REWRITE "mult_Id_left") (("1" (REWRITE "mult_Id_right") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "SQ") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (ASSERT) (("3" (LEMMA "det_mult") (("3" (INST - "IQ" "SQ") (("3" (ASSERT) (("3" (LEMMA "det_Id") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|mult_Id_right| FORMULA-DECL NIL |matrices| NIL) (|mult_Id_left| FORMULA-DECL NIL |matrices| NIL) (|matrix_mult_assoc| FORMULA-DECL NIL |matrices| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|left_inv| CONST-DECL "{Q: SquareMatrix(rows(S)) | Q * S = Id(rows(S))}" |matrix_inv| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|mult_left_inv_right| FORMULA-DECL NIL |matrix_inv| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|inverse_TCC1| 0 (|inverse_TCC1-1| |nil| 3614960158 ("" (SKEEP) (("" (TYPEPRED "SQ") (("" (ASSERT) (("" (EXPAND "invertible?") (("" (SKEEP) (("" (LEMMA "det_mult") (("" (INST - "IQ" "SQ") (("" (ASSERT) (("" (LEMMA "det_Id") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|inverse| SUBTYPE "matrix_inv.SQ" "{S | matrix_props.det(matrix_inv.S) /= 0}"))) (|inverse_TCC2| 0 (|inverse_TCC2-1| |nil| 3615726331 ("" (SKEEP) (("" (ASSERT) (("" (TYPEPRED "left_inv(SQ)") (("1" (ASSERT) (("1" (REWRITE "mult_left_inv_right") (("1" (TYPEPRED "SQ") (("1" (ASSERT) (("1" (EXPAND "invertible?") (("1" (SKEEP) (("1" (ASSERT) (("1" (LEMMA "det_mult") (("1" (ASSERT) (("1" (INST - "IQ" "SQ") (("1" (ASSERT) (("1" (LEMMA "det_Id") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (TYPEPRED "SQ") (("2" (ASSERT) (("2" (EXPAND "invertible?") (("2" (SKEEP) (("2" (LEMMA "det_mult") (("2" (INST - "IQ" "SQ") (("2" (ASSERT) (("2" (LEMMA "det_Id") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|mult_left_inv_right| FORMULA-DECL NIL |matrix_inv| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|left_inv| CONST-DECL "{Q: SquareMatrix(rows(S)) | Q * S = Id(rows(S))}" |matrix_inv| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL)) NIL (|inverse| SUBTYPE "matrix_inv.left_inv(matrix_inv.SQ)" "{IQ | booleans.AND(matrices.rows(matrix_inv.IQ) = matrices.rows(matrix_inv.SQ), booleans.AND(matrices.*(matrix_inv.IQ, matrix_inv.SQ) = matrices.Id(matrices.rows(matrix_inv.SQ)), matrices.*(matrix_inv.SQ, matrix_inv.IQ) = matrices.Id(matrices.rows(matrix_inv.SQ))))}"))) (|mult_inverse_left_TCC1| 0 (|mult_inverse_left_TCC1-1| |nil| 3614960158 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|mult| CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|rows| CONST-DECL "nat" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|mult_inverse_left| SUBTYPE "matrix_inv.SQ" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|mult_inverse_left_TCC2| 0 (|mult_inverse_left_TCC2-1| |nil| 3615638749 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|mult| CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|rows| CONST-DECL "nat" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|mult_inverse_left| SUBTYPE "matrices.rows(matrix_inv.SQ)" "posnat"))) (|mult_inverse_left| 0 (|mult_inverse_left-1| |nil| 3615804506 ("" (SKEEP) (("" (ASSERT) NIL NIL)) NIL) ((|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL)) SHOSTAK)) (|mult_inverse_right| 0 (|mult_inverse_right-1| |nil| 3615804514 ("" (SKEEP) (("" (ASSERT) NIL NIL)) NIL) ((|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL)) SHOSTAK)) (|inverse_unique| 0 (|inverse_unique-1| |nil| 3615804524 ("" (SKEEP) (("" (ASSERT) (("" (REWRITE "invertible_rew") (("" (GROUND) (("1" (INST + "IQ") (("1" (ASSERT) NIL NIL)) NIL) ("2" (LEMMA "det_mult") (("2" (INST - "SQ" "IQ") (("2" (ASSERT) (("2" (LEMMA "det_Id") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (CASE "NOT (IQ*SQ)*inverse(SQ)=Id(rows(SQ))*inverse(SQ)") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "mult_inverse_right") (("1" (REWRITE "mult_Id_right") (("1" (REWRITE "mult_Id_left") NIL NIL)) NIL) ("2" (REWRITE "invertible_rew") (("2" (FLATTEN) (("2" (INST + "IQ") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "SQ") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (CASE "NOT (IQ*SQ)*inverse(SQ) = Id(rows(SQ))*inverse(SQ)") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "mult_inverse_right") (("1" (REWRITE "mult_Id_right") (("1" (REWRITE "mult_Id_left") (("1" (REPLACES -1) (("1" (REWRITE "mult_inverse_right") NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "invertible_rew") (("2" (FLATTEN) (("2" (INST + "IQ") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "SQ") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (FLATTEN) (("3" (ASSERT) (("3" (LEMMA "det_mult") (("3" (INST - "SQ" "IQ") (("3" (ASSERT) (("3" (LEMMA "det_Id") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (LEMMA "det_mult") (("5" (INST - "IQ" "SQ") (("5" (ASSERT) (("5" (LEMMA "det_Id") (("5" (INST?) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (LEMMA "det_mult") (("6" (INST - "IQ" "SQ") (("6" (ASSERT) (("6" (LEMMA "det_Id") (("6" (INST?) (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (CASE "NOT inverse(SQ)*(SQ*IQ)=inverse(SQ)*Id(rows(SQ))") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "matrix_mult_assoc" :DIR RL) (("1" (REWRITE "mult_inverse_left") (("1" (REWRITE "mult_Id_left") (("1" (REWRITE "mult_Id_right") NIL NIL)) NIL) ("2" (REWRITE "invertible_rew") (("2" (FLATTEN) (("2" (INST 2 "IQ") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "SQ") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (CASE "det(SQ) = 0") (("1" (LEMMA "det_mult") (("1" (INST - "IQ" "SQ") (("1" (ASSERT) (("1" (LEMMA "det_Id") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "NOT inverse(SQ)*(SQ*IQ)=inverse(SQ)*Id(rows(SQ))") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "matrix_mult_assoc" :DIR RL) (("1" (REWRITE "mult_Id_right") (("1" (REWRITE "mult_inverse_left") (("1" (REWRITE "mult_Id_left") (("1" (REPLACE -1) (("1" (REWRITE "mult_inverse_left") NIL NIL)) NIL)) NIL) ("2" (REWRITE "invertible_rew") NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "SQ") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|matrix_mult_assoc| FORMULA-DECL NIL |matrices| NIL) (|mult_Id_right| FORMULA-DECL NIL |matrices| NIL) (|mult_Id_left| FORMULA-DECL NIL |matrices| NIL) (|mult_inverse_right| FORMULA-DECL NIL |matrix_inv| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|mult_inverse_left| FORMULA-DECL NIL |matrix_inv| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|invertible_rew| FORMULA-DECL NIL |matrix_inv| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|invertible_det| 0 (|invertible_det-1| |nil| 3615805638 ("" (SKEEP) (("" (REWRITE "invertible_rew") (("" (GROUND) (("1" (SKEEP) (("1" (LEMMA "det_mult") (("1" (INST?) (("1" (ASSERT) (("1" (LEMMA "det_Id") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "det_mult") (("2" (INST?) (("2" (ASSERT) (("2" (LEMMA "det_Id") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|invertible_rew| FORMULA-DECL NIL |matrix_inv| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL)) SHOSTAK)) (|invertible_mult_TCC1| 0 (|invertible_mult_TCC1-1| |nil| 3615806004 ("" (SKEEP) (("" (REWRITE "rows_mult") (("" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "S") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL)) NIL (|invertible_mult| SUBTYPE "matrices.*(matrix_inv.S, matrix_inv.R)" "Square"))) (|invertible_mult| 0 (|invertible_mult-1| |nil| 3615806004 ("" (SKEEP) (("" (REWRITE "det_mult") (("" (LEMMA "nzreal_times_nzreal_is_nzreal") (("" (CASE "FORALL (rr,ss:real): rr*ss=0 IFF (rr=0 OR ss=0)") (("1" (INST?) (("1" (HIDE -2) (("1" (LEMMA "invertible_det") (("1" (INST-CP - "S") (("1" (INST - "R") (("1" (LEMMA "invertible_det") (("1" (INST - "S*R") (("1" (LEMMA "det_mult") (("1" (INST?) (("1" (ASSERT) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "rows_mult") (("2" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "S") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND-REALS) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (S SKOLEM-CONST-DECL "Square" |matrix_inv| NIL) (R SKOLEM-CONST-DECL "Square" |matrix_inv| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|zero_times3| FORMULA-DECL NIL |real_props| NIL) (|nzreal_times_nzreal_is_nzreal| JUDGEMENT-TCC NIL |real_types| NIL)) SHOSTAK)) (|inverse_mult_TCC1| 0 (|inverse_mult_TCC1-1| |nil| 3615805789 ("" (SKEEP) (("" (ASSERT) (("" (LEMMA "det_mult") (("" (INST - "R" "S") (("" (ASSERT) (("" (REWRITE "invertible_det") (("" (REWRITE "invertible_det") (("" (REWRITE "invertible_det") (("1" (ASSERT) (("1" (CASE "FORALL (izb:bool): (izb OR izb) = izb") (("1" (REWRITE -1) (("1" (REWRITE -1) (("1" (REWRITE -1) (("1" (HIDE -1) (("1" (LEMMA "nzreal_times_nzreal_is_nzreal") (("1" (INST - "det(S)" "det(R)") (("1" (REWRITE "rows_mult") (("1" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "S") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (IFF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (REWRITE "rows_mult") (("2" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "S") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (S SKOLEM-CONST-DECL "Square" |matrix_inv| NIL) (R SKOLEM-CONST-DECL "Square" |matrix_inv| NIL) (|nzreal| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|nzreal_times_nzreal_is_nzreal| JUDGEMENT-TCC NIL |real_types| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL)) NIL (|inverse_mult| SUBTYPE "matrices.*(matrix_inv.S, matrix_inv.R)" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|inverse_mult| 0 (|inverse_mult-1| |nil| 3615805789 ("" (SKEEP) (("" (LEMMA "inverse_unique") (("" (INST - "inverse(R)*inverse(S)" "S*R") (("1" (ASSERT) (("1" (HIDE 2) (("1" (REWRITE "rows_mult") (("1" (REWRITE "rows_mult") (("1" (ASSERT) (("1" (REWRITE "matrix_mult_assoc" :DIR RL) (("1" (REWRITE "matrix_mult_assoc") (("1" (REWRITE "mult_inverse_left") (("1" (REWRITE "mult_Id_right") (("1" (REWRITE "mult_inverse_left") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REWRITE "invertible_det" 1) NIL NIL)) NIL) ("2" (TYPEPRED "inverse(S)") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "S") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REWRITE "rows_mult") (("2" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "inverse(R)") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|inverse_unique| FORMULA-DECL NIL |matrix_inv| NIL) (|columns_mult| FORMULA-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL) (|mult_Id_right| FORMULA-DECL NIL |matrices| NIL) (|mult_inverse_left| FORMULA-DECL NIL |matrix_inv| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|matrix_mult_assoc| FORMULA-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (<= CONST-DECL "bool" |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (R SKOLEM-CONST-DECL "Square" |matrix_inv| NIL) (S SKOLEM-CONST-DECL "Square" |matrix_inv| NIL)) SHOSTAK)) (|det_inverse_TCC1| 0 (|det_inverse_TCC1-1| |nil| 3615806915 ("" (SKEEP) (("" (ASSERT) (("" (REWRITE "invertible_det") NIL NIL)) NIL)) NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL)) NIL (|det_inverse| SUBTYPE "matrix_props.det(matrix_inv.S)" "nznum"))) (|det_inverse| 0 (|det_inverse-1| |nil| 3615806916 ("" (SKEEP) (("" (LEMMA "mult_inverse_left") (("" (INST?) (("" (SPLIT -1) (("1" (ASSERT) (("1" (LEMMA "det_mult") (("1" (INST?) (("1" (ASSERT) (("1" (LEMMA "det_Id") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REWRITE "invertible_det") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult_inverse_left| FORMULA-DECL NIL |matrix_inv| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (|inverse_invertible| 0 (|inverse_invertible-1| |nil| 3615807168 ("" (SKEEP) (("" (ASSERT) (("" (REWRITE "invertible_det" 1) (("" (REWRITE "det_inverse") (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|det_inverse| FORMULA-DECL NIL |matrix_inv| NIL) (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL)) SHOSTAK)) (|inverse_inverse_TCC1| 0 (|inverse_inverse_TCC1-1| |nil| 3615807119 ("" (SKEEP) (("" (REWRITE "invertible_det") (("" (REWRITE "invertible_det") (("" (REWRITE "det_inverse") (("1" (GROUND) NIL NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|invertible_det| FORMULA-DECL NIL |matrix_inv| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|det_inverse| FORMULA-DECL NIL |matrix_inv| NIL) (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (|inverse_inverse| SUBTYPE "matrix_inv.inverse(matrix_inv.S)" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (|inverse_inverse| 0 (|inverse_inverse-1| |nil| 3615807120 ("" (SKEEP) (("" (LEMMA "inverse_unique") (("" (INST - "S" "inverse(S)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|inverse_unique| FORMULA-DECL NIL |matrix_inv| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (GH_TCC1 0 (GH_TCC1-1 |nil| 3615807808 ("" (SUBTYPE-TCC) NIL NIL) ((/= CONST-DECL "boolean" |notequal| NIL)) NIL (GH SUBTYPE "2" "{i_1: integers.int | booleans.OR(matrix_inv.i /= 0, reals.>=(i_1, 0))}"))) (GH_TCC2 0 (GH_TCC2-1 |nil| 3615807808 ("" (SUBTYPE-TCC) NIL NIL) ((/= CONST-DECL "boolean" |notequal| NIL)) NIL (GH SUBTYPE "3" "{i: integers.int | booleans.OR(matrix_inv.j /= 0, reals.>=(i, 0))}"))) (GH_TCC3 0 (GH_TCC3-2 "" 3790097254 ("" (SKEEP) (("" (LEMMA "columns_form_matrix") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|columns_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK (GH SUBTYPE "3" "{i_1: integers.int | booleans.OR(matrix_inv.i /= 0, reals.>=(i_1, 0))}")) (GH_TCC3-1 |nil| 3615807808 ("" (SKEEP) (("" (REWRITE "rows_form_matrix") (("" (LEMMA "columns_form_matrix") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL (GH SUBTYPE "3" "{i_1: integers.int | booleans.OR(matrix_inv.i /= 0, reals.>=(i_1, 0))}"))) (GH_TCC4 0 (GH_TCC4-1 |nil| 3615808555 ("" (SKEEP) (("" (REWRITE "rows_form_matrix") (("" (LEMMA "columns_form_matrix") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|rows_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|rat_plus_rat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|posrat_div_posrat_is_posrat| APPLICATION-JUDGEMENT "posrat" |rationals| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nat_exp| APPLICATION-JUDGEMENT "nat" |exponentiation| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posrat_exp| APPLICATION-JUDGEMENT "posrat" |exponentiation| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|columns_form_matrix| FORMULA-DECL NIL |matrices| NIL)) NIL (GH SUBTYPE "matrices.form_matrix(LAMBDA (i, j): IF reals.<(matrix_inv.i, matrix_inv.j) THEN (number_fields.+)((number_fields.+)(exponentiation.^(matrix_inv.i, 2), exponentiation.^(matrix_inv.j, 3)), 3) ELSE (number_fields.+)((number_fields.+)((number_fields.-)(number_fields.*(matrix_inv.i, matrix_inv.j), 2), exponentiation.^(matrix_inv.i, 3)), exponentiation.^((number_fields./(1, 10)), matrix_inv.i)) ENDIF, matrix_inv.pn, matrix_inv.pn)" "Square"))) (|det_nonzero_simple_prod| 0 (|det_nonzero_simple_prod-6| "" 3758876442 ("" (SKEEP) (("" (LEMMA "inverse_inverse") (("" (INST?) (("" (ASSERT) (("" (EXPAND "inverse" -1 1) (("" (EXPAND "left_inv") (("" (CASE "FORALL (i:nat): i<rows(S) IMPLIES entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                  inverse(S))
                                                                                (i, i)/=0") (("1" (NAME "FG" "LAMBDA (FF:[nat->real]): (LAMBDA (i,j:nat): IF i/=j THEN 0 ELSE FF(i) ENDIF)") (("1" (CASE "FORALL (FF:[nat->real],n:nat): (FORALL (i:nat): i<n+1 IMPLIES FF(i)/=0) IMPLIES is_simple_prod?(n+1,TRUE,FALSE)(form_matrix(FG(FF),n+1,n+1))") (("1" (NAME "FFZ" "LAMBDA (i:nat): IF i>=rows(S) OR entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                   inverse(S))(i,i)=0 THEN 0 ELSE 1/entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                   inverse(S))(i,i) ENDIF") (("1" (NAME "G5" "FG(FFZ)") (("1" (CASE "(LAMBDA (i, j):
                                                                                                  IF i /= j OR
                                                                                                      entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                             inverse(S))
                                                                                                           (i, i)
                                                                                                       = 0
                                                                                                    THEN 0
                                                                                                  ELSE 1 /
                                                                                                        entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                               inverse(S))
                                                                                                             (i, i)
                                                                                                  ENDIF) = G5") (("1" (REPLACE -1) (("1" (REPLACE -7 2 :DIR RL) (("1" (REWRITE "mult_simple_prod") (("1" (HIDE 3) (("1" (REWRITE "rows_mult" 1) (("1" (REWRITE "rows_form_matrix") (("1" (EXPAND "G5" 1) (("1" (REWRITE -4 1) (("1" (HIDE 2) (("1" (SKOSIMP*) (("1" (EXPAND "FFZ" -2) (("1" (ASSERT) (("1" (INST -8 "i!1") (("1" (ASSERT) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (REWRITE "rows_mult") (("2" (REWRITE "rows_form_matrix") (("2" (TYPEPRED "diag(true,false,inverse(S))") (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-4 1)) (("2" (LEMMA "is_simple_prod_implic") (("2" (INST - "false" "false" "rows(inverse(S))" "diag(TRUE, FALSE, inverse(S))`multip" "true" "false") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 3) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "G5") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FFZ" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (INST -5 "x!1") (("1" (ASSERT) (("1" (CASE "x!1/=x!2") (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "entry_eq_0" 1) (("1" (FLATTEN) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "entry_eq_0" 2) (("2" (FLATTEN) (("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("3" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (SKEEP) (("2" (EXPAND "is_simple_prod?") (("2" (NAME "FMG" "LAMBDA (i:nat): Esr(1+n)(i,FF(i))") (("2" (INST + "FMG" "n") (("2" (ASSERT) (("2" (SPLIT 1) (("1" (EXPAND "is_simple_seq?") (("1" (SKEEP) (("1" (INST + "p" "FF(p)") (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (CASE "p < 1+n") (("1" (ASSERT) (("1" (EXPAND "FMG" 3) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REWRITE "full_matrix_eq" 2) (("2" (SKOSIMP*) (("2" (REWRITE "entry_Esr") (("2" (REWRITE "entry_Id") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "full_matrix_eq" 1) (("2" (SPLIT) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL)) NIL) ("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (CASE "FORALL (k:nat): FORALL (ii,jj:nat): ii<1+n AND jj<1+n AND k<=n IMPLIES entry(prod_mat(1+n)(FMG,k))(ii,jj) = IF ii=jj AND ii<=k THEN FF(ii) ELSIF ii=jj THEN 1 ELSE 0 ENDIF") (("1" (INST - "n") (("1" (INST?) (("1" (ASSERT) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "entry_form_matrix") (("1" (EXPAND "FG" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (GROUND) (("1" (TYPEPRED "i!1") (("1" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("2" (TYPEPRED "i!1") (("2" (REWRITE "rows_form_matrix") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i!1") (("2" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("3" (ASSERT) (("3" (TYPEPRED "j!1") (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (SKEEP) (("1" (ASSERT) (("1" (EXPAND "prod_mat" 1) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (SKEEP) (("2" (ASSERT) (("2" (EXPAND "prod_mat" +) (("2" (REWRITE "entry_mult") (("2" (ASSERT) (("2" (EXPAND "*" + 1) (("2" (REWRITE "dot_eq_sigma") (("2" (REWRITE "length_row") (("1" (REWRITE "length_col") (("1" (ASSERT) (("1" (EXPAND "FMG" 1 1) (("1" (ASSERT) (("1" (TYPEPRED "prod_mat(1 + n)
                                (LAMBDA (i: nat): Esr(1 + n)(i, FF(i)), j)") (("1" (HIDE (-1 -2)) (("1" (REPLACE -3 :DIR RL) (("1" (REPLACE -4) (("1" (ASSERT) (("1" (EXPAND "FMG" 1 1) (("1" (REWRITE "rows_Esr") (("1" (ASSERT) (("1" (EXPAND "min") (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LEMMA "sigma_eq_one_arg2") (("1" (INST?) (("1" (INST - "ii") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (INST - "ii" "ii") (("1" (ASSERT) (("1" (REPLACES -7 1) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr" 1) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (INST - "ii" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "ii") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (INST - "ii" "ii") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES -5) (("1" (EXPAND "FMG" +) (("1" (REWRITE "entry_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (INST - "ii" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (REWRITE "sigma_restrict_eq_0") (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (ASSERT) (("2" (INST - "ii" "i!2") (("2" (ASSERT) (("2" (REPLACE -5) (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (ASSERT) (("1" (REWRITE "entry_Esr") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "det_inverse") (("2" (INST - "S") (("2" (ASSERT) (("2" (CASE "det(inverse(S))=0") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (TYPEPRED "diag(TRUE, FALSE, inverse(S))") (("2" (REPLACE -3) (("2" (ASSERT) (("2" (INST -6 "i" "i") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|inverse_inverse| FORMULA-DECL NIL |matrix_inv| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|left_inv| CONST-DECL "{Q: SquareMatrix(rows(S)) | Q * S = Id(rows(S))}" |matrix_inv| NIL) (|det_inverse| FORMULA-DECL NIL |matrix_inv| NIL) (|Esr| CONST-DECL "SquareMatrix(pn)" |matrix_det| NIL) (|prod_mat| DEF-DECL "SquareMatrix(pn)" |matrix_det| NIL) (|entry_mult| FORMULA-DECL NIL |matrices| NIL) (|length_row| FORMULA-DECL NIL |matrices| NIL) (|nat_min| APPLICATION-JUDGEMENT "{k: nat | k <= i AND k <= j}" |real_defs| NIL) (|sigma_restrict_eq_0| FORMULA-DECL NIL |sigma| |reals|) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|access| CONST-DECL "real" |matrices| NIL) (|T_high| TYPE-EQ-DECL NIL |sigma| |reals|) (|T_low| TYPE-EQ-DECL NIL |sigma| |reals|) (|subrange| TYPE-EQ-DECL NIL |integers| NIL) (|access_col| FORMULA-DECL NIL |matrices| NIL) (|access_row| FORMULA-DECL NIL |matrices| NIL) (|sigma_eq_one_arg2| FORMULA-DECL NIL |sigma| |reals|) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|rows_Esr| FORMULA-DECL NIL |matrix_det| NIL) (|length_col| FORMULA-DECL NIL |matrices| NIL) (|sigma| DEF-DECL "real" |sigma| |reals|) (|array2list_it| DEF-DECL "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" |array2list| |structures|) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|dot_eq_sigma| FORMULA-DECL NIL |matrices| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|entry_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|is_simple_seq?| CONST-DECL "bool" |matrix_det| NIL) (FMG SKOLEM-CONST-DECL "[nat -> SquareMatrix(1 + n)]" |matrix_inv| NIL) (|entry_Id| FORMULA-DECL NIL |matrices| NIL) (|entry_Esr| FORMULA-DECL NIL |matrix_det| NIL) (|full_matrix_eq| FORMULA-DECL NIL |matrices| NIL) (|nzreal_div_nzreal_is_nzreal| APPLICATION-JUDGEMENT "nzreal" |real_types| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|columns_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|is_simple_prod_implic| FORMULA-DECL NIL |matrix_det| NIL) (|rows_form_matrix| FORMULA-DECL NIL |matrices| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (FFZ SKOLEM-CONST-DECL "[nat -> real]" |matrix_inv| NIL) (G5 SKOLEM-CONST-DECL "[[nat, nat] -> real]" |matrix_inv| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|mult_simple_prod| FORMULA-DECL NIL |matrix_det| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|entry_eq_0| FORMULA-DECL NIL |matrices| NIL) (FG SKOLEM-CONST-DECL "[[nat -> real] -> [[nat, nat] -> real]]" |matrix_inv| NIL) (S SKOLEM-CONST-DECL "Square" |matrix_inv| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|form_matrix_square| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|upper_triangular?| CONST-DECL "bool" |matrix_det| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|is_simple_prod?| CONST-DECL "bool" |matrix_det| NIL) (FALSE CONST-DECL "bool" |booleans| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|diag| CONST-DECL "{SGI:
   [# ans: SquareMatrix(rows(S)),
      multip: SquareMatrix(rows(S)),
      inv: SquareMatrix(rows(S)) #] |
        upper_triangular?(SGI`ans)
    AND (FORALL (k, p):
           k < rows(S) AND p < rows(S) AND entry(SGI`ans)(k, p) /= 0
            IMPLIES (k = p OR (k < p AND entry(SGI`ans)(p, p) = 0)))
    AND (comp_matrix IMPLIES
          SGI`multip * S = SGI`ans AND
           is_simple_prod?(rows(S), FALSE, FALSE)(SGI`multip))
    AND (comp_matrix AND comp_inverse IMPLIES
          (SGI`inv * SGI`multip = Id(rows(S)) AND
            SGI`multip * SGI`inv = Id(rows(S)) AND
             is_simple_prod?(rows(S), FALSE, FALSE)(SGI`inv)))
    AND (det(SGI`ans) = det(S))
    AND (det(S) /= 0 IFF
          (FORALL (k, p):
             k < rows(S) AND p < rows(S) IMPLIES
              (entry(SGI`ans)(k, p) /= 0 IFF k = p)))}" |matrix_diag| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK) (|det_nonzero_simple_prod-5| "" 3755410702 ("" (SKEEP) (("" (LEMMA "inverse_inverse") (("" (INST?) (("" (ASSERT) (("" (EXPAND "inverse" -1 1) (("" (EXPAND "left_inv") (("" (CASE "FORALL (i:nat): i<rows(S) IMPLIES entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                  inverse(S))
                                                                                (i, i)/=0") (("1" (NAME "FG" "LAMBDA (FF:[nat->real]): (LAMBDA (i,j:nat): IF i/=j THEN 0 ELSE FF(i) ENDIF)") (("1" (CASE "FORALL (FF:[nat->real],n:nat): (FORALL (i:nat): i<n+1 IMPLIES FF(i)/=0) IMPLIES is_simple_prod?(n+1,TRUE,FALSE)(form_matrix(FG(FF),n+1,n+1))") (("1" (NAME "FFZ" "LAMBDA (i:nat): IF i>=rows(S) OR entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                   inverse(S))(i,i)=0 THEN 0 ELSE 1/entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                   inverse(S))(i,i) ENDIF") (("1" (NAME "G5" "FG(FFZ)") (("1" (CASE "(LAMBDA (i, j):
                                                                                                  IF i /= j OR
                                                                                                      entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                             inverse(S))
                                                                                                           (i, i)
                                                                                                       = 0
                                                                                                    THEN 0
                                                                                                  ELSE 1 /
                                                                                                        entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                               inverse(S))
                                                                                                             (i, i)
                                                                                                  ENDIF) = G5") (("1" (REPLACE -1) (("1" (REPLACE -7 2 :DIR RL) (("1" (REWRITE "mult_simple_prod") (("1" (HIDE 3) (("1" (REWRITE "rows_mult" 1) (("1" (REWRITE "rows_form_matrix") (("1" (EXPAND "G5" 1) (("1" (REWRITE -4 1) (("1" (HIDE 2) (("1" (SKOSIMP*) (("1" (EXPAND "FFZ" -2) (("1" (ASSERT) (("1" (INST -8 "i!1") (("1" (ASSERT) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (REWRITE "rows_mult") (("2" (REWRITE "rows_form_matrix") (("2" (TYPEPRED "diag(true,false,inverse(S))") (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-4 1)) (("2" (LEMMA "is_simple_prod_implic") (("2" (INST - "false" "false" "rows(inverse(S))" "diag(TRUE, FALSE, inverse(S))`multip" "true" "false") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 3) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "G5") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FFZ" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (INST -5 "x!1") (("1" (ASSERT) (("1" (CASE "x!1/=x!2") (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "entry_eq_0" 1) (("1" (FLATTEN) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "entry_eq_0" 2) (("2" (FLATTEN) (("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("3" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (SKEEP) (("2" (EXPAND "is_simple_prod?") (("2" (NAME "FMG" "LAMBDA (i:nat): Esr(1+n)(i,FF(i))") (("2" (INST + "FMG" "n") (("2" (ASSERT) (("2" (SPLIT 1) (("1" (EXPAND "is_simple_seq?") (("1" (SKEEP) (("1" (INST + "p" "FF(p)") (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (CASE "p < 1+n") (("1" (ASSERT) (("1" (EXPAND "FMG" 3) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REWRITE "full_matrix_eq" 2) (("2" (SKOSIMP*) (("2" (REWRITE "entry_Esr") (("2" (REWRITE "entry_Id") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "full_matrix_eq" 1) (("2" (SPLIT) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL)) NIL) ("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (CASE "FORALL (k:nat): FORALL (ii,jj:nat): ii<1+n AND jj<1+n AND k<=n IMPLIES entry(prod_mat(1+n)(FMG,k))(ii,jj) = IF ii=jj AND ii<=k THEN FF(ii) ELSIF ii=jj THEN 1 ELSE 0 ENDIF") (("1" (INST - "n") (("1" (INST?) (("1" (ASSERT) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "entry_form_matrix") (("1" (EXPAND "FG" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (GROUND) (("1" (TYPEPRED "i!1") (("1" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("2" (TYPEPRED "i!1") (("2" (REWRITE "rows_form_matrix") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i!1") (("2" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("3" (ASSERT) (("3" (TYPEPRED "j!1") (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (SKEEP) (("1" (ASSERT) (("1" (EXPAND "prod_mat" 1) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (SKEEP) (("2" (ASSERT) (("2" (EXPAND "prod_mat" +) (("2" (REWRITE "entry_mult") (("2" (ASSERT) (("2" (EXPAND "*" + 1) (("2" (REWRITE "dot_eq_sigma") (("2" (REWRITE "length_row") (("2" (REWRITE "length_col") (("2" (ASSERT) (("2" (EXPAND "FMG" 1 1) (("2" (ASSERT) (("2" (TYPEPRED "prod_mat(1 + n)
                                (LAMBDA (i: nat): Esr(1 + n)(i, FF(i)), j)") (("2" (HIDE (-1 -2)) (("2" (REPLACE -3 :DIR RL) (("2" (REPLACE -4) (("2" (ASSERT) (("2" (EXPAND "FMG" 1 1) (("2" (REWRITE "rows_Esr") (("2" (ASSERT) (("2" (EXPAND "min") (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (LEMMA "sigma_eq_one_arg2") (("1" (INST?) (("1" (INST - "ii") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (INST - "ii" "ii") (("1" (ASSERT) (("1" (REPLACES -7 1) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "access_row") (("1" (REWRITE "entry_Esr" 1) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (INST - "ii" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "ii") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (INST - "ii" "ii") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES -5) (("1" (EXPAND "FMG" +) (("1" (REWRITE "access_row") (("1" (REWRITE "entry_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (INST - "ii" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (REWRITE "sigma_restrict_eq_0") (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (ASSERT) (("2" (INST - "ii" "i!2") (("2" (ASSERT) (("2" (REPLACE -5) (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (ASSERT) (("1" (REWRITE "access_row") (("1" (REWRITE "entry_Esr") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "access_row") (("1" (REWRITE "entry_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "det_inverse") (("2" (INST - "S") (("2" (ASSERT) (("2" (CASE "det(inverse(S))=0") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (TYPEPRED "diag(TRUE, FALSE, inverse(S))") (("2" (REPLACE -3) (("2" (ASSERT) (("2" (INST -6 "i" "i") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|det_nonzero_simple_prod-4| |nil| 3616760142 ("" (SKEEP) (("" (LEMMA "inverse_inverse") (("" (INST?) (("" (ASSERT) (("" (EXPAND "inverse" -1 1) (("" (EXPAND "left_inv") (("" (CASE "FORALL (i:nat): i<rows(S) IMPLIES entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                  inverse(S))
                                                                                (i, i)/=0") (("1" (NAME "FG" "LAMBDA (FF:[nat->real]): (LAMBDA (i,j:nat): IF i/=j THEN 0 ELSE FF(i) ENDIF)") (("1" (CASE "FORALL (FF:[nat->real],n:nat): (FORALL (i:nat): i<n+1 IMPLIES FF(i)/=0) IMPLIES is_simple_prod?(n+1,TRUE,FALSE)(form_matrix(FG(FF),n+1,n+1))") (("1" (NAME "FFZ" "LAMBDA (i:nat): IF i>=rows(S) OR entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                   inverse(S))(i,i)=0 THEN 0 ELSE 1/entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                   inverse(S))(i,i) ENDIF") (("1" (NAME "G5" "FG(FFZ)") (("1" (CASE "(LAMBDA (i, j):
                                                                                                  IF i /= j OR
                                                                                                      entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                             inverse(S))
                                                                                                           (i, i)
                                                                                                       = 0
                                                                                                    THEN 0
                                                                                                  ELSE 1 /
                                                                                                        entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                                               inverse(S))
                                                                                                             (i, i)
                                                                                                  ENDIF) = G5") (("1" (REPLACE -1) (("1" (REPLACE -7 2 :DIR RL) (("1" (REWRITE "mult_simple_prod") (("1" (HIDE 3) (("1" (REWRITE "rows_mult" 1) (("1" (REWRITE "rows_form_matrix") (("1" (EXPAND "G5" 1) (("1" (REWRITE -4 1) (("1" (HIDE 2) (("1" (SKOSIMP*) (("1" (EXPAND "FFZ" -2) (("1" (ASSERT) (("1" (INST -8 "i!1") (("1" (ASSERT) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (REWRITE "rows_mult") (("2" (REWRITE "rows_form_matrix") (("2" (TYPEPRED "diag(true,false,inverse(S))") (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-4 1)) (("2" (LEMMA "is_simple_prod_implic") (("2" (INST - "false" "false" "rows(inverse(S))" "diag(TRUE, FALSE, inverse(S))`multip" "true" "false") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 3) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "G5") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FFZ" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (INST -5 "x!1") (("1" (ASSERT) (("1" (CASE "x!1/=x!2") (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "entry_eq_0" 1) (("1" (FLATTEN) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "entry_eq_0" 2) (("2" (FLATTEN) (("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("3" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (SKEEP) (("2" (EXPAND "is_simple_prod?") (("2" (NAME "FMG" "LAMBDA (i:nat): Esr(1+n)(i,FF(i))") (("2" (INST + "FMG" "n") (("2" (ASSERT) (("2" (SPLIT 1) (("1" (EXPAND "is_simple_seq?") (("1" (SKEEP) (("1" (INST + "p" "FF(p)") (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (CASE "p < 1+n") (("1" (ASSERT) (("1" (EXPAND "FMG" 3) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) (("2" (REWRITE "full_matrix_eq" 2) (("2" (SKOSIMP*) (("2" (REWRITE "entry_Esr") (("2" (REWRITE "entry_Id") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "full_matrix_eq" 1) (("2" (SPLIT) (("1" (REWRITE "rows_form_matrix") (("1" (ASSERT) NIL NIL)) NIL) ("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (CASE "FORALL (k:nat): FORALL (ii,jj:nat): ii<1+n AND jj<1+n AND k<=n IMPLIES entry(prod_mat(1+n)(FMG,k))(ii,jj) = IF ii=jj AND ii<=k THEN FF(ii) ELSIF ii=jj THEN 1 ELSE 0 ENDIF") (("1" (INST - "n") (("1" (INST?) (("1" (ASSERT) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "entry_form_matrix") (("1" (EXPAND "FG" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (GROUND) (("1" (TYPEPRED "i!1") (("1" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("2" (TYPEPRED "i!1") (("2" (REWRITE "rows_form_matrix") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "i!1") (("2" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("3" (ASSERT) (("3" (TYPEPRED "j!1") (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (SKEEP) (("1" (ASSERT) (("1" (EXPAND "prod_mat" 1) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr") (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (SKEEP) (("2" (ASSERT) (("2" (EXPAND "prod_mat" +) (("2" (REWRITE "entry_mult") (("2" (ASSERT) (("2" (EXPAND "*" + 1) (("2" (REWRITE "dot_eq_sigma") (("2" (REWRITE "length_row") (("1" (REWRITE "length_col") (("1" (ASSERT) (("1" (EXPAND "FMG" 1 1) (("1" (ASSERT) (("1" (TYPEPRED "prod_mat(1 + n)
                                (LAMBDA (i: nat): Esr(1 + n)(i, FF(i)), j)") (("1" (HIDE (-1 -2)) (("1" (REPLACE -3 :DIR RL) (("1" (REPLACE -4) (("1" (ASSERT) (("1" (EXPAND "FMG" 1 1) (("1" (REWRITE "rows_Esr") (("1" (ASSERT) (("1" (EXPAND "min") (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (LEMMA "sigma_eq_one_arg2") (("1" (INST?) (("1" (INST - "ii") (("1" (ASSERT) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (INST - "ii" "ii") (("1" (ASSERT) (("1" (REPLACES -7 1) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr" 1) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (INST - "ii" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "ii") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (INST - "ii" "ii") (("1" (ASSERT) (("1" (REPLACES -1) (("1" (REPLACES -5) (("1" (EXPAND "FMG" +) (("1" (REWRITE "entry_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (INST - "ii" "i!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF) (("2" (ASSERT) (("2" (REWRITE "sigma_restrict_eq_0") (("2" (SKOSIMP*) (("2" (REWRITE "access_row") (("2" (REWRITE "access_col") (("2" (ASSERT) (("2" (INST - "ii" "i!2") (("2" (ASSERT) (("2" (REPLACE -5) (("2" (LIFT-IF) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (ASSERT) (("1" (EXPAND "FMG" 1) (("1" (REWRITE "entry_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "prod_mat(1+n)(FMG,j)") (("2" (ASSERT) (("2" (EXPAND "rows") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "det_inverse") (("2" (INST - "S") (("2" (ASSERT) (("2" (CASE "det(inverse(S))=0") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (TYPEPRED "diag(TRUE, FALSE, inverse(S))") (("2" (REPLACE -3) (("2" (ASSERT) (("2" (INST -6 "i" "i") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|det_nonzero_simple_prod-3| |nil| 3616753803 ("" (SKEEP) (("" (LEMMA "inverse_inverse") (("" (INST?) (("" (ASSERT) (("" (EXPAND "inverse" -1 1) (("" (EXPAND "left_inv") (("" (CASE "FORALL (i:nat): i<rows(S) IMPLIES entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                    inverse(S))
                                                                  (i, i)/=0") (("1" (NAME "FG" "LAMBDA (FF:[nat->real]): (LAMBDA (i,j:nat): IF i/=j THEN 0 ELSE FF(i) ENDIF)") (("1" (CASE "FORALL (FF:[nat->real],n:nat): (FORALL (i:nat): i<n+1 IMPLIES FF(i)/=0) IMPLIES is_simple_prod?(n+1,TRUE,FALSE)(form_matrix(FG(FF),n+1,n+1))") (("1" (NAME "FFZ" "LAMBDA (i:nat): IF i>=rows(S) OR entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                             inverse(S))(i,i)=0 THEN 0 ELSE 1/entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                             inverse(S))(i,i) ENDIF") (("1" (NAME "G5" "FG(FFZ)") (("1" (CASE "(LAMBDA (i, j):
                                                                        IF i /= j OR
                                                                            entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                   inverse(S))
                                                                                 (i, i)
                                                                             = 0
                                                                          THEN 0
                                                                        ELSE 1 /
                                                                              entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                                                     inverse(S))
                                                                                   (i, i)
                                                                        ENDIF) = G5") (("1" (REPLACE -1) (("1" (REPLACE -7 2 :DIR RL) (("1" (REWRITE "mult_simple_prod") (("1" (HIDE 3) (("1" (REWRITE "rows_mult" 1) (("1" (REWRITE "rows_form_matrix") (("1" (EXPAND "G5" 1) (("1" (REWRITE -4 1) (("1" (HIDE 2) (("1" (SKOSIMP*) (("1" (EXPAND "FFZ" -2) (("1" (ASSERT) (("1" (INST -8 "i!1") (("1" (ASSERT) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (REWRITE "rows_mult") (("2" (REWRITE "rows_form_matrix") (("2" (TYPEPRED "diag(true,false,inverse(S))") (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-4 1)) (("2" (LEMMA "is_simple_prod_implic") (("2" (INST - "false" "false" "rows(inverse(S))" "diag(TRUE, FALSE, inverse(S))`multip" "true" "false") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 3) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "G5") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FFZ" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (INST -5 "x!1") (("1" (ASSERT) (("1" (CASE "x!1/=x!2") (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "entry_eq_0" 1) (("1" (FLATTEN) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "entry_eq_0" 2) (("2" (FLATTEN) (("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("3" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (CASE "FORALL (FF: [nat -> real], n: nat,k:nat): k<=n AND
                                         (FORALL (i: nat): i < 1 + k IMPLIES FF(i) /= 0) AND
                                  (forall (i:nat): i>k AND i<1+n IMPLIES FF(i)=1) IMPLIES
                                          is_simple_prod?(1 + n, TRUE, FALSE)
                                                         (form_matrix(FG(FF), 1 + n, 1 + n))") (("1" (SKEEP) (("1" (INST - "FF" "n" "n") (("1" (ASSERT) (("1" (REPLACE -1) (("1" (SKOSIMP*) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (SKEEP) (("1" (ASSERT) (("1" (EXPAND "is_simple_prod?") (("1" (EXPAND "is_simple_seq?") (("1" (INST + "LAMBDA (j:nat): Esr(1+n)(0,FF(0))" "0") (("1" (SPLIT +) (("1" (SKEEP) (("1" (INST? 3) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "prod_mat" +) (("2" (EXPAND "FG") (("2" (EXPAND "Esr") (("2" (REWRITE "full_matrix_eq") (("2" (SPLIT +) (("1" (REWRITE "rows_form_matrix") (("1" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_form_matrix") (("3" (REWRITE "entry_form_matrix") (("3" (LIFT-IF) (("3" (LIFT-IF) (("3" (ASSERT) (("3" (GROUND) (("3" (INST - "i!1") (("3" (INST - "i!1") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) (("2" (SKEEP) (("2" (NAME "FF1" "LAMBDA (i:nat): IF i<1+j THEN FF(i) ELSE 1 ENDIF") (("2" (INST - "FF1" "n") (("2" (ASSERT) (("2" (SPLIT -2) (("1" (EXPAND "is_simple_prod?") (("1" (SKEEP) (("1" (NAME "FMnew" "LAMBDA (qr:nat): IF qr<=k THEN FM(qr) ELSIF qr = k+1 THEN Esr(1+n)(qr,FF(qr)) ELSE Id(1+n) ENDIF") (("1" (INST + "FMnew" "k+1") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (EXPAND "is_simple_seq?") (("1" (SKEEP) (("1" (INST - "p") (("1" (ASSERT) (("1" (EXPAND "FMnew" +) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (INST 4 "p" "FF(p)") (("1" (ASSERT) (("1" (REWRITE "full_matrix_eq" 1) (("1" (SKOSIMP*) (("1" (REWRITE "entry_Esr" 1) (("1" (REWRITE "entry_Id" 1) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "prod_mat" +) (("2" (CASE "NOT prod_mat(1 + n)(FMnew, k) = prod_mat(1 + n)(FM, k)") (("1" (REWRITE "prod_mat_eq") (("1" (SKOSIMP*) (("1" (EXPAND "FMnew" 1) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (REPLACE -3 :DIR RL) (("2" (REWRITE "full_matrix_eq" 1) (("2" (SPLIT 1) (("1" (REWRITE "rows_form_matrix") (("1" (REWRITE "rows_mult") (("1" (REWRITE "rows_form_matrix") NIL NIL)) NIL)) NIL) ("2" (REWRITE "columns_mult") (("1" (EXPAND "FMnew" 1) (("1" (REWRITE "columns_Esr") (("1" (LEMMA "columns_form_matrix") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "form_matrix(FG(FF1),1+n,1+n)") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_mult") (("3" (REWRITE "entry_form_matrix") (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (EXPAND "FMnew" + 1) (("3" (REWRITE "columns_Esr") (("3" (ASSERT) (("3" (LIFT-IF) (("3" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "*" 1) (("1" (REWRITE "dot_eq_sigma") (("1" (CASE "i!1 /= j!1") (("1" (FLATTEN) (("1" (EXPAND "FG" 2 1) (("1" (ASSERT) (("1" (REWRITE "sigma_restrict_eq_0" 2) (("1" (HIDE 3) (("1" (SKOSIMP*) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (EXPAND "FMnew" 1) (("1" (REWRITE "entry_Esr") (("1" (ASSERT) (("1" (REWRITE "entry_form_matrix") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FF1") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (REPLACES -1) (("2" (ASSERT) (("2" (EXPAND "FG" 1 1) (("2" (REWRITE "length_row") (("2" (REWRITE "length_col") (("2" (EXPAND "FMnew" 1 1) (("2" (REWRITE "rows_Esr") (("2" (ASSERT) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (SPLIT -1) (("1" (ASSERT) NIL NIL) ("2" (REPLACES -1) (("2" (ASSERT) (("2" (EXPAND "min") (("2" (LEMMA "sigma_eq_one_arg2") (("2" (INST?) (("2" (INST - "j!1") (("2" (ASSERT) (("2" (SPLIT -1) (("1" (REPLACES -1) (("1" (ASSERT) (("1" (REWRITE "access_row") (("1" (REWRITE "access_col") (("1" (EXPAND "FMnew" 1) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|det_nonzero_simple_prod-2| |nil| 3616753755 ("" (SKEEP) (("" (LEMMA "inverse_inverse") (("" (INST?) (("" (ASSERT) (("" (EXPAND "inverse" -1 1) (("" (EXPAND "left_inv") (("" (CASE "FORALL (i:nat): i<rows(S) IMPLIES entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                      inverse(S))
                                                    (i, i)/=0") (("1" (NAME "FG" "LAMBDA (FF:[nat->real]): (LAMBDA (i,j:nat): IF i/=j THEN 0 ELSE FF(i) ENDIF)") (("1" (CASE "FORALL (FF:[nat->real],n:nat): (FORALL (i:nat): i<n+1 IMPLIES FF(i)/=0) IMPLIES is_simple_prod?(n+1,TRUE,FALSE)(form_matrix(FG(FF),n+1,n+1))") (("1" (NAME "FFZ" "LAMBDA (i:nat): IF i>=rows(S) OR entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                       inverse(S))(i,i)=0 THEN 0 ELSE 1/entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                       inverse(S))(i,i) ENDIF") (("1" (NAME "G5" "FG(FFZ)") (("1" (CASE "(LAMBDA (i, j):
                                              IF i /= j OR
                                                  entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                         inverse(S))
                                                       (i, i)
                                                   = 0
                                                THEN 0
                                              ELSE 1 /
                                                    entry(diag(TRUE, FALSE, inverse(S))`multip *
                                                           inverse(S))
                                                         (i, i)
                                              ENDIF) = G5") (("1" (REPLACE -1) (("1" (REPLACE -7 2 :DIR RL) (("1" (REWRITE "mult_simple_prod") (("1" (HIDE 3) (("1" (REWRITE "rows_mult" 1) (("1" (REWRITE "rows_form_matrix") (("1" (EXPAND "G5" 1) (("1" (REWRITE -4 1) (("1" (HIDE 2) (("1" (SKOSIMP*) (("1" (EXPAND "FFZ" -2) (("1" (ASSERT) (("1" (INST -8 "i!1") (("1" (ASSERT) (("1" (ASSERT) NIL))))))))))))))))))))))) ("2" (HIDE 3) (("2" (REWRITE "rows_mult") (("2" (REWRITE "rows_form_matrix") (("2" (TYPEPRED "diag(true,false,inverse(S))") (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-4 1)) (("2" (LEMMA "is_simple_prod_implic") (("2" (INST - "false" "false" "rows(inverse(S))" "diag(TRUE, FALSE, inverse(S))`multip" "true" "false") (("2" (ASSERT) NIL))))))))))))))))) ("3" (HIDE 3) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL))))))))))))))))) ("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "G5") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FFZ" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (INST -5 "x!1") (("1" (ASSERT) (("1" (CASE "x!1/=x!2") (("1" (ASSERT) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "entry_eq_0" 1) (("1" (FLATTEN) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL))))))) ("2" (REWRITE "entry_eq_0" 2) (("2" (FLATTEN) (("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL))))))))))))))))))))))))))))))))))) ("2" (SKOSIMP*) NIL))) ("3" (SKOSIMP*) NIL))))) ("2" (SKOSIMP*) NIL))) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (CASE "FORALL (FF: [nat -> real], n: nat,k:nat): k<=n AND
                   (FORALL (i: nat): i < 1 + k IMPLIES FF(i) /= 0) AND
            (forall (i:nat): i>k AND i<1+n IMPLIES FF(i)=1) IMPLIES
                    is_simple_prod?(1 + n, TRUE, FALSE)
                                   (form_matrix(FG(FF), 1 + n, 1 + n))") (("1" (SKEEP) (("1" (INST - "FF" "n" "n") (("1" (ASSERT) (("1" (REPLACE -1) (("1" (SKOSIMP*) (("1" (ASSERT) NIL))))))))))) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (SKEEP) (("1" (ASSERT) (("1" (EXPAND "is_simple_prod?") (("1" (EXPAND "is_simple_seq?") (("1" (INST + "LAMBDA (j:nat): Esr(1+n)(0,FF(0))" "0") (("1" (SPLIT +) (("1" (SKEEP) (("1" (INST? 3) (("1" (ASSERT) NIL))))) ("2" (EXPAND "prod_mat" +) (("2" (EXPAND "FG") (("2" (EXPAND "Esr") (("2" (REWRITE "full_matrix_eq") (("2" (SPLIT +) (("1" (REWRITE "rows_form_matrix") (("1" (REWRITE "rows_form_matrix") NIL))) ("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) NIL))))))))))))) ("3" (SKOSIMP*) (("3" (REWRITE "entry_form_matrix") (("3" (REWRITE "entry_form_matrix") (("3" (LIFT-IF) (("3" (LIFT-IF) (("3" (ASSERT) (("3" (GROUND) (("3" (INST - "i!1") (("3" (INST - "i!1") (("3" (ASSERT) NIL))))))))))))))))))))))))))))))))))))))))) ("2" (SKEEP) (("2" (ASSERT) (("2" (SKEEP) (("2" (NAME "FF1" "LAMBDA (i:nat): IF i<1+j THEN FF(i) ELSE 1 ENDIF") (("2" (INST - "FF1" "n") (("2" (ASSERT) (("2" (SPLIT -2) (("1" (EXPAND "is_simple_prod?") (("1" (SKEEP) (("1" (NAME "FMnew" "LAMBDA (qr:nat): IF qr<=k THEN FM(qr) ELSIF qr = k+1 THEN Ess(1+n)(qr,FF(qr)) ELSE Id(1+n) ENDIF") (("1" (INST + "FMnew" "k+1") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (EXPAND "is_simple_seq?") (("1" (SKEEP) (("1" (INST - "p") (("1" (ASSERT) (("1" (EXPAND "FMnew" +) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GROUND) NIL))))) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (INST 4 "p" "FF(p)") (("1" (ASSERT) (("1" (POSTPONE) NIL))))))))) ("2" (POSTPONE) NIL))))))))))))))))))))))) ("2" (POSTPONE) NIL))))))) ("2" (POSTPONE) NIL))))))) ("2" (POSTPONE) NIL) ("3" (POSTPONE) NIL))))))))))))))) ("3" (POSTPONE) NIL))))) ("3" (POSTPONE) NIL))))))) ("3" (POSTPONE) NIL))))) ("2" (POSTPONE) NIL)))))))))))))) NIL) NIL NIL) (|det_nonzero_simple_prod-1| |nil| 3616748905 ("" (SKEEP) (("" (LEMMA "inverse_inverse") (("" (INST?) (("" (ASSERT) (("" (EXPAND "inverse" -1 1) (("" (EXPAND "left_inv") (("" (CASE "FORALL (i:nat): i<rows(S) IMPLIES entry(diag(TRUE, FALSE, inverse(S))`multip *
                                               inverse(S))
                                             (i, i)/=0") (("1" (NAME "FG" "LAMBDA (FF:[nat->real]): (LAMBDA (i,j:nat): IF i/=j THEN 0 ELSE FF(i) ENDIF)") (("1" (CASE "FORALL (FF:[nat->real],n:nat): (FORALL (i:nat): i<n+1 IMPLIES FF(i)/=0) IMPLIES is_simple_prod?(n+1,TRUE,FALSE)(form_matrix(FG(FF),n+1,n+1))") (("1" (NAME "FFZ" "LAMBDA (i:nat): IF i>=rows(S) OR entry(diag(TRUE, FALSE, inverse(S))`multip *
                                            inverse(S))(i,i)=0 THEN 0 ELSE 1/entry(diag(TRUE, FALSE, inverse(S))`multip *
                                            inverse(S))(i,i) ENDIF") (("1" (NAME "G5" "FG(FFZ)") (("1" (CASE "(LAMBDA (i, j):
                                 IF i /= j OR
                                     entry(diag(TRUE, FALSE, inverse(S))`multip *
                                            inverse(S))
                                          (i, i)
                                      = 0
                                   THEN 0
                                 ELSE 1 /
                                       entry(diag(TRUE, FALSE, inverse(S))`multip *
                                              inverse(S))
                                            (i, i)
                                 ENDIF) = G5") (("1" (REPLACE -1) (("1" (REPLACE -7 2 :DIR RL) (("1" (REWRITE "mult_simple_prod") (("1" (HIDE 3) (("1" (REWRITE "rows_mult" 1) (("1" (REWRITE "rows_form_matrix") (("1" (EXPAND "G5" 1) (("1" (REWRITE -4 1) (("1" (HIDE 2) (("1" (SKOSIMP*) (("1" (EXPAND "FFZ" -2) (("1" (ASSERT) (("1" (INST -8 "i!1") (("1" (ASSERT) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (REWRITE "rows_mult") (("2" (REWRITE "rows_form_matrix") (("2" (TYPEPRED "diag(true,false,inverse(S))") (("2" (ASSERT) (("2" (HIDE-ALL-BUT (-4 1)) (("2" (LEMMA "is_simple_prod_implic") (("2" (INST - "false" "false" "rows(inverse(S))" "diag(TRUE, FALSE, inverse(S))`multip" "true" "false") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 3) (("3" (REWRITE "rows_form_matrix") (("3" (ASSERT) (("3" (LEMMA "columns_form_matrix") (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "G5") (("1" (EXPAND "FG" 1) (("1" (EXPAND "FFZ" 1) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (INST -5 "x!1") (("1" (ASSERT) (("1" (CASE "x!1/=x!2") (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) (("1" (REWRITE "entry_eq_0" 1) (("1" (FLATTEN) (("1" (REWRITE "rows_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "entry_eq_0" 2) (("2" (FLATTEN) (("2" (REWRITE "rows_mult") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("3" (SKOSIMP*) NIL NIL)) NIL)) NIL) ("2" (SKOSIMP*) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (ASSERT) (("2" (CASE "FORALL (FF: [nat -> real], n: nat,k:nat): k<=n AND
        (FORALL (i: nat): i < 1 + k IMPLIES FF(i) /= 0) AND
 (forall (i:nat): i>k AND i<1+n IMPLIES FF(i)=1) IMPLIES
         is_simple_prod?(1 + n, TRUE, FALSE)
                        (form_matrix(FG(FF), 1 + n, 1 + n))") (("1" (SKEEP) (("1" (INST - "FF" "n" "n") (("1" (ASSERT) (("1" (REPLACE -1) (("1" (SKOSIMP*) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (SKEEP) (("1" (ASSERT) (("1" (EXPAND "is_simple_prod?") (("1" (EXPAND "is_simple_seq?") (("1" (INST + "LAMBDA (j:nat): Esr(1+n)(0,FF(0))" "0") (("1" (SPLIT +) (("1" (SKEEP) (("1" (INST? 3) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (EXPAND "prod_mat" +) (("2" (EXPAND "FG") (("2" (EXPAND "Esr") (("2" (REWRITE "full_matrix_eq") (("2" (SPLIT +) (("1" (REWRITE "rows_form_matrix") (("1" (REWRITE "rows_form_matrix") NIL NIL)) NIL) ("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) (("2" (REPLACES -1) (("2" (LEMMA "columns_form_matrix") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKOSIMP*) (("3" (REWRITE "entry_form_matrix") (("3" (REWRITE "entry_form_matrix") (("3" (LIFT-IF) (("3" (LIFT-IF) (("3" (ASSERT) (("3" (GROUND) (("3" (INST - "i!1") (("3" (INST - "i!1") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) (("2" (SKEEP) (("2" (NAME "FF1" "LAMBDA (i:nat): IF i<1+j THEN FF(i) ELSE 1 ENDIF") (("2" (INST - "FF1" "n") (("2" (ASSERT) (("2" (SPLIT -2) (("1" (EXPAND "is_simple_prod?") (("1" (SKEEP) (("1" (NAME "FMnew" "LAMBDA (qr:nat): IF qr<=k THEN FM(qr) ELSIF qr = k+1 THEN Ers(1+n)(qr,FF(qr)) ELSE Id(1+n) ENDIF") (("1" (INST + "FMnew" "k+1") (("1" (ASSERT) (("1" (SPLIT 1) (("1" (EXPAND "is_simple_seq?") (("1" (SKEEP) (("1" (INST - "p") (("1" (ASSERT) (("1" (EXPAND "FMnew" +) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (ASSERT) (("1" (GROUND) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (SPLIT 2) (("1" (FLATTEN) (("1" (ASSERT) (("1" (INST 4 "p" "FF(p)") (("1" (ASSERT) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|mult_induction_TCC1| 0 (|mult_induction_TCC1-1| |nil| 3616766004 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (/= CONST-DECL "boolean" |notequal| NIL)) NIL (|mult_induction| SUBTYPE "matrices.rows(matrix_inv.S)" "posnat"))) (|mult_induction_TCC2| 0 (|mult_induction_TCC2-1| |nil| 3616766004 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|Easr| CONST-DECL "SquareMatrix(pn)" |matrix_det| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (/= CONST-DECL "boolean" |notequal| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|mult_induction| SUBTYPE "matrices.rows(matrix_inv.S)" "posnat"))) (|mult_induction_TCC3| 0 (|mult_induction_TCC3-1| |nil| 3616766371 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (<= CONST-DECL "bool" |reals| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|Esr| CONST-DECL "SquareMatrix(pn)" |matrix_det| NIL) (|Easr| CONST-DECL "SquareMatrix(pn)" |matrix_det| NIL) (|form_matrix| CONST-DECL "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" |matrices| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (/= CONST-DECL "boolean" |notequal| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|mult_induction| SUBTYPE "matrices.rows(matrix_inv.S)" "posnat"))) (|mult_induction_TCC4| 0 (|mult_induction_TCC4-1| |nil| 3616766561 ("" (SKEEP) (("" (SKEEP) (("" (REWRITE "rows_mult") (("" (REWRITE "columns_mult") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "Q") (("2" (EXPAND "rows") (("2" (EXPAND "length") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|columns_mult| FORMULA-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL)) NIL (|mult_induction| SUBTYPE "matrices.*(matrix_inv.Q, matrix_inv.R)" "SquareMatrix(matrices.rows(matrix_inv.S))"))) (|mult_induction| 0 (|mult_induction-1| |nil| 3616766005 ("" (SKEEP) (("" (LEMMA "det_nonzero_simple_prod") (("" (INST?) (("" (ASSERT) (("" (EXPAND "is_simple_prod?") (("" (SKEEP) (("" (CASE "EXISTS (z:nat): z<=k AND det(FM(z)) = 0") (("1" (SKEEP) (("1" (CASE "FORALL (j:nat): z+j<=k IMPLIES det(prod_mat(rows(S))(FM,z+j)) = 0") (("1" (INST - "k-z") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (INDUCT "j") (("1" (ASSERT) (("1" (EXPAND "prod_mat" +) (("1" (LIFT-IF) (("1" (GROUND) (("1" (REWRITE "det_mult") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKOSIMP*) (("2" (ASSERT) (("2" (EXPAND "prod_mat" +) (("2" (REWRITE "det_mult") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "FORALL (z:nat): z<=k IMPLIES P(prod_mat(rows(S))(FM,z))") (("1" (INST - "k") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INDUCT "z") (("1" (ASSERT) (("1" (EXPAND "prod_mat" +) (("1" (EXPAND "is_simple_seq?") (("1" (ASSERT) (("1" (INST - "0") (("1" (ASSERT) (("1" (SPLIT -) (("1" (SKEEP) (("1" (INST - "i" "j" "r") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST - "i" "r") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -5) (("2" (INST + "0") (("2" (ASSERT) (("2" (REPLACE -2) (("2" (REWRITE "det_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "prod_mat" +) (("2" (REWRITE -8 1) (("2" (EXPAND "is_simple_seq?") (("2" (INST - "1+j") (("2" (ASSERT) (("2" (SPLIT -) (("1" (SKOSIMP*) (("1" (INST - "i!1" "j!1" "r!1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST - "i" "r") (("2" (ASSERT) (("2" (FLATTEN) (("2" (REPLACE -7) (("2" (REPLACE -2) (("2" (INST + "1+j") (("2" (REPLACE -2) (("2" (ASSERT) (("2" (REWRITE "det_Esr") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|det_nonzero_simple_prod| FORMULA-DECL NIL |matrix_inv| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|is_simple_seq?| CONST-DECL "bool" |matrix_det| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|det_Esr| FORMULA-DECL NIL |matrix_det| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|z| SKOLEM-CONST-DECL "nat" |matrix_inv| NIL) (|k| SKOLEM-CONST-DECL "nat" |matrix_inv| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|prod_mat| DEF-DECL "SquareMatrix(pn)" |matrix_det| NIL) (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|is_simple_prod?| CONST-DECL "bool" |matrix_det| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (|det_transpose| 0 (|det_transpose-1| |nil| 3616766723 ("" (SKEEP) (("" (CASE "rows(SM)/=columns(SM) OR rows(transpose(SM))/=columns(transpose(SM)) OR rows(transpose(SM))/=columns(SM)") (("1" (CASE "rows(SM)/=columns(SM)") (("1" (HIDE -2) (("1" (FLATTEN) (("1" (EXPAND "det" 2) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (GROUND) (("1" (REWRITE "rows_transpose") (("1" (REWRITE "columns_transpose") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REWRITE "rows_transpose") (("2" (REWRITE "columns_transpose") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REWRITE "rows_transpose") (("2" (REWRITE "columns_transpose") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (CASE "det(SM)/=0") (("1" (FLATTEN) (("1" (LEMMA "mult_induction") (("1" (INST - "SM" "LAMBDA (KV:SquareMatrix(rows(SM))): det(transpose(KV)) = det(KV)") (("1" (ASSERT) (("1" (SPLIT) (("1" (SKEEP) (("1" (REWRITE "transpose_Easr") (("1" (REWRITE "det_Easr") (("1" (REWRITE "det_Easr") (("1" (LIFT-IF) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (REWRITE "transpose_Esr") NIL NIL)) NIL) ("3" (REWRITE "transpose_Id") NIL NIL) ("4" (SKEEP) (("4" (REWRITE "transpose_mult") (("4" (REWRITE "det_mult") (("1" (REWRITE "det_mult") (("1" (ASSERT) NIL NIL)) NIL) ("2" (REWRITE "rows_transpose") (("2" (REWRITE "rows_transpose") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (REWRITE "rows_transpose") (("3" (REWRITE "columns_transpose") (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (REWRITE "rows_transpose") (("4" (REWRITE "columns_transpose") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "mult_inverse_right") (("2" (INST - "transpose(SM)") (("2" (SPLIT -1) (("1" (CASE "NOT det(transpose(transpose(SM) * inverse(transpose(SM)))) = det(transpose(Id(rows(transpose(SM)))))") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "transpose_mult") (("2" (REWRITE "transpose_transpose") (("2" (REWRITE "transpose_Id") (("2" (REWRITE "det_Id") (("2" (REWRITE "det_mult") (("1" (ASSERT) NIL NIL) ("2" (REWRITE "rows_transpose") (("2" (ASSERT) NIL NIL)) NIL) ("3" (REWRITE "rows_transpose") (("3" (REWRITE "columns_transpose") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REWRITE "rows_mult") (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (LEMMA "invertible_rew") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|transpose| CONST-DECL "PosFullMatrix" |matrices| NIL) (|PosFullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|columns| DEF-DECL "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" |matrices| NIL) (<= CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|FullMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (< CONST-DECL "bool" |reals| NIL) (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|rows| CONST-DECL "nat" |matrices| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|Matrix| TYPE-EQ-DECL NIL |matrices| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|det| DEF-DECL "real" |matrix_props| NIL) (|rows_transpose| FORMULA-DECL NIL |matrices| NIL) (|columns_transpose| FORMULA-DECL NIL |matrices| NIL) (|nzreal_exp| APPLICATION-JUDGEMENT "nzreal" |exponentiation| NIL) (|int_exp| APPLICATION-JUDGEMENT "int" |exponentiation| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_times_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL) (|mult_induction| FORMULA-DECL NIL |matrix_inv| NIL) (|det_mult| FORMULA-DECL NIL |matrix_diag| NIL) (|mult_full| APPLICATION-JUDGEMENT "FullMatrix" |matrices| NIL) (|transpose_mult| FORMULA-DECL NIL |matrices| NIL) (|transpose_Id| FORMULA-DECL NIL |matrices| NIL) (|transpose_Esr| FORMULA-DECL NIL |matrix_det| NIL) (|det_Easr| FORMULA-DECL NIL |matrix_det| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|transpose_Easr| FORMULA-DECL NIL |matrix_det| NIL) (|SquareMatrix| TYPE-EQ-DECL NIL |matrices| NIL) (|Square| TYPE-EQ-DECL NIL |matrices| NIL) (SM SKOLEM-CONST-DECL "PosFullMatrix" |matrix_inv| NIL) (|mult_inverse_right| FORMULA-DECL NIL |matrix_inv| NIL) (|rows_mult| FORMULA-DECL NIL |matrices| NIL) (|det_Id| FORMULA-DECL NIL |matrix_props| NIL) (|transpose_transpose| FORMULA-DECL NIL |matrices| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|MatrixMN| TYPE-EQ-DECL NIL |matrices| NIL) (|entry| CONST-DECL "real" |matrices| NIL) (|Vector| TYPE-EQ-DECL NIL |matrices| NIL) (* CONST-DECL "real" |matrices| NIL) (|row| CONST-DECL "Vector" |matrices| NIL) (|VectorN| TYPE-EQ-DECL NIL |matrices| NIL) (|col| DEF-DECL "VectorN(rows(M))" |matrices| NIL) (* CONST-DECL "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(N)(j)}" |matrices| NIL) (|invertible?| CONST-DECL "bool" |matrix_inv| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Id| CONST-DECL "{M: SquareMatrix(pm) |
   (FORALL (i, j):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" |matrices| NIL) (|inverse| CONST-DECL "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" |matrix_inv| NIL) (|invertible_rew| FORMULA-DECL NIL |matrix_inv| NIL)) SHOSTAK)))
