(query_coeff (bump_one_ind_TCC1 0 (bump_one_ind_TCC1-1 nil 3621165054 ("" (subtype-tcc) nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (bump_one_ind subtype "((number_fields.-)((number_fields.+)(query_coeff.j, 1), query_coeff.i))" "naturalnumber"))) (bump_one_ind_TCC2 0 (bump_one_ind_TCC2-1 nil 3621165054 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (bump_one_ind subtype "(number_fields.+)(query_coeff.f(query_coeff.i), 1)" "naturalnumbers.below(3)"))) (bump_one_ind_TCC3 0 (bump_one_ind_TCC3-1 nil 3621165054 ("" (skeep) (("" (typepred (f)) (("" (typepred (i)) (("" (skeep) (("" (inst -2 "k") (("" (typepred (k)) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (above nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) nil (bump_one_ind subtype "query_coeff.f WITH [(query_coeff.i) := (number_fields.+)(query_coeff.f(query_coeff.i), 1)]" "{ff: [naturalnumbers.nat -> naturalnumbers.below(3)] | FORALL (k: integers.above((number_fields.+)(query_coeff.j, 1))): ff(k) = 0}"))) (bump_one_ind_TCC4 0 (bump_one_ind_TCC4-1 nil 3621165054 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (bump_one_ind subtype "(number_fields.+)(query_coeff.i, 1)" "naturalnumbers.upto((number_fields.+)(1, query_coeff.j))"))) (bump_one_ind_TCC5 0 (bump_one_ind_TCC5-2 "" 3790097663 ("" (skeep) (("" (typepred (i)) (("" (split-ineq -1) nil nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (bump_one_ind termination "query_coeff.bump_one_ind(query_coeff.j, query_coeff.f, (number_fields.+)(query_coeff.i, 1))" "nil")) (bump_one_ind_TCC5-1 nil 3621165054 ("" (skeep) (("" (typepred (i)) (("" (split-ineq -1) (("" (typepred (f)) (("" (inst -1 "i") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (bump_one_ind termination "query_coeff.bump_one_ind(query_coeff.j, query_coeff.f, (number_fields.+)(query_coeff.i, 1))" "nil"))) (bump_one_ind_TCC6 0 (bump_one_ind_TCC6-1 nil 3621165054 ("" (skeep) (("" (skeep) (("" (typepred " v(j, f, i + 1)") (("1" (typepred (k)) (("1" (inst -2 "k") (("1" (ground) nil nil)) nil)) nil) ("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (ground) (("1" (typepred (f)) (("1" (inst -1 "i") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (bump_one_ind subtype "query_coeff.bump_one_ind(query_coeff.j, query_coeff.f, (number_fields.+)(query_coeff.i, 1)) WITH [(query_coeff.i) := 0]" "{ff: [naturalnumbers.nat -> naturalnumbers.below(3)] | FORALL (k: integers.above((number_fields.+)(query_coeff.j, 1))): ff(k) = 0}"))) (switch_one_entry_TCC1 0 (switch_one_entry_TCC1-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (/= const-decl "boolean" notequal nil)) nil (switch_one_entry subtype "query_coeff.i" "below[length[below(3)](ll)]"))) (switch_one_entry_TCC2 0 (switch_one_entry_TCC2-1 nil 3621672198 ("" (skeep) (("" (split 1) (("1" (ground) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth def-decl "T" list_props nil)) nil (switch_one_entry subtype "list_adt[naturalnumbers.below(3)].cons(query_coeff.new, list_adt[naturalnumbers.below(3)].cdr(query_coeff.L))" "{ll: list_adt[naturalnumbers.below(3)].list | booleans.AND(list_props[naturalnumbers.below(3)].length(ll) = list_props[naturalnumbers.below(3)].length(query_coeff.L), FORALL (i: naturalnumbers.below(list_props[naturalnumbers.below(3)].length(query_coeff.L))): booleans.IMPLIES(i /= query_coeff.n, list_props[naturalnumbers.below(3)].nth(ll, i) = list_props[naturalnumbers.below(3)].nth(query_coeff.L, i)))}"))) (switch_one_entry_TCC3 0 (switch_one_entry_TCC3-1 nil 3621672198 ("" (skeep) (("" (grind) (("" (typepred (L)) (("" (grind) (("" (typepred (n)) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (switch_one_entry subtype "list_adt[naturalnumbers.below(3)].cdr(query_coeff.L)" "{ll: list_adt[naturalnumbers.below(3)].list | list_adt[naturalnumbers.below(3)].cons?(ll)}"))) (switch_one_entry_TCC4 0 (switch_one_entry_TCC4-1 nil 3621672198 ("" (skeep) (("" (typepred (n)) (("" (grind) nil nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (switch_one_entry subtype "(number_fields.-)(query_coeff.n, 1)" "naturalnumbers.below(list_props[naturalnumbers.below(3)].length(list_adt[naturalnumbers.below(3)].cdr(query_coeff.L)))"))) (switch_one_entry_TCC5 0 (switch_one_entry_TCC5-1 nil 3621672198 ("" (termination-tcc) nil nil) nil nil (switch_one_entry termination "query_coeff.switch_one_entry(list_adt[naturalnumbers.below(3)].cdr(query_coeff.L), (number_fields.-)(query_coeff.n, 1), query_coeff.new)" "nil"))) (switch_one_entry_TCC6 0 (switch_one_entry_TCC6-1 nil 3621672198 ("" (skeep) (("" (split 2) (("1" (grind) nil nil) ("2" (skeep) (("2" (typepred "v(cdr[below(3)](L), n-1, new)") (("1" (inst -3 "i-1") (("1" (grind) (("1" (expand "nth" 2 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (typepred (L)) (("2" (typepred (i)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred (n)) (("2" (grind) nil nil)) nil) ("3" (typepred (n)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "below(length(L))" query_coeff nil) (L skolem-const-decl "{ll: list[below(3)] | cons?[below(3)](ll)}" query_coeff nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (switch_one_entry subtype "list_adt[naturalnumbers.below(3)].cons(list_adt[naturalnumbers.below(3)].car(query_coeff.L), query_coeff.switch_one_entry(list_adt[naturalnumbers.below(3)].cdr(query_coeff.L), (number_fields.-)(query_coeff.n, 1), query_coeff.new))" "{ll: list_adt[naturalnumbers.below(3)].list | booleans.AND(list_props[naturalnumbers.below(3)].length(ll) = list_props[naturalnumbers.below(3)].length(query_coeff.L), FORALL (i: naturalnumbers.below(list_props[naturalnumbers.below(3)].length(query_coeff.L))): booleans.IMPLIES(i /= query_coeff.n, list_props[naturalnumbers.below(3)].nth(ll, i) = list_props[naturalnumbers.below(3)].nth(query_coeff.L, i)))}"))) (switch_is_with_TCC1 0 (switch_is_with_TCC1-1 nil 3621678714 ("" (existence-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (switch_is_with existence "" "naturalnumbers.below(3)"))) (switch_is_with 0 (switch_is_with-2 "" 3744292736 ("" (case " FORALL (nn:posnat, L: list[below(3)], n: below(length(L)), new: below(3),
                            (f: [nat -> below(3)]
                                 | array2list[below(3)](length(L))(f) = L)):
                      nn = length(L) IMPLIES switch_one_entry(L, n, new) =
                       array2list[below(3)](length(L))(f WITH [n := new])") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "length(L)") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (skeep) (("3" (skeep) (("3" (case-replace "j=0") (("1" (expand "switch_one_entry") (("1" (hide -2) (("1" (typepred (n)) (("1" (ground) (("1" (replace -4 :dir rl) (("1" (case-replace "n=0") (("1" (grind) (("1" (case "cdr(L) = null") (("1" (ground) nil nil) ("2" (grind) (("2" (expand "length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "n=0") (("1" (expand "switch_one_entry" 2) (("1" (ground) (("1" (expand "array2list" 2) (("1" (expand "array2list_it") (("1" (case-replace "cdr(L) = array2list_it(f WITH [n := new], length(L), 1)") (("1" (hide 3) (("1" (lemma "list_extensionality[below(3)]") (("1" (inst -1 "cdr(L)" " array2list_it(f WITH [n := new], length(L), 1)") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (typepred "array2list_it(f WITH [n := new], length(L), 1)") (("1" (replace -2) (("1" (ground) (("1" (typepred "cdr(L)") (("1" (expand "length" 1 2) (("1" (lift-if 1) (("1" (ground) (("1" (typepred (L)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil) ("3" (skeep) (("3" (typepred "array2list_it(f WITH [n := new], length(L), 1)") (("1" (typepred (n_1)) (("1" (inst -4 "n_1+1") (("1" (replace -6) (("1" (ground) (("1" (replace -4 :dir rl) (("1" (typepred (f)) (("1" (case-replace "nth(cdr(L), n_1) = nth(L, n_1+1)") (("1" (replace -2 :dir rl) (("1" (hide 2) (("1" (typepred "array2list[below(3)](length(L))(f)") (("1" (inst -3 "n_1+1") (("1" (ground) nil nil) ("2" (ground) (("2" (expand "length" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 2) (("2" (propax) nil nil)) nil) ("3" (expand "length" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "switch_one_entry" 3) (("2" (ground) (("2" (expand "array2list" 3) (("2" (expand "array2list_it") (("2" (typepred (f)) (("2" (case-replace "f(0) = car(L)") (("1" (case-replace "switch_one_entry(cdr(L), n - 1, new) = array2list_it(f WITH [n := new], length(L), 1)") (("1" (hide 4) (("1" (lemma "list_extensionality[below(3)]") (("1" (hide -2) (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (typepred "array2list_it(f WITH [n:=new], length(L), 1)") (("1" (replace -2) (("1" (hide 2) (("1" (expand "length" 1 2) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (ground) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil) ("3" (typepred "array2list_it(f WITH [n := new], length(L), 1)") (("1" (skeep) (("1" (inst -3 "n_1+1") (("1" (replace -3 :dir rl) (("1" (typepred "switch_one_entry(cdr(L), n - 1, new)") (("1" (inst -3 "n_1") (("1" (typepred (n_1)) (("1" (case "n_1/=n-1") (("1" (ground) (("1" (replace -1) (("1" (typepred (f)) (("1" (case-replace "nth(cdr(L), n_1) = nth(L, n_1+1)") (("1" (typepred (n_1)) (("1" (typepred "array2list[below(3)](length(L))(f)") (("1" (inst -3 "n_1+1") (("1" (replace -6) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 2) (("2" (propax) nil nil)) nil) ("3" (expand "length" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (ground) (("2" (replace -1) (("2" (case "FORALL (mm:posnat, ll:{lll:list[below(3)]|cons?(lll) AND length(lll) =mm}, m:below(mm)):
                               nth(switch_one_entry(ll, m, new), m) = new") (("1" (inst -1 "length(cdr(L))" "cdr(L)" "n-1") nil nil) ("2" (hide-all-but 1) (("2" (induct "mm") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (skeep) (("3" (skeep) (("3" (case "j!1=0") (("1" (case-replace "m=0") (("1" (expand "switch_one_entry") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred (m)) (("2" (ground) nil nil)) nil)) nil) ("2" (case "m=0") (("1" (replace -1) (("1" (expand "switch_one_entry") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "switch_one_entry" 3) (("2" (ground) (("2" (expand "nth" 3) (("2" (inst -1 "cdr(ll)" "m-1") (("2" (typepred (ll)) (("2" (expand "length" -3) (("2" (ground) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (typepred (ll)) (("4" (typepred "switch_one_entry(ll, m, new)") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -) (("3" (skeep) (("3" (typepred (m)) (("3" (typepred "mm") (("3" (typepred (ll)) (("3" (typepred "switch_one_entry(ll, m, new)") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (typepred (n_1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil) ("2" (hide 4) (("2" (typepred "array2list[below(3)](length(L))(f)") (("1" (inst -3 "0") (("1" (ground) (("1" (replace -4) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("4" (grind) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (n skolem-const-decl "below(length(L))" query_coeff nil) (new skolem-const-decl "below(3)" query_coeff nil) (n_1 skolem-const-decl "below(length(switch_one_entry(cdr(L), n - 1, new)))" query_coeff nil) (ll skolem-const-decl "{lll: list[below(3)] | cons?(lll) AND length(lll) = 1 + j!1}" query_coeff nil) (j!1 skolem-const-decl "nat" query_coeff nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (list_extensionality formula-decl nil more_list_props structures) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (L skolem-const-decl "list[below(3)]" query_coeff nil) (n_1 skolem-const-decl "below(length(cdr(L)))" query_coeff nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (listn type-eq-decl nil listn structures) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (/= const-decl "boolean" notequal nil) (switch_one_entry def-decl "{ll: list[below(3)] |
   length(ll) = length(L) AND
    FORALL (i: below(length(L))): i /= n IMPLIES nth(ll, i) = nth(L, i)}" query_coeff nil)) shostak) (switch_is_with-1 nil 3621678727 ("" (case " FORALL (nn:posnat, L: list[below(3)], n: below(length(L)), new: below(3),
                     (f: [nat -> below(3)]
                          | array2list[below(3)](length(L))(f) = L)):
               nn = length(L) IMPLIES switch_one_entry(L, n, new) =
                array2list[below(3)](length(L))(f WITH [n := new])") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "length(L)") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (skeep) (("3" (skeep) (("3" (case-replace "j=0") (("1" (expand "switch_one_entry") (("1" (hide -2) (("1" (typepred (n)) (("1" (ground) (("1" (replace -4 :dir rl) (("1" (case-replace "n=0") (("1" (grind) (("1" (case "cdr(L) = null") (("1" (ground) nil nil) ("2" (grind) (("2" (expand "length") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "n=0") (("1" (expand "switch_one_entry" 2) (("1" (ground) (("1" (expand "array2list" 2) (("1" (expand "array2list_it") (("1" (case-replace "cdr(L) = array2list_it(f WITH [n := new], length(L), 1)") (("1" (hide 3) (("1" (lemma "list_extensionality[below(3)]") (("1" (inst -1 "cdr(L)" " array2list_it(f WITH [n := new], length(L), 1)") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (typepred "array2list_it(f WITH [n := new], length(L), 1)") (("2" (replace -2) (("2" (ground) (("2" (typepred "cdr(L)") (("2" (expand "length" 1 2) (("2" (lift-if 1) (("2" (ground) (("2" (typepred (L)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (typepred "array2list_it(f WITH [n := new], length(L), 1)") (("3" (typepred (n_1)) (("3" (inst -4 "n_1+1") (("1" (replace -6) (("1" (ground) (("1" (replace -4 :dir rl) (("1" (typepred (f)) (("1" (case-replace "nth(cdr(L), n_1) = nth(L, n_1+1)") (("1" (replace -2 :dir rl) (("1" (hide 2) (("1" (typepred "array2list[below(3)](length(L))(f)") (("1" (inst -3 "n_1+1") (("1" (ground) nil nil) ("2" (ground) (("2" (expand "length" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 2) (("2" (propax) nil nil)) nil) ("3" (expand "length" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "switch_one_entry" 3) (("2" (ground) (("2" (expand "array2list" 3) (("2" (expand "array2list_it") (("2" (typepred (f)) (("2" (case-replace "f(0) = car(L)") (("1" (case-replace "switch_one_entry(cdr(L), n - 1, new) = array2list_it(f WITH [n := new], length(L), 1)") (("1" (hide 4) (("1" (lemma "list_extensionality[below(3)]") (("1" (hide -2) (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (typepred "array2list_it(f WITH [n:=new], length(L), 1)") (("2" (replace -2) (("2" (hide 2) (("2" (expand "length" 1 2) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (ground) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "array2list_it(f WITH [n := new], length(L), 1)") (("3" (skeep) (("3" (inst -3 "n_1+1") (("1" (replace -3 :dir rl) (("1" (typepred "switch_one_entry(cdr(L), n - 1, new)") (("1" (inst -3 "n_1") (("1" (typepred (n_1)) (("1" (case "n_1/=n-1") (("1" (ground) (("1" (replace -1) (("1" (typepred (f)) (("1" (case-replace "nth(cdr(L), n_1) = nth(L, n_1+1)") (("1" (typepred (n_1)) (("1" (typepred "array2list[below(3)](length(L))(f)") (("1" (inst -3 "n_1+1") (("1" (replace -6) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 2) (("2" (propax) nil nil)) nil) ("3" (expand "length" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (ground) (("2" (replace -1) (("2" (case "FORALL (mm:posnat, ll:{lll:list[below(3)]|cons?(lll) AND length(lll) =mm}, m:below(mm)):
        nth(switch_one_entry(ll, m, new), m) = new") (("1" (inst -1 "length(cdr(L))" "cdr(L)" "n-1") nil nil) ("2" (hide-all-but 1) (("2" (induct "mm") (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (skeep) (("3" (skeep) (("3" (case "j!1=0") (("1" (case-replace "m=0") (("1" (expand "switch_one_entry") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred (m)) (("2" (ground) nil nil)) nil)) nil) ("2" (case "m=0") (("1" (replace -1) (("1" (expand "switch_one_entry") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "switch_one_entry" 3) (("2" (ground) (("2" (expand "nth" 3) (("2" (inst -1 "cdr(ll)" "m-1") (("2" (typepred (ll)) (("2" (expand "length" -3) (("2" (ground) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (typepred (ll)) (("4" (typepred "switch_one_entry(ll, m, new)") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -) (("3" (skeep) (("3" (typepred (m)) (("3" (typepred "mm") (("3" (typepred (ll)) (("3" (typepred "switch_one_entry(ll, m, new)") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (typepred (n_1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "array2list[below(3)](length(L))(f)") (("2" (inst -3 "0") (("2" (ground) (("2" (replace -4) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil) ((array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (list_extensionality formula-decl nil more_list_props structures) (listn type-eq-decl nil listn structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures)) shostak)) (bump_one_ind_list_TCC1 0 (bump_one_ind_list_TCC1-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (bump_one_ind_list subtype "(number_fields.-)((number_fields.+)(query_coeff.j, 1), query_coeff.i)" "naturalnumber"))) (bump_one_ind_list_TCC2 0 (bump_one_ind_list_TCC2-1 nil 3621672198 ("" (skeep) (("" (typepred (j)) (("" (lemma "expt_ge1") (("" (inst -1 "3" "j+1") (("" (ground) (("" (skeep) (("" (grind) (("" (typepred (L)) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt_ge1 formula-decl nil exponentiation nil)) nil (bump_one_ind_list subtype "query_coeff.L" "{ll: list_adt[naturalnumbers.below(3)].list | list_adt[naturalnumbers.below(3)].cons?(ll)}"))) (bump_one_ind_list_TCC3 0 (bump_one_ind_list_TCC3-2 "" 3790097669 ("" (skeep) (("" (skeep) (("" (typepred (j)) (("" (typepred (L)) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil)) shostak (bump_one_ind_list subtype "query_coeff.i" "naturalnumbers.below(list_props[naturalnumbers.below(3)].length(query_coeff.L))")) (bump_one_ind_list_TCC3-1 nil 3621672198 ("" (skeep) (("" (skeep) (("" (typepred (j)) (("" (typepred (L)) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn structures)) nil (bump_one_ind_list subtype "query_coeff.i" "naturalnumbers.below(list_props[naturalnumbers.below(3)].length(query_coeff.L))"))) (bump_one_ind_list_TCC4 0 (bump_one_ind_list_TCC4-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (bump_one_ind_list subtype "(number_fields.+)(query_coeff.ent, 1)" "naturalnumbers.below(3)"))) (bump_one_ind_list_TCC5 0 (bump_one_ind_list_TCC5-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (bump_one_ind_list subtype "query_coeff.switch_one_entry(query_coeff.L, query_coeff.i, (number_fields.+)(query_coeff.ent, 1))" "listn[naturalnumbers.below(3)].listn((number_fields.+)(1, query_coeff.j))"))) (bump_one_ind_list_TCC6 0 (bump_one_ind_list_TCC6-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (bump_one_ind_list subtype "(number_fields.+)(query_coeff.i, 1)" "naturalnumbers.upto((number_fields.+)(1, query_coeff.j))"))) (bump_one_ind_list_TCC7 0 (bump_one_ind_list_TCC7-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (bump_one_ind_list termination "query_coeff.bump_one_ind_list(query_coeff.j, query_coeff.L, (number_fields.+)(query_coeff.i, 1))" "nil"))) (bump_one_ind_list_TCC8 0 (bump_one_ind_list_TCC8-1 nil 3621672198 ("" (skeep) (("" (skeep) (("" (typepred "v(j, L, i + 1)") (("1" (ground) (("1" (grind) nil nil)) nil) ("2" (typepred (L)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (bump_one_ind_list subtype "query_coeff.bump_one_ind_list(query_coeff.j, query_coeff.L, (number_fields.+)(query_coeff.i, 1))" "{ll: list_adt[naturalnumbers.below(3)].list | list_adt[naturalnumbers.below(3)].cons?(ll)}"))) (bump_one_ind_list_TCC9 0 (bump_one_ind_list_TCC9-1 nil 3621672198 ("" (skeep) (("" (skeep) (("" (typepred "v(j, L, i + 1)") (("1" (grind) nil nil) ("2" (typepred (L)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (bump_one_ind_list subtype "query_coeff.i" "naturalnumbers.below(list_props[naturalnumbers.below(3)].length(query_coeff.bump_one_ind_list(query_coeff.j, query_coeff.L, (number_fields.+)(1, query_coeff.i))))"))) (bump_one_ind_list_TCC10 0 (bump_one_ind_list_TCC10-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (bump_one_ind_list subtype "query_coeff.switch_one_entry(query_coeff.bump_one_ind_list(query_coeff.j, query_coeff.L, (number_fields.+)(query_coeff.i, 1)), query_coeff.i, 0)" "listn[naturalnumbers.below(3)].listn((number_fields.+)(1, query_coeff.j))"))) (bump_one_ind_list_TCC11 0 (bump_one_ind_list_TCC11-1 nil 3621672198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn structures) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (bump_one_ind_list subtype "query_coeff.i" "below[length[below(3)](L)]"))) (bump_one_below 0 (bump_one_below-1 nil 3621242035 ("" (skolem 1 ("j" "_" "_" "_")) (("" (case "FORALL (n:nat, 
              (f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0),
              (i: upto(j + 1)), (k: nat)): (n=j+1-i) IMPLIES (
        k < i IMPLIES bump_one_ind(j, f, i)(k) = f(k))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "j+1-i") (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (skeep) (("1" (typepred (f)) (("1" (inst -1 "i") (("1" (expand "bump_one_ind") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (simplify) (("2" (skeep) (("2" (expand "bump_one_ind" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (inst -1 "f" "i+1" "k") (("1" (split -1) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (above nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (j skolem-const-decl "posnat" query_coeff nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (bump_one_ind_lem 0 (bump_one_ind_lem-2 "" 3750606833 ("" (skeep) (("" (lift-if 1) (("" (split 1) (("1" (expand "base_n_to_nat") (("1" (lemma "sigma_with") (("1" (expand "bump_one_ind") (("1" (flatten) (("1" (case-replace "(LAMBDA (s: nat):
                  3 ^ s *
                   IF f(i) < 2 THEN f WITH [i := 1 + f(i)](s)
                   ELSE bump_one_ind(j, f, 1 + i) WITH [i := 0](s)
                   ENDIF) =  (LAMBDA (s: nat): 3 ^ s * f(s)) WITH [i:= 3^i*(1+f(i))]") (("1" (inst -2 "(LAMBDA (s: nat): 3 ^ s * f(s)) WITH [i := 3 ^ i * (1 + f(i))]" "LAMBDA (s: nat): 3 ^ s * f(s)" "3 ^ i * (1 + f(i))" "1+j" "i" "0") (("1" (split -2) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (ground) (("2" (case "i=x!1") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "base_n_to_nat") (("2" (expand "bump_one_ind" 2 1) (("2" (lemma "sigma_with") (("2" (inst -1 "LAMBDA (s: nat):
              3 ^ s *
               IF f(i) < 2 THEN f WITH [i := 1 + f(i)](s)
               ELSE bump_one_ind(j, f, 1 + i) WITH [i := 0](s)
               ENDIF " " LAMBDA (s: nat): 3 ^ s * bump_one_ind(j, f, 1 + i)(s)" "0" "j+1" "i" "0") (("1" (split -1) (("1" (ground) (("1" (case "i+1<=j+1") (("1" (ground) (("1" (replace -2) (("1" (case-replace "bump_one_ind(j, f, 1 + i)(i) = f(i)") (("1" (ground) nil nil) ("2" (lemma "bump_one_below") (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (typepred (f)) (("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (hide 3) (("4" (decompose-equality 1) (("1" (case "x!1 = i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (typepred (f)) (("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred (f)) (("3" (typepred (i)) (("3" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (f)) (("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (typepred (f)) (("3" (typepred (i)) (("3" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bump_one_below formula-decl nil query_coeff nil) (posint_exp application-judgement "posint" exponentiation nil) (sigma_nat application-judgement "nat" sigma_nat reals) (base_n_to_nat const-decl "nat" base_repr reals) (bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (j skolem-const-decl "posnat" query_coeff nil) (f skolem-const-decl "{f | FORALL (k: above(j)): f(k) = 0}" query_coeff nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (sigma_with formula-decl nil sigma reals) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (bump_one_ind_lem-1 nil 3621174807 ("" (skeep) (("" (lift-if 1) (("" (split 1) (("1" (expand "base_n_to_nat") (("1" (lemma "sigma_with") (("1" (expand "bump_one_ind") (("1" (flatten) (("1" (case-replace "(LAMBDA (s: nat):
                  3 ^ s *
                   IF f(i) < 2 THEN f WITH [i := 1 + f(i)](s)
                   ELSE bump_one_ind(j, f, 1 + i) WITH [i := 0](s)
                   ENDIF) =  (LAMBDA (s: nat): 3 ^ s * f(s)) WITH [i:= 3^i*(1+f(i))]") (("1" (inst -2 "(LAMBDA (s: nat): 3 ^ s * f(s)) WITH [i := 3 ^ i * (1 + f(i))]" "LAMBDA (s: nat): 3 ^ s * f(s)" "3 ^ i * (1 + f(i))" "1+j" "i" "0") (("1" (split -2) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (ground) (("2" (case "i=x!1") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "base_n_to_nat") (("2" (expand "bump_one_ind" 2 1) (("2" (lemma "sigma_with") (("2" (inst -1 "LAMBDA (s: nat):
              3 ^ s *
               IF f(i) < 2 THEN f WITH [i := 1 + f(i)](s)
               ELSE bump_one_ind(j, f, 1 + i) WITH [i := 0](s)
               ENDIF " " LAMBDA (s: nat): 3 ^ s * bump_one_ind(j, f, 1 + i)(s)" "0" "j+1" "i" "0") (("1" (split -1) (("1" (ground) (("1" (case "i+1<=j+1") (("1" (ground) (("1" (replace -2) (("1" (case-replace "bump_one_ind(j, f, 1 + i)(i) = f(i)") (("1" (ground) nil nil) ("2" (lemma "bump_one_below") (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (typepred (f)) (("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (hide 3) (("4" (decompose-equality 1) (("1" (case "x!1 = i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (typepred (f)) (("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred (f)) (("3" (typepred (i)) (("3" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (f)) (("2" (typepred (i)) (("2" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (typepred (f)) (("3" (typepred (i)) (("3" (case "i<1+j") (("1" (ground) nil nil) ("2" (case "i=1+j") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_with formula-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (base_n_to_nat const-decl "nat" base_repr reals)) shostak)) (bump_one_ind_lem2_TCC1 0 (bump_one_ind_lem2_TCC1-1 nil 3621258320 ("" (subtype-tcc) nil nil) nil nil (bump_one_ind_lem2 subtype "0" "naturalnumbers.upto((number_fields.+)(1, query_coeff.j))"))) (bump_one_ind_lem2_TCC2 0 (bump_one_ind_lem2_TCC2-1 nil 3621258320 ("" (skeep) (("" (typepred (i)) (("" (case "i=j+1") (("1" (typepred (f)) (("1" (inst -1 "i") (("1" (inst -4 "i") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (j skolem-const-decl "posnat" query_coeff nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (bump_one_ind_lem2 subtype "(number_fields.+)(query_coeff.i, 1)" "naturalnumbers.upto((number_fields.+)(1, query_coeff.j))"))) (bump_one_ind_lem2 0 (bump_one_ind_lem2-2 "" 3804279830 ("" (skolem 1 ("j" "_" "_")) (("" (case "FORALL (n:nat, (f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0),
                     (i: upto(1 + j))): n=i IMPLIES
               (FORALL (m: nat): m <= i IMPLIES f(m) = 2) IMPLIES
                base_n_to_nat(3, bump_one_ind(j, f, 0), j + 1) =
                 base_n_to_nat(3, bump_one_ind(j, f, i + 1), j + 1) -
                  sigma(0, i, LAMBDA (s: nat): 2 * 3 ^ s)") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "i") (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (skeep) (("1" (replace -1 :dir rl) (("1" (simplify) (("1" (rewrite "sigma_eq_arg") (("1" (expand "bump_one_ind" 1 1) (("1" (inst -2 "0") (("1" (split -2) (("1" (ground) (("1" (expand "base_n_to_nat") (("1" (lemma "sigma_with") (("1" (inst -1 "LAMBDA (s: nat):
              3 ^ s * bump_one_ind(j, f, 1) WITH [(0) := 0](s)" "LAMBDA (s: nat): 3 ^ s * bump_one_ind(j, f, 1)(s)" "0" "j+1" "0" "0") (("1" (split -1) (("1" (rewrite "bump_one_below") (("1" (ground) (("1" (replace -2) (("1" (ground) (("1" (expand "*") (("1" (ground) (("1" (case-replace "(LAMBDA (s: nat):
              (LAMBDA (x: nat): 3 ^ s * bump_one_ind(j, f, 1)(x))
                WITH [(0) := 0]
                  (s)) = LAMBDA (s: nat):
              3 ^ s * (bump_one_ind(j, f, 1) WITH [(0) := 0])(s)") (("1" (decompose-equality 1) (("1" (hide (-1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (hide 2) (("4" (decompose-equality 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (inst -1 "f" "i-1") (("1" (split -1) (("1" (simplify -1) (("1" (lemma "bump_one_ind_lem") (("1" (inst -1 "j" "f" "i") (("1" (lift-if -1) (("1" (inst-cp -4 "i") (("1" (split -5) (("1" (ground) (("1" (replace -3) (("1" (replace -1) (("1" (simplify 2) (("1" (both-sides "*" "-1" 2) (("1" (simplify 2) (("1" (replace -2) (("1" (expand "sigma" 2 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 "m") (("2" (ground) nil nil)) nil)) nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (typepred (f)) (("3" (typepred (i)) (("3" (inst - "i") (("1" (inst - "i") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred (f)) (("3" (typepred (j)) (("3" (typepred (i)) (("3" (inst -5 "i") (("3" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (bump_one_ind_lem2-1 nil 3621258372 ("" (skolem 1 ("j" "_" "_")) (("" (case "FORALL (n:nat, (f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0),
                     (i: upto(1 + j))): n=i IMPLIES
               (FORALL (m: nat): m <= i IMPLIES f(m) = 2) IMPLIES
                base_n_to_nat(3, bump_one_ind(j, f, 0), j + 1) =
                 base_n_to_nat(3, bump_one_ind(j, f, i + 1), j + 1) -
                  sigma(0, i, LAMBDA (s: nat): 2 * 3 ^ s)") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "i") (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (skeep) (("1" (replace -1 :dir rl) (("1" (simplify) (("1" (rewrite "sigma_eq_arg") (("1" (expand "bump_one_ind" 1 1) (("1" (inst -2 "0") (("1" (split -2) (("1" (ground) (("1" (expand "base_n_to_nat") (("1" (lemma "sigma_with") (("1" (inst -1 "LAMBDA (s: nat):
              3 ^ s * bump_one_ind(j, f, 1) WITH [(0) := 0](s)" "LAMBDA (s: nat): 3 ^ s * bump_one_ind(j, f, 1)(s)" "0" "j+1" "0" "0") (("1" (split -1) (("1" (rewrite "bump_one_below") (("1" (ground) (("1" (replace -2) (("1" (ground) (("1" (expand "*") (("1" (ground) (("1" (case-replace "(LAMBDA (s: nat):
              (LAMBDA (x: nat): 3 ^ s * bump_one_ind(j, f, 1)(x))
                WITH [(0) := 0]
                  (s)) = LAMBDA (s: nat):
              3 ^ s * (bump_one_ind(j, f, 1) WITH [(0) := 0])(s)") (("1" (decompose-equality 1) (("1" (hide (-1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil) ("4" (hide 2) (("4" (decompose-equality 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (inst -1 "f" "i-1") (("1" (split -1) (("1" (simplify -1) (("1" (lemma "bump_one_ind_lem") (("1" (inst -1 "j" "f" "i") (("1" (lift-if -1) (("1" (inst-cp -4 "i") (("1" (split -5) (("1" (ground) (("1" (replace -3) (("1" (replace -1) (("1" (simplify 2) (("1" (both-sides "*" "-1" 2) (("1" (simplify 2) (("1" (replace -2) (("1" (expand "sigma" 2 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 "m") (("2" (ground) nil nil)) nil)) nil) ("3" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (typepred (f)) (("3" (typepred (i)) (("3" (inst -3 "i") (("3" (inst -2 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred (f)) (("3" (typepred (j)) (("3" (typepred (i)) (("3" (inst -4 "i") (("3" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "upto(1 + j)" query_coeff nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times1 formula-decl nil real_props nil) (odd? const-decl "bool" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bump_one_ind_lem formula-decl nil query_coeff nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_times_even_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (bump_one_below formula-decl nil query_coeff nil) (* const-decl "[T -> real]" real_fun_ops reals) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_with formula-decl nil sigma reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma reals) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_nat application-judgement "nat" sigma_nat reals) (posint_exp application-judgement "posint" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (j skolem-const-decl "posnat" query_coeff nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (base_n_to_nat const-decl "nat" base_repr reals) (bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil)) shostak)) (low2_TCC1 0 (low2_TCC1-1 nil 3621333123 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (j!1 skolem-const-decl "posnat" query_coeff nil) (f!1 skolem-const-decl "{f | FORALL (k: above(j!1)): f(k) = 0}" query_coeff nil) (i!1 skolem-const-decl "{ii: upto(1 + j!1) | f!1(ii) < 2}" query_coeff nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (low2 subtype "{m: naturalnumbers.nat | booleans.AND(reals.<(m, query_coeff.i), reals.<(query_coeff.f(m), 2))}" "(sets[nat].nonempty?)"))) (low2_TCC2 0 (low2_TCC2-1 nil 3621333123 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i!1 skolem-const-decl "{ii: upto(1 + j!1) | f!1(ii) < 2}" query_coeff nil) (f!1 skolem-const-decl "{f | FORALL (k: above(j!1)): f(k) = 0}" query_coeff nil) (j!1 skolem-const-decl "posnat" query_coeff nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (low2 subtype "sets[nat].choose({m: naturalnumbers.nat | booleans.AND(reals.<(m, query_coeff.i), reals.<(query_coeff.f(m), 2))})" "{ii: naturalnumbers.upto((number_fields.+)(1, query_coeff.j)) | reals.<(query_coeff.f(ii), 2)}"))) (low2_lem 0 (low2_lem-1 nil 3621333584 ("" (skolem 1 ("j" "f" "_")) (("" (case "FORALL (n:nat, i: {ii: upto(1 + j) | f(ii) < 2}):
               LET M = low2(j, f, i) IN
               n=i IMPLIES (
                 f(M) < 2 AND (FORALL (m: nat): m < M IMPLIES f(m) = 2))") (("1" (skeep) (("1" (inst -1 "i" "i") nil nil)) nil) ("2" (hide 2) (("2" (induct "n" 1 "NAT_induction") (("1" (ground) nil nil) ("2" (skeep) (("2" (ground) (("2" (skeep) (("2" (expand "low2" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (inst -2 "choose({m: nat | m < i AND f(m) < 2}) ") (("1" (split -2) (("1" (inst -1 "choose({m: nat | m < i AND f(m) < 2}) ") (("1" (ground) nil nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skeep -2) (("2" (inst -1 "m") (("2" (ground) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skeep -2) (("2" (inst -1 "m") (("2" (ground) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred (i)) (("2" (ground) (("2" (case "nonempty?({m:nat| m<i AND f(m)<2})") (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (inst 2 "x") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (skeep) (("2" (expand "empty?") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((low2 def-decl "{ii: upto(j + 1) | f(ii) < 2}" query_coeff nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (above nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (i skolem-const-decl "{ii: upto(1 + j) | f(ii) < 2}" query_coeff nil) (f skolem-const-decl "{f | FORALL (k: above(j)): f(k) = 0}" query_coeff nil) (j skolem-const-decl "posnat" query_coeff nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (choose const-decl "(p)" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (bump_one_prep_TCC1 0 (bump_one_prep_TCC1-1 nil 3621256133 ("" (subtype-tcc) nil nil) nil nil (bump_one_prep subtype "0" "naturalnumbers.upto((number_fields.+)(1, query_coeff.j))"))) (bump_one_prep 0 (bump_one_prep-1 nil 3621256149 ("" (case "FORALL (j: posnat,
                     (f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0), n:{nn:upto(j+1)|f(nn)<2 AND (FORALL (m:nat):m<nn IMPLIES f(m) = 2 )}):
               base_n_to_nat(3, bump_one_ind(j, f, 0), j + 1) =
                base_n_to_nat(3, f, j + 1) + 1") (("1" (skeep) (("1" (case "EXISTS (nn:upto(j+1)): f(nn) < 2 AND
                                   (FORALL (m: nat): m < nn IMPLIES f(m) = 2)") (("1" (skeep) (("1" (inst? -3) (("1" (inst -3 "nn") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (typepred (f)) (("2" (ground) (("2" (inst 1 " low2(j, f, j+1)") (("1" (lemma "low2_lem") (("1" (inst -1 "j" "f" "j+1") (("1" (ground) nil nil) ("2" (inst -1 "j+1") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (inst -1 "j+1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (typepred (n)) (("2" (lemma "bump_one_ind_lem2") (("2" (inst?) (("2" (case-replace "n=0") (("1" (typepred (j)) (("1" (lemma "bump_one_ind_lem") (("1" (inst -1 "j" "f" "0") (("1" (ground) (("1" (expand "^") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "n-1") (("1" (split -1) (("1" (simplify -1) (("1" (lemma "bump_one_ind_lem") (("1" (inst -1 "j" "f" "n") (("1" (ground) (("1" (replace -1) (("1" (replace -2) (("1" (simplify 2) (("1" (rewrite "sigma_scal") (("1" (lemma "sigma_geometric") (("1" (inst -1 "n-1" "0" "3") (("1" (split -1) (("1" (replace -1) (("1" (simplify 2) (("1" (ground) (("1" (case-replace "2 * ((3 ^ 0 - 3 ^ n) / (-2)) = - (3^0-3^n)") (("1" (ground) (("1" (case "forall(a,b:real): a - (-b) = a+b") (("1" (inst -1 "3^n" "(3 ^ 0 - 3 ^ n)") (("1" (ground) (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (cross-mult) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (skeep) (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_nat application-judgement "nat" sigma_nat reals) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "posnat" query_coeff nil) (f skolem-const-decl "{f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0}" query_coeff nil) (n skolem-const-decl "{nn: upto(1 + j) | f(nn) < 2 AND FORALL (m: nat): m < nn IMPLIES f(m) = 2}" query_coeff nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_geometric formula-decl nil sigma_nat reals) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div1 formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sigma_scal formula-decl nil sigma reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bump_one_ind_lem formula-decl nil query_coeff nil) (bump_one_ind_lem2 formula-decl nil query_coeff nil) (low2_lem formula-decl nil query_coeff nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (low2 def-decl "{ii: upto(j + 1) | f(ii) < 2}" query_coeff nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j skolem-const-decl "posnat" query_coeff nil) (f skolem-const-decl "{f | FORALL (k: above(j)): f(k) = 0}" query_coeff nil) (nn skolem-const-decl "upto(1 + j)" query_coeff nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (base_n_to_nat const-decl "nat" base_repr reals) (bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil)) shostak)) (bump_one_prep2_TCC1 0 (bump_one_prep2_TCC1-1 nil 3621264743 ("" (skeep) (("" (skeep) (("" (typepred (f)) (("" (typepred (k_1)) (("" (lemma "upper_is_bound") (("" (inst?) (("" (inst -1 "k_1") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((above nonempty-type-eq-decl nil integers nil) (upper_index const-decl "nat" base_repr reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upper_is_bound formula-decl nil base_repr reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (base_n def-decl "nat" base_repr reals)) nil (bump_one_prep2 subtype "query_coeff.f" "{f | FORALL (k_1: integers.above((number_fields.+)(1, base_repr.upper_index(3, query_coeff.k)))): query_coeff.f(k_1) = 0}"))) (bump_one_prep2_TCC2 0 (bump_one_prep2_TCC2-1 nil 3621264743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (base_n def-decl "nat" base_repr reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (bump_one_prep2 subtype "0" "naturalnumbers.upto((number_fields.+)(2, base_repr.upper_index(3, query_coeff.k)))"))) (bump_one_prep2 0 (bump_one_prep2-1 nil 3621264745 ("" (skeep) (("" (lemma "bump_one_prep") (("" (inst?) (("" (lemma "base_n_unique") (("" (typepred (f)) (("" (replace -1) (("" (lemma "base_n_is_n_alt") (("" (inst -1 "3" "k" "upper_index(3, k) +2") (("" (split -1) (("1" (replace -1 :dir rl) (("1" (inst -3 "upper_index(3,k)+2 " "3" "bump_one_ind(upper_index(3, k) + 1, base_n(3, k), 0)") (("1" (expand "base_n_to_nat" -4) (("1" (ground) (("1" (decompose-equality 1) (("1" (typepred "bump_one_ind(1 + upper_index(3, k), base_n(3, k), 0)") (("1" (case "x!1>2+upper_index(3,k)") (("1" (inst -2 "x!1") (("1" (lemma "upper_is_bound") (("1" (inst -1 "3" "k+1" "x!1") (("1" (split -1) (("1" (ground) nil nil) ("2" (hide (2 -6 -2 -6)) (("2" (hide -4) (("2" (expand "upper_index") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (lemma "log_nat_incr") (("1" (replace -2) (("1" (expand "log_nat") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "log_nat_incr") (("2" (expand "log_nat" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (flip-ineq 1) (("2" (expand "log_nat" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (simplify 2) (("2" (inst -2 "3" "(1 + k) / 3 / 3" "k") (("2" (split -2) (("1" (ground) nil nil) ("2" (hide (-3 -4 -2 3)) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "x!1") (("2" (split -4) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "upper_index") (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (lemma "log_nat_bounds") (("2" (inst -1 "3" "k") (("2" (ground) (("2" (flatten) (("2" (expand "^") (("2" (expand "expt" 2) (("2" (expand "expt" 2) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bump_one_prep formula-decl nil query_coeff nil) (base_n_unique formula-decl nil base_repr reals) (log_nat_bounds formula-decl nil log_nat reals) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nat_exp application-judgement "nat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (base_n_to_nat const-decl "nat" base_repr reals) (k skolem-const-decl "nat" query_coeff nil) (upper_is_bound formula-decl nil base_repr reals) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (log_nat_incr formula-decl nil log_nat reals) (x!1 skolem-const-decl "nat" query_coeff nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (base_n_lt_n formula-decl nil base_repr reals) (posint_exp application-judgement "posint" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sigma_nat application-judgement "nat" sigma_nat reals) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil) (base_n_is_n_alt formula-decl nil base_repr reals) (NOT const-decl "[bool -> bool]" booleans nil) (base_n def-decl "nat" base_repr reals) (= const-decl "[T, T -> boolean]" equalities nil) (above nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upper_index const-decl "nat" base_repr reals) (nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak)) (bump_one_TCC1 0 (bump_one_TCC1-1 nil 3621165054 ("" (lemma "bump_one_prep2") (("" (ground) nil nil)) nil) ((bump_one_prep2 formula-decl nil query_coeff nil)) nil (bump_one subtype "query_coeff.bump_one_ind((number_fields.+)(base_repr.upper_index(3, query_coeff.k), 1), query_coeff.f, 0)" "{ff: [naturalnumbers.nat -> naturalnumbers.below(3)] | ff = base_repr.base_n(3, (number_fields.+)(1, query_coeff.k))}"))) (switch_to_array 0 (switch_to_array-2 "" 3750606908 ("" (case "FORALL (nn:nat, j: posnat, L: listn[below(3)](j + 1),
              (f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0),
              i: upto(j + 1)): nn = j+1-i IMPLIES
        ( array2list[below(3)](j + 1)(f) = L IMPLIES
         bump_one_ind_list(j, L, i) =
          array2list[below(3)](j + 1)(bump_one_ind(j, f, i)))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "j+1-i") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (skeep) (("1" (both-sides "+" "i" -1) (("1" (simplify) (("1" (expand "bump_one_ind_list") (("1" (lift-if 1) (("1" (ground) (("1" (lemma "bump_one_below") (("1" (lemma "list_extensionality[below(3)]") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (typepred "array2list[below(3)](1 + j)(bump_one_ind(j, f, i))") (("1" (replace -2) (("1" (split -4) (("1" (propax) nil nil) ("2" (typepred (L)) (("2" (propax) nil nil)) nil) ("3" (skeep) (("3" (inst -3 "n") (("3" (replace -3 :dir rl) (("3" (inst -4 "j" "f" "i" "n") (("3" (typepred (n)) (("3" (ground) (("3" (replace -1) (("3" (typepred (f)) (("3" (typepred (L)) (("3" (replace -11 :dir rl) (("3" (hide 2) (("3" (typepred "array2list[below(3)](1 + j)(f)") (("3" (inst -3 "n") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (case "nth(L,i) = f(i)") (("1" (case "f(i)<2") (("1" (expand "bump_one_ind_list") (("1" (expand "bump_one_ind") (("1" (hide -3) (("1" (ground) (("1" (lemma "switch_is_with") (("1" (inst -1 "L" "i" "1+f(i)" "f") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bump_one_ind" 2) (("2" (expand "bump_one_ind_list" 2) (("2" (ground) (("2" (lemma "switch_is_with") (("2" (inst -1 "bump_one_ind_list(j, L, 1 + i)" "i" "0" "bump_one_ind(j, f, 1 + i)") (("1" (ground) nil nil) ("2" (hide 3) (("2" (inst -2 "j" "L" "f" "i+1") (("2" (split -2) (("1" (ground) nil nil) ("2" (propax) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :dir rl) (("2" (typepred "array2list[below(3)](j + 1)(f)") (("1" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil) ("3" (ground) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst 1 "0") nil nil)) nil) ("4" (skeep) (("4" (inst 1 "0") nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst 1 "0") nil nil)) nil) ("4" (skeep) (("4" (inst 1 "0") nil nil)) nil)) nil) ((j skolem-const-decl "posnat" query_coeff nil) (L skolem-const-decl "listn[below(3)](1 + j)" query_coeff nil) (i skolem-const-decl "upto(1 + j)" query_coeff nil) (f skolem-const-decl "{f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0}" query_coeff nil) (switch_is_with formula-decl nil query_coeff nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bump_one_below formula-decl nil query_coeff nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_extensionality formula-decl nil more_list_props structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn structures) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (bump_one_ind_list def-decl "listn[below(3)](j + 1)" query_coeff nil) (bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil)) shostak) (switch_to_array-1 nil 3621677401 ("" (case "FORALL (nn:nat, j: posnat, L: listn[below(3)](j + 1),
              (f: [nat -> below(3)] | FORALL (k: above(j)): f(k) = 0),
              i: upto(j + 1)): nn = j+1-i IMPLIES
        ( array2list[below(3)](j + 1)(f) = L IMPLIES
         bump_one_ind_list(j, L, i) =
          array2list[below(3)](j + 1)(bump_one_ind(j, f, i)))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "j+1-i") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (skeep) (("1" (both-sides "+" "i" -1) (("1" (simplify) (("1" (expand "bump_one_ind_list") (("1" (lift-if 1) (("1" (ground) (("1" (lemma "bump_one_below") (("1" (lemma "list_extensionality[below(3)]") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (typepred "array2list[below(3)](1 + j)(bump_one_ind(j, f, i))") (("1" (replace -2) (("1" (split -4) (("1" (propax) nil nil) ("2" (typepred (L)) (("2" (propax) nil nil)) nil) ("3" (skeep) (("3" (inst -3 "n") (("3" (replace -3 :dir rl) (("3" (inst -4 "j" "f" "i" "n") (("3" (typepred (n)) (("3" (ground) (("3" (replace -1) (("3" (typepred (f)) (("3" (typepred (L)) (("3" (replace -11 :dir rl) (("3" (hide 2) (("3" (typepred "array2list[below(3)](1 + j)(f)") (("3" (inst -3 "n") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (case "nth(L,i) = f(i)") (("1" (case "f(i)<2") (("1" (expand "bump_one_ind_list") (("1" (expand "bump_one_ind") (("1" (hide -3) (("1" (ground) (("1" (lemma "switch_is_with") (("1" (inst -1 "L" "i" "1+f(i)" "f") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bump_one_ind" 2) (("2" (expand "bump_one_ind_list" 2) (("2" (ground) (("2" (lemma "switch_is_with") (("2" (inst -1 "bump_one_ind_list(j, L, 1 + i)" "i" "0" "bump_one_ind(j, f, 1 + i)") (("1" (ground) nil nil) ("2" (hide 3) (("2" (inst -2 "j" "L" "f" "i+1") (("2" (split -2) (("1" (ground) nil nil) ("2" (propax) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :dir rl) (("2" (typepred "array2list[below(3)](j + 1)(f)") (("2" (inst -3 "i") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (listn type-eq-decl nil listn structures) (list_extensionality formula-decl nil more_list_props structures)) shostak)) (bump_one_list_TCC1 0 (bump_one_list_TCC1-1 nil 3621696480 ("" (subtype-tcc) nil nil) nil nil (bump_one_list subtype "0" "naturalnumbers.upto((number_fields.+)(1, query_coeff.j))"))) (bump_one_list_TCC2 0 (bump_one_list_TCC2-1 nil 3621696480 ("" (skeep) (("" (lemma "switch_to_array") (("" (inst -1 "j" "L" "base_n(3,k)" "0") (("1" (typepred (L)) (("1" (split -4) (("1" (replace -1) (("1" (expand "base_list") (("1" (case-replace "bump_one_ind(j, base_n(3, k), 0) = base_n(3, 1 + k)") (("1" (hide -) (("1" (hide 2) (("1" (lemma "bump_one_prep") (("1" (inst -1 "j" " base_n(3, k)") (("1" (lemma "base_n_is_n_alt") (("1" (inst -1 "3" "k" "j+1") (("1" (typepred (k)) (("1" (split -2) (("1" (replace -1 :dir rl) (("1" (lemma "base_n_to_nat_unique") (("1" (inst -1 "3" "k" "j+1" "bump_one_ind(j, base_n(3, k), 0)" " base_n(3, k+1)") (("1" (split -1) (("1" (decompose-equality 1) (("1" (typepred "bump_one_ind(j, base_n(3, k), 0)") (("1" (case "x!1 >1+j") (("1" (inst -2 "x!1") (("1" (lemma "base_n_0") (("1" (inst -1 "3 " "1+k" "x!1") (("1" (split -1) (("1" (ground) nil nil) ("2" (typepred (k)) (("2" (case "k=0") (("1" (replace -1) (("1" (lemma "both_sides_expt_gt1_gt") (("1" (inst -1 "3" "x!1" "1+j") (("1" (ground) (("1" (case "forall (a,b:nat): a<b IMPLIES a+1<=b") (("1" (inst -1 "0" "3^(1+j)") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k+1<=3^(1+j)") (("1" (lemma "both_sides_expt_gt1_gt") (("1" (inst -1 "3" "x!1" "1+j") (("1" (flatten) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) (("2" (case "forall (a,b:nat): a<b IMPLIES a+1<=b") (("1" (inst -1 "k" "3^(1+j)") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "x!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "base_n_lt_n") nil nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "base_n_lt_n") (("2" (typepred "bump_one_ind(j, base_n(3, k), 0)") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (replace -3) (("3" (lemma "base_n_is_n_alt") (("3" (inst -1 "3" "k+1" "j+1") (("3" (split -1) (("1" (propax) nil nil) ("2" (case "forall (a,b:nat): a<b IMPLIES a+1<=b") (("1" (inst -1 "k" "3^(1+j)") (("1" (ground) (("1" (lemma "both_sides_expt_gt1_gt") (("1" (inst -1 "3" "j+2" "j+1") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt" 1) (("2" (case "1<3") (("1" (mult-ineq -1 -2) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "base_list") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (split 1) (("1" (skeep) (("1" (rewrite "base_n_lt_n") nil nil)) nil) ("2" (skeep) (("2" (typepred (k_1)) (("2" (typepred (k)) (("2" (lemma "base_n_0") (("2" (inst -1 "3" "k" "k_1") (("2" (case "k_1>=j+1") (("1" (lemma "both_sides_expt_gt1_ge") (("1" (inst -1 "3" "k_1" "j+1") (("1" (flatten) (("1" (hide -1) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((switch_to_array formula-decl nil query_coeff nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_expt_gt1_ge formula-decl nil exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (bump_one_ind def-decl "{ff: [nat -> below(3)] | FORALL (k: above(j + 1)): ff(k) = 0}" query_coeff nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (base_n_to_nat_unique formula-decl nil base_repr reals) (base_n_lt_n formula-decl nil base_repr reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "nat" query_coeff nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (both_sides_expt_gt1_gt formula-decl nil exponentiation nil) (base_n_0 formula-decl nil base_repr reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (expt def-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (lt_times_lt_any1 formula-decl nil extra_real_props nil) (base_n_is_n_alt formula-decl nil base_repr reals) (bump_one_prep formula-decl nil query_coeff nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (base_list const-decl "listn[below(n)](digits)" base_repr reals) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (base_n def-decl "nat" base_repr reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (j skolem-const-decl "posnat" query_coeff nil) (below type-eq-decl nil naturalnumbers nil) (k skolem-const-decl "below(3 ^ (1 + j))" query_coeff nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil (bump_one_list subtype "query_coeff.bump_one_ind_list(query_coeff.j, query_coeff.L, 0)" "{ll: listn[naturalnumbers.below(3)].listn((number_fields.+)(query_coeff.j, 1)) | ll = base_repr.base_list(3, (number_fields.+)(1, query_coeff.k), (number_fields.+)(1, query_coeff.j))}"))) (is_nonzero_TCC1 0 (is_nonzero_TCC1-1 nil 3621592121 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (is_nonzero subtype "0" "{x: reals.real | x = number_fields.*(query_coeff.F(query_coeff.l), query_coeff.G(query_coeff.l))}"))) (dot_tail_sum2plus_TCC1 0 (dot_tail_sum2plus_TCC1-1 nil 3621758096 ("" (subtype-tcc) nil nil) nil nil (dot_tail_sum2plus subtype "query_coeff.n" "posnat"))) (dot_tail_sum2plus_TCC2 0 (dot_tail_sum2plus_TCC2-1 nil 3621758096 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (base_list const-decl "listn[below(n)](digits)" base_repr reals) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (dot_tail_sum2plus subtype "(number_fields.-)(exponentiation.^(3, query_coeff.n), query_coeff.i)" "naturalnumber"))) (dot_tail_sum2plus_TCC3 0 (dot_tail_sum2plus_TCC3-2 "" 3790097680 ("" (skeep) (("" (skeep) (("" (ground) (("" (typepred (i)) (("" (case "forall (a, b:nat): a<b IMPLIES a+1<=b") (("1" (inst -1 "i" "3^n") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (dot_tail_sum2plus subtype "(number_fields.+)(query_coeff.i, 1)" "naturalnumbers.upto(exponentiation.^(3, query_coeff.n))")) (dot_tail_sum2plus_TCC3-1 nil 3621758096 ("" (skeep) (("" (skeep) (("" (ground) (("" (typepred (i)) (("" (ground) (("" (case "forall (a, b:nat): a<b IMPLIES a+1<=b") (("1" (inst -1 "i" "3^n") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (dot_tail_sum2plus subtype "(number_fields.+)(query_coeff.i, 1)" "naturalnumbers.upto(exponentiation.^(3, query_coeff.n))"))) (dot_tail_sum2plus_TCC4 0 (dot_tail_sum2plus_TCC4-1 nil 3621758096 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil)) nil (dot_tail_sum2plus subtype "(number_fields.-)(query_coeff.n, 1)" "posnat"))) (dot_tail_sum2plus_TCC5 0 (dot_tail_sum2plus_TCC5-1 nil 3621758096 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (base_list const-decl "listn[below(n)](digits)" base_repr reals) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (^ const-decl "real" exponentiation nil)) nil (dot_tail_sum2plus subtype "query_coeff.i" "naturalnumbers.below(exponentiation.^(3, query_coeff.n))"))) (dot_tail_sum2plus_TCC6 0 (dot_tail_sum2plus_TCC6-1 nil 3621758096 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (^ const-decl "real" exponentiation nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (base_list const-decl "listn[below(n)](digits)" base_repr reals)) nil (dot_tail_sum2plus subtype "query_coeff.L" "{ll: listn[naturalnumbers.below(3)].listn(query_coeff.n) | ll = base_repr.base_list(3, query_coeff.i, query_coeff.n)}"))) (dot_tail_sum2plus_TCC7 0 (dot_tail_sum2plus_TCC7-1 nil 3621758096 ("" (termination-tcc) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (is_nonzero const-decl "{x: real | x = F(l) * G(l)}" query_coeff nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (dot_tail_sum2plus termination "query_coeff.dot_tail_sum2plus(query_coeff.n, query_coeff.F, query_coeff.G, query_coeff.A, (number_fields.+)(query_coeff.i, 1), query_coeff.bump_one_list((number_fields.-)(query_coeff.n, 1), query_coeff.i, query_coeff.L))" "nil"))) (dot_tail_sum2plus_TCC8 0 (dot_tail_sum2plus_TCC8-1 nil 3621758096 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (base_list const-decl "listn[below(n)](digits)" base_repr reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (^ const-decl "real" exponentiation nil)) nil (dot_tail_sum2plus subtype "query_coeff.L" "{ll: list_adt[naturalnumbers.below(3)].list | list_props[naturalnumbers.below(3)].length(ll) = query_coeff.n}"))) (dot_tail_sum_lem 0 (dot_tail_sum_lem-2 "" 3790097685 ("" (case "FORALL (nn:nat, n: {x:nat|x>1},
                     F, G: [{ll: list[below(3)] | length(ll) = n} -> real],
                     a: real, i: upto(3 ^ n), L:{ll:list[below(3)]| ll = base_list(3, i, n)}):
               nn = 3^n-i IMPLIES
               dot_tail_sum2plus(n, F, G, a, i, L) =
                a +
                 sigma(i, 3 ^ n - 1,
                       LAMBDA (j: nat):
                         F(base_list(3, j, n)) * G(base_list(3, j, n)))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "3^n-i") nil nil)) nil)) nil) ("2" (hide 2) (("2" (skolem 1 ("_" "n" "F" "G" "_" "_" "_")) (("2" (induct "nn") (("1" (skeep) (("1" (both-sides "+" "i" -1) (("1" (simplify -1) (("1" (replace -1) (("1" (expand "dot_tail_sum2plus") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "dot_tail_sum2plus" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (inst -1 "is_nonzero(n, L, F, G) + a" "i+1" "bump_one_list(n - 1, i, L)") (("1" (split -1) (("1" (replace -1) (("1" (swap-rel 2) (("1" (rewrite "sigma_first" (2 2)) (("1" (simplify 2) (("1" (typepred "is_nonzero(n, L, F, G)") (("1" (typepred (L)) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (sigma_first formula-decl nil sigma reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (is_nonzero const-decl "{x: real | x = F(l) * G(l)}" query_coeff nil) (bump_one_list const-decl "{ll: listn[below(3)](j + 1) | ll = base_list(3, k + 1, j + 1)}" query_coeff nil) (i skolem-const-decl "upto(3 ^ n)" query_coeff nil) (n skolem-const-decl "{x: nat | x > 1}" query_coeff nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (listn type-eq-decl nil listn structures) (base_list const-decl "listn[below(n)](digits)" base_repr reals) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (dot_tail_sum2plus def-decl "real" query_coeff nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (dot_tail_sum_lem-1 nil 3621592773 ("" (case "FORALL (nn:nat, n: {x:nat|x>1},
                     F, G: [{ll: list[below(3)] | length(ll) = n} -> real],
                     a: real, i: upto(3 ^ n), L:{ll:list[below(3)]| ll = base_list(3, i, n)}):
               nn = 3^n-i IMPLIES
               dot_tail_sum2plus(n, F, G, a, i, L) =
                a +
                 sigma(i, 3 ^ n - 1,
                       LAMBDA (j: nat):
                         F(base_list(3, j, n)) * G(base_list(3, j, n)))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "3^n-i") nil nil)) nil)) nil) ("2" (hide 2) (("2" (skolem 1 ("_" "n" "F" "G" "_" "_" "_")) (("2" (induct "nn") (("1" (skeep) (("1" (both-sides "+" "i" -1) (("1" (simplify -1) (("1" (replace -1) (("1" (expand "dot_tail_sum2plus") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "dot_tail_sum2plus" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (inst -1 "is_nonzero(n, L, F, G) + a" "i+1" "bump_one_list(n - 1, i, L)") (("1" (split -1) (("1" (replace -1) (("1" (swap-rel 2) (("1" (rewrite "sigma_first" (2 2)) (("1" (simplify 2) (("1" (typepred "is_nonzero(n, L, F, G)") (("1" (typepred (L)) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (ground) nil nil)) nil)) nil) ((sigma_first formula-decl nil sigma reals) (listn type-eq-decl nil listn structures) (base_list const-decl "listn[below(n)](digits)" base_repr reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals)) shostak)) (is_nz_TCC1 0 (is_nz_TCC1-1 nil 3621595927 ("" (subtype-tcc) nil nil) ((real_times_real_is_real application-judgement "real" reals nil)) nil (is_nz subtype "0" "{x: reals.real | x = number_fields.*(query_coeff.F(query_coeff.f), query_coeff.G(query_coeff.f))}"))) (dot_tail_sum2_TCC1 0 (dot_tail_sum2_TCC1-2 "" 3790097685 ("" (skeep) (("" (typepred (i)) (("" (ground) nil nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (dot_tail_sum2 subtype "(number_fields.-)(exponentiation.^(3, query_coeff.n), query_coeff.i)" "naturalnumber")) (dot_tail_sum2_TCC1-1 nil 3621595927 ("" (skeep) (("" (skeep) (("" (typepred (i)) (("" (ground) (("" (case "forall (k, l:nat): k<l IMPLIES k+1<=l") (("1" (inst -1 "i" "3^n") (("1" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (dot_tail_sum2 subtype "(number_fields.-)(exponentiation.^(3, query_coeff.n), query_coeff.i)" "naturalnumber"))) (dot_tail_sum2_TCC2 0 (dot_tail_sum2_TCC2-1 nil 3621595927 ("" (skeep) (("" (skeep) (("" (typepred (i)) (("" (case "forall (a, b:nat): a<b IMPLIES a+1<=b") (("1" (inst -1 "i" "3^n") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) nil (dot_tail_sum2 subtype "(number_fields.+)(query_coeff.i, 1)" "naturalnumbers.upto(exponentiation.^(3, query_coeff.n))"))) (dot_tail_sum2_TCC3 0 (dot_tail_sum2_TCC3-1 nil 3621758128 ("" (termination-tcc) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (is_nz const-decl "{x: real | x = F(f) * G(f)}" query_coeff nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (dot_tail_sum2 termination "query_coeff.dot_tail_sum2(query_coeff.n, query_coeff.F, query_coeff.G, query_coeff.A, (number_fields.+)(query_coeff.i, 1), query_coeff.bump_one(query_coeff.i, query_coeff.f))" "nil"))) (dot_tail_sum_lem2_TCC1 0 (dot_tail_sum_lem2_TCC1-1 nil 3621595927 ("" (skeep) (("" (skeep) (("" (rewrite "base_n_lt_n") nil nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (base_n_lt_n formula-decl nil base_repr reals)) nil (dot_tail_sum_lem2 subtype "base_repr.base_n(3, query_coeff.i)" "{f | query_coeff.f = base_repr.base_n(3, query_coeff.i)}"))) (dot_tail_sum_lem2_TCC2 0 (dot_tail_sum_lem2_TCC3-1 nil 3621758128 ("" (skeep) (("" (skeep) (("" (rewrite "base_n_lt_n") nil nil)) nil)) nil) ((> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (base_n_lt_n formula-decl nil base_repr reals)) nil (dot_tail_sum_lem2 subtype "base_repr.base_n(3, query_coeff.j)" "[nat -> naturalnumbers.below(3)]"))) (dot_tail_sum_lem2 0 (dot_tail_sum_lem2-2 "" 3750606989 ("" (skolem 1 ("n" "F" "G" "_" "_")) (("" (case "FORALL (nn:nat, a: real, i: upto(3 ^ n)): nn=3^n-i IMPLIES
        dot_tail_sum2(n, F, G, a, i, base_n(3, i)) =
         a +
          sigma(i, 3 ^ n - 1,
                LAMBDA (j: nat): F(base_n(3, j)) * G(base_n(3, j))) ") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "3^n-i") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (skeep) (("1" (both-sides "+" "i" -1) (("1" (simplify -1) (("1" (replace -1) (("1" (expand "dot_tail_sum2") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "dot_tail_sum2" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (inst -1 "is_nz(n, base_n(3, i), F, G) + a " "1 + i") (("2" (split -1) (("1" (typepred "bump_one(i, base_n(3, i))") (("1" (replace -1) (("1" (replace -2) (("1" (swap-rel 2) (("1" (rewrite "sigma_first" 2) (("1" (typepred "is_nz(n, base_n(3, i), F, G)") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("4" (skeep) (("4" (skeep) (("4" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("4" (skeep) (("4" (skeep) (("4" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (dot_tail_sum2 def-decl "real" query_coeff nil) (base_n def-decl "nat" base_repr reals) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (n skolem-const-decl "posnat" query_coeff nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (base_n_lt_n formula-decl nil base_repr reals) (sigma_first formula-decl nil sigma reals) (bump_one const-decl "{ff: [nat -> below(3)] | ff = base_n(3, k + 1)}" query_coeff nil) (is_nz const-decl "{x: real | x = F(f) * G(f)}" query_coeff nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (dot_tail_sum_lem2-1 nil 3621596460 ("" (skolem 1 ("n" "F" "G" "_" "_")) (("" (case "FORALL (nn:nat, a: real, i: upto(3 ^ n)): nn=3^n-i IMPLIES
        dot_tail_sum2(n, F, G, a, i, base_n(3, i)) =
         a +
          sigma(i, 3 ^ n - 1,
                LAMBDA (j: nat): F(base_n(3, j)) * G(base_n(3, j))) ") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "3^n-i") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (skeep) (("1" (both-sides "+" "i" -1) (("1" (simplify -1) (("1" (replace -1) (("1" (expand "dot_tail_sum2") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "dot_tail_sum2" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (inst -1 "is_nz(n, base_n(3, i), F, G) + a " "1 + i") (("2" (split -1) (("1" (typepred "bump_one(i, base_n(3, i))") (("1" (replace -1) (("1" (replace -2) (("1" (swap-rel 2) (("1" (rewrite "sigma_first" 2) (("1" (typepred "is_nz(n, base_n(3, i), F, G)") (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (ground) nil nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (ground) nil nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (rewrite "base_n_lt_n") nil nil)) nil)) nil)) nil)) nil)) nil) ((sigma_first formula-decl nil sigma reals) (base_n_lt_n formula-decl nil base_repr reals) (base_n def-decl "nat" base_repr reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals)) shostak)))
