(matrix_props (matrix_2x2 0 (matrix_2x2-3 "" 3790097551 ("" (skeep) (("" (rewrite "full_matrix_eq") (("1" (split) (("1" (grind :exclude "entry") nil nil) ("2" (grind :exclude "entry") nil nil) ("3" (skosimp*) (("3" (case "(i!1=0 OR i!1=1) AND (j!1 = 0 OR j!1=1)") (("1" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "entry" + 2) (("1" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("3" (replaces -1) (("3" (replaces -1) (("3" (expand "entry" + 2) (("3" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("4" (replaces -1) (("4" (replaces -1) (("4" (expand "entry" + 2) (("4" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case "(i!1=0 OR i!1=1) AND (j!1 = 0 OR j!1=1)") (("1" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "entry" + 2) (("1" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "entry" + 2) (("2" (typepred "i!1") (("2" (typepred "j!1") (("2" (hide 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (entry const-decl "real" matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (access const-decl "real" matrices nil) (row const-decl "Vector" matrices nil) (TRUE const-decl "bool" booleans nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak) (matrix_2x2-2 "" 3750621074 ("" (skeep) (("" (rewrite "full_matrix_eq") (("1" (split) (("1" (grind :exclude "entry") nil nil) ("2" (grind :exclude "entry") nil nil) ("3" (skosimp*) (("3" (case "(i!1=0 OR i!1=1) AND (j!1 = 0 OR j!1=1)") (("1" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "entry" + 2) (("1" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("3" (replaces -1) (("3" (replaces -1) (("3" (expand "entry" + 2) (("3" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("4" (replaces -1) (("4" (replaces -1) (("4" (expand "entry" + 2) (("4" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case "(i!1=0 OR i!1=1) AND (j!1 = 0 OR j!1=1)") (("1" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "entry" + 2) (("1" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (typepred "i!1") (("2" (typepred "j!1") (("2" (hide 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (row const-decl "Vector" matrices nil)) shostak) (matrix_2x2-1 nil 3615814158 ("" (skeep) (("" (rewrite "full_matrix_eq") (("1" (split) (("1" (grind :exclude "entry") nil nil) ("2" (grind :exclude "entry") nil nil) ("3" (skosimp*) (("3" (case "(i!1=0 OR i!1=1) AND (j!1 = 0 OR j!1=1)") (("1" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "entry" + 2) (("1" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("3" (replaces -1) (("3" (replaces -1) (("3" (expand "entry" + 2) (("3" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("4" (replaces -1) (("4" (replaces -1) (("4" (expand "entry" + 2) (("4" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (case "(i!1=0 OR i!1=1) AND (j!1 = 0 OR j!1=1)") (("1" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "entry" + 2) (("1" (grind :exclude "entry") nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (expand "entry" + 2) (("2" (typepred "i!1") (("2" (typepred "j!1") (("2" (hide 2) (("2" (grind :exclude "entry") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (row const-decl "Vector" matrices nil)) shostak)) (length_row 0 (length_row-2 "" 3750621128 ("" (skeep) (("" (expand "row") (("" (expand "rows") (("" (lift-if) (("" (ground) (("1" (grind) nil nil) ("2" (typepred "columns(SM)") (("2" (assert) (("2" (split -) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (typepred "SM") (("2" (split -) (("1" (grind) nil nil) ("2" (inst - "i" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((row const-decl "Vector" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (length def-decl "nat" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil)) shostak) (length_row-1 nil 3614701537 ("" (skeep) (("" (expand "row") (("" (expand "rows") (("" (lift-if) (("" (ground) (("" (typepred "columns(SM)") (("" (assert) (("" (split -) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (typepred "SM") (("2" (split -) (("1" (grind) nil nil) ("2" (inst - "i" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((row const-decl "Vector" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (FullMatrix type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil)) shostak)) (length_nth_row 0 (length_nth_row-1 nil 3614702183 ("" (skeep) (("" (lemma "length_row") (("" (inst - "SM" "i") (("" (assert) (("" (expand "rows") (("" (assert) (("" (expand "row") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row const-decl "Vector" matrices nil) (rows const-decl "nat" matrices nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil)) shostak)) (columns_cdr_TCC1 0 (columns_cdr_TCC1-1 nil 3614702658 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil)) nil (columns_cdr subtype "matrix_props.D" "(list_adt[list[real]].cons?)"))) (columns_cdr 0 (columns_cdr-1 nil 3614702658 ("" (skeep) (("" (typepred "columns(cdr(D))") (("" (assert) (("" (split -) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (typepred "columns(D)") (("2" (split -) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (typepred "D") (("2" (split -) (("1" (grind) nil nil) ("2" (inst - "i!1+1" "i!2") (("1" (assert) (("1" (expand "nth" -1 1) (("1" (ground) nil nil)) nil)) nil) ("2" (expand "length" 1) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (i!1 skolem-const-decl "below(length(cdr(D)))" matrix_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (columns_cons 0 (columns_cons-1 nil 3614939393 ("" (induct "M") (("1" (grind) nil nil) ("2" (skolem 1 ("m1" "M")) (("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil)) shostak)) (access_col 0 (access_col-1 nil 3615029745 ("" (skeep) (("" (expand "access") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (ground) (("1" (lemma "col_def") (("1" (inst?) (("1" (assert) (("1" (inst - "j") (("1" (replaces -1) (("1" (lift-if) (("1" (ground) (("1" (expand "row" 1) (("1" (lift-if) (("1" (ground) (("1" (rewrite "length_col") (("1" (expand "rows") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_nth_row") (("1" (rewrite "length_row") nil nil) ("2" (rewrite "length_col") (("2" (expand "rows") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_row") (("2" (rewrite "length_col") (("2" (assert) (("2" (lemma "col_def") (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (rewrite "length_nth_row") (("2" (expand "rows") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "length_col") (("3" (rewrite "length_row") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((access const-decl "real" matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (length_nth_row formula-decl nil matrix_props nil) (length_row formula-decl nil matrix_props nil) (row const-decl "Vector" matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length_col formula-decl nil matrices nil) (TRUE const-decl "bool" booleans nil) (col_def formula-decl nil matrices nil)) shostak)) (remove_TCC1 0 (remove_TCC1-1 nil 3614083040 ("" (skeep) (("" (ground) (("1" (grind) nil nil) ("2" (skeep 1) (("2" (rewrite "columns_0_entry") (("1" (rewrite "columns_0_entry") nil nil) ("2" (expand "columns" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil) (length def-decl "nat" list_props nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (columns_0_entry formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil)) nil (remove subtype "list_adt[list[real]].null" "{N | booleans.AND((booleans.IMPLIES(booleans.AND(reals.>(matrices.rows(matrix_props.M), 1), reals.>(matrices.columns(matrix_props.M), 1)), (booleans.AND(matrices.rows(matrix_props.N) = (number_fields.-)(matrices.rows(matrix_props.M), 1), matrices.columns(matrix_props.N) = (number_fields.-)(matrices.columns(matrix_props.M), 1))))), (FORALL (m, n): matrices.entry(matrix_props.N)(matrix_props.m, matrix_props.n) = matrices.entry(matrix_props.M)(IF booleans.OR(reals.>=(matrix_props.m, matrix_props.i), reals.>=(matrix_props.i, matrices.rows(matrix_props.M))) THEN (number_fields.+)(1, matrix_props.m) ELSE matrix_props.m ENDIF, IF booleans.OR(reals.>=(matrix_props.n, matrix_props.j), reals.>=(matrix_props.j, matrices.columns(matrix_props.M))) THEN (number_fields.+)(1, matrix_props.n) ELSE matrix_props.n ENDIF)))}"))) (remove_TCC2 0 (remove_TCC2-1 nil 3614083040 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil)) nil (remove subtype "(number_fields.-)(matrices.rows(matrix_props.M), 1)" "nat"))) (remove_TCC3 0 (remove_TCC3-1 nil 3614083040 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil)) nil (remove subtype "(number_fields.-)(matrices.columns(matrix_props.M), 1)" "nat"))) (remove_TCC4 0 (remove_TCC4-1 nil 3614083040 ("" (skeep) (("" (assert) (("" (ground) (("1" (rewrite "rows_form_matrix" 1) nil nil) ("2" (lemma "columns_form_matrix") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "entry_form_matrix") (("3" (lift-if) (("3" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "entry_eq_0") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (entry_eq_0 formula-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (entry_form_matrix formula-decl nil matrices nil) (columns_form_matrix formula-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rows_form_matrix formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil (remove subtype "matrices.form_matrix(LAMBDA (m, n): LET newm = IF booleans.OR(reals.>=(matrix_props.m, matrix_props.i), reals.>=(matrix_props.i, matrices.rows(matrix_props.M))) THEN (number_fields.+)(matrix_props.m, 1) ELSE matrix_props.m ENDIF, newn = IF booleans.OR(reals.>=(matrix_props.n, matrix_props.j), reals.>=(matrix_props.j, matrices.columns(matrix_props.M))) THEN (number_fields.+)(matrix_props.n, 1) ELSE matrix_props.n ENDIF IN matrices.entry(matrix_props.M)(matrix_props.newm, matrix_props.newn), (number_fields.-)(matrices.rows(matrix_props.M), 1), (number_fields.-)(matrices.columns(matrix_props.M), 1))" "{N | booleans.AND((booleans.IMPLIES(booleans.AND(reals.>(matrices.rows(matrix_props.M), 1), reals.>(matrices.columns(matrix_props.M), 1)), (booleans.AND(matrices.rows(matrix_props.N) = (number_fields.-)(matrices.rows(matrix_props.M), 1), matrices.columns(matrix_props.N) = (number_fields.-)(matrices.columns(matrix_props.M), 1))))), (FORALL (m, n): matrices.entry(matrix_props.N)(matrix_props.m, matrix_props.n) = matrices.entry(matrix_props.M)(IF booleans.OR(reals.>=(matrix_props.m, matrix_props.i), reals.>=(matrix_props.i, matrices.rows(matrix_props.M))) THEN (number_fields.+)(1, matrix_props.m) ELSE matrix_props.m ENDIF, IF booleans.OR(reals.>=(matrix_props.n, matrix_props.j), reals.>=(matrix_props.j, matrices.columns(matrix_props.M))) THEN (number_fields.+)(1, matrix_props.n) ELSE matrix_props.n ENDIF)))}"))) (remove_posfullmatrix 0 (remove_posfullmatrix-1 nil 3614602887 ("" (skeep) (("" (skosimp*) (("" (name "R" "remove(D,i,j)") (("" (replace -1) (("" (assert) (("" (expand "remove" -1) (("" (invoke (name "FZ" "%1") (! -1 1)) (("" (replaces -1) (("" (typepred "FZ") (("" (assert) (("" (copy -5) (("" (inst - "i!1" "j!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (MatrixMN type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil)) nil (remove_posfullmatrix subtype "matrix_props.remove(matrix_props.D, matrix_props.i, matrix_props.j)" "FullMatrix"))) (rows_remove 0 (rows_remove-1 nil 3615024326 ("" (skeep) (("" (expand "remove") (("" (lift-if) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (rewrite "rows_form_matrix") nil nil)) nil)) nil)) nil)) nil) ((remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rows const-decl "nat" matrices nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (entry const-decl "real" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rows_form_matrix formula-decl nil matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (columns_remove 0 (columns_remove-2 "" 3790097555 ("" (skeep) (("" (expand "remove") (("" (lift-if) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (lemma "columns_form_matrix") (("3" (inst?) (("3" (lift-if) (("3" (ground) (("1" (replace -2) (("1" (expand "form_matrix" 1) (("1" (expand "array2list" + 1) (("1" (expand "array2list_it") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "rows(M)=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "form_matrix" 1) (("1" (expand "array2list" + 1) (("1" (expand "array2list_it") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (rows const-decl "nat" matrices nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (TRUE const-decl "bool" booleans nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (columns_form_matrix formula-decl nil matrices nil)) shostak) (columns_remove-1 nil 3615024543 ("" (skeep) (("" (expand "remove") (("" (lift-if) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (lemma "columns_form_matrix") (("3" (inst?) (("3" (assert) (("3" (lift-if) (("3" (ground) (("1" (replace -2) (("1" (expand "form_matrix" 1) (("1" (expand "array2list" + 1) (("1" (expand "array2list_it") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "rows(M)=1") (("1" (replaces -1) (("1" (assert) (("1" (expand "form_matrix" 1) (("1" (expand "array2list" + 1) (("1" (expand "array2list_it") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((form_matrix_square application-judgement "FullMatrix" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (rows const-decl "nat" matrices nil) (Matrix type-eq-decl nil matrices nil) (entry const-decl "real" matrices nil) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (columns_form_matrix formula-decl nil matrices nil)) shostak)) (remove_remove_1_0 0 (remove_remove_1_0-1 nil 3614609488 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("1" (assert) (("1" (hide 2) (("1" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (assert) (("1" (typepred "remove(D,1,1+n)") (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (typepred "remove(D,0,m)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 1, 1 + n), 0, m)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 0, m), 0, n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (assert) (("1" (typepred "remove(D,1,1+n)") (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (typepred "remove(D,0,m)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 1, 1 + n), 0, m)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 0, m), 0, n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (typepred "remove(remove(D, 1, 1 + n), 0, m)") (("2" (assert) (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(remove(D, 0, m), 0, n)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(D,1,1+n)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (typepred "remove(D,0,m)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (hide (-1 -2)) (("2" (typepred "remove(D,1,1+n)") (("2" (hide (-1 -3 -4)) (("2" (assert) (("2" (flatten) (("2" (typepred "remove(D,0,m)") (("2" (hide (-1 -3 -4)) (("2" (assert) (("2" (flatten) (("2" (typepred "remove(remove(D, 1, 1 + n), 0, m)") (("2" (hide (-1 -3)) (("2" (assert) (("2" (flatten) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "remove_posfullmatrix") (("2" (inst?) (("1" (split -) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (typepred "remove(D,0,m)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (lemma "remove_posfullmatrix") (("3" (inst?) (("1" (assert) nil nil) ("2" (typepred "remove(D,1,1+n)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (remove_posfullmatrix judgement-tcc nil matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Matrix type-eq-decl nil matrices nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (n skolem-const-decl "nat" matrix_props nil) (m skolem-const-decl "nat" matrix_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil)) shostak)) (remove_remove_1_0_0 0 (remove_remove_1_0_0-1 nil 3614612404 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("1" (assert) (("1" (hide 2) (("1" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (assert) (("1" (typepred "remove(D,1,0)") (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (typepred "remove(D,0,1+n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 1, 0), 0, n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 0, 1+n), 0, 0)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (assert) (("1" (typepred "remove(D,1,0)") (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (typepred "remove(D,0,1+n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 1, 0), 0, n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 0, 1+n), 0, 0)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (typepred "remove(remove(D, 1, 0), 0, n)") (("2" (assert) (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(remove(D, 0, 1 + n), 0, 0)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(D,1,0)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (typepred "remove(D,0,1+n)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (hide (-1 -2)) (("2" (typepred "remove(D,1,0)") (("2" (hide (-1 -3 -4)) (("2" (assert) (("2" (typepred "remove(D,0,1+n)") (("2" (flatten) (("2" (hide (-1 -3 -4)) (("2" (assert) (("2" (flatten) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "remove_posfullmatrix") (("2" (inst?) (("1" (split -) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (typepred "remove(D,0,1+n)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (lemma "remove_posfullmatrix") (("3" (inst?) (("1" (assert) nil nil) ("2" (typepred "remove(D,1,0)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (remove_posfullmatrix judgement-tcc nil matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Matrix type-eq-decl nil matrices nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (n skolem-const-decl "nat" matrix_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (remove_remove_1_n 0 (remove_remove_1_n-1 nil 3614614465 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("1" (assert) (("1" (hide 2) (("1" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (assert) (("1" (typepred "remove(D,1,n)") (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (typepred "remove(D,0,1+m+n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 1, n), 0, m + n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 0, 1 + m + n), 0, n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 1 1)) (("1" (hide 2) (("1" (assert) (("1" (typepred "remove(D,1,n)") (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (typepred "remove(D,0,1+m+n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 1, n), 0, m + n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(remove(D, 0, 1 + m + n), 0, n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (typepred "remove(remove(D, 1, n), 0, m + n)") (("2" (assert) (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(remove(D, 0, 1 + m + n), 0, n)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(D,1,n)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (typepred "remove(D,0,1+m+n)") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (hide (-1 -2)) (("2" (typepred "remove(D,1,n)") (("2" (hide (-1 -3 -4)) (("2" (assert) (("2" (flatten) (("2" (typepred "remove(D,0,1+m+n)") (("2" (hide (-1 -3 -4)) (("2" (assert) (("2" (flatten) (("2" (typepred "remove(remove(D, 1, n), 0, m + n)") (("2" (hide (-1 -3)) (("2" (assert) (("2" (flatten) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "remove_posfullmatrix") (("2" (inst?) (("1" (split -) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (typepred "remove(D,0,1+m+n)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (lemma "remove_posfullmatrix") (("3" (inst?) (("1" (assert) nil nil) ("2" (typepred "remove(D,1,n)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (remove_posfullmatrix judgement-tcc nil matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Matrix type-eq-decl nil matrices nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (n skolem-const-decl "nat" matrix_props nil) (m skolem-const-decl "nat" matrix_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (entry_remove 0 (entry_remove-1 nil 3614961120 ("" (skeep) (("" (assert) (("" (typepred "remove(M,i,j)") (("" (inst?) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil)) shostak)) (remove_Id_0_0_TCC1 0 (remove_Id_0_0_TCC1-1 nil 3615047099 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (remove_Id_0_0 subtype "(number_fields.-)(matrix_props.pm, 1)" "posnat"))) (remove_Id_0_0 0 (remove_Id_0_0-1 nil 3615047100 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (split) (("1" (rewrite "rows_remove") (("1" (assert) nil nil)) nil) ("2" (rewrite "columns_remove") (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (rewrite "entry_remove") (("3" (rewrite "entry_Id") (("3" (rewrite "entry_Id") (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (posnat nonempty-type-eq-decl nil integers nil) (PosFullMatrix type-eq-decl nil matrices nil) (Square type-eq-decl nil matrices nil) (SquareMatrix type-eq-decl nil matrices nil) (MatrixMN type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (* const-decl "real" matrices nil) (row const-decl "Vector" matrices nil) (VectorN type-eq-decl nil matrices nil) (col def-decl "VectorN(rows(M))" matrices nil) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices nil) (Id const-decl "{M: SquareMatrix(pm) |
   (FORALL (i: nat, j: nat):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" matrices nil) (entry_Id formula-decl nil matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (entry_remove formula-decl nil matrix_props nil) (columns_remove formula-decl nil matrix_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rows_remove formula-decl nil matrix_props nil)) shostak)) (remove_test 0 (remove_test-1 nil 3614091324 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)) (det_TCC1 0 (det_TCC1-2 "" 3750621154 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rows const-decl "nat" matrices nil) (nth def-decl "T" list_props nil) (row const-decl "Vector" matrices nil) (length def-decl "nat" list_props nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (det termination "matrix_props.det(matrix_props.remove(matrix_props.M, 0, matrix_props.k))" "nil")) (det_TCC1-1 nil 3614091064 ("" (subtype-tcc) nil nil) ((Matrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (rows const-decl "nat" matrices nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil)) nil (det termination "matrix_props.det(matrix_props.remove(matrix_props.M, 0, matrix_props.k))" "nil"))) (det_test 0 (det_test-1 nil 3614096607 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (det def-decl "real" matrix_props nil) (expt def-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sigma def-decl "real" sigma reals) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (det_size_noteq 0 (det_size_noteq-1 nil 3614958230 ("" (skeep) (("" (expand "det") (("" (assert) nil nil)) nil)) nil) ((det def-decl "real" matrix_props nil)) shostak)) (swap_fun_test 0 (swap_fun_test-1 nil 3614700165 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)) (swap_TCC1 0 (swap_TCC1-1 nil 3614443657 ("" (skeep) (("" (assert) (("" (rewrite "rows_form_matrix") (("" (assert) (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) (("" (name "FM" "form_matrix(swap(i, j)(entry(D)), rows(D), columns(D))") (("" (replaces -1) (("" (skeep) (("" (expand "FM" 1) (("" (rewrite "entry_form_matrix") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (assert) (("" (expand "swap" 1) (("" (lemma "entry_eq_0") (("" (inst-cp - "D" "k" "p") (("" (assert) (("" (inst-cp - "D" "i" "p") (("" (inst-cp - "D" "j" "p") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((form_matrix_square application-judgement "FullMatrix" matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (row const-decl "Vector" matrices nil) (Vector type-eq-decl nil matrices nil) (MatrixMN type-eq-decl nil matrices nil) (entry_form_matrix formula-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (entry_eq_0 formula-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (FM skolem-const-decl "{M: MatrixMN(rows(D), columns(D)) |
   FORALL (i_1: below(rows(D)), j_1: below(columns(D))):
     nth(row(M)(i_1), j_1) = swap(i, j)(entry(D))(i_1, j_1)}" matrix_props nil) (TRUE const-decl "bool" booleans nil) (columns_form_matrix formula-decl nil matrices nil) (entry const-decl "real" matrices nil) (swap const-decl "real" matrix_props nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rows const-decl "nat" matrices nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rows_form_matrix formula-decl nil matrices nil)) nil (swap subtype "matrices.form_matrix(matrix_props.swap(matrix_props.i, matrix_props.j)(matrices.entry(matrix_props.D)), matrices.rows(matrix_props.D), matrices.columns(matrix_props.D))" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), FORALL (k, p): booleans.IMPLIES(booleans.AND(reals.<(matrix_props.i, matrices.rows(matrix_props.D)), reals.<(matrix_props.j, matrices.rows(matrix_props.D))), matrices.entry(matrix_props.PFM)(matrix_props.k, matrix_props.p) = (IF matrix_props.k = matrix_props.i THEN matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.p) ELSIF matrix_props.k = matrix_props.j THEN matrices.entry(matrix_props.D)(matrix_props.i, matrix_props.p) ELSE matrices.entry(matrix_props.D)(matrix_props.k, matrix_props.p) ENDIF))))}"))) (entry_swap 0 (entry_swap-1 nil 3615020687 ("" (skeep) (("" (expand "swap" + 1) (("" (rewrite "entry_form_matrix") nil nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (entry const-decl "real" matrices nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (swap const-decl "real" matrix_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (entry_form_matrix formula-decl nil matrices nil)) shostak)) (swap_test_TCC1 0 (swap_test_TCC1-1 nil 3614697478 ("" (assert) (("" (split) (("1" (eval-formula) nil nil) ("2" (eval-formula) nil nil) ("3" (eval-formula) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) nil (swap_test subtype "(: (: 1, 2 :), (: 3, 4 :) :)" "PosFullMatrix"))) (swap_test 0 (swap_test-1 nil 3614697479 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)) (remove_swap_1 0 (remove_swap_1-1 nil 3614602382 ("" (skeep) (("" (name "S" "swap(0,1)(D)") (("" (replace -1) (("" (name "RS" "remove(S,0,n)") (("" (replace -1) (("" (name "RD" "remove(D,1,n)") (("" (replace -1) (("" (lemma "full_matrix_eq") (("" (inst - "RS" "RD") (("1" (assert) (("1" (hide 2) (("1" (case "NOT rows(RS)=rows(RD)") (("1" (hide 2) (("1" (typepred "RS") (("1" (assert) (("1" (flatten) (("1" (typepred "RD") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "NOT columns(RS)=columns(RD)") (("1" (typepred "RS") (("1" (typepred "RD") (("1" (assert) (("1" (typepred "S") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (typepred "j!1") (("2" (typepred "RS") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (typepred "RD") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (replaces -1) (("2" (assert) (("2" (typepred "S") (("2" (assert) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (inst?) (("2" (replaces -1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp*) (("2" (typepred "RS") (("2" (lemma "remove_posfullmatrix") (("2" (inst - "S" "0" "n") (("2" (assert) (("2" (inst - "i!1" "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (PosFullMatrix type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (full_matrix_eq formula-decl nil matrices nil) (remove_posfullmatrix judgement-tcc nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (S skolem-const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k, p):
       0 < rows(D) AND 1 < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = 0 THEN entry(D)(1, p)
          ELSIF k = 1 THEN entry(D)(0, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (n skolem-const-decl "nat" matrix_props nil) (RS skolem-const-decl "{N |
   (rows(S) > 1 AND columns(S) > 1 IMPLIES
     (rows(N) = rows(S) - 1 AND columns(N) = columns(S) - 1))
    AND
    FORALL (m, n_1: nat):
      entry(N)(m, n_1) =
       entry(S)
            (1 + m,
             IF n_1 >= n OR n >= columns(S) THEN 1 + n_1 ELSE n_1 ENDIF)}" matrix_props nil)) shostak)) (remove_swap_2_TCC1 0 (remove_swap_2_TCC1-1 nil 3614689741 ("" (skeep) (("" (typepred "remove(D,0,n)") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((PosFullMatrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (entry const-decl "real" matrices nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (remove_swap_2 subtype "matrix_props.remove(matrix_props.D, 0, matrix_props.n)" "PosFullMatrix"))) (remove_swap_2_TCC2 0 (remove_swap_2_TCC2-1 nil 3614689741 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rows const-decl "nat" matrices nil) (/= const-decl "boolean" notequal nil)) nil (remove_swap_2 subtype "(number_fields.-)(matrix_props.i, 1)" "nat"))) (remove_swap_2_TCC3 0 (remove_swap_2_TCC3-1 nil 3614689741 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rows const-decl "nat" matrices nil) (/= const-decl "boolean" notequal nil)) nil (remove_swap_2 subtype "(number_fields.-)(matrix_props.j, 1)" "nat"))) (remove_swap_2 0 (remove_swap_2-2 "" 3790097572 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (assert) (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 4) (("1" (typepred "remove(swap(i, j)(D), 0, n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -2) (("1" (typepred "remove(D,0,n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 4) (("1" (typepred "remove(swap(i, j)(D), 0, n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(D,0,n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (typepred "remove(swap(i, j)(D), 0, n)") (("2" (assert) (("2" (flatten) (("2" (hide (-1 -5)) (("2" (inst?) (("2" (replaces -3) (("2" (assert) (("2" (typepred "swap(i - 1, j - 1)(remove(D, 0, n))") (("2" (hide (-1 -2)) (("2" (assert) (("2" (inst?) (("2" (replaces -5) (("2" (typepred "remove(D,0,n)") (("2" (rewrite -3) (("2" (rewrite -3) (("2" (rewrite -3) (("2" (assert) (("2" (hide -2) (("2" (hide -3) (("2" (typepred "swap(i,j)(D)") (("2" (assert) (("2" (hide (-1 -2)) (("2" (rewrite -5) (("2" (hide (-1 -2 -3 -4 -5)) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (PosFullMatrix type-eq-decl nil matrices nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (remove_swap_2-1 nil 3614689742 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (assert) (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 4) (("1" (typepred "remove(swap(i, j)(D), 0, n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -2) (("1" (typepred "remove(D,0,n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 4) (("1" (typepred "remove(swap(i, j)(D), 0, n)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (typepred "remove(D,0,n)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (typepred "remove(swap(i, j)(D), 0, n)") (("2" (assert) (("2" (flatten) (("2" (hide (-1 -5)) (("2" (inst?) (("2" (replaces -3) (("2" (assert) (("2" (typepred "swap(i - 1, j - 1)(remove(D, 0, n))") (("2" (hide (-1 -2)) (("2" (assert) (("2" (inst?) (("2" (replaces -5) (("2" (assert) (("2" (typepred "remove(D,0,n)") (("2" (rewrite -3) (("2" (rewrite -3) (("2" (rewrite -3) (("2" (assert) (("2" (hide -2) (("2" (hide -3) (("2" (typepred "swap(i,j)(D)") (("2" (assert) (("2" (hide (-1 -2)) (("2" (rewrite -5) (("2" (hide (-1 -2 -3 -4 -5)) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (entry const-decl "real" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil)) shostak)) (swap_sym 0 (swap_sym-1 nil 3614688578 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (assert) (("" (skosimp*) (("" (expand "swap" +) (("" (rewrite "entry_form_matrix") (("" (rewrite "entry_form_matrix") (("" (expand "swap") (("" (lift-if) (("" (lift-if) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (entry_form_matrix formula-decl nil matrices nil) (swap const-decl "real" matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (det_swap_0_1 0 (det_swap_0_1-2 "" 3750621521 ("" (skeep) (("" (case "rows(D)/=columns(D)") (("1" (flatten) (("1" (expand "det" + 2) (("1" (assert) (("1" (expand "det" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "rows(D) = 2") (("1" (case "EXISTS (a,b,c,d:real): D = (:(:a,b:),(:c,d:):)") (("1" (skeep) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-3 2)) (("2" (typepred "D") (("2" (inst + "entry(D)(0,0)" "entry(D)(0,1)" "entry(D)(1,0)" "entry(D)(1,1)") (("2" (rewrite "list_extensionality[list[real]]") (("1" (splash +) (("1" (skosimp*) (("1" (case "NOT (n!1 = 0 OR n!1=1)") (("1" (typepred "n!1") (("1" (expand "rows") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (rewrite "list_extensionality[real]" 1) (("2" (split +) (("1" (assert) (("1" (split -4) (("1" (grind) nil nil) ("2" (case "NOT columns(D)=2") (("1" (assert) nil nil) ("2" (typepred "columns(D)") (("2" (split -2) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst - "n!1" "i!1") (("2" (assert) (("2" (replace -4) (("2" (replace -1) (("2" (replace -3) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case "NOT (n!2 = 0 OR n!2 = 1)") (("1" (hide 2) (("1" (typepred "n!2") (("1" (typepred "columns(D)") (("1" (split -2) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (split -7) (("1" (grind) nil nil) ("2" (inst - "n!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (rows(D)=2 AND columns(D)=2)") (("1" (assert) nil nil) ("2" (expand "entry") (("2" (expand "access") (("2" (expand "row") (("2" (assert) (("2" (case "NOT length(D)=2") (("1" (expand "rows") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (hide -2) (("2" (case "null?(D)") (("1" (grind) nil nil) ("2" (assert) (("2" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (replaces -1) (("3" (replaces -1) (("3" (hide -) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (replaces -1) (("4" (replaces -1) (("4" (hide -) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4)) (("2" (hide -3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rows(D)>=3") (("1" (assert) nil nil) ("2" (hide (-3 1)) (("2" (copy -2) (("2" (hide -3) (("2" (name "S" "swap(0,1)(D)") (("2" (replaces -1) (("2" (expand "det") (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (typepred "S") (("1" (grind) nil nil)) nil) ("2" (typepred "S") (("2" (grind) nil nil)) nil) ("3" (typepred "S") (("3" (hide (-1 -2 -3 -4 -7)) (("3" (case "NOT FORALL (rr:real): -rr = (-1)*rr") (("1" (assert) nil nil) ("2" (invoke (inst - "%1") (! 2 2 1)) (("2" (replaces -1) (("2" (rewrite "sigma_scal" :dir rl) (("2" (expand "det" + 2) (("2" (invoke (case "NOT (%1 = (sigma(0, columns(D) - 1,
                               LAMBDA (i: nat):
                                 sigma(0, columns(remove(D, 0, i)) - 1,
                                               LAMBDA (k):
                                                 det(remove(remove(D, 0, i), 0, k)) *
                                                  entry(remove(D, 0, i))(0, k)
                                                  * (-1) ^ k*(-1) *
                                  entry(D)(0, i) * (-1) ^ i))))") (! 2 2)) (("1" (hide 3) (("1" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (lift-if) (("1" (ground) (("1" (typepred "remove(D,0,n!1)") (("1" (assert) (("1" (flatten) (("1" (grind :exclude "remove") nil nil)) nil)) nil)) nil) ("2" (typepred "remove(D,0,n!1)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "remove(D,0,n!1)") (("3" (assert) nil nil)) nil) ("4" (rewrite "sigma_scal" :dir rl) (("4" (rewrite "sigma_scal" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replace -2) (("2" (assert) (("2" (case "NOT (LAMBDA (i: nat):
                                   sigma(0, columns(remove(D, 0, i)) - 1,
                                         LAMBDA (k):
                                           -1 *
                                            (det(remove(remove(D, 0, i), 0, k)) *
                                              entry(remove(D, 0, i))(0, k)
                                              * entry(D)(0, i)
                                              * (-1) ^ i
                                              * (-1) ^ k))) = (LAMBDA (i: nat):
                                   sigma(0, columns(D)-2,
                                         LAMBDA (k):
                                           -1 *
                                            (det(remove(remove(D, 0, i), 0, k)) *
                                              entry(remove(D, 0, i))(0, k)
                                              * entry(D)(0, i)
                                              * (-1) ^ i
                                              * (-1) ^ k)))") (("1" (hide 3) (("1" (decompose-equality) (("1" (typepred "remove(D,0,x!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "sigma_swap") (("2" (name "H" "LAMBDA (j:nat): LAMBDA (i_1:nat): -1 *
                                             (det(remove(remove(D, 0, i_1), 0, j)) *
                                               entry(remove(D, 0, i_1))(0, j)
                                               * entry(D)(0, i_1)
                                               * (-1) ^ i_1
                                               * (-1) ^ j)") (("2" (invoke (case "NOT %1 = sigma(0,columns(D)-2,LAMBDA (j:nat): sigma(0,columns(D)-1,H(j)))") (! 2 2)) (("1" (hide (3)) (("1" (expand "H" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (replaces -1) (("2" (name "H1" "LAMBDA (j:nat): LAMBDA (i_1:nat): IF j<i_1 THEN H(j)(i_1) ELSE 0 ENDIF") (("2" (name "H2" "LAMBDA (j:nat): LAMBDA (i_1:nat): IF j>=i_1 THEN H(j)(i_1) ELSE 0 ENDIF") (("2" (case "NOT (LAMBDA (j: nat): sigma(0, columns(D) - 1, H(j))) = (LAMBDA (j: nat): sigma(0, columns(D) - 1, H1(j)) + sigma(0,columns(D)-1,H2(j)))") (("1" (hide-all-but 1) (("1" (decompose-equality) (("1" (rewrite "sigma_sum") (("1" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (expand "H1") (("1" (expand "H2") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (name "K1" "LAMBDA (j:nat): sigma(0, columns(D) - 1, H1(j))") (("2" (name "K2" "LAMBDA (j:nat): sigma(0, columns(D) - 1, H2(j))") (("2" (invoke (case "NOT %1 = K1+K2") (! 2 2 3)) (("1" (decompose-equality 1) (("1" (expand "+" 1) (("1" (expand "K1" 1) (("1" (expand "K2" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (name "H3" "LAMBDA (j:nat): IF j>=1 THEN H2(j-1) ELSE (LAMBDA (kj:nat): 0) ENDIF") (("1" (name "K3" "LAMBDA (j:nat): sigma(0, columns(D) - 1, H3(j))") (("1" (expand "+" 2) (("1" (rewrite "sigma_sum" 2 :dir rl) (("1" (case "NOT sigma(0, columns(D) - 2, K2) = sigma(0,columns(D)-1,K3)") (("1" (hide 3) (("1" (lemma "sigma_split") (("1" (inst - "K3" _ _ _) (("1" (inst?) (("1" (inst - "0") (("1" (assert) (("1" (replaces -1) (("1" (expand "sigma" + 2) (("1" (expand "sigma" + 2) (("1" (expand "K3" + 1) (("1" (expand "H3" + 1) (("1" (invoke (case "NOT %1 = 0") (! 1 2 1)) (("1" (rewrite "sigma_restrict_eq_0" 1) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "sigma_shift_fun_eq") (("2" (skeep) (("2" (expand "K3" 1) (("2" (expand "K2" 1) (("2" (rewrite "sigma_eq" 1) (("2" (skosimp*) (("2" (expand "H3" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (name "D8" "LAMBDA (k:nat): IF k<=columns(D)-2 THEN K1(k) ELSE 0 ENDIF") (("2" (case "NOT sigma(0,columns(D)-2,K1)=sigma(0,columns(D)-1,D8)") (("1" (expand "sigma" + 2) (("1" (expand "D8" + 1) (("1" (rewrite "sigma_eq") (("1" (skosimp*) (("1" (expand "D8" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "sigma_sum") (("2" (rewrite "sigma_eq" 2) (("2" (hide 3) (("2" (skosimp*) (("2" (typepred "n!1") (("2" (expand "D8" 1) (("2" (assert) (("2" (expand "K3" 1) (("2" (typepred "S") (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (inst - "0" "n!1") (("2" (assert) (("2" (replaces -1) (("2" (expand "S" 1) (("2" (rewrite "remove_swap_1") (("2" (case "n!1 = columns(D)-1") (("1" (assert) (("1" (expand "H3" 1) (("1" (expand "H2" 1) (("1" (expand "H" 1) (("1" (expand "det" + 1) (("1" (lift-if) (("1" (assert) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (split -1) (("1" (case "NOT rows(remove(D,1,n!1))=0") (("1" (expand "rows" 1) (("1" (expand "length" 1) (("1" (typepred "remove(D,1,n!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "remove(D,1,n!1)") (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "remove(D,1,n!1)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (typepred "remove(D,1,n!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "sigma_scal" :dir rl) (("2" (case "NOT columns(remove(D,1,n!1))=columns(D)-1") (("1" (typepred "remove(D,1,n!1)") (("1" (assert) nil nil)) nil) ("2" (replace -1 2) (("2" (assert) (("2" (expand "sigma" + 2) (("2" (rewrite "sigma_eq" 2) (("2" (hide 3) (("2" (skosimp*) (("2" (case "(-1)^(n!1)=-(-1)^(n!1-1)") (("1" (replaces -1) (("1" (typepred "remove(D,0,n!2)") (("1" (hide (-1 -2 -4)) (("1" (inst?) (("1" (replace -1) (("1" (assert) (("1" (typepred "remove(D,1,n!1)") (("1" (hide (-1 -2 -4)) (("1" (inst?) (("1" (replaces -1) (("1" (assert) (("1" (lemma "remove_remove_1_0") (("1" (inst - "D" "n!2" "n!1-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt" + 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "n!1 = 0") (("1" (replaces -1) (("1" (expand "K1" +) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (rewrite "sigma_first" +) (("1" (expand "H1" 2 1) (("1" (invoke (case "NOT %1 = 0") (! 2 2 1)) (("1" (rewrite "sigma_restrict_eq_0" 1) (("1" (skosimp*) (("1" (expand "H3" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (expand "det" +) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (typepred "remove(D,1,0)") (("1" (assert) (("1" (flatten) (("1" (expand "rows") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "remove(D,1,0)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "remove(D,1,0)") (("3" (assert) nil nil)) nil) ("4" (typepred "remove(D,1,0)") (("4" (assert) (("4" (flatten) (("4" (replace -3 +) (("4" (assert) (("4" (rewrite "sigma_scal_right" :dir rl) (("4" (rewrite "sigma_shift_fun_eq" 2) (("4" (hide 3) (("4" (skosimp*) (("4" (typepred "i!1") (("4" (expand "H1" 1) (("4" (expand "H" 1) (("4" (typepred "remove(D,1,0)") (("4" (hide (-1 -2 -4)) (("4" (inst?) (("4" (replaces -1) (("4" (assert) (("4" (typepred "remove(D,0,1+i!1)") (("4" (hide (-1 -2 -4)) (("4" (inst?) (("4" (replaces -1) (("4" (assert) (("4" (case "NOT (-1)^0=1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (case "NOT (-1)^(1+i!1) = -(-1)^i!1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "remove_remove_1_0_0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "H3" +) (("2" (case "NOT sigma(0, columns(D) - 1, H2(n!1 - 1)) = sigma(0, n!1-1, H(n!1 - 1))") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "n!1-1") (("1" (assert) (("1" (replaces -1) (("1" (invoke (case "NOT %1 = 0") (! 1 1 2)) (("1" (rewrite "sigma_restrict_eq_0") (("1" (skosimp*) (("1" (expand "H2") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (lemma "sigma_eq") (("2" (inst - "H2(n!1-1)" "H(n!1-1)" "n!1-1" "0") (("2" (assert) (("2" (skosimp*) (("2" (expand "H2" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "K1" +) (("2" (case "NOT sigma(0, columns(D) - 1, H1(n!1)) = sigma(n!1+1, columns(D) - 1, H(n!1))") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "n!1") (("1" (assert) (("1" (invoke (case "NOT %1 = 0") (! -1 2 1)) (("1" (rewrite "sigma_restrict_eq_0") (("1" (skosimp*) (("1" (expand "H1" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (replaces -1) (("2" (rewrite "sigma_eq" 1) (("2" (skosimp*) (("2" (expand "H1" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (expand "det" +) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (typepred "remove(D,1,n!1)") (("1" (assert) (("1" (flatten) (("1" (expand "rows") (("1" (expand "length" -2 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "remove(D,1,n!1)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "remove(D,1,n!1)") (("3" (assert) nil nil)) nil) ("4" (typepred "remove(D,1,n!1)") (("4" (hide (-1 -3 -4)) (("4" (assert) (("4" (flatten) (("4" (replaces -2) (("4" (assert) (("4" (rewrite "sigma_scal" :dir rl) (("4" (lemma "sigma_split") (("4" (inst?) (("4" (inst - "n!1-1") (("4" (assert) (("4" (replaces -1) (("4" (case "FORALL (aa,bb,cc,dd:real): aa=cc AND bb=dd IMPLIES aa+bb=cc+dd") (("1" (rewrite -1 2) (("1" (hide 3) (("1" (hide -1) (("1" (rewrite "sigma_eq" 1) (("1" (hide 2) (("1" (skosimp*) (("1" (expand "H" 1) (("1" (case "NOT (-1)^n!1 = -(-1)^(n!1-1)") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (lemma "remove_remove_1_0") (("2" (inst - "D" "n!2" "n!1-1") (("2" (assert) (("2" (replaces -1) (("2" (typepred "remove(D,1,n!1)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (typepred "remove(D,0,n!2)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "sigma_shift_fun_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "H" 1) (("2" (lemma "remove_remove_1_0") (("2" (lemma "remove_remove_1_n") (("2" (rewrite -1 1) (("2" (typepred "remove(D,1,n!1)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (typepred "remove(D,0,1+i!1+n!1)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (case "(-1)^(1+i!1+n!1) = -(-1)^(i!1+n!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rows const-decl "nat" matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (det def-decl "real" matrix_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (D8 skolem-const-decl "[nat -> real]" matrix_props nil) (remove_swap_1 formula-decl nil matrix_props nil) (remove_remove_1_n formula-decl nil matrix_props nil) (sigma_first formula-decl nil sigma reals) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_scal_right formula-decl nil sigma reals) (remove_remove_1_0_0 formula-decl nil matrix_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (remove_remove_1_0 formula-decl nil matrix_props nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (S skolem-const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k, p):
       0 < rows(D) AND 1 < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = 0 THEN entry(D)(1, p)
          ELSIF k = 1 THEN entry(D)(0, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (H3 skolem-const-decl "[nat -> [nat -> real]]" matrix_props nil) (sigma_shift_fun_eq formula-decl nil sigma reals) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (sigma_nat application-judgement "nat" sigma_nat reals) (K3 skolem-const-decl "[nat -> real]" matrix_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_split formula-decl nil sigma reals) (K1 skolem-const-decl "[nat -> real]" matrix_props nil) (K2 skolem-const-decl "[nat -> real]" matrix_props nil) (+ const-decl "[T -> real]" real_fun_ops reals) (sigma_sum formula-decl nil sigma reals) (H1 skolem-const-decl "[nat -> [nat -> real]]" matrix_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (H2 skolem-const-decl "[nat -> [nat -> real]]" matrix_props nil) (H skolem-const-decl "[nat -> [nat -> real]]" matrix_props nil) (sigma_swap formula-decl nil sigma_swap reals) (subrange type-eq-decl nil integers nil) (rat_exp application-judgement "rat" exponentiation nil) (sigma_eq formula-decl nil sigma reals) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (sigma_scal formula-decl nil sigma reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma reals) (expt def-decl "real" exponentiation nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (^ const-decl "real" exponentiation nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (swap const-decl "real" matrix_props nil) (entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (row const-decl "Vector" matrices nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_extensionality formula-decl nil more_list_props structures) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) shostak) (det_swap_0_1-1 nil 3614509198 ("" (skeep) (("" (case "rows(D)/=columns(D)") (("1" (flatten) (("1" (expand "det" + 2) (("1" (assert) (("1" (expand "det" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "rows(D) = 2") (("1" (case "EXISTS (a,b,c,d:real): D = (:(:a,b:),(:c,d:):)") (("1" (skeep) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-3 2)) (("2" (typepred "D") (("2" (inst + "entry(D)(0,0)" "entry(D)(0,1)" "entry(D)(1,0)" "entry(D)(1,1)") (("2" (rewrite "list_extensionality[list[real]]") (("2" (splash +) (("1" (skosimp*) (("1" (case "NOT (n!1 = 0 OR n!1=1)") (("1" (typepred "n!1") (("1" (expand "rows") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (rewrite "list_extensionality[real]" 1) (("2" (split +) (("1" (assert) (("1" (split -4) (("1" (grind) nil nil) ("2" (case "NOT columns(D)=2") (("1" (assert) nil nil) ("2" (typepred "columns(D)") (("2" (split -2) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst - "n!1" "i!1") (("2" (assert) (("2" (replace -4) (("2" (replace -1) (("2" (replace -3) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case "NOT (n!2 = 0 OR n!2 = 1)") (("1" (hide 2) (("1" (typepred "n!2") (("1" (typepred "columns(D)") (("1" (split -2) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (split -7) (("1" (grind) nil nil) ("2" (inst - "n!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (rows(D)=2 AND columns(D)=2)") (("1" (assert) nil nil) ("2" (expand "entry") (("2" (expand "access") (("2" (expand "row") (("2" (rewrite "length_null") (("2" (assert) (("2" (case "NOT length(D)=2") (("1" (expand "rows") (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (hide -2) (("2" (case "null?(D)") (("1" (grind) nil nil) ("2" (assert) (("2" (ground) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -1) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (replaces -1) (("3" (replaces -1) (("3" (hide -) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (replaces -1) (("4" (replaces -1) (("4" (hide -) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4)) (("2" (hide -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rows(D)>=3") (("1" (assert) nil nil) ("2" (hide (-3 1)) (("2" (copy -2) (("2" (hide -3) (("2" (name "S" "swap(0,1)(D)") (("2" (replaces -1) (("2" (expand "det") (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (typepred "S") (("1" (grind) nil nil)) nil) ("2" (typepred "S") (("2" (grind) nil nil)) nil) ("3" (typepred "S") (("3" (hide (-1 -2 -3 -4 -7)) (("3" (case "NOT FORALL (rr:real): -rr = (-1)*rr") (("1" (assert) nil nil) ("2" (invoke (inst - "%1") (! 2 2 1)) (("2" (replaces -1) (("2" (rewrite "sigma_scal" :dir rl) (("2" (expand "det" + 2) (("2" (invoke (case "NOT (%1 = (sigma(0, columns(D) - 1,
                               LAMBDA (i: nat):
                                 sigma(0, columns(remove(D, 0, i)) - 1,
                                               LAMBDA (k):
                                                 det(remove(remove(D, 0, i), 0, k)) *
                                                  entry(remove(D, 0, i))(0, k)
                                                  * (-1) ^ k*(-1) *
                                  entry(D)(0, i) * (-1) ^ i))))") (! 2 2)) (("1" (hide 3) (("1" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (lift-if) (("1" (ground) (("1" (typepred "remove(D,0,n!1)") (("1" (assert) (("1" (flatten) (("1" (grind :exclude "remove") nil nil)) nil)) nil)) nil) ("2" (typepred "remove(D,0,n!1)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "remove(D,0,n!1)") (("3" (assert) nil nil)) nil) ("4" (rewrite "sigma_scal" :dir rl) (("4" (rewrite "sigma_scal" :dir rl) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst + "10") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst + "10") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replace -2) (("2" (assert) (("2" (case "NOT (LAMBDA (i: nat):
                                   sigma(0, columns(remove(D, 0, i)) - 1,
                                         LAMBDA (k):
                                           -1 *
                                            (det(remove(remove(D, 0, i), 0, k)) *
                                              entry(remove(D, 0, i))(0, k)
                                              * entry(D)(0, i)
                                              * (-1) ^ i
                                              * (-1) ^ k))) = (LAMBDA (i: nat):
                                   sigma(0, columns(D)-2,
                                         LAMBDA (k):
                                           -1 *
                                            (det(remove(remove(D, 0, i), 0, k)) *
                                              entry(remove(D, 0, i))(0, k)
                                              * entry(D)(0, i)
                                              * (-1) ^ i
                                              * (-1) ^ k)))") (("1" (hide 3) (("1" (decompose-equality) (("1" (typepred "remove(D,0,x!1)") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (typepred "remove(D,0,i!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "sigma_swap") (("2" (name "H" "LAMBDA (j:nat): LAMBDA (i_1:nat): -1 *
                                             (det(remove(remove(D, 0, i_1), 0, j)) *
                                               entry(remove(D, 0, i_1))(0, j)
                                               * entry(D)(0, i_1)
                                               * (-1) ^ i_1
                                               * (-1) ^ j)") (("2" (invoke (case "NOT %1 = sigma(0,columns(D)-2,LAMBDA (j:nat): sigma(0,columns(D)-1,H(j)))") (! 2 2)) (("1" (hide (3)) (("1" (expand "H" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (replaces -1) (("2" (name "H1" "LAMBDA (j:nat): LAMBDA (i_1:nat): IF j<i_1 THEN H(j)(i_1) ELSE 0 ENDIF") (("2" (name "H2" "LAMBDA (j:nat): LAMBDA (i_1:nat): IF j>=i_1 THEN H(j)(i_1) ELSE 0 ENDIF") (("2" (case "NOT (LAMBDA (j: nat): sigma(0, columns(D) - 1, H(j))) = (LAMBDA (j: nat): sigma(0, columns(D) - 1, H1(j)) + sigma(0,columns(D)-1,H2(j)))") (("1" (hide-all-but 1) (("1" (decompose-equality) (("1" (rewrite "sigma_sum") (("1" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (expand "H1") (("1" (expand "H2") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (name "K1" "LAMBDA (j:nat): sigma(0, columns(D) - 1, H1(j))") (("2" (name "K2" "LAMBDA (j:nat): sigma(0, columns(D) - 1, H2(j))") (("2" (invoke (case "NOT %1 = K1+K2") (! 2 2 3)) (("1" (decompose-equality 1) (("1" (expand "+" 1) (("1" (expand "K1" 1) (("1" (expand "K2" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (name "H3" "LAMBDA (j:nat): IF j>=1 THEN H2(j-1) ELSE (LAMBDA (kj:nat): 0) ENDIF") (("1" (name "K3" "LAMBDA (j:nat): sigma(0, columns(D) - 1, H3(j))") (("1" (expand "+" 2) (("1" (rewrite "sigma_sum" 2 :dir rl) (("1" (case "NOT sigma(0, columns(D) - 2, K2) = sigma(0,columns(D)-1,K3)") (("1" (hide 3) (("1" (lemma "sigma_split") (("1" (inst - "K3" _ _ _) (("1" (inst?) (("1" (inst - "0") (("1" (assert) (("1" (replaces -1) (("1" (expand "sigma" + 2) (("1" (expand "sigma" + 2) (("1" (expand "K3" + 1) (("1" (expand "H3" + 1) (("1" (invoke (case "NOT %1 = 0") (! 1 2 1)) (("1" (rewrite "sigma_restrict_eq_0" 1) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "sigma_shift_fun_eq") (("2" (skeep) (("2" (expand "K3" 1) (("2" (expand "K2" 1) (("2" (rewrite "sigma_eq" 1) (("2" (skosimp*) (("2" (expand "H3" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (name "D8" "LAMBDA (k:nat): IF k<=columns(D)-2 THEN K1(k) ELSE 0 ENDIF") (("2" (case "NOT sigma(0,columns(D)-2,K1)=sigma(0,columns(D)-1,D8)") (("1" (expand "sigma" + 2) (("1" (expand "D8" + 1) (("1" (rewrite "sigma_eq") (("1" (skosimp*) (("1" (expand "D8" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "sigma_sum") (("2" (rewrite "sigma_eq" 2) (("2" (hide 3) (("2" (skosimp*) (("2" (typepred "n!1") (("2" (expand "D8" 1) (("2" (assert) (("2" (expand "K3" 1) (("2" (typepred "S") (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (inst - "0" "n!1") (("2" (assert) (("2" (replaces -1) (("2" (expand "S" 1) (("2" (rewrite "remove_swap_1") (("2" (case "n!1 = columns(D)-1") (("1" (assert) (("1" (expand "H3" 1) (("1" (expand "H2" 1) (("1" (expand "H" 1) (("1" (expand "det" + 1) (("1" (lift-if) (("1" (assert) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (split -1) (("1" (case "NOT rows(remove(D,1,n!1))=0") (("1" (expand "rows" 1) (("1" (expand "length" 1) (("1" (typepred "remove(D,1,n!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "remove(D,1,n!1)") (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "remove(D,1,n!1)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (typepred "remove(D,1,n!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "sigma_scal" :dir rl) (("2" (case "NOT columns(remove(D,1,n!1))=columns(D)-1") (("1" (typepred "remove(D,1,n!1)") (("1" (assert) nil nil)) nil) ("2" (replace -1 2) (("2" (assert) (("2" (expand "sigma" + 2) (("2" (rewrite "sigma_eq" 2) (("2" (hide 3) (("2" (skosimp*) (("2" (case "(-1)^(n!1)=-(-1)^(n!1-1)") (("1" (replaces -1) (("1" (typepred "remove(D,0,n!2)") (("1" (hide (-1 -2 -4)) (("1" (inst?) (("1" (replace -1) (("1" (assert) (("1" (typepred "remove(D,1,n!1)") (("1" (hide (-1 -2 -4)) (("1" (inst?) (("1" (replaces -1) (("1" (assert) (("1" (lemma "remove_remove_1_0") (("1" (inst - "D" "n!2" "n!1-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt" + 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "n!1 = 0") (("1" (replaces -1) (("1" (expand "K1" +) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (rewrite "sigma_first" +) (("1" (expand "H1" 2 1) (("1" (invoke (case "NOT %1 = 0") (! 2 2 1)) (("1" (rewrite "sigma_restrict_eq_0" 1) (("1" (skosimp*) (("1" (expand "H3" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (expand "det" +) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (typepred "remove(D,1,0)") (("1" (assert) (("1" (flatten) (("1" (expand "rows") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "remove(D,1,0)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "remove(D,1,0)") (("3" (assert) nil nil)) nil) ("4" (typepred "remove(D,1,0)") (("4" (assert) (("4" (flatten) (("4" (replace -3 +) (("4" (assert) (("4" (rewrite "sigma_scal_right" :dir rl) (("4" (rewrite "sigma_shift_fun_eq" 2) (("4" (hide 3) (("4" (skosimp*) (("4" (typepred "i!1") (("4" (expand "H1" 1) (("4" (expand "H" 1) (("4" (typepred "remove(D,1,0)") (("4" (hide (-1 -2 -4)) (("4" (inst?) (("4" (replaces -1) (("4" (assert) (("4" (typepred "remove(D,0,1+i!1)") (("4" (hide (-1 -2 -4)) (("4" (inst?) (("4" (replaces -1) (("4" (assert) (("4" (case "NOT (-1)^0=1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (case "NOT (-1)^(1+i!1) = -(-1)^i!1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "remove_remove_1_0_0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "H3" +) (("2" (case "NOT sigma(0, columns(D) - 1, H2(n!1 - 1)) = sigma(0, n!1-1, H(n!1 - 1))") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "n!1-1") (("1" (assert) (("1" (replaces -1) (("1" (invoke (case "NOT %1 = 0") (! 1 1 2)) (("1" (rewrite "sigma_restrict_eq_0") (("1" (skosimp*) (("1" (expand "H2") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (lemma "sigma_eq") (("2" (inst - "H2(n!1-1)" "H(n!1-1)" "n!1-1" "0") (("2" (assert) (("2" (skosimp*) (("2" (expand "H2" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "K1" +) (("2" (case "NOT sigma(0, columns(D) - 1, H1(n!1)) = sigma(n!1+1, columns(D) - 1, H(n!1))") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "n!1") (("1" (assert) (("1" (invoke (case "NOT %1 = 0") (! -1 2 1)) (("1" (rewrite "sigma_restrict_eq_0") (("1" (skosimp*) (("1" (expand "H1" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (replaces -1) (("2" (rewrite "sigma_eq" 1) (("2" (skosimp*) (("2" (expand "H1" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (expand "det" +) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (typepred "remove(D,1,n!1)") (("1" (assert) (("1" (flatten) (("1" (expand "rows") (("1" (expand "length" -2 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "remove(D,1,n!1)") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "remove(D,1,n!1)") (("3" (assert) nil nil)) nil) ("4" (typepred "remove(D,1,n!1)") (("4" (hide (-1 -3 -4)) (("4" (assert) (("4" (flatten) (("4" (replaces -2) (("4" (assert) (("4" (rewrite "sigma_scal" :dir rl) (("4" (lemma "sigma_split") (("4" (inst?) (("4" (inst - "n!1-1") (("4" (assert) (("4" (replaces -1) (("4" (case "FORALL (aa,bb,cc,dd:real): aa=cc AND bb=dd IMPLIES aa+bb=cc+dd") (("1" (rewrite -1 2) (("1" (hide 3) (("1" (hide -1) (("1" (rewrite "sigma_eq" 1) (("1" (hide 2) (("1" (skosimp*) (("1" (expand "H" 1) (("1" (case "NOT (-1)^n!1 = -(-1)^(n!1-1)") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (lemma "remove_remove_1_0") (("2" (inst - "D" "n!2" "n!1-1") (("2" (assert) (("2" (replaces -1) (("2" (assert) (("2" (typepred "remove(D,1,n!1)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (typepred "remove(D,0,n!2)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "sigma_shift_fun_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "H" 1) (("2" (lemma "remove_remove_1_0") (("2" (lemma "remove_remove_1_n") (("2" (rewrite -1 1) (("2" (typepred "remove(D,1,n!1)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (typepred "remove(D,0,1+i!1+n!1)") (("2" (hide (-1 -2 -4)) (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (case "(-1)^(1+i!1+n!1) = -(-1)^(i!1+n!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (typepred "remove(D,0,i!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (inst + "10") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 3) (("4" (skosimp*) (("4" (inst + "10") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_extensionality formula-decl nil more_list_props structures) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (sigma def-decl "real" sigma reals) (form_matrix_square application-judgement "FullMatrix" matrices nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma_scal formula-decl nil sigma reals) (sigma_eq formula-decl nil sigma reals) (sigma_swap formula-decl nil sigma_swap reals) (sigma_sum formula-decl nil sigma reals) (sigma_split formula-decl nil sigma reals) (sigma_restrict_eq_0 formula-decl nil sigma reals) (sigma_shift_fun_eq formula-decl nil sigma reals) (sigma_scal_right formula-decl nil sigma reals) (sigma_first formula-decl nil sigma reals) (Matrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (FullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil)) shostak)) (swap_swap_matrix 0 (swap_swap_matrix-2 "" 3790097602 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("" (assert) (("" (hide 2) (("" (skosimp*) (("" (typepred "i!1") (("" (typepred "j!1") (("" (typepred "swap(i, j)(swap(i, j)(D))") (("" (hide (-1 -2 -3 -4 -7)) (("" (copy -3) (("" (copy -5) (("" (replace -4) (("" (replace -3) (("" (typepred "swap(i,j)(D)") (("" (hide (-1 -2 -3 -4 -7)) (("" (copy -3) (("" (copy -5) (("" (replace -4) (("" (replace -3) (("" (assert) (("" (typepred "swap(i, j)(swap(i, j)(D))") (("" (hide (-1 -2 -3 -4 -5 -6)) (("" (inst - "i!1" "j!1") (("" (invoke (case "%1") (! -1 1)) (("1" (flatten) (("1" (assert) (("1" (replaces -3 +) (("1" (lift-if) (("1" (ground) (("1" (replaces -1) (("1" (typepred "swap(i,j)(D)") (("1" (hide (-1 -2 -3 -4 -5 -6)) (("1" (inst - "j" "j!1") (("1" (assert) (("1" (replaces -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "swap(i,j)(D)") (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (inst - "i" "j!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (typepred "swap(i,j)(D)") (("3" (hide (-1 -2 -3 -4 -5 -6)) (("3" (inst - "i!1" "j!1") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (PosFullMatrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil)) shostak) (swap_swap_matrix-1 nil 3614444971 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("" (assert) (("" (hide 2) (("" (skosimp*) (("" (typepred "i!1") (("" (typepred "j!1") (("" (typepred "swap(i, j)(swap(i, j)(D))") (("" (hide (-1 -2 -3 -4 -7)) (("" (copy -3) (("" (copy -5) (("" (replace -4) (("" (replace -3) (("" (typepred "swap(i,j)(D)") (("" (hide (-1 -2 -3 -4 -7)) (("" (copy -3) (("" (copy -5) (("" (replace -4) (("" (replace -3) (("" (assert) (("" (typepred "swap(i, j)(swap(i, j)(D))") (("" (hide (-1 -2 -3 -4 -5 -6)) (("" (inst - "i!1" "j!1") (("" (invoke (case "%1") (! -1 1)) (("1" (flatten) (("1" (assert) (("1" (replaces -3 +) (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (replaces -1) (("1" (typepred "swap(i,j)(D)") (("1" (hide (-1 -2 -3 -4 -5 -6)) (("1" (inst - "j" "j!1") (("1" (assert) (("1" (replaces -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "swap(i,j)(D)") (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (inst - "i" "j!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (typepred "swap(i,j)(D)") (("3" (hide (-1 -2 -3 -4 -5 -6)) (("3" (inst - "i!1" "j!1") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (entry const-decl "real" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (rows const-decl "nat" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil)) shostak)) (swap_similar 0 (swap_similar-2 "" 3790097603 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (assert) (("" (skosimp*) (("" (expand "swap" + 1) (("" (rewrite "entry_form_matrix") (("" (expand "swap" + 2) (("" (rewrite "entry_form_matrix") (("" (expand "swap" + 3) (("" (expand "swap" + 1) (("" (expand "swap" + 1) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (ground) (("1" (rewrite "entry_form_matrix") (("1" (expand "swap" + 1) (("1" (ground) (("1" (expand "swap" + 1) (("1" (rewrite "entry_form_matrix") (("1" (expand "swap" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "swap" + 1) (("2" (rewrite "entry_form_matrix") (("2" (expand "swap" +) (("2" (rewrite "entry_form_matrix") (("2" (expand "swap" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "entry_form_matrix") (("3" (expand "swap" +) (("3" (rewrite "entry_form_matrix") (("3" (expand "swap" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (rewrite "entry_form_matrix") (("4" (expand "swap" +) (("4" (rewrite "entry_form_matrix") (("4" (expand "swap" +) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (entry_form_matrix formula-decl nil matrices nil) (swap const-decl "real" matrix_props nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (swap_similar-1 nil 3614695692 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (assert) (("" (skosimp*) (("" (expand "swap" + 1) (("" (rewrite "entry_form_matrix") (("" (expand "swap" + 2) (("" (rewrite "entry_form_matrix") (("" (expand "swap" + 3) (("" (expand "swap" + 1) (("" (expand "swap" + 1) (("" (assert) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (ground) (("1" (rewrite "entry_form_matrix") (("1" (expand "swap" + 1) (("1" (ground) (("1" (expand "swap" + 1) (("1" (rewrite "entry_form_matrix") (("1" (expand "swap" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "swap" + 1) (("2" (rewrite "entry_form_matrix") (("2" (expand "swap" +) (("2" (rewrite "entry_form_matrix") (("2" (expand "swap" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "entry_form_matrix") (("3" (expand "swap" +) (("3" (rewrite "entry_form_matrix") (("3" (expand "swap" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (rewrite "entry_form_matrix") (("4" (expand "swap" +) (("4" (rewrite "entry_form_matrix") (("4" (expand "swap" +) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (entry const-decl "real" matrices nil) (entry_form_matrix formula-decl nil matrices nil) (form_matrix_square application-judgement "FullMatrix" matrices nil)) shostak)) (det_swap 0 (det_swap-1 nil 3614688092 ("" (case "FORALL (D: PosFullMatrix, i, j, n: nat):
                             i < j AND i < rows(D) AND j < rows(D) AND rows(D)=columns(D) AND rows(D)=n+2 IMPLIES
                              det(swap(i, j)(D)) = -det(D)") (("1" (skeep) (("1" (case "rows(D)/=columns(D)") (("1" (flatten) (("1" (assert) (("1" (expand "det" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "i < j") (("1" (inst - "D" "i" "j" "rows(D)-2") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst - "D" "j" "i" "rows(D)-2") (("1" (assert) (("1" (rewrite "swap_sym" -) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (skeep) (("1" (assert) (("1" (lemma "det_swap_0_1") (("1" (inst - "D") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "n") (("2" (flatten) (("2" (assert) (("2" (case "NOT FORALL (D: PosFullMatrix, i, j: nat):
             1<=i AND i < j AND i < rows(D) AND j < rows(D) AND rows(D) = columns(D)
         AND rows(D) = 3 + n
         IMPLIES det(swap(i, j)(D)) = -det(D)") (("1" (hide 2) (("1" (skeep) (("1" (expand "det" +) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (assert) (("1" (ground) (("1" (typepred "swap(i,j)(D)") (("1" (expand "rows") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "D") (("2" (expand "rows") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (case "FORALL (rr:real): -rr=(-1)*rr") (("1" (invoke (inst - "%1") (! 2 2 1)) (("1" (replaces -1) (("1" (rewrite "sigma_scal" :dir rl) (("1" (typepred "swap(i,j)(D)") (("1" (hide (-1 -2 -3 -4 -5 -7)) (("1" (replaces -1) (("1" (assert) (("1" (rewrite "sigma_eq" 2) (("1" (hide 3) (("1" (skosimp*) (("1" (case "entry(swap(i, j)(D))(0, n!1) = entry(D)(0, n!1)") (("1" (replaces -1) (("1" (assert) (("1" (case "remove(swap(i, j)(D), 0, n!1) = swap(i-1,j-1)(remove(D,0,n!1))") (("1" (replaces -1) (("1" (inst?) (("1" (assert) (("1" (typepred "remove(D,0,n!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (rewrite "remove_swap_2") nil nil)) nil)) nil) ("3" (assert) (("3" (hide 2) (("3" (typepred "remove(D,0,n!1)") (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "swap(i,j)(D)") (("2" (rewrite -7) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "NOT i = 0") (("1" (inst - "D" "i" "j") (("1" (assert) nil nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (lemma "swap_similar") (("2" (inst - "D" "1" "j" "0") (("2" (assert) (("2" (case "j = 1") (("1" (hide -2) (("1" (lemma "det_swap_0_1") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replaces -1 +) (("2" (inst-cp - "swap(0, 1)(swap(1, j)(D))" "1" "j") (("2" (assert) (("2" (replaces -2) (("2" (rewrite "det_swap_0_1" +) (("2" (inst - "D" "1" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((swap_similar formula-decl nil matrix_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (sigma_eq formula-decl nil sigma reals) (rat_exp application-judgement "rat" exponentiation nil) (remove_swap_2 formula-decl nil matrix_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (subrange type-eq-decl nil integers nil) (sigma_scal formula-decl nil sigma reals) (minus_odd_is_odd application-judgement "odd_int" integers nil) (^ const-decl "real" exponentiation nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (det_swap_0_1 formula-decl nil matrix_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (swap_sym formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (det def-decl "real" matrix_props nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (- const-decl "[numfield -> numfield]" number_fields nil)) shostak)) (row_swap 0 (row_swap-1 nil 3614963731 ("" (skeep) (("" (rewrite "list_extensionality[real]") (("" (split) (("1" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "entry_swap") (("2" (inst - "D" "i" "j" "k" "n") (("2" (expand "entry") (("2" (expand "access" -1) (("2" (replaces -1) (("2" (expand "swap") (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (rewrite "length_row") (("2" (rewrite "length_row") (("2" (rewrite "length_row") (("2" (assert) (("2" (ground) (("1" (expand "row" 2) (("1" (expand "rows") (("1" (assert) (("1" (typepred "n") (("1" (rewrite "length_row") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_row") (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "n") (("3" (rewrite "length_row") (("3" (assert) nil nil)) nil)) nil) ("4" (typepred "n") (("4" (rewrite "length_row") (("4" (lift-if) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_extensionality formula-decl nil more_list_props structures) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Vector type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (access const-decl "real" matrices nil) (swap const-decl "real" matrix_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (entry_swap formula-decl nil matrix_props nil) (length_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (rows_swap 0 (rows_swap-1 nil 3615053514 ("" (skeep) (("" (expand "swap") (("" (rewrite "rows_form_matrix") nil nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (entry const-decl "real" matrices nil) (swap const-decl "real" matrix_props nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rows const-decl "nat" matrices nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rows_form_matrix formula-decl nil matrices nil)) shostak)) (columns_swap 0 (columns_swap-1 nil 3615053542 ("" (skeep) (("" (expand "swap") (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (swap const-decl "real" matrix_props nil) (entry const-decl "real" matrices nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (columns_form_matrix formula-decl nil matrices nil)) shostak)) (swap_id 0 (swap_id-2 "" 3790097611 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("" (assert) (("" (skosimp*) (("" (typepred "swap(i,i)(D)") (("" (hide (-1 -2 -3 -4 -5 -6)) (("" (inst - "i!1" "j!1") (("" (assert) (("" (case "i < rows(D)") (("1" (assert) (("1" (replaces -2) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "swap") (("2" (rewrite "entry_form_matrix") (("2" (expand "swap" 2) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (entry_form_matrix formula-decl nil matrices nil) (swap const-decl "real" matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (PosFullMatrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil)) shostak) (swap_id-1 nil 3614445784 ("" (skeep) (("" (lemma "full_matrix_eq") (("" (inst?) (("" (assert) (("" (skosimp*) (("" (typepred "swap(i,i)(D)") (("" (hide (-1 -2 -3 -4 -5 -6)) (("" (inst - "i!1" "j!1") (("" (assert) (("" (case "i < rows(D)") (("1" (assert) (("1" (replaces -2) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "swap") (("2" (rewrite "entry_form_matrix") (("2" (expand "swap" 2) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (entry_form_matrix formula-decl nil matrices nil) (entry const-decl "real" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (rows const-decl "nat" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil)) shostak)) (swap_eq 0 (swap_eq-1 nil 3615027356 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (rewrite "entry_swap") (("3" (expand "swap") (("3" (expand "entry") (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (swap const-decl "real" matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (entry_swap formula-decl nil matrix_props nil)) shostak)) (det_rows_eq_0 0 (det_rows_eq_0-1 nil 3615027482 ("" (skeep) (("" (lemma "swap_eq") (("" (inst?) (("" (assert) (("" (lemma "det_swap") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((swap_eq formula-decl nil matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (det_swap formula-decl nil matrix_props nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil)) shostak)) (replace_row_TCC1 0 (replace_row_TCC1-1 nil 3614701196 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (D!1 skolem-const-decl "{D | columns(D) = length(v!1)}" matrix_props nil) (v!1 skolem-const-decl "Vector" matrix_props nil) (j!1 skolem-const-decl "nat" matrix_props nil) (j!1 skolem-const-decl "nat" matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil) (entry const-decl "real" matrices nil)) nil (replace_row subtype "matrix_props.D" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), booleans.AND((FORALL (j): matrices.row(matrix_props.PFM)(matrix_props.j) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrix_props.v ELSE matrices.row(matrix_props.D)(matrix_props.j) ENDIF), (FORALL (j, k): matrices.entry(matrix_props.PFM)(matrix_props.j, matrix_props.k) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrices.access(matrix_props.v)(matrix_props.k) ELSE matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.k) ENDIF))))}"))) (replace_row_TCC2 0 (replace_row_TCC2-1 nil 3614701196 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil) (length def-decl "nat" list_props nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nth def-decl "T" list_props nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil)) nil (replace_row subtype "list_adt[Vector].cons(matrix_props.v, list_adt[list[real]].null)" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), booleans.AND((FORALL (j): matrices.row(matrix_props.PFM)(matrix_props.j) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrix_props.v ELSE matrices.row(matrix_props.D)(matrix_props.j) ENDIF), (FORALL (j, k): matrices.entry(matrix_props.PFM)(matrix_props.j, matrix_props.k) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrices.access(matrix_props.v)(matrix_props.k) ELSE matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.k) ENDIF))))}"))) (replace_row_TCC3 0 (replace_row_TCC3-1 nil 3614701196 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil)) nil (replace_row subtype "matrix_props.D" "(list_adt[list[real]].cons?)"))) (replace_row_TCC4 0 (replace_row_TCC4-3 "" 3790097615 ("" (skeep) (("" (replace -1) (("" (assert) (("" (split) (("1" (skosimp*) (("1" (expand "nth") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (typepred "D") (("1" (assert) (("1" (split -) (("1" (grind) nil nil) ("2" (typepred "columns(D)") (("2" (assert) (("2" (skosimp*) (("2" (inst - "i!2" "j!1") (("1" (expand "nth" -3 2) (("1" (assert) nil nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "columns(D)") (("2" (ground) (("2" (skosimp*) (("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "i!2") (("1" (expand "nth" -1) (("1" (lift-if) (("1" (ground) (("1" (case "length(car(D)) = columns(D)") (("1" (assert) nil nil) ("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "0" "i!2") (("2" (expand "nth" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" -6) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "D") (("3" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "j!1") (("1" (assert) (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" (-1 1)) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i!1") (("3" (expand "length" (-1 1)) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) (("4" (expand "length" 1 2) (("4" (lift-if) (("4" (ground) nil nil)) nil)) nil)) nil) ("5" (name "KD" "cons[Vector](v, cdr[list[real]](D))") (("5" (replace -1) (("5" (typepred "columns(KD)") (("5" (ground) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (replaces -1 1 :dir rl) (("2" (typepred "columns(D)") (("2" (ground) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (case "i!1 = 0") (("1" (replaces -1) (("1" (expand "nth" 1 1) (("1" (expand "KD" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "i!2") (("1" (expand "KD" 2) (("1" (expand "nth" + 1) (("1" (replaces -1 :dir rl) (("1" (expand "nth" + 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (assert) (("2" (expand "KD" -1) (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp*) (("6" (expand "row" 1 1) (("6" (lift-if) (("6" (lift-if) (("6" (lift-if) (("6" (assert) (("6" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "row") (("3" (lift-if) (("3" (ground) (("3" (expand "length" -1 1) (("3" (expand "length" 1) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "nth") (("4" (propax) nil nil)) nil) ("5" (expand "rows") (("5" (expand "length" (1 3)) (("5" (lift-if) (("5" (ground) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (expand "nth" 2) (("6" (expand "row" 2) (("6" (lift-if) (("6" (ground) (("1" (expand "length" (-1 3)) (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) (("7" (skeep) (("7" (expand "entry") (("7" (expand "row") (("7" (expand "access") (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (assert) (("7" (case "null?(D)") (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (case "null?(v)") (("1" (hide 2) (("1" (typepred "D") (("1" (grind) nil nil)) nil)) nil) ("2" (ground) (("1" (expand "length" -4) (("1" (expand "rows" -2) (("1" (expand "length" -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "length" (-2 2)) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (expand "length" (-1 3)) (("6" (grind) nil nil)) nil) ("7" (expand "rows" +) (("7" (assert) (("7" (grind) nil nil)) nil)) nil) ("8" (expand "rows" +) (("8" (assert) nil nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil) ("15" (grind) nil nil) ("16" (grind) nil nil) ("17" (grind) nil nil) ("18" (grind) nil nil) ("19" (grind) nil nil) ("20" (grind) nil nil) ("21" (grind) nil nil) ("22" (grind) nil nil) ("23" (grind) nil nil) ("24" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (v skolem-const-decl "Vector" matrix_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (D skolem-const-decl "{D | columns(D) = length(v)}" matrix_props nil) (j!1 skolem-const-decl "below(length(cons(v, cdr(D))))" matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (i!1 skolem-const-decl "below(length(cons(v, cdr(D))))" matrix_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (TRUE const-decl "bool" booleans nil) (i!1 skolem-const-decl "below(length(KD))" matrix_props nil) (KD skolem-const-decl "(cons?[Vector])" matrix_props nil) (row const-decl "Vector" matrices nil) (real_minus_real_is_real application-judgement "real" reals nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (replace_row subtype "list_adt[Vector].cons(matrix_props.v, list_adt[list[real]].cdr(matrix_props.D))" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), booleans.AND((FORALL (j): matrices.row(matrix_props.PFM)(matrix_props.j) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrix_props.v ELSE matrices.row(matrix_props.D)(matrix_props.j) ENDIF), (FORALL (j, k): matrices.entry(matrix_props.PFM)(matrix_props.j, matrix_props.k) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrices.access(matrix_props.v)(matrix_props.k) ELSE matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.k) ENDIF))))}")) (replace_row_TCC4-2 "" 3750621600 ("" (skeep) (("" (replace -1) (("" (assert) (("" (split) (("1" (skosimp*) (("1" (expand "nth") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (replaces -1) (("1" (typepred "D") (("1" (assert) (("1" (split -) (("1" (grind) nil nil) ("2" (typepred "columns(D)") (("2" (assert) (("2" (skosimp*) (("2" (inst - "i!2" "j!1") (("1" (expand "nth" -3 2) (("1" (assert) nil nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "columns(D)") (("2" (ground) (("2" (skosimp*) (("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "i!2") (("1" (expand "nth" -1) (("1" (lift-if) (("1" (ground) (("1" (case "length(car(D)) = columns(D)") (("1" (assert) nil nil) ("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "0" "i!2") (("2" (expand "nth" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" -6) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "D") (("3" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "j!1") (("1" (assert) (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" (-1 1)) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i!1") (("3" (expand "length" (-1 1)) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) (("4" (expand "length" 1 2) (("4" (lift-if) (("4" (ground) nil nil)) nil)) nil)) nil) ("5" (name "KD" "cons[Vector](v, cdr[list[real]](D))") (("5" (replace -1) (("5" (typepred "columns(KD)") (("5" (ground) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (replaces -1 1 :dir rl) (("2" (typepred "columns(D)") (("2" (ground) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (case "i!1 = 0") (("1" (replaces -1) (("1" (expand "nth" 1 1) (("1" (expand "KD" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "i!2") (("1" (expand "KD" 2) (("1" (expand "nth" + 1) (("1" (replaces -1 :dir rl) (("1" (expand "nth" + 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (assert) (("2" (expand "KD" -1) (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp*) (("6" (expand "row" 1 1) (("6" (lift-if) (("6" (lift-if) (("6" (lift-if) (("6" (assert) (("6" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "row") (("3" (lift-if) (("3" (ground) (("3" (expand "length" -1 1) (("3" (expand "length" 1) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "nth") (("4" (propax) nil nil)) nil) ("5" (expand "rows") (("5" (expand "length" (1 3)) (("5" (lift-if) (("5" (ground) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (expand "nth" 2) (("6" (expand "row" 2) (("6" (lift-if) (("6" (ground) (("1" (expand "length" (-1 3)) (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) (("7" (skeep) (("7" (expand "entry") (("7" (expand "row") (("7" (expand "access") (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (assert) (("7" (case "null?(D)") (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (case "null?(v)") (("1" (hide 2) (("1" (typepred "D") (("1" (grind) nil nil)) nil)) nil) ("2" (ground) (("1" (expand "length" -4) (("1" (expand "rows" -2) (("1" (expand "length" -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "length" (-2 2)) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (expand "length" (-1 3)) (("6" (grind) nil nil)) nil) ("7" (expand "rows" +) (("7" (assert) (("7" (grind) nil nil)) nil)) nil) ("8" (expand "rows" +) (("8" (assert) nil nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil) ("15" (grind) nil nil) ("16" (grind) nil nil) ("17" (grind) nil nil) ("18" (grind) nil nil) ("19" (grind) nil nil) ("20" (grind) nil nil) ("21" (grind) nil nil) ("22" (grind) nil nil) ("23" (grind) nil nil) ("24" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil)) shostak (replace_row subtype "list_adt[Vector].cons(matrix_props.v, list_adt[list[real]].cdr(matrix_props.D))" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), booleans.AND((FORALL (j): matrices.row(matrix_props.PFM)(matrix_props.j) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrix_props.v ELSE matrices.row(matrix_props.D)(matrix_props.j) ENDIF), (FORALL (j, k): matrices.entry(matrix_props.PFM)(matrix_props.j, matrix_props.k) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrices.access(matrix_props.v)(matrix_props.k) ELSE matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.k) ENDIF))))}")) (replace_row_TCC4-1 nil 3614701196 ("" (skeep) (("" (replace -1) (("" (assert) (("" (split) (("1" (skosimp*) (("1" (expand "nth") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (replaces -1) (("1" (typepred "D") (("1" (assert) (("1" (split -) (("1" (grind) nil nil) ("2" (typepred "columns(D)") (("2" (assert) (("2" (skosimp*) (("2" (inst - "i!2" "j!1") (("1" (expand "nth" -3 2) (("1" (assert) nil nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "columns(D)") (("2" (ground) (("2" (skosimp*) (("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "i!2") (("1" (expand "nth" -1) (("1" (lift-if) (("1" (ground) (("1" (case "length(car(D)) = columns(D)") (("1" (assert) nil nil) ("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "0" "i!2") (("2" (expand "nth" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" -6) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "D") (("3" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "j!1") (("1" (assert) (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" (-1 1)) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i!1") (("3" (expand "length" (-1 1)) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) (("4" (expand "length" 1 2) (("4" (lift-if) (("4" (ground) nil nil)) nil)) nil)) nil) ("5" (name "KD" "cons[Vector](v, cdr[list[real]](D))") (("5" (replace -1) (("5" (typepred "columns(KD)") (("5" (ground) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (replaces -1 1 :dir rl) (("2" (typepred "columns(D)") (("2" (ground) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (case "i!1 = 0") (("1" (replaces -1) (("1" (expand "nth" 1 1) (("1" (expand "KD" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "D") (("2" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1" "i!2") (("1" (expand "KD" 2) (("1" (expand "nth" + 1) (("1" (replaces -1 :dir rl) (("1" (expand "nth" + 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (assert) (("2" (expand "KD" -1) (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp*) (("6" (expand "row" 1 1) (("6" (lift-if) (("6" (lift-if) (("6" (lift-if) (("6" (assert) (("6" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "row") (("3" (lift-if) (("3" (ground) (("3" (expand "length" -1 1) (("3" (expand "length" 1) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "nth") (("4" (propax) nil nil)) nil) ("5" (expand "rows") (("5" (expand "length" (1 3)) (("5" (lift-if) (("5" (ground) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (expand "nth" 2) (("6" (expand "row" 2) (("6" (lift-if) (("6" (ground) (("1" (expand "length" (-1 3)) (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) (("7" (skeep) (("7" (expand "entry") (("7" (expand "row") (("7" (expand "access") (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (assert) (("7" (case "null?(D)") (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (case "null?(v)") (("1" (hide 2) (("1" (typepred "D") (("1" (grind) nil nil)) nil)) nil) ("2" (ground) (("1" (expand "length" -4) (("1" (expand "rows" -2) (("1" (expand "length" -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" -2) (("2" (expand "length" 2) (("2" (propax) nil nil)) nil)) nil) ("3" (expand "length" (-2 2)) (("3" (propax) nil nil)) nil) ("4" (expand "nth" + 2) (("4" (propax) nil nil)) nil) ("5" (expand "nth" -3 1) (("5" (propax) nil nil)) nil) ("6" (expand "length" (-1 3)) (("6" (propax) nil nil)) nil) ("7" (expand "rows" +) (("7" (assert) nil nil)) nil) ("8" (expand "rows" +) (("8" (assert) nil nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (row const-decl "Vector" matrices nil) (Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil)) nil (replace_row subtype "list_adt[Vector].cons(matrix_props.v, list_adt[list[real]].cdr(matrix_props.D))" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), booleans.AND((FORALL (j): matrices.row(matrix_props.PFM)(matrix_props.j) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrix_props.v ELSE matrices.row(matrix_props.D)(matrix_props.j) ENDIF), (FORALL (j, k): matrices.entry(matrix_props.PFM)(matrix_props.j, matrix_props.k) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrices.access(matrix_props.v)(matrix_props.k) ELSE matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.k) ENDIF))))}"))) (replace_row_TCC5 0 (replace_row_TCC5-1 nil 3614701196 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil)) nil (replace_row subtype "matrix_props.D" "(list_adt[list[real]].cons?)"))) (replace_row_TCC6 0 (replace_row_TCC6-2 "" 3804293761 ("" (skeep) (("" (assert) (("" (ground) (("1" (skosimp*) (("1" (typepred "D") (("1" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1+1" "j!1+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i!1") (("3" (expand "length" 1) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rows" (3 2)) (("2" (expand "length" +) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "columns_cdr") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "columns_cdr") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_row subtype "list_adt[list[real]].cdr(matrix_props.D)" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrix_props.v)}")) (replace_row_TCC6-1 nil 3614701196 ("" (skeep) (("" (assert) (("" (ground) (("1" (skosimp*) (("1" (typepred "D") (("1" (ground) (("1" (grind) nil nil) ("2" (inst - "i!1+1" "j!1+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" 1) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i!1") (("3" (expand "length" 1) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rows" (3 4)) (("2" (expand "length" +) (("2" (lift-if) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "columns_cdr") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "columns_cdr") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (columns_cdr formula-decl nil matrix_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (j!1 skolem-const-decl "below(length(cdr(D)))" matrix_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (v skolem-const-decl "Vector" matrix_props nil) (D skolem-const-decl "{D | columns(D) = length(v)}" matrix_props nil) (i!1 skolem-const-decl "below(length(cdr(D)))" matrix_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (replace_row subtype "list_adt[list[real]].cdr(matrix_props.D)" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrix_props.v)}"))) (replace_row_TCC7 0 (replace_row_TCC7-1 nil 3614701196 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rows const-decl "nat" matrices nil)) nil (replace_row subtype "(number_fields.-)(matrix_props.i, 1)" "nat"))) (replace_row_TCC8 0 (replace_row_TCC8-1 nil 3614701196 ("" (skeep) (("" (expand "rows" +) (("" (expand "length" 4 2) (("" (lift-if) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((rows const-decl "nat" matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (replace_row termination "matrix_props.replace_row((number_fields.-)(matrix_props.i, 1), matrix_props.v)(list_adt[list[real]].cdr(matrix_props.D))" "nil"))) (replace_row_TCC9 0 (replace_row_TCC9-1 nil 3614704097 ("" (skeep) (("" (case "null?(D)") (("1" (grind) nil nil) ("2" (assert) (("2" (name "W" "v1(i-1,v)(cdr[list[real]](D))") (("1" (replace -1) (("1" (name "KD" "cons[list[real]](car[list[real]](D), W)") (("1" (replace -1) (("1" (case "NOT length(KD) = length(D)") (("1" (hide 6) (("1" (expand "KD" 1) (("1" (expand "length" 1) (("1" (assert) (("1" (typepred "W") (("1" (expand "rows") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (ground) (("1" (skosimp*) (("1" (expand "KD" +) (("1" (expand "nth" +) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (lemma "length_nth_row") (("1" (inst - "W" "j!1-1") (("1" (assert) (("1" (split -) (("1" (replaces -1) (("1" (typepred "W") (("1" (replace -6 +) (("1" (rewrite "columns_cdr" +) (("1" (lemma "length_nth_row") (("1" (inst - "D" "0") (("1" (assert) (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "length_nth_row") (("2" (inst - "W" "i!1-1") (("2" (assert) (("2" (split -) (("1" (replaces -1) (("1" (typepred "W") (("1" (replace -6 +) (("1" (rewrite "columns_cdr" +) (("1" (assert) (("1" (lemma "length_nth_row") (("1" (inst - "D" "0") (("1" (assert) (("1" (split -) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "nth" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "length_nth_row") (("3" (inst-cp - "W" "i!1-1") (("3" (assert) (("3" (inst-cp - "W" "j!1-1") (("3" (ground) (("1" (typepred "i!1") (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "j!1") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "j!1") (("3" (expand "length" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "KD" 1) (("2" (expand "rows" 1) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "KD" 1) (("3" (rewrite "columns_cons" 1) (("3" (hide -) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (expand "KD" 1) (("4" (expand "rows" 1) (("4" (expand "length" 1 1) (("4" (typepred "W") (("4" (expand "rows") (("4" (replace -5) (("4" (expand "length" + 2) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "KD" 1) (("5" (rewrite "columns_cons" 1) (("5" (hide -) (("5" (expand "max") (("5" (lift-if) (("5" (ground) (("1" (typepred "W") (("1" (replace -6) (("1" (rewrite "columns_cdr" 1) nil nil)) nil)) nil) ("2" (lemma "length_nth_row") (("2" (inst - "D" "0") (("2" (split -) (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep) (("6" (expand "row") (("6" (expand "rows") (("6" (lift-if) (("6" (lift-if) (("6" (lift-if) (("6" (assert) (("6" (ground) (("1" (expand "KD" 1) (("1" (expand "nth" 1) (("1" (typepred "W") (("1" (inst - "j-1") (("1" (expand "row" -7) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (split -2) (("1" (grind) nil nil) ("2" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "KD" 2) (("2" (expand "nth" 2 1) (("2" (lift-if) (("2" (ground) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil) ("2" (typepred "W") (("2" (inst - "j-1") (("2" (split -2) (("1" (grind) nil nil) ("2" (expand "row" -7) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (ground) (("1" (expand "length" -10 2) (("1" (assert) nil nil)) nil) ("2" (expand "rows") (("2" (assert) nil nil)) nil) ("3" (expand "rows") (("3" (assert) nil nil)) nil) ("4" (replace -1 +) (("4" (expand "nth" 4 2) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (expand "entry" 1) (("7" (lift-if) (("7" (ground) (("1" (case "row(KD)(j) = v") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "KD" 1) (("2" (expand "row" 1) (("2" (lift-if) (("2" (ground) (("1" (expand "length" -1) (("1" (expand "rows" -2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (typepred "W") (("2" (hide -2) (("2" (inst - "j-1") (("2" (lift-if) (("2" (ground) (("1" (expand "row" -3) (("1" (lift-if) (("1" (ground) (("1" (expand "rows") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 2) (("2" (expand "rows" 1) (("2" (assert) (("2" (typepred "W") (("2" (expand "rows") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "row" 2) (("2" (expand "rows" 1) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "KD" +) (("3" (expand "row") (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (expand "nth" + 1) (("3" (lift-if) (("3" (ground) (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "W") (("2" (hide -2) (("2" (inst - "j-1") (("2" (lift-if) (("2" (ground) (("1" (expand "row" -1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (assert) (("1" (expand "length" 4) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" 4) (("2" (assert) (("2" (typepred "W") (("2" (expand "rows") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "row" -1 1) (("2" (lift-if) (("2" (assert) (("2" (split -) (("1" (flatten) (("1" (expand "length" 4) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "row" 4) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (typepred "W") (("1" (expand "rows") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "nth" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 6) (("2" (split) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "length_nth_row") (("1" (inst-cp - "D" "i!1+1") (("1" (inst - "D" "j!1+1") (("1" (assert) (("1" (ground) (("1" (expand "nth" -) (("1" (assert) nil nil)) nil) ("2" (typepred "i!1") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "length" 1) (("3" (assert) nil nil)) nil) ("4" (expand "length" 1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "columns_cdr") (("2" (assert) nil nil)) nil) ("3" (expand "rows") (("3" (expand "length" 1 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Vector type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (row const-decl "Vector" matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (KD skolem-const-decl "(cons?[list[real]])" matrix_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (length_nth_row formula-decl nil matrix_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (columns_cdr formula-decl nil matrix_props nil) (columns_cons formula-decl nil matrix_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (replace_row subtype "list_adt[list[real]].cons(list_adt[list[real]].car(matrix_props.D), matrix_props.replace_row((number_fields.-)(matrix_props.i, 1), matrix_props.v)(list_adt[list[real]].cdr(matrix_props.D)))" "{PFM | booleans.AND(matrices.rows(matrix_props.PFM) = matrices.rows(matrix_props.D), booleans.AND(matrices.columns(matrix_props.PFM) = matrices.columns(matrix_props.D), booleans.AND((FORALL (j): matrices.row(matrix_props.PFM)(matrix_props.j) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrix_props.v ELSE matrices.row(matrix_props.D)(matrix_props.j) ENDIF), (FORALL (j, k): matrices.entry(matrix_props.PFM)(matrix_props.j, matrix_props.k) = IF booleans.AND(reals.<(matrix_props.j, matrices.rows(matrix_props.D)), matrix_props.j = matrix_props.i) THEN matrices.access(matrix_props.v)(matrix_props.k) ELSE matrices.entry(matrix_props.D)(matrix_props.j, matrix_props.k) ENDIF))))}"))) (entry_replace_row 0 (entry_replace_row-1 nil 3614957681 ("" (skeep) (("" (typepred "replace_row(i,v)(D)") (("" (inst? -8) nil nil)) nil)) nil) ((replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (row const-decl "Vector" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (rows_replace_row 0 (rows_replace_row-1 nil 3615028851 ("" (skeep) (("" (typepred "replace_row(i,v)(D)") (("" (propax) nil nil)) nil)) nil) ((replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (row const-decl "Vector" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (columns_replace_row 0 (columns_replace_row-1 nil 3614960446 ("" (skeep) (("" (assert) nil nil)) nil) nil shostak)) (remove_replace_row 0 (remove_replace_row-1 nil 3614960599 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (split) (("1" (rewrite "rows_remove") (("1" (assert) (("1" (rewrite "rows_remove") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "columns_remove") (("2" (rewrite "columns_remove") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "entry_remove") (("3" (rewrite "entry_remove") (("3" (rewrite "entry_replace_row") (("3" (assert) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (Vector type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (entry_replace_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (entry_remove formula-decl nil matrix_props nil) (columns_remove formula-decl nil matrix_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rows_remove formula-decl nil matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (swap_replace_row_TCC1 0 (swap_replace_row_TCC1-1 nil 3614955316 ("" (skeep) (("" (typepred "swap(i,j)(D)") (("" (assert) nil nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (swap_replace_row subtype "matrix_props.swap(matrix_props.i, matrix_props.j)(matrix_props.D)" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrix_props.v)}"))) (swap_replace_row_TCC2 0 (swap_replace_row_TCC2-1 nil 3614955933 ("" (skeep) (("" (typepred "swap(i,j)(D)") (("" (assert) nil nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (swap_replace_row subtype "matrix_props.swap(matrix_props.i, matrix_props.j)(matrix_props.D)" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrix_props.v)}"))) (swap_replace_row_TCC3 0 (swap_replace_row_TCC3-1 nil 3614955933 ("" (skeep) (("" (typepred "swap(i,j)(D)") (("" (assert) nil nil)) nil)) nil) ((swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (swap_replace_row subtype "matrix_props.swap(matrix_props.i, matrix_props.j)(matrix_props.D)" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrix_props.v)}"))) (swap_replace_row 0 (swap_replace_row-2 "" 3790097626 ("" (skeep) (("" (lift-if) (("" (ground) (("1" (replaces -1) (("1" (assert) (("1" (rewrite "full_matrix_eq") (("1" (skosimp*) (("1" (typepred "replace_row(j, v)(swap(k, j)(D))") (("1" (inst? -8) (("1" (replace -8) (("1" (hide (-1 -2 -3 -4 -5 -6 -7 -8)) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (typepred "swap(k, j)(replace_row(k, v)(D))") (("1" (assert) (("1" (inst? -7) (("1" (replace -7) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (replace -8) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "swap(k, j)(replace_row(k, v)(D))") (("2" (assert) (("2" (inst? -7) (("2" (replace -7) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(k,j)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (replace -8) (("2" (typepred "swap(k,j)(D)") (("2" (inst? -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "full_matrix_eq") (("2" (skosimp*) (("2" (typepred "replace_row(i, v)(swap(i,k)(D))") (("2" (inst? -8) (("2" (replace -8) (("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8)) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (typepred "swap(i, k)(replace_row(k, v)(D))") (("1" (assert) (("1" (inst? -7) (("1" (replace -7) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (replace -8) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (typepred "swap(i,k)(replace_row(k, v)(D))") (("2" (assert) (("2" (inst? -7) (("2" (replace -7) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(i,k)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (replace -8) (("2" (typepred "swap(i,k)(D)") (("2" (inst? -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "full_matrix_eq") (("3" (skosimp*) (("3" (typepred "replace_row(k, v)(swap(i,j)(D))") (("3" (inst? -8) (("3" (replace -8) (("3" (hide (-1 -2 -3 -4 -5 -6 -7 -8)) (("3" (lift-if) (("3" (split +) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (typepred "swap(i, j)(replace_row(k, v)(D))") (("1" (assert) (("1" (inst? -7) (("1" (replace -7) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (replace -8) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (typepred "swap(i,j)(replace_row(k, v)(D))") (("2" (assert) (("2" (inst? -7) (("2" (replace -7) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(i,j)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(i,j)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (replace -8) (("2" (typepred "swap(i,j)(D)") (("2" (inst? -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (Vector type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (swap_replace_row-1 nil 3614955317 ("" (skeep) (("" (lift-if) (("" (ground) (("1" (replaces -1) (("1" (assert) (("1" (rewrite "full_matrix_eq") (("1" (skosimp*) (("1" (typepred "replace_row(j, v)(swap(k, j)(D))") (("1" (inst? -8) (("1" (replace -8) (("1" (hide (-1 -2 -3 -4 -5 -6 -7 -8)) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (typepred "swap(k, j)(replace_row(k, v)(D))") (("1" (assert) (("1" (inst? -7) (("1" (replace -7) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (replace -8) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "swap(k, j)(replace_row(k, v)(D))") (("2" (assert) (("2" (inst? -7) (("2" (replace -7) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(k,j)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (replace -8) (("2" (typepred "swap(k,j)(D)") (("2" (inst? -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "full_matrix_eq") (("2" (skosimp*) (("2" (typepred "replace_row(i, v)(swap(i,k)(D))") (("2" (inst? -8) (("2" (replace -8) (("2" (hide (-1 -2 -3 -4 -5 -6 -7 -8)) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (typepred "swap(i, k)(replace_row(k, v)(D))") (("1" (assert) (("1" (inst? -7) (("1" (replace -7) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (replace -8) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (typepred "swap(i,k)(replace_row(k, v)(D))") (("2" (assert) (("2" (inst? -7) (("2" (replace -7) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(i,k)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (replace -8) (("2" (typepred "swap(i,k)(D)") (("2" (inst? -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "full_matrix_eq") (("3" (skosimp*) (("3" (typepred "replace_row(k, v)(swap(i,j)(D))") (("3" (inst? -8) (("3" (replace -8) (("3" (hide (-1 -2 -3 -4 -5 -6 -7 -8)) (("3" (lift-if) (("3" (split +) (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (typepred "swap(i, j)(replace_row(k, v)(D))") (("1" (assert) (("1" (inst? -7) (("1" (replace -7) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (replace -8) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (typepred "swap(i,j)(replace_row(k, v)(D))") (("2" (assert) (("2" (inst? -7) (("2" (replace -7) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(i,j)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (typepred "replace_row(k, v)(D)") (("1" (inst? -8) (("1" (assert) (("1" (replace -8) (("1" (typepred "swap(i,j)(D)") (("1" (inst? -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "replace_row(k, v)(D)") (("2" (inst? -8) (("2" (assert) (("2" (replace -8) (("2" (typepred "swap(i,j)(D)") (("2" (inst? -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((full_matrix_eq formula-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (FullMatrix type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (entry const-decl "real" matrices nil) (Vector type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil)) shostak)) (row_replace_row 0 (row_replace_row-1 nil 3615027709 ("" (skeep) (("" (typepred "replace_row(i, v)(D)") (("" (assert) (("" (inst - "j") nil nil)) nil)) nil)) nil) ((replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (row const-decl "Vector" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (remove_replace_row_eq 0 (remove_replace_row_eq-1 nil 3615024120 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (split) (("1" (rewrite "rows_remove") (("1" (rewrite "rows_remove") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "columns_remove") (("2" (rewrite "columns_remove") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "entry_remove") (("3" (rewrite "entry_remove") (("3" (rewrite "entry_replace_row") (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (Vector type-eq-decl nil matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (access const-decl "real" matrices nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (entry_replace_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (entry_remove formula-decl nil matrix_props nil) (columns_remove formula-decl nil matrix_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rows_remove formula-decl nil matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (det_replace_row_sum_TCC1 0 (det_replace_row_sum_TCC1-1 nil 3614955316 ("" (skeep) (("" (typepred "v1+v2") (("" (expand "max") (("" (assert) nil nil)) nil)) nil)) nil) ((+ const-decl "VectorN(max(length(v1), length(v2)))" matrices nil) (VectorN type-eq-decl nil matrices nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (det_replace_row_sum subtype "matrix_props.D" "{D | matrices.columns(matrix_props.D) = list_props[real].length((matrices.+)(matrix_props.v1, matrix_props.v2))}"))) (det_replace_row_sum_TCC2 0 (det_replace_row_sum_TCC2-1 nil 3614955316 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (rows const-decl "nat" matrices nil)) nil (det_replace_row_sum subtype "matrix_props.D" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrix_props.v2)}"))) (det_replace_row_sum 0 (det_replace_row_sum-1 nil 3614957047 ("" (case "FORALL (D: PosFullMatrix, i: nat, v1, v2: Vector):
                      length(v1) = length(v2) AND columns(D) = length(v1) IMPLIES
                       det(replace_row(0, v1 + v2)(D)) =
                        det(replace_row(0, v1)(D)) + det(replace_row(0, v2)(D))") (("1" (skeep) (("1" (case "i = 0") (("1" (inst - "D" "0" "v1" "v2") (("1" (assert) nil nil)) nil) ("2" (case "i<rows(D)") (("1" (lemma "det_swap") (("1" (inst - "replace_row(i,v1+v2)(D)" "i" "0") (("1" (assert) (("1" (neg-formula -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "det_swap") (("1" (inst - "replace_row(i,v1)(D)" "i" "0") (("1" (assert) (("1" (neg-formula -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "det_swap") (("1" (inst - "replace_row(i,v2)(D)" "i" "0") (("1" (assert) (("1" (neg-formula -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "swap_replace_row") (("1" (rewrite "swap_replace_row") (("1" (rewrite "swap_replace_row") (("1" (inst - "swap(i,0)(D)" "0" "v1" "v2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "v1+v2") (("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "rows(D)/=columns(D)") (("1" (flatten) (("1" (rewrite "det_size_noteq") (("1" (rewrite "det_size_noteq") (("1" (rewrite "det_size_noteq") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "det" 1 1) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (typepred "replace_row(0,v1+v2)(D)") (("1" (grind) nil nil) ("2" (typepred "v1+v2") (("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split +) (("1" (flatten) (("1" (expand "det" 1 1) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (hide-all-but (-1 -4)) (("1" (typepred "replace_row(0,v1)(D)") (("1" (hide (-1 -2 -7 -8)) (("1" (split -) (("1" (grind) nil nil) ("2" (ground) nil nil)) nil)) nil) ("2" (typepred "D") (("2" (assert) (("2" (split -) (("1" (grind) nil nil) ("2" (split -) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "det" +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "entry_replace_row" +) (("1" (rewrite "entry_replace_row" +) (("1" (rewrite "entry_replace_row" +) (("1" (expand "access" +) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (expand "+" 1) (("1" (expand "add" 1) (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "nth" 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "columns_replace_row" +) (("1" (name "FF" "LAMBDA (k):
                               det(remove(replace_row(0, v1 + v2)(D), 0, k)) *
                                entry(replace_row(0, v1 + v2)(D))(0, k)
                                * (-1) ^ k") (("1" (name "F1" "LAMBDA (k):
                               det(remove(replace_row(0, v1)(D), 0, k)) *
                                entry(replace_row(0, v1)(D))(0, k)
                                * (-1) ^ k") (("1" (name "F2" "LAMBDA (k):
                               det(remove(replace_row(0, v2)(D), 0, k)) *
                                entry(replace_row(0, v2)(D))(0, k)
                                * (-1) ^ k") (("1" (case "FF = F1 + F2") (("1" (replace -4) (("1" (replace -1 +) (("1" (expand "+" 2 1) (("1" (rewrite "sigma_sum" :dir rl) (("1" (case "FORALL (a,b,c,d:real): a=c AND b=d IMPLIES a+b=c+d") (("1" (rewrite -1 2) (("1" (hide (-1 2 3)) (("1" (expand "det" 1) (("1" (lift-if) (("1" (ground) (("1" (hide-all-but (-1 2)) (("1" (typepred "replace_row(0,v1)(D)") (("1" (typepred "replace_row(0,v1+v2)(D)") (("1" (expand "rows") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "det" 1) (("2" (lift-if) (("2" (ground) (("2" (hide-all-but (-1 3)) (("2" (typepred "replace_row(0,v1+v2)(D)") (("2" (typepred "replace_row(0,v2)(D)") (("2" (expand "rows") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (decompose-equality 1) (("2" (case "FORALL (vvv:Vector): length(vvv)=columns(D) IMPLIES remove(replace_row(0, vvv)(D), 0, x!1)=remove(replace_row(0, v2)(D), 0, x!1)") (("1" (hide (-2 -3 -4)) (("1" (expand "FF" 1) (("1" (expand "F1" 1) (("1" (expand "F2" 1) (("1" (expand "+") (("1" (inst-cp - "v1") (("1" (assert) (("1" (replaces -2) (("1" (inst-cp - "add(v1,v2)") (("1" (assert) (("1" (split -2) (("1" (replaces -1) (("1" (assert) (("1" (case "entry(replace_row(0, add(v1, v2))(D))(0, x!1)
                            =
                             entry(replace_row(0, v1)(D))(0, x!1)+
                              entry(replace_row(0, v2)(D))(0, x!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "entry_replace_row" +) (("1" (rewrite "entry_replace_row" +) (("1" (rewrite "entry_replace_row" +) (("1" (lemma "access_sum") (("1" (expand "+" -1) (("1" (rewrite -1) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "add(v1,v2)") (("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "add(v1,v2)") (("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "remove_replace_row" 1) (("2" (rewrite "remove_replace_row" 1) nil nil)) nil)) nil) ("3" (assert) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1+v2") (("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (typepred "v1!1+v2!1") (("4" (expand "max") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (det_size_noteq formula-decl nil matrix_props nil) (v2 skolem-const-decl "Vector" matrix_props nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add def-decl "VectorN(max(length(v1), length(v2)))" matrices nil) (entry_replace_row formula-decl nil matrix_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (columns_replace_row formula-decl nil matrix_props nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[T -> real]" real_fun_ops reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma_sum formula-decl nil sigma reals) (sigma def-decl "real" sigma reals) (remove_replace_row formula-decl nil matrix_props nil) (F1 skolem-const-decl "[nat -> real]" matrix_props nil) (access_sum formula-decl nil matrices nil) (F2 skolem-const-decl "[nat -> real]" matrix_props nil) (FF skolem-const-decl "[nat -> real]" matrix_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (^ const-decl "real" exponentiation nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (neg_neg formula-decl nil extra_tegies nil) (mult_neg formula-decl nil extra_tegies nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (swap_replace_row formula-decl nil matrix_props nil) (det_swap formula-decl nil matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (det def-decl "real" matrix_props nil) (row const-decl "Vector" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (VectorN type-eq-decl nil matrices nil) (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (det_replace_row_scal_TCC1 0 (det_replace_row_scal_TCC1-1 nil 3614962519 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rows const-decl "nat" matrices nil) (* const-decl "VectorN(length(v2))" matrices nil)) nil (det_replace_row_scal subtype "matrix_props.D" "{D | matrices.columns(matrix_props.D) = list_props[real].length(matrices.*(matrix_props.r, matrix_props.v))}"))) (det_replace_row_scal 0 (det_replace_row_scal-2 nil 3615025070 ("" (case "FORALL (D: PosFullMatrix, i: nat, r: real, v: Vector):
                                                  columns(D) = length(v) AND 0 < rows(D) IMPLIES
                                                   det(replace_row(0, r * v)(D)) = r * det(replace_row(0,v)(D))") (("1" (skeep) (("1" (lemma "det_swap") (("1" (inst-cp - "replace_row(i,r*v)(D)" "i" "0") (("1" (inst - "replace_row(i,v)(D)" "i" "0") (("1" (assert) (("1" (case "i = 0") (("1" (hide -2) (("1" (inst - "D" "i" "r" "v") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (neg-formula -1) (("2" (neg-formula -2) (("2" (replace -1 :dir rl) (("2" (replace -2 :dir rl) (("2" (rewrite "swap_replace_row") (("2" (rewrite "swap_replace_row") (("2" (assert) (("2" (inst - "swap(i,0)(D)" "0" "r" "v") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "det") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (typepred "replace_row(0,r*v)(D)") (("2" (typepred "replace_row(0,v)(D)") (("2" (expand "rows") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (rewrite "entry_replace_row") (("4" (rewrite "entry_replace_row") (("4" (rewrite "access_scal") nil nil)) nil)) nil) ("5" (typepred "replace_row(0,r*v)(D)") (("5" (typepred "replace_row(0,v)(D)") (("5" (expand "rows") (("5" (expand "length") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (rewrite "sigma_scal" :dir rl) (("6" (typepred "replace_row(0,r*v)(D)") (("6" (replace -6) (("6" (typepred "replace_row(0,v)(D)") (("6" (replace -6) (("6" (assert) (("6" (rewrite "sigma_eq" +) (("6" (hide 3) (("6" (skosimp*) (("6" (rewrite "remove_replace_row_eq") (("6" (rewrite "remove_replace_row_eq") (("6" (rewrite "entry_replace_row" +) (("6" (rewrite "entry_replace_row" +) (("6" (rewrite "access_scal") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (access_scal formula-decl nil matrices nil) (entry_replace_row formula-decl nil matrix_props nil) (subrange type-eq-decl nil integers nil) (remove_replace_row_eq formula-decl nil matrix_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (rat_exp application-judgement "rat" exponentiation nil) (sigma_eq formula-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_scal formula-decl nil sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (swap_replace_row formula-decl nil matrix_props nil) (swap const-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     FORALL (k: nat, p: nat):
       i < rows(D) AND j < rows(D) IMPLIES
        entry(PFM)(k, p) =
         (IF k = i THEN entry(D)(j, p)
          ELSIF k = j THEN entry(D)(i, p)
          ELSE entry(D)(k, p)
          ENDIF)}" matrix_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (mult_neg formula-decl nil extra_tegies nil) (neg_neg formula-decl nil extra_tegies nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (minus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (det_swap formula-decl nil matrix_props nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (det def-decl "real" matrix_props nil) (row const-decl "Vector" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (VectorN type-eq-decl nil matrices nil) (* const-decl "VectorN(length(v2))" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil) (det_replace_row_scal-1 nil 3614962520 ("" (case "FORALL (D: PosFullMatrix, i: nat, r: real, v: Vector):
               columns(D) = length(v) AND 0 < rows(D) IMPLIES
                det(replace_row(0, r * v)(D)) = r * det(D)") (("1" (skeep) (("1" (lemma "det_swap") (("1" (inst - "replace_row(i,r*v)(D)" "i" "0") (("1" (assert) (("1" (case "i = 0") (("1" (hide -2) (("1" (inst - "D" "i" "r" "v") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (neg-formula -1) (("2" (replace -1 :dir rl) (("2" (rewrite "swap_replace_row") (("2" (assert) (("2" (inst - "swap(i,0)(D)" "0" "r" "v") (("2" (assert) (("2" (replace -2) (("2" (rewrite "det_swap") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "det") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (hide-all-but (-1 2)) (("3" (grind) nil nil)) nil) ("4" (rewrite "entry_replace_row") (("4" (postpone) nil nil)) nil) ("5" (grind) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil) nil shostak)) (replace_row_id_TCC1 0 (replace_row_id_TCC1-1 nil 3615026690 ("" (skeep) (("" (rewrite "length_row") (("" (lift-if) (("" (ground) nil nil)) nil)) nil)) nil) ((length_row formula-decl nil matrix_props nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (replace_row_id subtype "matrix_props.D" "{D_1 | matrices.columns(D_1) = list_props[real].length(matrices.row(matrix_props.D)(matrix_props.i))}"))) (replace_row_id 0 (replace_row_id-1 nil 3615026691 ("" (skeep) (("" (case "i < rows(D)") (("1" (rewrite "full_matrix_eq") (("1" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (rewrite "entry_replace_row") (("1" (expand "entry") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "length_row") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ((PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rows const-decl "nat" matrices nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (entry_replace_row formula-decl nil matrix_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length_row formula-decl nil matrix_props nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (access const-decl "real" matrices nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (row const-decl "Vector" matrices nil) (Vector type-eq-decl nil matrices nil) (full_matrix_eq formula-decl nil matrices nil)) shostak)) (det_replace_row_sum_scal_TCC1 0 (det_replace_row_sum_scal_TCC1-1 nil 3615027140 ("" (skeep) (("" (typepred "row(D)(i) + r*row(D)(j)") (("" (expand "max") (("" (lift-if) (("" (ground) (("1" (replaces -2) (("1" (typepred "r*row(D)(j)") (("1" (replace -2) (("1" (rewrite "length_row") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "length_row") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "VectorN(length(v2))" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (> const-decl "bool" reals nil) (FullMatrix type-eq-decl nil matrices nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (row const-decl "Vector" matrices nil) (Matrix type-eq-decl nil matrices nil) (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices nil) (VectorN type-eq-decl nil matrices nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil matrices nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (length_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (det_replace_row_sum_scal subtype "matrix_props.D" "{D_1 | matrices.columns(D_1) = list_props[real].length((matrices.+)(matrices.row(matrix_props.D)(matrix_props.i), matrices.*(matrix_props.r, matrices.row(matrix_props.D)(matrix_props.j))))}"))) (det_replace_row_sum_scal 0 (det_replace_row_sum_scal-1 nil 3615027141 ("" (skeep) (("" (rewrite "det_replace_row_sum") (("1" (rewrite "det_replace_row_scal") (("1" (lemma "det_rows_eq_0") (("1" (inst - "replace_row(i,row(D)(j))(D)" "i" "j") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (rewrite "replace_row_id") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "row_replace_row") (("1" (rewrite "row_replace_row") (("1" (rewrite "length_row") nil nil)) nil) ("2" (rewrite "length_row") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_row") nil nil)) nil) ("2" (rewrite "length_row") (("2" (assert) (("2" (lemma "length_row") (("2" (inst - "D" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (rewrite "length_row") nil nil)) nil)) nil) ((det_replace_row_sum formula-decl nil matrix_props nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (row const-decl "Vector" matrices nil) (VectorN type-eq-decl nil matrices nil) (* const-decl "VectorN(length(v2))" matrices nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (det_rows_eq_0 formula-decl nil matrix_props nil) (length_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (row_replace_row formula-decl nil matrix_props nil) (TRUE const-decl "bool" booleans nil) (replace_row_id formula-decl nil matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (entry const-decl "real" matrices nil) (access const-decl "real" matrices nil) (replace_row def-decl "{PFM |
   rows(PFM) = rows(D) AND
    columns(PFM) = columns(D) AND
     (FORALL (j: nat):
        row(PFM)(j) = IF j < rows(D) AND j = i THEN v ELSE row(D)(j) ENDIF)
      AND
      (FORALL (j: nat, k: nat):
         entry(PFM)(j, k) =
          IF j < rows(D) AND j = i THEN access(v)(k)
          ELSE entry(D)(j, k)
          ENDIF)}" matrix_props nil) (real_times_real_is_real application-judgement "real" reals nil) (det_replace_row_scal formula-decl nil matrix_props nil)) shostak)) (replace_row_sum_to_scal_TCC1 0 (replace_row_sum_to_scal_TCC1-1 nil 3615888640 ("" (skeep) (("" (rewrite "length_add_vect") (("" (rewrite "length_row") (("" (rewrite "length_row") (("" (expand "max") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length_add_vect formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (row const-decl "Vector" matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length_row formula-decl nil matrix_props nil)) nil (replace_row_sum_to_scal subtype "matrix_props.D" "{D_1 | matrices.columns(D_1) = list_props[real].length((matrices.+)(matrices.row(matrix_props.D)(matrix_props.i), matrices.row(matrix_props.D)(matrix_props.j)))}"))) (replace_row_sum_to_scal_TCC2 0 (replace_row_sum_to_scal_TCC2-1 nil 3615888640 ("" (skeep) (("" (rewrite "length_add_vect") (("" (rewrite "length_scal_vect") (("" (rewrite "length_row") (("" (rewrite "length_row") (("" (expand "max") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length_add_vect formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (row const-decl "Vector" matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (VectorN type-eq-decl nil matrices nil) (* const-decl "VectorN(length(v2))" matrices nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (length_row formula-decl nil matrix_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_scal_vect formula-decl nil matrices nil)) nil (replace_row_sum_to_scal subtype "matrix_props.D" "{D_1 | matrices.columns(D_1) = list_props[real].length((matrices.+)(matrices.row(matrix_props.D)(matrix_props.i), matrices.*(1, matrices.row(matrix_props.D)(matrix_props.j))))}"))) (replace_row_sum_to_scal 0 (replace_row_sum_to_scal-1 nil 3615888641 ("" (assert) (("" (skeep) (("" (lemma "vect_scal_1") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Vector type-eq-decl nil matrices nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (row const-decl "Vector" matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vect_scal_1 formula-decl nil matrices nil)) shostak)) (det_Id 0 (det_Id-1 nil 3615046987 ("" (case "FORALL (n: nat): det(Id(n+1)) = 1") (("1" (skeep) (("1" (inst - "pn-1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "det" +) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (typepred "Id(2+j)") (("1" (expand "rows") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq_one_arg2") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (split -) (("1" (replaces -1) (("1" (rewrite "remove_Id_0_0") (("1" (replaces -1) (("1" (assert) (("1" (rewrite "entry_Id") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp*) (("2" (rewrite "entry_Id") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_eq_one_arg2 formula-decl nil sigma reals) (remove_Id_0_0 formula-decl nil matrix_props nil) (expt def-decl "real" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (entry_Id formula-decl nil matrices nil) (TRUE const-decl "bool" booleans nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (subrange type-eq-decl nil integers nil) (rat_exp application-judgement "rat" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (access const-decl "real" matrices nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (det def-decl "real" matrix_props nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (SquareMatrix type-eq-decl nil matrices nil) (entry const-decl "real" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (MatrixMN type-eq-decl nil matrices nil) (Vector type-eq-decl nil matrices nil) (* const-decl "real" matrices nil) (row const-decl "Vector" matrices nil) (VectorN type-eq-decl nil matrices nil) (col def-decl "VectorN(rows(M))" matrices nil) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices nil) (Id const-decl "{M: SquareMatrix(pm) |
   (FORALL (i: nat, j: nat):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (det_first_column_zero 0 (det_first_column_zero-1 nil 3615634578 ("" (case "FORALL (D: PosFullMatrix,kz:nat): kz+1=rows(D) AND
               (FORALL (i): i < rows(D) IMPLIES entry(D)(i, 0) = 0) IMPLIES
                det(D) = 0") (("1" (skeep) (("1" (inst - "D" "rows(D)-1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kz") (("1" (skeep) (("1" (assert) (("1" (expand "det" 1) (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (inst - "0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (skeep) (("2" (assert) (("2" (expand "det" +) (("2" (lift-if) (("2" (ground) (("2" (rewrite "sigma_restrict_eq_0" 2) (("2" (hide 3) (("2" (skeep) (("2" (typepred "i") (("2" (case "i = 0") (("1" (inst -7 "0") (("1" (assert) nil nil)) nil) ("2" (inst - "remove(D,0,i)") (("1" (assert) (("1" (split +) (("1" (rewrite "rows_remove") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (rewrite "entry_remove") (("2" (inst - "1+i!1") (("2" (assert) (("2" (rewrite "rows_remove") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "rows_remove") (("2" (assert) (("2" (rewrite "columns_remove") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (D skolem-const-decl "PosFullMatrix" matrix_props nil) (i skolem-const-decl "subrange(0, columns(D) - 1)" matrix_props nil) (rows_remove formula-decl nil matrix_props nil) (entry_remove formula-decl nil matrix_props nil) (columns_remove formula-decl nil matrix_props nil) (remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (rat_exp application-judgement "rat" exponentiation nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (- const-decl "[numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (det def-decl "real" matrix_props nil)) shostak)) (remove_transpose_TCC1 0 (remove_transpose_TCC1-1 nil 3615811126 ("" (skeep) (("" (rewrite "rows_remove") (("" (rewrite "columns_remove") (("" (assert) nil nil)) nil)) nil)) nil) ((rows_remove formula-decl nil matrix_props nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (PosFullMatrix type-eq-decl nil matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (columns_remove formula-decl nil matrix_props nil)) nil (remove_transpose subtype "matrix_props.remove(matrix_props.D, matrix_props.j, matrix_props.i)" "PosFullMatrix"))) (remove_transpose 0 (remove_transpose-1 nil 3615811127 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (case "NOT ( (rows(remove(transpose(D), i, j)) = rows(transpose(remove(D, j, i)))
        AND
        columns(remove(transpose(D), i, j)) =
         columns(transpose(remove(D, j, i)))))") (("1" (hide 2) (("1" (split) (("1" (rewrite "rows_remove") (("1" (rewrite "rows_transpose") (("1" (rewrite "rows_transpose") (("1" (rewrite "columns_remove") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "columns_remove") (("2" (assert) (("2" (rewrite "rows_transpose") (("2" (assert) (("2" (rewrite "columns_transpose") (("2" (rewrite "columns_transpose") (("2" (rewrite "rows_remove") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (skosimp*) (("2" (rewrite "entry_remove") (("2" (rewrite "rows_transpose" +) (("2" (rewrite "columns_transpose" +) (("2" (assert) (("2" (rewrite "entry_transpose" +) (("2" (rewrite "entry_transpose" +) (("2" (rewrite "entry_remove" +) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (rewrite "rows_remove" +) (("3" (rewrite "columns_remove" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (rewrite "rows_remove" +) (("4" (rewrite "columns_remove" +) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_posfullmatrix application-judgement "FullMatrix" matrix_props nil) (full_matrix_eq formula-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (rows const-decl "nat" matrices nil) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (entry const-decl "real" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "{N |
   (rows(M) > 1 AND columns(M) > 1 IMPLIES
     (rows(N) = rows(M) - 1 AND columns(N) = columns(M) - 1))
    AND
    (FORALL (m: nat, n: nat):
       LET newm = IF m >= i OR i >= rows(M) THEN m + 1 ELSE m ENDIF,
           newn = IF n >= j OR j >= columns(M) THEN n + 1 ELSE n ENDIF
         IN entry(N)(m, n) = entry(M)(newm, newn))}" matrix_props nil) (PosFullMatrix type-eq-decl nil matrices nil) (transpose const-decl "PosFullMatrix" matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (entry_transpose formula-decl nil matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (entry_remove formula-decl nil matrix_props nil) (columns_transpose formula-decl nil matrices nil) (rows_remove formula-decl nil matrix_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (columns_remove formula-decl nil matrix_props nil) (rows_transpose formula-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)))
