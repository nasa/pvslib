(cross_metric_cont
 (IMP_cross_metric_spaces_TCC1 0
  (IMP_cross_metric_spaces_TCC1-1 nil 3459693207
   ("" (lemma "fullset_metric_space1") (("" (propax) nil nil)) nil)
   ((fullset_metric_space1 formula-decl nil cross_metric_cont nil)) nil
   (IMP_cross_metric_spaces assuming
    "cross_metric_spaces[cross_metric_cont.T1, cross_metric_cont.d1, cross_metric_cont.T2, cross_metric_cont.d2].cross_metric_spaces"
    "fullset_metric_space1: ASSUMPTION metric_spaces_def[cross_metric_spaces.T1, cross_metric_spaces.d1].metric_space?(sets[cross_metric_spaces.T1].fullset)")))
 (IMP_cross_metric_spaces_TCC2 0
  (IMP_cross_metric_spaces_TCC2-1 nil 3459693207
   ("" (lemma "fullset_metric_space2") (("" (propax) nil nil)) nil)
   ((fullset_metric_space2 formula-decl nil cross_metric_cont nil)) nil
   (IMP_cross_metric_spaces assuming
    "cross_metric_spaces[cross_metric_cont.T1, cross_metric_cont.d1, cross_metric_cont.T2, cross_metric_cont.d2].cross_metric_spaces"
    "fullset_metric_space2: ASSUMPTION metric_spaces_def[cross_metric_spaces.T2, cross_metric_spaces.d2].metric_space?(sets[cross_metric_spaces.T2].fullset)")))
 (IMP_continuity_ms_def_TCC1 0
  (IMP_continuity_ms_def_TCC1-1 nil 3459693207
   ("" (lemma "product_is_metric") (("" (propax) nil nil)) nil)
   ((product_is_metric formula-decl nil cross_metric_spaces nil)
    (T1 formal-nonempty-type-decl nil cross_metric_cont nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (d1 formal-const-decl "[T1, T1 -> nnreal]" cross_metric_cont nil)
    (T2 formal-nonempty-type-decl nil cross_metric_cont nil)
    (d2 formal-const-decl "[T2, T2 -> nnreal]" cross_metric_cont nil))
   nil
   (IMP_continuity_ms_def assuming
    "continuity_ms_def[[cross_metric_cont.T1, cross_metric_cont.T2], cross_metric_spaces[cross_metric_cont.T1, cross_metric_cont.d1, cross_metric_cont.T2, cross_metric_cont.d2].d, cross_metric_cont.T3, cross_metric_cont.d3].continuity_ms_def"
    "fullset_metric_space1: ASSUMPTION metric_spaces_def[continuity_ms_def.T1, continuity_ms_def.d1].metric_space?(sets[continuity_ms_def.T1].fullset)")))
 (IMP_continuity_ms_def_TCC2 0
  (IMP_continuity_ms_def_TCC2-1 nil 3459693207
   ("" (lemma "fullset_metric_space3") (("" (propax) nil nil)) nil)
   ((fullset_metric_space3 formula-decl nil cross_metric_cont nil)) nil
   (IMP_continuity_ms_def assuming
    "continuity_ms_def[[cross_metric_cont.T1, cross_metric_cont.T2], cross_metric_spaces[cross_metric_cont.T1, cross_metric_cont.d1, cross_metric_cont.T2, cross_metric_cont.d2].d, cross_metric_cont.T3, cross_metric_cont.d3].continuity_ms_def"
    "fullset_metric_space2: ASSUMPTION metric_spaces_def[continuity_ms_def.T2, continuity_ms_def.d2].metric_space?(sets[continuity_ms_def.T2].fullset)")))
 (product_cont_equiv 0
  (product_cont_equiv-1 nil 3459694386
   ("" (skosimp*)
    (("" (prop)
      (("1" (expand "continuous?")
        (("1" (expand "continuous_at?")
          (("1" (skosimp*)
            (("1" (inst - "x!1")
              (("1" (inst - "epsilon!1/4")
                (("1" (skosimp*)
                  (("1" (expand "member")
                    (("1" (expand "ball")
                      (("1" (inst + "delta!1/4")
                        (("1" (skosimp*)
                          (("1" (inst - "y!1")
                            (("1" (prop)
                              (("1" (cross-mult -1) (("1" (grind) nil nil))
                                nil)
                               ("2" (expand "d") (("2" (grind) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "continuous?")
        (("2" (expand "continuous_at?")
          (("2" (expand "member")
            (("2" (expand "ball")
              (("2" (skosimp*)
                (("2" (typepred "x!1")
                  (("2" (inst - "x!1" "epsilon!1")
                    (("2" (skosimp*)
                      (("2" (inst + "delta!1")
                        (("2" (skosimp*)
                          (("2" (inst - "y!1")
                            (("2" (expand "d") (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (continuous? const-decl "bool" continuity_ms_def nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (d3 formal-const-decl "[T3, T3 -> nnreal]" cross_metric_cont nil)
    (nnreal type-eq-decl nil real_types nil)
    (T3 formal-nonempty-type-decl nil cross_metric_cont nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (d const-decl "nnreal" cross_metric_spaces nil)
    (ball const-decl "set[T]" metric_spaces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T2 formal-nonempty-type-decl nil cross_metric_cont nil)
    (T1 formal-nonempty-type-decl nil cross_metric_cont nil)
    (continuous_at? const-decl "bool" continuity_ms_def nil))
   shostak))
 (product_cont_product_subset 0
  (product_cont_product_subset-2 "" 3790090734
   ("" (skosimp*)
    (("" (prop)
      (("1" (skosimp*)
        (("1" (lemma "product_cont_equiv")
          (("1" (assert)
            (("1" (inst - "fullset[[(X!1),(Y!1)]]" "f!1")
              (("1" (prop)
                (("1" (typepred "x!1")
                  (("1" (inst - "(x!1,y!1)" "epsilon!1")
                    (("1" (skosimp*)
                      (("1" (inst + "delta!1")
                        (("1" (skosimp*)
                          (("1" (typepred "z!1")
                            (("1" (typepred "w!1")
                              (("1" (inst - "(z!1,w!1)")
                                (("1" (prop) nil nil)
                                 ("2" (expand "extend")
                                  (("2" (expand "fullset")
                                    (("2" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "extend")
                      (("2" (expand "fullset") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "continuous?")
        (("2" (skosimp*)
          (("2" (expand "continuous_at?")
            (("2" (expand "member")
              (("2" (expand "ball")
                (("2" (skosimp*)
                  (("2" (typepred "x!1")
                    (("2" (inst - "x!1`1" "x!1`2" "epsilon !1")
                      (("1" (skosimp*)
                        (("1" (inst + "delta!1")
                          (("1" (skosimp*)
                            (("1" (typepred "y!1")
                              (("1" (expand "d")
                                (("1" (inst - "y!1`1" "y!1`2")
                                  (("1" (prop)
                                    (("1" (case "x!1 = (x!1`1,x!1`2)")
                                      (("1"
                                        (replace -1 1)
                                        (("1"
                                          (case "y!1 = (y!1`1,y!1`2)")
                                          (("1"
                                            (replace -1 1)
                                            (("1" (propax) nil nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil)
                                   ("2" (assert) (("2" (grind) nil nil)) nil)
                                   ("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil) ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((continuous? const-decl "bool" continuity_ms_def nil)
    (continuous_at? const-decl "bool" continuity_ms_def nil)
    (ball const-decl "set[T]" metric_spaces nil)
    (x!1 skolem-const-decl
     "(extend[[T1, T2], [(X!1), (Y!1)], bool, FALSE](fullset[[(X!1), (Y!1)]]))"
     cross_metric_cont nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (y!1 skolem-const-decl
     "(extend[[T1, T2], [(X!1), (Y!1)], bool, FALSE](fullset[[(X!1), (Y!1)]]))"
     cross_metric_cont nil)
    (d const-decl "nnreal" cross_metric_spaces nil)
    (member const-decl "bool" sets nil)
    (z!1 skolem-const-decl "(X!1)" cross_metric_cont nil)
    (w!1 skolem-const-decl "(Y!1)" cross_metric_cont nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (X!1 skolem-const-decl "set[T1]" cross_metric_cont nil)
    (Y!1 skolem-const-decl "set[T2]" cross_metric_cont nil)
    (x!1 skolem-const-decl "(X!1)" cross_metric_cont nil)
    (y!1 skolem-const-decl "(Y!1)" cross_metric_cont nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T3 formal-nonempty-type-decl nil cross_metric_cont nil)
    (fullset const-decl "set" sets nil) (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T2 formal-nonempty-type-decl nil cross_metric_cont nil)
    (T1 formal-nonempty-type-decl nil cross_metric_cont nil)
    (product_cont_equiv formula-decl nil cross_metric_cont nil))
   shostak)
  (product_cont_product_subset-1 nil 3459695893
   ("" (skosimp*)
    (("" (prop)
      (("1" (skosimp*)
        (("1" (lemma "product_cont_equiv")
          (("1" (assert)
            (("1" (inst - "fullset[[(X!1),(Y!1)]]" "f!1")
              (("1" (prop)
                (("1" (typepred "x!1")
                  (("1" (inst - "(x!1,y!1)" "epsilon!1")
                    (("1" (skosimp*)
                      (("1" (inst + "delta!1")
                        (("1" (skosimp*)
                          (("1" (typepred "z!1")
                            (("1" (typepred "w!1")
                              (("1" (inst - "(z!1,w!1)")
                                (("1" (prop) nil nil)
                                 ("2" (expand "extend")
                                  (("2" (expand "fullset")
                                    (("2" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "extend")
                      (("2" (expand "fullset") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "continuous?")
        (("2" (skosimp*)
          (("2" (expand "continuous_at?")
            (("2" (expand "member")
              (("2" (expand "ball")
                (("2" (skosimp*)
                  (("2" (typepred "x!1")
                    (("2" (inst - "x!1`1" "x!1`2" "epsilon !1")
                      (("1" (skosimp*)
                        (("1" (inst + "delta!1")
                          (("1" (skosimp*)
                            (("1" (typepred "y!1")
                              (("1" (expand "d")
                                (("1" (inst - "y!1`1" "y!1`2")
                                  (("1" (prop)
                                    (("1" (case "x!1 = (x!1`1,x!1`2)")
                                      (("1"
                                        (replace -1 1)
                                        (("1"
                                          (case "y!1 = (y!1`1,y!1`2)")
                                          (("1"
                                            (replace -1 1)
                                            (("1"
                                              (expand "restrict")
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "restrict")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil)
                                     ("2" (expand "restrict")
                                      (("2" (grind) nil nil)) nil)
                                     ("3" (expand "restrict")
                                      (("3" (grind) nil nil)) nil))
                                    nil)
                                   ("2" (assert) (("2" (grind) nil nil)) nil)
                                   ("3" (expand "restrict")
                                    (("3" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil) ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((d const-decl "nnreal" cross_metric_spaces nil)
    (ball const-decl "set[T]" metric_spaces nil))
   shostak))
 (one_variable_unif_cont_sequence 0
  (one_variable_unif_cont_sequence-2 "" 3790090735
   ("" (skosimp*)
    (("" (prop)
      (("1" (expand "uniformly_continuous_in_first?")
        (("1" (skosimp*)
          (("1" (inst 2 "epsilon!1/2")
            (("1" (inst 2 "y1!1")
              (("1"
                (inst 2
                 "(LAMBDA (n: posint): Let pointy = choose({point: [T1,T1,T2] | X!1(point`1) AND X!1(point`2) AND Y!1(point`3)
                AND d1(point`1, point`2) < 1 / n
                AND d2(y1!1, point`3) < 1 / n
                AND d3(f!1(point`1, y1!1), f!1(point`2, point`3)) >
                     epsilon!1 / 2}) in pointy)")
                (("1" (skosimp*)
                  (("1" (prop)
                    (("1" (assert) nil nil) ("2" (assert) nil nil)
                     ("3" (assert) nil nil) ("4" (assert) nil nil)
                     ("5" (assert) nil nil) ("6" (assert) nil nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (expand "nonempty?")
                    (("2" (expand "empty?")
                      (("2" (expand "member")
                        (("2" (inst + "1/(n!1+1)")
                          (("2" (skosimp*)
                            (("2" (inst - "(x1!1,x2!1,y2!1)")
                              (("2" (prop)
                                (("1" (assert) nil nil) ("2" (assert) nil nil)
                                 ("3" (assert) nil nil)
                                 ("4" (case "1/(n!1+1) < 1/n!1")
                                  (("1" (assert) nil nil)
                                   ("2" (cross-mult +) nil nil))
                                  nil)
                                 ("5" (case "1/(n!1+1) < 1/n!1")
                                  (("1" (assert) nil nil)
                                   ("2" (cross-mult +) nil nil))
                                  nil)
                                 ("6" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "uniformly_continuous_in_first?")
        (("2" (skosimp*)
          (("2" (inst -2 "y!1" "epsilon!1/2")
            (("2" (skosimp*)
              (("2" (lemma "archimedean")
                (("2" (inst - "delta!1")
                  (("2" (skosimp*)
                    (("2" (inst - "n!1")
                      (("2" (prop)
                        (("2"
                          (inst - "seq!1(n!1)`1" "seq!1(n!1)`2"
                           "seq!1(n!1)`3")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((archimedean formula-decl nil real_props nil)
    (n!1 skolem-const-decl "posnat" cross_metric_cont nil)
    (seq!1 skolem-const-decl "[posint -> [T1, T1, T2]]" cross_metric_cont nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (uniformly_continuous_in_first? const-decl "bool" cross_metric_cont nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (empty? const-decl "bool" sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div2 formula-decl nil real_props nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (choose const-decl "(p)" sets nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (T1 formal-nonempty-type-decl nil cross_metric_cont nil)
    (nonempty? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (X!1 skolem-const-decl "set[T1]" cross_metric_cont nil)
    (Y!1 skolem-const-decl "set[T2]" cross_metric_cont nil)
    (< const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (d1 formal-const-decl "[T1, T1 -> nnreal]" cross_metric_cont nil)
    (d2 formal-const-decl "[T2, T2 -> nnreal]" cross_metric_cont nil)
    (y1!1 skolem-const-decl "(Y!1)" cross_metric_cont nil)
    (T3 formal-nonempty-type-decl nil cross_metric_cont nil)
    (d3 formal-const-decl "[T3, T3 -> nnreal]" cross_metric_cont nil)
    (f!1 skolem-const-decl "[[T1, T2] -> T3]" cross_metric_cont nil)
    (epsilon!1 skolem-const-decl "posreal" cross_metric_cont nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (T2 formal-nonempty-type-decl nil cross_metric_cont nil)
    (set type-eq-decl nil sets nil))
   shostak)
  (one_variable_unif_cont_sequence-1 nil 3460215379
   ("" (skosimp*)
    (("" (prop)
      (("1" (expand "uniformly_continuous_in_first?")
        (("1" (skosimp*)
          (("1" (inst 2 "epsilon!1/2")
            (("1" (inst 2 "y1!1")
              (("1"
                (inst 2
                 "(LAMBDA (n: posint): Let pointy = choose({point: [T1,T1,T2] | X!1(point`1) AND X!1(point`2) AND Y!1(point`3)
                AND d1(point`1, point`2) < 1 / n
                AND d2(y1!1, point`3) < 1 / n
                AND d3(f!1(point`1, y1!1), f!1(point`2, point`3)) >
                     epsilon!1 / 2}) in pointy)")
                (("1" (skosimp*)
                  (("1" (prop)
                    (("1" (assert) nil nil) ("2" (assert) nil nil)
                     ("3" (assert) nil nil) ("4" (assert) nil nil)
                     ("5" (assert) nil nil) ("6" (assert) nil nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (expand "nonempty?")
                    (("2" (expand "empty?")
                      (("2" (expand "member")
                        (("2" (inst + "1/(n!1+1)")
                          (("2" (skosimp*)
                            (("2" (inst - "(x1!1,x2!1,y2!1)")
                              (("2" (prop)
                                (("1" (assert) nil nil) ("2" (assert) nil nil)
                                 ("3" (assert) nil nil)
                                 ("4" (case "1/(n!1+1) < 1/n!1")
                                  (("1" (assert) nil nil)
                                   ("2" (cross-mult +)
                                    (("2" (assert) nil nil)) nil))
                                  nil)
                                 ("5" (case "1/(n!1+1) < 1/n!1")
                                  (("1" (assert) nil nil)
                                   ("2" (cross-mult +)
                                    (("2" (assert) nil nil)) nil))
                                  nil)
                                 ("6" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "uniformly_continuous_in_first?")
        (("2" (skosimp*)
          (("2" (inst -2 "y!1" "epsilon!1/2")
            (("2" (skosimp*)
              (("2" (lemma "archimedean")
                (("2" (inst - "delta!1")
                  (("2" (skosimp*)
                    (("2" (inst - "n!1")
                      (("2" (prop)
                        (("2"
                          (inst - "seq!1(n!1)`1" "seq!1(n!1)`2"
                           "seq!1(n!1)`3")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (curried_is_uniform 0
  (curried_is_uniform-1 nil 3460387624
   ("" (skosimp*)
    (("" (expand "uniformly_continuous?")
      (("" (expand "uniformly_continuous_in_first?")
        (("" (skosimp*)
          (("" (inst - "y!1" "epsilon!1")
            (("" (skosimp*)
              (("" (inst + "delta!1")
                (("" (skosimp*)
                  (("" (inst - "x!1" "p!1" "y!1")
                    (("" (assert)
                      (("" (lemma "fullset_metric_space2")
                        (("" (expand "metric_space?")
                          (("" (expand "space_zero?")
                            (("" (prop)
                              (("" (inst - "y!1" "y!1")
                                (("1" (assert) nil nil)
                                 ("2" (expand "fullset")
                                  (("2" (propax) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((uniformly_continuous? const-decl "bool" uniform_continuity nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (metric_space? const-decl "bool" metric_spaces_def nil)
    (fullset const-decl "set" sets nil)
    (Y!1 skolem-const-decl "set[T2]" cross_metric_cont nil)
    (y!1 skolem-const-decl "(Y!1)" cross_metric_cont nil)
    (space_zero? const-decl "bool" metric_spaces_def nil)
    (fullset_metric_space2 formula-decl nil cross_metric_cont nil)
    (T1 formal-nonempty-type-decl nil cross_metric_cont nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T2 formal-nonempty-type-decl nil cross_metric_cont nil)
    (uniformly_continuous_in_first? const-decl "bool" cross_metric_cont nil))
   shostak)))

