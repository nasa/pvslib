(partitions_scaf
 (gen_seq_lem_TCC1 0
  (gen_seq_lem_TCC1-1 nil 3280594050 ("" (grind) nil nil)
   ((|#| const-decl "finite_sequence[T]" partitions_scaf nil)) shostak
   (gen_seq_lem subtype "0" "below[length( #(x))]")))
 (gen_seq_lem 0
  (gen_seq_lem-1 nil 3280833619
   ("" (skosimp*)
    (("" (assert) (("" (expand "#") (("" (propax) nil nil)) nil)) nil)) nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil))
   shostak))
 (part2set_prep_TCC1 0
  (part2set_prep_TCC1-2 "" 3790090705
   ("" (lemma "connected_domain") (("" (skosimp*) nil nil)) nil)
   ((connected_domain formula-decl nil partitions_scaf nil)) shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))
  (part2set_prep_TCC1-1 nil 3281096981
   ("" (lemma "connected_domain")
    (("" (skosimp*) (("" (expand "connected?") (("" (propax) nil nil)) nil))
      nil))
    nil)
   nil shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (part2set_prep_TCC2 0
  (part2set_prep_TCC2-2 "" 3790090705
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil partitions_scaf nil)) shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))
  (part2set_prep_TCC2-1 nil 3281096981
   ("" (skosimp*)
    (("" (lemma "not_one_element")
      (("" (expand "not_one_element?") (("" (propax) nil nil)) nil)) nil))
    nil)
   nil shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (part2set_prep 0
  (part2set_prep-1 nil 3281096964
   ("" (skosimp*)
    (("" (lemma "is_finite_surj[T]")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (inst + "length(P!1)" "seq(P!1)")
              (("1" (expand "surjective?")
                (("1" (skosimp*)
                  (("1" (typepred "y!1") (("1" (propax) nil nil)) nil)) nil))
                nil)
               ("2" (skosimp*) (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite_surj formula-decl nil finite_sets nil)
    (surjective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "T" partitions_scaf nil)
    (b!1 skolem-const-decl "{x: T | a!1 < x}" partitions_scaf nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil))
 (part2set_TCC1 0
  (part2set_TCC1-1 nil 3281096981
   ("" (skosimp*)
    (("" (lemma "is_finite_surj[T]")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (inst + "length(P!1)" "seq(P!1)")
              (("1" (expand "surjective?")
                (("1" (skosimp*)
                  (("1" (typepred "y!1") (("1" (propax) nil nil)) nil)) nil))
                nil)
               ("2" (skosimp*) (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite_surj formula-decl nil finite_sets nil)
    (surjective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "T" partitions_scaf nil)
    (b!1 skolem-const-decl "{x: T | a!1 < x}" partitions_scaf nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak
   (part2set subtype
    "{s: partitions_scaf.T | EXISTS (kk: naturalnumbers.below(length(partitions_scaf.P))): seq(partitions_scaf.P)(kk) = s}"
    "finite_set[T]")))
 (part2set_lem 0
  (part2set_lem-1 nil 3281181911
   ("" (skosimp*)
    (("" (expand "part2set")
      (("" (assert)
        (("" (prop)
          (("1" (inst + "0") (("1" (assert) nil nil)) nil)
           ("2" (inst + "length(P!1)-1") (("2" (assert) nil nil)) nil)
           ("3" (skosimp*) (("3" (inst?) nil nil)) nil)
           ("4" (skosimp*)
            (("4" (typepred "x!1")
              (("4" (expand "part2set")
                (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((part2set const-decl "finite_set[T]" partitions_scaf nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil))
   shostak))
 (card_part2set 0
  (card_part2set-1 nil 3281117875
   ("" (skosimp*)
    (("" (expand "part2set")
      (("" (typepred "P!1")
        (("" (lemma "card_subset[T]")
          (("" (inst - "add(a!1,singleton[T](b!1))" "_")
            (("" (inst?)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (case-replace "card(add(a!1,singleton[T](b!1))) = 2")
                    (("1" (assert) nil nil)
                     ("2" (hide 2)
                      (("2" (rewrite "card_add")
                        (("2" (rewrite "card_singleton")
                          (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (expand "subset?")
                      (("2" (skosimp*)
                        (("2" (assert)
                          (("2" (typepred "x!1")
                            (("2" (expand "add")
                              (("2" (expand "member")
                                (("2" (expand "singleton")
                                  (("2" (split -2)
                                    (("1" (inst + "0")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (inst + "length(P!1)-1")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "part2set_prep")
                  (("2" (assert) (("2" (inst?) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((part2set const-decl "finite_set[T]" partitions_scaf nil)
    (card_subset formula-decl nil finite_sets nil)
    (part2set_prep formula-decl nil partitions_scaf nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (card_add formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (card_singleton formula-decl nil finite_sets nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" partitions_scaf nil)
    (b!1 skolem-const-decl "{x: T | a!1 < x}" partitions_scaf nil)
    (a!1 skolem-const-decl "T" partitions_scaf nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set[T]"
     partitions_scaf nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[T]"
     partitions_scaf nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[real]"
     integral_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil))
   nil))
 (minmax_part2set_TCC1 0
  (minmax_part2set_TCC1-1 nil 3281118218
   ("" (skosimp*)
    (("" (lemma "card_part2set")
      (("" (inst?)
        (("" (lemma "card_empty?[T]")
          (("" (inst?) (("" (ground) (("" (assert) nil nil)) nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((card_part2set formula-decl nil partitions_scaf nil)
    (card_empty? formula-decl nil finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak
   (minmax_part2set subtype
    "partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)"
    "non_empty_finite_set[T]")))
 (minmax_part2set 0
  (minmax_part2set-2 "" 3790090707
   ("" (skosimp*)
    (("" (prop)
      (("1" (lemma "min_lem[T,<=]")
        (("1" (inst?)
          (("1" (assert)
            (("1" (hide 2)
              (("1" (expand "part2set")
                (("1" (prop)
                  (("1" (inst + "0") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2" (inst - "a!1" "b!1" "P!1" "0" "kk!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "max_lem[T,<=]")
        (("2" (inst?)
          (("2" (assert)
            (("2" (hide 2)
              (("2" (expand "part2set")
                (("2" (prop)
                  (("1" (inst + "length(P!1)-1") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2"
                              (inst - "a!1" "b!1" "P!1" "kk!1"
                               "length(P!1)-1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_lem formula-decl nil finite_sets_minmax finite_sets)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (parts_order formula-decl nil integral_def nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil))
   shostak)
  (minmax_part2set-1 nil 3281118004
   ("" (skosimp*)
    (("" (prop)
      (("1" (lemma "min_lem[T,<=]")
        (("1" (inst?)
          (("1" (assert)
            (("1" (hide 2)
              (("1" (expand "part2set")
                (("1" (prop)
                  (("1" (inst + "0") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2" (inst - "a!1" "b!1" "P!1" "0" "kk!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (lemma "card_empty?[T]")
              (("2" (inst?)
                (("2" (assert)
                  (("2" (lemma "card_part2set")
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "max_lem[T,<=]")
        (("2" (inst?)
          (("1" (assert)
            (("1" (hide 2)
              (("1" (expand "part2set")
                (("1" (prop)
                  (("1" (inst + "length(P!1)-1") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2"
                              (inst - "a!1" "b!1" "P!1" "kk!1"
                               "length(P!1)-1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "card_empty?[T]")
            (("2" (inst?)
              (("2" (assert)
                (("2" (lemma "card_part2set")
                  (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil)
    (parts_order formula-decl nil integral_def nil)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (max_lem formula-decl nil finite_sets_minmax finite_sets))
   nil))
 (part2set_TCC2 0
  (part2set_TCC2-1 nil 3281096981
   ("" (skosimp*)
    (("" (lemma "card_part2set") (("" (assert) (("" (inst?) nil nil)) nil))
      nil))
    nil)
   ((card_part2set formula-decl nil partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (part2set_ subtype
    "partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)"
    "{s: finite_sets[T].finite_set | reals.>(finite_sets[T].card(s), 1)}")))
 (set2seq_TCC1 0
  (set2seq_TCC1-1 nil 3280842302
   ("" (skosimp*) (("" (expand "nonempty?") (("" (propax) nil nil)) nil)) nil)
   ((nonempty? const-decl "bool" sets nil)) shostak
   (set2seq subtype "partitions_scaf.S" "(sets[T].nonempty?)")))
 (set2seq_TCC2 0
  (set2seq_TCC2-1 nil 3280842320
   ("" (skosimp*) (("" (rewrite "card_rest[T]") (("" (assert) nil nil)) nil))
    nil)
   ((card_rest formula-decl nil finite_sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (set2seq termination
    "partitions_scaf.set2seq(sets[T].rest(partitions_scaf.S))" "nil")))
 (set2seq_length 0
  (set2seq_length-1 nil 3281098906
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (expand "set2seq")
      (("1" (expand "#")
        (("1" (expand "o ")
          (("1" (ground)
            (("1" (case "empty?[T](emptyset[T])")
              (("1" (assert)
                (("1" (rewrite "card_emptyset[T]")
                  (("1" (assert)
                    (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "set2seq" 1)
        (("2" (expand "o ")
          (("2" (expand "#")
            (("2" (assert)
              (("2" (rewrite "card_rest") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (empty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)
    (card_emptyset formula-decl nil finite_sets nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (member const-decl "bool" sets nil)
    (O const-decl "finseq" finite_sequences nil)
    (finite_emptyset name-judgement "finite_set[T]" partitions_scaf nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (card_rest formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   shostak))
 (set2seq_lem 0
  (set2seq_lem-2 "" 3790090708
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (expand "set2seq")
        (("2" (case "empty?[T](emptyset[T])")
          (("1" (assert)
            (("1" (typepred "ii!1")
              (("1" (expand "set2seq")
                (("1" (expand "empty_seq") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (expand "set2seq" 1)
        (("3" (expand "o ")
          (("3" (assert)
            (("3" (expand "#")
              (("3" (ground)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (lemma "rest_member[T]")
                      (("3" (expand "member")
                        (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" partitions_scaf nil)
    (empty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rest_member formula-decl nil sets_lemmas nil)
    (rest const-decl "set" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (O const-decl "finseq" finite_sequences nil))
   shostak)
  (set2seq_lem-1 nil 3280846807
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (expand "set2seq")
        (("2" (case "empty?[T](emptyset[T])")
          (("1" (assert)
            (("1" (typepred "ii!1")
              (("1" (expand "set2seq")
                (("1" (expand "empty_seq") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (expand "set2seq" 1)
        (("3" (expand "o ")
          (("3" (assert)
            (("3" (expand "#")
              (("3" (ground)
                (("3" (inst?)
                  (("1" (assert)
                    (("1" (lemma "rest_member[T]")
                      (("1" (expand "member")
                        (("1" (inst?)
                          (("1" (assert) nil nil)
                           ("2" (assert)
                            (("2" (hide 3)
                              (("2" (typepred "ii!1")
                                (("2" (assert)
                                  (("2" (expand "set2seq")
                                    (("2" (expand "o ")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "#")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (typepred "ii!1")
                      (("2" (expand "set2seq")
                        (("2" (expand "#")
                          (("2" (expand "o")
                            (("2" (assert)
                              (("2" (lift-if)
                                (("2" (ground)
                                  (("1" (expand "set2seq")
                                    (("1" (assert) nil nil)) nil)
                                   ("2" (expand "set2seq")
                                    (("2" (assert)
                                      (("2"
                                        (expand "o")
                                        (("2"
                                          (expand "#")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((non_empty_finite_set type-eq-decl nil finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil))
   shostak))
 (set2seq_exists 0
  (set2seq_exists-1 nil 3281099741
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (skosimp*) (("1" (assert) (("1" (inst?) nil nil)) nil)) nil)
     ("2" (skosimp*)
      (("2" (typepred "x!1")
        (("2" (expand "emptyset") (("2" (propax) nil nil)) nil)) nil))
      nil)
     ("3" (skosimp*)
      (("3" (expand "set2seq" 1)
        (("3" (expand "o " 1)
          (("3" (expand "#")
            (("3" (assert)
              (("3" (inst?)
                (("3" (assert)
                  (("3" (lemma "choose_rest_or[T]")
                    (("3" (inst?)
                      (("3" (inst?)
                        (("3" (expand "member")
                          (("3" (split -1)
                            (("1" (assert)
                              (("1" (skosimp*)
                                (("1" (typepred "ii!1")
                                  (("1" (inst + "ii!1+1")
                                    (("1" (assert) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst + "0")
                              (("1" (assert) nil nil)
                               ("2" (expand "set2seq") (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (choose_rest_or formula-decl nil sets_lemmas nil)
    (rest const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (SS!1 skolem-const-decl "non_empty_finite_set[T]" partitions_scaf nil)
    (ii!1 skolem-const-decl "below(length(set2seq(rest(SS!1))))"
     partitions_scaf nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (finite_remove application-judgement "finite_set[T]" partitions_scaf nil)
    (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (O const-decl "finseq" finite_sequences nil))
   shostak))
 (minmax_set2seq_TCC1 0
  (minmax_set2seq_TCC1-1 nil 3281118238
   ("" (skosimp*) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_length formula-decl nil partitions_scaf nil))
   shostak
   (minmax_set2seq subtype "partitions_scaf.set2seq(partitions_scaf.S)"
    "ne_seqs[T]")))
 (minmax_set2seq_TCC2 0
  (minmax_set2seq_TCC2-1 nil 3281118238
   ("" (skosimp*)
    (("" (lemma "card_empty?[T]")
      (("" (inst?) (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil))
    nil)
   ((T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (card_empty? formula-decl nil finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak
   (minmax_set2seq subtype "partitions_scaf.S" "non_empty_finite_set[T]")))
 (minmax_set2seq 0
  (minmax_set2seq-2 "" 3790090710
   ("" (skosimp*)
    (("" (prop)
      (("1" (typepred "min(set2seq(S!1))")
        (("1" (skosimp*)
          (("1" (replace -3 * rl)
            (("1"
              (typepred
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1" (lemma "set2seq_lem")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (inst - "jj!1")
                      (("1" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("1" (assert)
                          (("1" (lemma "set2seq_exists")
                            (("1"
                              (inst - "S!1"
                               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("1" (assert)
                                (("1" (skosimp*)
                                  (("1" (replace -1 * rl)
                                    (("1" (inst -7 "ii!1")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "max(set2seq(S!1))")
        (("2" (skosimp*)
          (("2" (replace -3 * rl)
            (("2"
              (typepred
               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("2" (lemma "set2seq_lem")
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (inst - "jj!1")
                      (("2" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("2" (assert)
                          (("2" (lemma "set2seq_exists")
                            (("2"
                              (inst - "S!1"
                               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("2" (assert)
                                (("2" (skosimp*)
                                  (("2" (replace -1 * rl)
                                    (("2" (inst -7 "ii!1")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max const-decl "{t: T |
   (FORALL (ii: dom(s)): seq(s)(ii) <= t) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" max_seq structures)
    (dom type-eq-decl nil max_seq structures)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (min const-decl "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" min_seq structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (dom type-eq-decl nil min_seq structures) (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil) (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ne_seqs type-eq-decl nil seqs structures)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (set2seq_lem formula-decl nil partitions_scaf nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_exists formula-decl nil partitions_scaf nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil))
   shostak)
  (minmax_set2seq-1 nil 3281118135
   ("" (skosimp*)
    (("" (prop)
      (("1" (typepred "min(set2seq(S!1))")
        (("1" (skosimp*)
          (("1" (replace -3 * rl)
            (("1"
              (typepred
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1" (lemma "set2seq_lem")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (inst - "jj!1")
                      (("1" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("1" (assert)
                          (("1" (lemma "set2seq_exists")
                            (("1"
                              (inst - "S!1"
                               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("1" (assert)
                                (("1" (skosimp*)
                                  (("1" (replace -1 * rl)
                                    (("1" (inst -7 "ii!1")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert)
                                (("2" (lemma "card_empty?[T]")
                                  (("2" (inst?) (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) (("2" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil)
       ("2" (typepred "max(set2seq(S!1))")
        (("1" (skosimp*)
          (("1" (replace -3 * rl)
            (("1"
              (typepred
               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1" (lemma "set2seq_lem")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (inst - "jj!1")
                      (("1" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("1" (assert)
                          (("1" (lemma "set2seq_exists")
                            (("1"
                              (inst - "S!1"
                               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("1" (assert)
                                (("1" (skosimp*)
                                  (("1" (replace -1 * rl)
                                    (("1" (inst -7 "ii!1")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert)
                                (("2" (lemma "card_empty?[T]")
                                  (("2" (inst?) (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) (("2" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((non_empty_finite_set type-eq-decl nil finite_sets nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (ne_seqs type-eq-decl nil seqs structures)
    (dom type-eq-decl nil min_seq structures)
    (min const-decl "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" min_seq structures)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (dom type-eq-decl nil max_seq structures)
    (max const-decl "{t: T |
   (FORALL (ii: dom(s)): seq(s)(ii) <= t) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" max_seq structures))
   nil))
 (set2seq_neq_TCC1 0
  (set2seq_neq_TCC1-1 nil 3281092893
   ("" (skosimp*)
    (("" (assert) (("" (typepred "ii!1") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil))
   shostak (set2seq_neq subtype "partitions_scaf.ii" "below[SP`length]")))
 (set2seq_neq_TCC2 0
  (set2seq_neq_TCC2-1 nil 3281094287
   ("" (skosimp*)
    (("" (assert) (("" (typepred "jj!1") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil))
   shostak (set2seq_neq subtype "partitions_scaf.jj" "below[SP`length]")))
 (set2seq_neq 0
  (set2seq_neq-1 nil 3281100425
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (typepred "ii!1")
        (("2" (typepred "jj!1")
          (("2" (assert)
            (("2" (rewrite "card_emptyset") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (typepred "ii!1")
        (("3" (typepred "jj!1")
          (("3" (assert)
            (("3" (expand "set2seq" -4)
              (("3" (expand "#")
                (("3" (expand "o")
                  (("3" (case "ii!1 < 1")
                    (("1" (assert)
                      (("1" (lemma "set2seq_lem")
                        (("1" (inst?)
                          (("1" (assert)
                            (("1" (inst - "jj!1-1")
                              (("1" (assert)
                                (("1" (lemma "choose_not_member[T]")
                                  (("1" (inst?) (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (case "jj!1 < 1")
                      (("1" (assert)
                        (("1" (lemma "set2seq_lem")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (inst - "ii!1-1")
                                (("1" (lemma "choose_not_member[T]")
                                  (("1" (inst?) (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (inst -3 "ii!1-1" "jj!1-1")
                          (("1" (assert) nil nil)
                           ("2" (rewrite "card_rest") (("2" (assert) nil nil))
                            nil)
                           ("3" (rewrite "card_rest") (("3" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp*)
      (("4" (assert)
        (("4" (skosimp*)
          (("4" (hide 2)
            (("4" (typepred "ii!1")
              (("4" (typepred "jj!1") (("4" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp*)
      (("5" (assert)
        (("5" (skosimp*)
          (("5" (assert)
            (("5" (typepred "ii!1")
              (("5" (typepred "jj!1") (("5" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil naturalnumbers nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (seqs type-eq-decl nil sort_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" partitions_scaf nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (sort_length formula-decl nil sort_seq structures)
    (card_emptyset formula-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (SS!1 skolem-const-decl "non_empty_finite_set[T]" partitions_scaf nil)
    (ii!1 skolem-const-decl "below(length(sort(set2seq(SS!1))))"
     partitions_scaf nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (jj!1 skolem-const-decl "below(length(sort(set2seq(SS!1))))"
     partitions_scaf nil)
    (card_rest formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (rest const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (choose_not_member formula-decl nil sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (set2seq_lem formula-decl nil partitions_scaf nil)
    (O const-decl "finseq" finite_sequences nil))
   shostak))
 (sort_set2seq_lem 0
  (sort_set2seq_lem-1 nil 3281101427
   ("" (skosimp*)
    (("" (assert)
      (("" (skosimp*)
        (("" (lemma "sort_seq_in")
          (("" (inst?)
            (("1" (expand "in?")
              (("1" (skosimp*)
                (("1" (replace -1)
                  (("1" (hide -1)
                    (("1" (lemma "set2seq_lem")
                      (("1" (inst?)
                        (("1" (assert) (("1" (inst?) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (typepred "ii!1") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sort_seq_in formula-decl nil sort_seq structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ii!1 skolem-const-decl "below(length(sort(set2seq(S!1))))"
     partitions_scaf nil)
    (below type-eq-decl nil naturalnumbers nil)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (set2seq_lem formula-decl nil partitions_scaf nil)
    (in? const-decl "bool" seqs structures)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sort_length formula-decl nil sort_seq structures))
   shostak))
 (set2part_prep_TCC1 0
  (set2part_prep_TCC1-1 nil 3280844789
   ("" (skosimp*)
    (("" (assert)
      (("" (typepred "S!1")
        (("" (lemma "card_empty?[T]")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((card_empty? formula-decl nil finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil))
   shostak
   (set2part_prep subtype "partitions_scaf.S" "non_empty_finite_set[T]")))
 (set2part_prep 0
  (set2part_prep-2 "" 3790090712
   ("" (skosimp*)
    (("" (typepred "S!1")
      ((""
        (typepred "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
        ((""
          (typepred
           "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
          (("" (assert)
            ((""
              (name-replace "MINS"
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              ((""
                (name-replace "MAXS"
                 "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                ((""
                  (case "EXISTS (xx,yy: T): S!1(xx) AND S!1(yy) and xx /= yy")
                  (("1" (skosimp*)
                    (("1" (inst-cp -5 "xx!1")
                      (("1" (inst-cp -5 "yy!1")
                        (("1" (inst-cp -10 "yy!1")
                          (("1" (inst-cp -10 "xx!1") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide -1 -2 -3 -4 -5 -6 2)
                    (("2" (case "card(S!1) = 0")
                      (("1" (assert) nil nil)
                       ("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (expand "empty?")
                              (("2" (skosimp*)
                                (("2" (expand "member")
                                  (("2" (case "card(remove(x!1,S!1)) = 0")
                                    (("1" (rewrite "card_remove")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (lemma "card_empty?[T]")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (ground)
                                            (("2"
                                              (expand "empty?")
                                              (("2"
                                                (skosimp*)
                                                (("2"
                                                  (expand "member")
                                                  (("2"
                                                    (expand "remove")
                                                    (("2"
                                                      (expand "member")
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (inst + "x!1" "x!2")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (member const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[T]" partitions_scaf nil)
    (remove const-decl "set" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (card_empty? formula-decl nil finite_sets nil)
    (/= const-decl "boolean" notequal nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets))
   shostak)
  (set2part_prep-1 nil 3280844160
   ("" (skosimp*)
    (("" (typepred "S!1")
      ((""
        (typepred "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
        (("1"
          (typepred
           "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
          (("1" (assert)
            (("1"
              (name-replace "MINS"
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1"
                (name-replace "MAXS"
                 "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                (("1"
                  (case "EXISTS (xx,yy: T): S!1(xx) AND S!1(yy) and xx /= yy")
                  (("1" (skosimp*)
                    (("1" (inst-cp -5 "xx!1")
                      (("1" (inst-cp -5 "yy!1")
                        (("1" (inst-cp -10 "yy!1")
                          (("1" (inst-cp -10 "xx!1") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide -1 -2 -3 -4 -5 -6 2)
                    (("2" (case "card(S!1) = 0")
                      (("1" (assert) nil nil)
                       ("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (expand "empty?")
                              (("2" (skosimp*)
                                (("2" (expand "member")
                                  (("2" (case "card(remove(x!1,S!1)) = 0")
                                    (("1" (rewrite "card_remove")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (lemma "card_empty?[T]")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (ground)
                                            (("2"
                                              (expand "empty?")
                                              (("2"
                                                (skosimp*)
                                                (("2"
                                                  (expand "member")
                                                  (("2"
                                                    (expand "remove")
                                                    (("2"
                                                      (expand "member")
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (inst + "x!1" "x!2")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "card_empty?[T]")
          (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (card_remove formula-decl nil finite_sets nil)
    (card_empty? formula-decl nil finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets))
   shostak))
 (sort_set2seq_neq_TCC1 0
  (sort_set2seq_neq_TCC1-1 nil 3281094366
   ("" (skosimp*) (("" (typepred "ii!1") (("" (assert) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures))
   shostak
   (sort_set2seq_neq subtype "partitions_scaf.ii" "below[SP`length]")))
 (sort_set2seq_neq_TCC2 0
  (sort_set2seq_neq_TCC2-1 nil 3281094380
   ("" (skosimp*) (("" (typepred "jj!1") (("" (assert) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures))
   shostak
   (sort_set2seq_neq subtype "partitions_scaf.jj" "below[SP`length]")))
 (sort_set2seq_neq 0
  (sort_set2seq_neq-1 nil 3281106057
   ("" (skosimp*)
    (("" (assert)
      (("" (skosimp*)
        (("" (typepred "sort(set2seq(S!1))")
          (("" (hide -2)
            (("" (lemma "perm_symmetric[T,<=]")
              (("" (inst - "set2seq(S!1)" "sort(set2seq(S!1))")
                (("" (assert)
                  (("" (hide -2)
                    (("" (expand "permutation?")
                      (("" (skosimp*)
                        (("" (typepred "ii!1")
                          (("" (typepred "jj!1")
                            (("" (inst-cp - "ii!1")
                              (("" (inst - "jj!1")
                                (("" (replace -4)
                                  (("" (hide -4)
                                    (("" (replace -4)
                                      ((""
                                        (hide -4)
                                        ((""
                                          (lemma "set2seq_neq")
                                          ((""
                                            (inst?)
                                            ((""
                                              (assert)
                                              ((""
                                                (inst
                                                 -
                                                 "f!1(ii!1)"
                                                 "f!1(jj!1)")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand "bijective?")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           "injective?")
                                                          (("1"
                                                            (inst
                                                             -
                                                             "ii!1"
                                                             "jj!1")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (typepred "f!1(jj!1)")
                                                  (("2" (assert) nil nil))
                                                  nil)
                                                 ("3"
                                                  (typepred "f!1(ii!1)")
                                                  (("3" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (seqs type-eq-decl nil sort_seq structures)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (perm_symmetric formula-decl nil permutations_seq structures)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (set2seq_neq formula-decl nil partitions_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (sort_length formula-decl nil sort_seq structures)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (f!1 skolem-const-decl
     "[below(length(sort(set2seq(S!1)))) -> below(length(set2seq(S!1)))]"
     partitions_scaf nil)
    (ii!1 skolem-const-decl "below(length(sort(sort(set2seq(S!1)))))"
     partitions_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (jj!1 skolem-const-decl "below(length(sort(sort(set2seq(S!1)))))"
     partitions_scaf nil)
    (injective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (set2part_TCC1 0
  (set2part_TCC1-1 nil 3280842341
   ("" (skosimp*) (("" (rewrite "set2part_prep") nil nil)) nil)
   ((set2part_prep formula-decl nil partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil))
   shostak
   (set2part subtype
    "finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].max(partitions_scaf.S)"
    "{x: partitions_scaf.T | reals.<(finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].min(partitions_scaf.S), x)}")))
 (set2part_TCC2 0
  (set2part_TCC2-2 "" 3790090714
   ("" (skosimp*)
    (("" (prop)
      (("1" (skosimp*)
        (("1" (lemma "min_lem[T,<=]")
          (("1" (inst?)
            (("1" (inst - "min(S!1)")
              (("1" (assert)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (hide -1)
                      (("1" (lemma "max_lem[T,<=]")
                        (("1" (inst?)
                          (("1" (inst - "max(S!1)")
                            (("1" (assert)
                              (("1" (inst?)
                                (("1" (hide 2)
                                  (("1" (lemma "sort_set2seq_lem")
                                    (("1" (assert) (("1" (inst?) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (lemma "sort_set2seq_lem")
                      (("2" (inst?)
                        (("2" (assert) (("2" (inst?) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (lemma "card_empty?[T]")
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil)
       ("3" (assert)
        (("3" (rewrite "sort_seq_min")
          (("3" (typepred "min(set2seq(S!1))")
            (("3" (lemma "minmax_set2seq")
              (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("4" (typepred "S!1")
        (("4" (lemma "sort_seq_max")
          (("4" (inst?)
            (("4" (assert)
              (("4" (lemma "minmax_set2seq")
                (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skosimp*)
        (("5" (lemma "sort_seq_lem")
          (("5" (inst?)
            (("5" (flatten)
              (("5" (hide -1)
                (("5" (expand "increasing?")
                  (("5" (inst - "ii!1" "ii!1+1")
                    (("5" (assert)
                      (("5" (typepred "ii!1")
                        (("5" (assert)
                          (("5" (lemma "sort_set2seq_neq")
                            (("5" (inst?)
                              (("5" (assert)
                                (("5" (inst - "ii!1" "ii!1+1")
                                  (("5" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sort_set2seq_neq formula-decl nil partitions_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (sort_seq_lem formula-decl nil sort_seq structures)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sort_seq_max formula-decl nil sort_seq_lems structures)
    (min const-decl "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" min_seq structures)
    (dom type-eq-decl nil min_seq structures)
    (minmax_set2seq formula-decl nil partitions_scaf nil)
    (ne_seqs type-eq-decl nil seqs structures)
    (sort_seq_min formula-decl nil sort_seq_lems structures)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (card_empty? formula-decl nil finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (x1!1 skolem-const-decl "below[sort(set2seq(S!1))`length]" partitions_scaf
     nil)
    (< const-decl "bool" reals nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil)
    (sort_set2seq_lem formula-decl nil partitions_scaf nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (max_lem formula-decl nil finite_sets_minmax finite_sets)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (empty? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (S!1 skolem-const-decl "{s: finite_set[T] | card[T](s) > 1}"
     partitions_scaf nil)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil))
   shostak
   (set2part subtype
    "sort_seq[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].sort(partitions_scaf.set2seq(partitions_scaf.S))"
    "integral_def[T].partition(finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].min(partitions_scaf.S), finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].max(partitions_scaf.S))"))
  (set2part_TCC2-1 nil 3280842717
   ("" (skosimp*)
    (("" (prop)
      (("1" (skosimp*)
        (("1" (lemma "min_lem[T,<=]")
          (("1" (inst?)
            (("1" (inst - "min(S!1)")
              (("1" (assert)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (hide -1)
                      (("1" (lemma "max_lem[T,<=]")
                        (("1" (inst?)
                          (("1" (inst - "max(S!1)")
                            (("1" (assert)
                              (("1" (inst?)
                                (("1" (hide 2)
                                  (("1" (lemma "sort_set2seq_lem")
                                    (("1" (assert) (("1" (inst?) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "S!1")
                              (("2" (lemma "card_empty?[T]")
                                (("2" (inst?) (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lemma "card_empty?[T]")
                            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (lemma "sort_set2seq_lem")
                      (("2" (inst?)
                        (("2" (assert) (("2" (inst?) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (lemma "card_empty?[T]")
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil)
       ("3" (assert)
        (("3" (rewrite "sort_seq_min")
          (("3" (typepred "min(set2seq(S!1))")
            (("3" (lemma "minmax_set2seq")
              (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("4" (typepred "S!1")
        (("4" (lemma "sort_seq_max")
          (("4" (inst?)
            (("4" (assert)
              (("4" (lemma "minmax_set2seq")
                (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skosimp*)
        (("5" (lemma "sort_seq_lem")
          (("5" (inst?)
            (("5" (flatten)
              (("5" (hide -1)
                (("5" (expand "increasing?")
                  (("5" (inst - "ii!1" "ii!1+1")
                    (("5" (assert)
                      (("5" (typepred "ii!1")
                        (("5" (assert)
                          (("5" (lemma "sort_set2seq_neq")
                            (("5" (inst?)
                              (("5" (assert)
                                (("5" (inst - "ii!1" "ii!1+1")
                                  (("5" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((min_lem formula-decl nil finite_sets_minmax finite_sets)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (seqs type-eq-decl nil sort_seq structures)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (max_lem formula-decl nil finite_sets_minmax finite_sets)
    (card_empty? formula-decl nil finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (sort_length formula-decl nil sort_seq structures)
    (sort_seq_min formula-decl nil sort_seq_lems structures)
    (ne_seqs type-eq-decl nil seqs structures)
    (dom type-eq-decl nil min_seq structures)
    (min const-decl "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" min_seq structures)
    (sort_seq_max formula-decl nil sort_seq_lems structures)
    (sort_seq_lem formula-decl nil sort_seq structures))
   shostak
   (set2part subtype
    "sort_seq[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].sort(partitions_scaf.set2seq(partitions_scaf.S))"
    "integral_def[T].partition(finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].min(partitions_scaf.S), finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].max(partitions_scaf.S))")))
 (set2part_length 0
  (set2part_length-1 nil 3281119415
   ("" (skosimp*)
    (("" (assert) (("" (expand "set2part") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil))
   shostak))
 (set2part_lem 0
  (set2part_lem-2 "" 3790090714
   ("" (skosimp*)
    (("" (expand "set2part")
      (("" (lemma "sort_set2seq_lem")
        (("" (inst?)
          (("" (assert)
            (("" (inst?) (("" (typepred "ii!1") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (below type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (closed_interval type-eq-decl nil intervals_real reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (ii!1 skolem-const-decl "below(length(set2part(S!1)))" partitions_scaf
     nil)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (set2part_length formula-decl nil partitions_scaf nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_set2seq_lem formula-decl nil partitions_scaf nil))
   shostak)
  (set2part_lem-1 nil 3281118998
   ("" (skosimp*)
    (("" (expand "set2part")
      (("" (lemma "sort_set2seq_lem")
        (("" (inst?)
          (("" (assert)
            (("" (inst?)
              (("" (typepred "ii!1")
                (("" (assert)
                  (("" (expand "set2part") (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (sort_length formula-decl nil sort_seq structures)
    (seqs type-eq-decl nil sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil))
   shostak))
 (set2part_ix 0
  (set2part_ix-1 nil 3281207584
   ("" (skosimp*)
    (("" (expand "set2part")
      (("" (lemma "set2seq_exists")
        (("" (inst?)
          (("" (assert)
            (("" (assert)
              (("" (skosimp*)
                (("" (lemma "sort_seq_in?")
                  (("" (inst?)
                    (("" (inst -1 "x!1")
                      (("" (flatten)
                        (("" (hide -2)
                          (("" (split -1)
                            (("1" (expand "in?")
                              (("1" (skosimp*)
                                (("1" (inst?)
                                  (("1" (assert)
                                    (("1" (typepred "ii!2")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "in?")
                              (("2" (hide 2)
                                (("2" (inst?) (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (sort_seq_in? formula-decl nil sort_seq structures)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (sort_length formula-decl nil sort_seq structures)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (ii!2 skolem-const-decl "below(length(sort(set2seq(S!1))))"
     partitions_scaf nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set2part_length formula-decl nil partitions_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (in? const-decl "bool" seqs structures)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_exists formula-decl nil partitions_scaf nil))
   shostak))
 (insert_TCC1 0
  (insert_TCC1-2 "" 3790090715
   ("" (skosimp*)
    (("" (rewrite "card_add[T]")
      (("" (assert)
        (("" (lemma "card_part2set")
          (("" (inst?) (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((card_add formula-decl nil finite_sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (nil application-judgement "{s: finite_set[T] | card(s) > 1}"
     partitions_scaf nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (card_part2set formula-decl nil partitions_scaf nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (insert subtype
    "sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P))"
    "{s: finite_sets[T].finite_set | reals.>(finite_sets[T].card(s), 1)}"))
  (insert_TCC1-1 nil 3281116766
   ("" (skosimp*)
    (("" (rewrite "card_add[T]")
      (("" (assert)
        (("" (lemma "card_part2set")
          (("" (inst?)
            (("" (assert) (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((card_add formula-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil)
    (open_interval type-eq-decl nil intervals_real reals))
   shostak
   (insert subtype
    "sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P))"
    "{s: finite_sets[T].finite_set | reals.>(finite_sets[T].card(s), 1)}")))
 (insert_TCC2 0
  (insert_TCC2-2 "" 3790090718
   ("" (skosimp*)
    (("" (case "card(add[T](xx!1, part2set(a!1, b!1, P!1))) > 1")
      (("1" (prop)
        (("1" (skosimp*)
          (("1" (assert)
            (("1" (lemma "minmax_part2set")
              (("1" (inst?)
                (("1" (flatten)
                  (("1" (case "NOT empty?[T](part2set(a!1, b!1, P!1))")
                    (("1" (auto-rewrite-theory "sets[T]")
                      (("1" (prop)
                        (("1" (lemma "min_lem[T,<=]")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (lemma "set2part_lem")
                                (("1" (inst?)
                                  (("1" (assert) (("1" (inst?) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (lemma "max_lem[T,<=]")
                            (("2" (inst?)
                              (("2" (assert)
                                (("2" (lemma "set2part_lem")
                                  (("2" (inst?)
                                    (("2" (assert)
                                      (("2"
                                        (skosimp*)
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but -1)
                      (("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (lemma "card_part2set")
                            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil)
         ("3" (assert)
          (("3" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("3" (assert)
              (("3" (replace -2)
                (("3" (hide -)
                  (("3" (lemma "min_lem[T,<=]")
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (hide 2)
                          (("3" (expand "add")
                            (("3" (expand "member")
                              (("3" (lemma "part2set_lem")
                                (("3" (inst?)
                                  (("3" (flatten)
                                    (("3" (assert)
                                      (("3"
                                        (skosimp*)
                                        (("3"
                                          (typepred "x!1")
                                          (("3"
                                            (expand "add")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (expand "part2set")
                                                (("3"
                                                  (skosimp*)
                                                  (("3"
                                                    (lemma "parts_order[T]")
                                                    (("3"
                                                      (inst
                                                       -
                                                       "a!1"
                                                       "b!1"
                                                       "P!1"
                                                       "0"
                                                       "kk!1")
                                                      (("3" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("4" (assert)
              (("4" (replace -3)
                (("4" (hide -)
                  (("4" (lemma "max_lem[T,<=]")
                    (("4" (inst?)
                      (("4" (assert)
                        (("4" (hide 2)
                          (("4" (expand "add")
                            (("4" (expand "member")
                              (("4" (lemma "part2set_lem")
                                (("4" (inst?)
                                  (("4" (flatten)
                                    (("4" (assert)
                                      (("4"
                                        (skosimp*)
                                        (("4"
                                          (hide -3)
                                          (("4"
                                            (typepred "x!1")
                                            (("4"
                                              (expand "add")
                                              (("4"
                                                (assert)
                                                (("4"
                                                  (inst?)
                                                  (("4" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (skosimp*)
          (("5" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("5" (hide -1 -2 -3) (("5" (inst?) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rewrite "card_add")
          (("2" (lemma "card_part2set")
            (("2" (inst?) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (card_add formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (set2part_length formula-decl nil partitions_scaf nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (parts_order formula-decl nil integral_def nil)
    (part2set_lem formula-decl nil partitions_scaf nil)
    (minmax_part2set formula-decl nil partitions_scaf nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (max_lem formula-decl nil finite_sets_minmax finite_sets)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil)
    (set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set2part_lem formula-decl nil partitions_scaf nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (card_empty? formula-decl nil finite_sets nil)
    (card_part2set formula-decl nil partitions_scaf nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "{s: finite_set[T] | card(s) > 1}"
     partitions_scaf nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[T]"
     partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil))
   shostak
   (insert subtype
    "partitions_scaf.set2part(sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)))"
    "integral_def[T].partition(partitions_scaf.a, partitions_scaf.b)"))
  (insert_TCC2-1 nil 3281116767
   ("" (skosimp*)
    (("" (case "card(add[T](xx!1, part2set(a!1, b!1, P!1))) > 1")
      (("1" (prop)
        (("1" (skosimp*)
          (("1" (assert)
            (("1" (lemma "minmax_part2set")
              (("1" (inst?)
                (("1" (flatten)
                  (("1" (case "NOT empty?[T](part2set(a!1, b!1, P!1))")
                    (("1" (auto-rewrite-theory "sets[T]")
                      (("1" (prop)
                        (("1" (lemma "min_lem[T,<=]")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (lemma "set2part_lem")
                                (("1" (inst?)
                                  (("1" (assert) (("1" (inst?) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "empty?")
                              (("2" (skosimp*)
                                (("2" (assert) (("2" (inst?) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (lemma "max_lem[T,<=]")
                            (("2" (inst?)
                              (("1" (assert)
                                (("1" (lemma "set2part_lem")
                                  (("1" (inst?)
                                    (("1" (assert)
                                      (("1"
                                        (skosimp*)
                                        (("1" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (expand "empty?")
                                (("2" (skosimp*)
                                  (("2" (assert) (("2" (inst?) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but -1)
                      (("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (lemma "card_part2set")
                            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil)
         ("3" (assert)
          (("3" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("3" (assert)
              (("3" (replace -2)
                (("3" (hide -)
                  (("3" (lemma "min_lem[T,<=]")
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (hide 2)
                          (("3" (expand "add")
                            (("3" (expand "member")
                              (("3" (lemma "part2set_lem")
                                (("3" (inst?)
                                  (("3" (flatten)
                                    (("3" (assert)
                                      (("3"
                                        (skosimp*)
                                        (("3"
                                          (typepred "x!1")
                                          (("3"
                                            (expand "add")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (expand "part2set")
                                                (("3"
                                                  (skosimp*)
                                                  (("3"
                                                    (lemma "parts_order[T]")
                                                    (("3"
                                                      (inst
                                                       -
                                                       "a!1"
                                                       "b!1"
                                                       "P!1"
                                                       "0"
                                                       "kk!1")
                                                      (("3" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("4" (assert)
              (("4" (replace -3)
                (("4" (hide -)
                  (("4" (lemma "max_lem[T,<=]")
                    (("4" (inst?)
                      (("4" (assert)
                        (("4" (hide 2)
                          (("4" (expand "add")
                            (("4" (expand "member")
                              (("4" (lemma "part2set_lem")
                                (("4" (inst?)
                                  (("4" (flatten)
                                    (("4" (assert)
                                      (("4"
                                        (skosimp*)
                                        (("4"
                                          (hide -3)
                                          (("4"
                                            (typepred "x!1")
                                            (("4"
                                              (expand "add")
                                              (("4"
                                                (assert)
                                                (("4"
                                                  (inst?)
                                                  (("4" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (skosimp*)
          (("5" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("1" (hide -1 -2 -3) (("1" (inst?) nil nil)) nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rewrite "card_add")
          (("2" (lemma "card_part2set")
            (("2" (inst?) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((partition type-eq-decl nil integral_def nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (open_interval type-eq-decl nil intervals_real reals)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (parts_order formula-decl nil integral_def nil)
    (card_empty? formula-decl nil finite_sets nil)
    (max_lem formula-decl nil finite_sets_minmax finite_sets)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (card_add formula-decl nil finite_sets nil))
   shostak
   (insert subtype
    "partitions_scaf.set2part(sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)))"
    "integral_def[T].partition(partitions_scaf.a, partitions_scaf.b)"))))

