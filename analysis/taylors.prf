(taylors (deriv_domain 0 (deriv_domain-2 nil 3472399633 ("" (lemma "connected_deriv_domain[T]") (("" (lemma not_one_element) (("" (lemma "connected_domain") (("" (assert) nil nil)) nil)) nil)) nil) ((not_one_element formula-decl nil taylors nil) (connected_domain formula-decl nil taylors nil) (connected_deriv_domain formula-decl nil deriv_domain_def nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil)) nil) (deriv_domain-1 nil 3471607174 ("" (skosimp*) (("" (lemma "connected_domain") (("" (lemma "connected_deriv_domain[T]") (("1" (replace -2) (("1" (inst?) nil nil)) nil) ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) nil nil)) (sigma_derivable_TCC1 0 (sigma_derivable_TCC1-2 "" 3790090844 ("" (skosimp*) (("" (lemma "deriv_domain") (("" (propax) nil nil)) nil)) nil) ((deriv_domain formula-decl nil taylors nil)) shostak (sigma_derivable assuming "derivatives[T].derivatives" "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")) (sigma_derivable_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (lemma "deriv_domain") (("" (inst?) nil nil)) nil)) nil) nil nil (sigma_derivable assuming "derivatives[T].derivatives" "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?"))) (sigma_derivable_TCC2 0 (sigma_derivable_TCC2-1 nil 3255192119 ("" (skolem!) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil)) nil) ((not_one_element formula-decl nil taylors nil)) nil (sigma_derivable assuming "derivatives[T].derivatives" "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))) (sigma_derivable 0 (sigma_derivable-1 nil 3255192119 ("" (induct "n" 1) (("1" (skosimp*) (("1" (expand "sigma") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1) (("2" (case-replace "(LAMBDA aa: g!1(aa, 1 + j!1) + sigma(0, j!1, LAMBDA m: g!1(aa, m))) = (LAMBDA aa: g!1(aa, 1 + j!1))  + (LAMBDA aa: sigma(0, j!1, LAMBDA m: g!1(aa, m)))") (("1" (hide -1) (("1" (inst - "g!1") (("1" (split -1) (("1" (inst - "1+j!1") (("1" (lemma "sum_derivable_fun[T]" ("f1" "LAMBDA aa: g!1(aa, 1 + j!1)" "f2" "LAMBDA aa: sigma(0, j!1, LAMBDA m: g!1(aa, m))")) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "+
") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (derivable? const-decl "bool" derivatives nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (nat_induction formula-decl nil naturalnumbers nil) (sigma_0_neg formula-decl nil sigma_nat reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sum_derivable_fun formula-decl nil derivatives nil)) nil)) (tay1_TCC1 0 (tay1_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (tay1 subtype "taylors.n" "{i: integers.int | booleans.OR(((number_fields.-)(taylors.bb, taylors.x)) /= 0, reals.>=(i, 0))}"))) (tay1 0 (tay1-2 "" 3790090845 ("" (skosimp*) (("" (case "derivable?[T](LAMBDA x: (bb!1 - x) ^ n!1)") (("1" (lemma "scal_derivable_fun[T]" ("f" "LAMBDA x: (bb!1 - x) ^ n!1" "b" "1/ factorial(n!1)")) (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "n!1=0") (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt") (("1" (lemma "const_derivable_fun[T]" ("b" "1")) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "const_derivable_fun[T]" ("b" "bb!1")) (("2" (lemma "identity_derivable_fun[T]") (("2" (expand "I") (("2" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): bb!1" "f2" "LAMBDA (x: T): x")) (("2" (expand "-") (("2" (assert) (("2" (lemma "deriv_exp_fun[T]" ("f" "LAMBDA (x_1: T): bb!1 - x_1" "n" "n!1")) (("2" (assert) (("2" (flatten -1) (("2" (expand "^" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (const_derivable_fun formula-decl nil derivatives nil) (expt def-decl "real" exponentiation nil) (identity_derivable_fun formula-decl nil derivatives nil) (diff_derivable_fun formula-decl nil derivatives nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "[T -> real]" real_fun_ops reals) (deriv_exp_fun formula-decl nil derivatives nil) nil (I const-decl "(bijective?[T, T])" identity nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (scal_derivable_fun formula-decl nil derivatives nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) nil (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil) (bool nonempty-type-eq-decl nil booleans nil) (derivable? const-decl "bool" derivatives nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (tay1-1 nil 3255192119 ("" (skosimp*) (("" (case "derivable?[T](LAMBDA x: (bb!1 - x) ^ n!1)") (("1" (lemma "scal_derivable_fun[T]" ("f" "LAMBDA x: (bb!1 - x) ^ n!1" "b" "1/ factorial(n!1)")) (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "n!1=0") (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt") (("1" (lemma "const_derivable_fun[T]" ("b" "1")) (("1" (expand "const_fun") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "const_derivable_fun[T]" ("b" "bb!1")) (("2" (lemma "identity_derivable_fun[T]") (("2" (expand "I") (("2" (expand "const_fun") (("2" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): bb!1" "f2" "LAMBDA (x: T): x")) (("2" (expand "-") (("2" (assert) (("2" (lemma "deriv_exp_fun[T]" ("f" "LAMBDA (x_1: T): bb!1 - x_1" "n" "n!1")) (("2" (assert) (("2" (flatten -1) (("2" (expand "^" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((derivable? const-decl "bool" derivatives nil) (scal_derivable_fun formula-decl nil derivatives nil) (factorial def-decl "posnat" factorial ints) (const_derivable_fun formula-decl nil derivatives nil) (identity_derivable_fun formula-decl nil derivatives nil) (diff_derivable_fun formula-decl nil derivatives nil) (^ const-decl "[T -> real]" real_fun_ops reals) (deriv_exp_fun formula-decl nil derivatives nil)) nil)) (tay2 0 (tay2-2 "" 3790090845 ("" (skosimp*) (("" (lemma "const_derivable_fun[T]" ("b" "bb!1")) (("" (lemma "deriv_const_fun[T]" ("b" "bb!1")) (("" (lemma "identity_derivable_fun[T]") (("" (lemma "deriv_id_fun[T]") (("" (expand "I") (("" (expand "const_fun") (("" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): bb!1" "f2" "LAMBDA (x: T): x")) (("" (expand "-" -1) (("" (assert) (("" (lemma "deriv_diff_fun[T]" ("ff1" "LAMBDA (x: T): bb!1" "ff2" "LAMBDA (x: T): x")) (("" (replace -5) (("" (replace -3) (("" (expand "-" -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (const_derivable_fun formula-decl nil derivatives nil) (identity_derivable_fun formula-decl nil derivatives nil) (I const-decl "(bijective?[T, T])" identity nil) (diff_derivable_fun formula-decl nil derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (derivable? const-decl "bool" derivatives nil) (bool nonempty-type-eq-decl nil booleans nil) (deriv_diff_fun formula-decl nil derivatives nil) nil (const_fun const-decl "[T -> real]" real_fun_ops reals) (real_minus_real_is_real application-judgement "real" reals nil) (deriv_id_fun formula-decl nil derivatives nil) (deriv_const_fun formula-decl nil derivatives nil)) shostak) (tay2-1 nil 3255192119 ("" (skosimp*) (("" (lemma "const_derivable_fun[T]" ("b" "bb!1")) (("" (lemma "deriv_const_fun[T]" ("b" "bb!1")) (("" (lemma "identity_derivable_fun[T]") (("" (lemma "deriv_id_fun[T]") (("" (expand "I") (("" (expand "const_fun") (("" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): bb!1" "f2" "LAMBDA (x: T): x")) (("" (expand "-" -1) (("" (assert) (("" (lemma "deriv_diff_fun[T]" ("ff1" "LAMBDA (x: T): bb!1" "ff2" "LAMBDA (x: T): x")) (("" (replace -5) (("" (replace -3) (("" (expand "-" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((const_derivable_fun formula-decl nil derivatives nil) (identity_derivable_fun formula-decl nil derivatives nil) (diff_derivable_fun formula-decl nil derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (derivable? const-decl "bool" derivatives nil) (deriv_diff_fun formula-decl nil derivatives nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (deriv_id_fun formula-decl nil derivatives nil) (deriv_const_fun formula-decl nil derivatives nil)) nil)) (tay3_TCC1 0 (tay3_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (assert) nil nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (tay3 subtype "((number_fields.+)(taylors.n, 1))" "{i: integers.int | booleans.OR(((number_fields.-)(taylors.bb, taylors.x)) /= 0, reals.>=(i, 0))}"))) (tay3 0 (tay3-2 "" 3790090846 ("" (skosimp*) (("" (lemma "tay1" ("bb" "bb!1" "n" "n!1+1")) (("" (lemma "tay2" ("bb" "bb!1")) (("" (flatten -1) (("" (replace -3 1) (("" (lemma "deriv_exp_fun[T]" ("f" "LAMBDA x: (bb!1 - x)" "n" "n!1+1")) (("" (assert) (("" (flatten -1) (("" (replace -4) (("" (expand "^" -2) (("" (expand "const_fun") (("" (expand "*" -2) (("" (lemma "deriv_scal_fun[T]" ("ff" "LAMBDA (t: T): (bb!1 - t) ^ (1 + n!1)" "b" "1/factorial(1+n!1)")) (("1" (replace -3 -1) (("1" (expand "*" -1) (("1" (replace -1 1) (("1" (lemma "extensionality" ("f" "(LAMBDA (x: T):
         -1 * ((bb!1 - x) ^ n!1 * (1 / factorial(1 + n!1))) -
          (bb!1 - x) ^ n!1 * (1 / factorial(1 + n!1)) * n!1)" "g" "-(LAMBDA x: (bb!1 - x) ^ n!1 / factorial(n!1))")) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (expand "-") (("2" (case "-1 * ((bb!1 - x!1) ^ n!1) *(1+n!1)/factorial(1 + n!1) = -1 * ((bb!1 - x!1) ^ n!1)/factorial(n!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "(1 + n!1) / factorial(1 + n!1) = 1/factorial(n!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "factorial" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "^" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (tay1 formula-decl nil taylors nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (deriv_exp_fun formula-decl nil derivatives nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "[T -> real]" real_fun_ops reals) (real_times_real_is_real application-judgement "real" reals nil) nil nil (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (deriv_scal_fun formula-decl nil derivatives nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints) (derivable? const-decl "bool" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (extensionality formula-decl nil functions nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) nil (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (derivable_const application-judgement "deriv_fun" derivatives nil) (constant_seq2 application-judgement "(convergent_nz?)" convergence_ops nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (tay2 formula-decl nil taylors nil)) shostak) (tay3-1 nil 3255192119 ("" (skosimp*) (("" (lemma "tay1" ("bb" "bb!1" "n" "n!1+1")) (("" (lemma "tay2" ("bb" "bb!1")) (("" (flatten -1) (("" (replace -3 1) (("" (lemma "deriv_exp_fun[T]" ("f" "LAMBDA x: (bb!1 - x)" "n" "n!1+1")) (("" (assert) (("" (flatten -1) (("" (replace -4) (("" (expand "^" -2) (("" (expand "const_fun") (("" (expand "*" -2) (("" (lemma "deriv_scal_fun[T]" ("ff" "LAMBDA (t: T): (bb!1 - t) ^ (1 + n!1)" "b" "1/factorial(1+n!1)")) (("1" (replace -3 -1) (("1" (expand "*" -1) (("1" (replace -1 1) (("1" (lemma "extensionality" ("f" "(LAMBDA (x: T):
         -1 * ((bb!1 - x) ^ n!1 * (1 / factorial(1 + n!1))) -
          (bb!1 - x) ^ n!1 * (1 / factorial(1 + n!1)) * n!1)" "g" "-(LAMBDA x: (bb!1 - x) ^ n!1 / factorial(n!1))")) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (expand "-") (("2" (case "-1 * ((bb!1 - x!1) ^ n!1) *(1+n!1)/factorial(1 + n!1) = -1 * ((bb!1 - x!1) ^ n!1)/factorial(n!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "(1 + n!1) / factorial(1 + n!1) = 1/factorial(n!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "factorial" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "^" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((deriv_exp_fun formula-decl nil derivatives nil) (^ const-decl "[T -> real]" real_fun_ops reals) (deriv_fun type-eq-decl nil derivatives nil) (derivable? const-decl "bool" derivatives nil) (factorial def-decl "posnat" factorial ints) (deriv_scal_fun formula-decl nil derivatives nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (derivable_const application-judgement "deriv_fun" derivatives nil) (constant_seq2 application-judgement "(convergent_nz?)" convergence_ops nil)) nil)) (deriv_sigma_TCC1 0 (deriv_sigma_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (lemma "sigma_derivable" ("g" "FF!1" "n" "n1!1")) (("" (replace -2 -1) (("" (propax) nil nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sigma_derivable formula-decl nil taylors nil)) nil (deriv_sigma subtype "LAMBDA x: sigma[nat].sigma(0, taylors.n, (LAMBDA n: taylors.FF(taylors.x, taylors.n)))" "deriv_fun[T]"))) (deriv_sigma_TCC2 0 (deriv_sigma_TCC2-2 "" 3803971080 ("" (skosimp*) (("" (inst - "ii!1") (("" (assert) nil nil)) nil)) nil) nil shostak (deriv_sigma subtype "LAMBDA xx: taylors.FF(taylors.xx, taylors.ii)" "deriv_fun[T]")) (deriv_sigma_TCC2-1 nil 3255192119 ("" (skosimp*) (("" (inst - "ii1!1") (("" (assert) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (subrange type-eq-decl nil integers nil) (n!1 skolem-const-decl "nat" taylors nil) (ii!1 skolem-const-decl "nat" taylors nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (deriv_sigma subtype "LAMBDA xx: taylors.FF(taylors.xx, taylors.ii)" "deriv_fun[T]"))) (deriv_sigma 0 (deriv_sigma-3 "" 3803971345 ("" (induct "n1") (("1" (skosimp*) (("1" (expand "sigma" 1) (("1" (inst - "0") (("1" (lemma "extensionality" ("f" "deriv(LAMBDA x: FF!1(x, 0))" "g" "(LAMBDA x: deriv(LAMBDA xx: FF!1(xx, 0))(x))")) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil) ("2" (skosimp*) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "FF!1") (("2" (split -1) (("1" (expand "sigma" 1) (("1" (lemma "deriv_sum_fun[T]" ("ff1" "LAMBDA x: FF!1(x, 1 + j!1)" "ff2" "LAMBDA x: sigma(0, j!1, LAMBDA n: FF!1(x, n))")) (("1" (replace -2 -1) (("1" (expand "+" -1) (("1" (replace -1 1) (("1" (hide -1 -2) (("1" (lemma "extensionality" ("f" "(LAMBDA (x_1: T):
                           deriv(LAMBDA x: FF!1(x, 1 + j!1))(x_1) +
                            sigma(0, j!1,
                                  LAMBDA ii:
                                    IF ii > j!1 THEN 0
                                    ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x_1)
                                    ENDIF))" "g" "(LAMBDA x:
                            deriv(LAMBDA xx: FF!1(xx, 1 + j!1))(x) +
                             sigma(0, j!1,
                                   LAMBDA ii:
                                     IF ii > 1 + j!1 THEN 0
                                     ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x)
                                     ENDIF))")) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "sigma_eq[nat]" ("low" "0" "high" "j!1" "F" "LAMBDA ii:
                                         IF ii > j!1 THEN 0
                                         ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x!1)
                                         ENDIF" "G" "LAMBDA ii:
                                          IF ii > 1 + j!1 THEN 0
                                          ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x!1)
                                          ENDIF")) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide 3) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (inst - "1+j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_derivable" ("g" "FF!1" "n" "j!1")) (("2" (assert) (("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst - "1+j!1") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "sigma_derivable" ("g" "FF!1" "n" "n1!2")) (("4" (replace -2) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (deriv_sigma-2 nil 3303660794 ("" (induct "n1") (("1" (skosimp*) (("1" (expand "sigma" 1) (("1" (inst - "0") (("1" (lemma "extensionality" ("f" "deriv(LAMBDA x: FF!1(x, 0))" "g" "(LAMBDA x: deriv(LAMBDA xx: FF!1(xx, 0))(x))")) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil) ("2" (skosimp*) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "FF!1") (("2" (split -1) (("1" (expand "sigma" 1) (("1" (lemma "deriv_sum_fun[T]" ("ff1" "LAMBDA x: FF!1(x, 1 + j!1)" "ff2" "LAMBDA x: sigma(0, j!1, LAMBDA n: FF!1(x, n))")) (("1" (replace -2 -1) (("1" (expand "+" -1) (("1" (replace -1 1) (("1" (hide -1 -2) (("1" (lemma "extensionality" ("f" "(LAMBDA (x_1: T):
                           deriv(LAMBDA x: FF!1(x, 1 + j!1))(x_1) +
                            sigma(0, j!1,
                                  LAMBDA ii:
                                    IF ii > j!1 THEN 0
                                    ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x_1)
                                    ENDIF))" "g" "(LAMBDA x:
                            deriv(LAMBDA xx: FF!1(xx, 1 + j!1))(x) +
                             sigma(0, j!1,
                                   LAMBDA ii:
                                     IF ii > 1 + j!1 THEN 0
                                     ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x)
                                     ENDIF))")) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "sigma_eq[nat]" ("low" "0" "high" "j!1" "F" "LAMBDA ii:
                                         IF ii > j!1 THEN 0
                                         ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x!1)
                                         ENDIF" "G" "LAMBDA ii:
                                          IF ii > 1 + j!1 THEN 0
                                          ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x!1)
                                          ENDIF")) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide 3) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (inst - "1+j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_derivable" ("g" "FF!1" "n" "j!1")) (("2" (assert) (("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst - "1+j!1") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst - "ii1!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "sigma_derivable" ("g" "FF!1" "n" "n1!2")) (("4" (replace -2) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((n1!2 skolem-const-decl "nat" taylors nil) (ii!1 skolem-const-decl "nat" taylors nil) (sigma_derivable formula-decl nil taylors nil) (ii!1 skolem-const-decl "nat" taylors nil) (ii!1 skolem-const-decl "nat" taylors nil) (ii!1 skolem-const-decl "nat" taylors nil) (j!1 skolem-const-decl "nat" taylors nil) (ii!1 skolem-const-decl "nat" taylors nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_eq formula-decl nil sigma reals) (+ const-decl "[T -> real]" real_fun_ops reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (deriv_sum_fun formula-decl nil derivatives nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_0_neg formula-decl nil sigma_nat reals) (extensionality formula-decl nil functions nil) (nat_induction formula-decl nil naturalnumbers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (derivable? const-decl "bool" derivatives nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals)) nil) (deriv_sigma-1 nil 3255192119 ("" (induct "n") (("1" (skosimp*) (("1" (expand "sigma" 1) (("1" (inst - "0") (("1" (lemma "extensionality" ("f" "deriv(LAMBDA x: FF!1(x, 0))" "g" "(LAMBDA x: deriv(LAMBDA xx: FF!1(xx, 0))(x))")) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil) ("2" (skosimp*) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "FF!1") (("2" (split -1) (("1" (expand "sigma" 1) (("1" (lemma "deriv_sum_fun[T]" ("ff1" "LAMBDA x: FF!1(x, 1 + j!1)" "ff2" "LAMBDA x: sigma(0, j!1, LAMBDA n: FF!1(x, n))")) (("1" (replace -2 -1) (("1" (expand "+" -1) (("1" (replace -1 1) (("1" (hide -1 -2) (("1" (lemma "extensionality" ("f" "(LAMBDA (x_1: T):
         deriv(LAMBDA x: FF!1(x, 1 + j!1))(x_1) +
          sigma(0, j!1,
                LAMBDA ii:
                  IF ii > j!1 THEN 0
                  ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x_1)
                  ENDIF))" "g" "(LAMBDA x:
          deriv(LAMBDA xx: FF!1(xx, 1 + j!1))(x) +
           sigma(0, j!1,
                 LAMBDA ii:
                   IF ii > 1 + j!1 THEN 0
                   ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x)
                   ENDIF))")) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "sigma_eq[nat]" ("low" "0" "high" "j!1" "F" "LAMBDA ii:
               IF ii > j!1 THEN 0
               ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x!1)
               ENDIF" "G" "LAMBDA ii:
                IF ii > 1 + j!1 THEN 0
                ELSE deriv(LAMBDA xx: FF!1(xx, ii))(x!1)
                ENDIF")) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide 3) (("3" (inst - "ii!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (inst - "1+j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_derivable[T]" ("g" "FF!1" "n" "j!1")) (("2" (assert) (("2" (hide 2) (("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst - "1+j!1") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "ii!1") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst - "ii1!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "sigma_derivable[T]" ("g" "FF!1" "n" "n!2")) (("4" (replace -2) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((deriv_sum_fun formula-decl nil derivatives nil) (sigma_eq formula-decl nil sigma reals) (deriv const-decl "[T -> real]" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (sigma def-decl "real" sigma reals)) nil)) (nderiv_term_derivable_TCC1 0 (nderiv_term_derivable_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (lemma "derivable_n_times_lem[T]") (("" (inst - "f!1" "n!1" "n!1+1") (("" (assert) nil nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (nderiv_term_derivable subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.n)"))) (nderiv_term_derivable 0 (nderiv_term_derivable-2 "" 3790090848 ("" (skosimp*) (("" (case "n!1=0") (("1" (replace -1) (("1" (expand "derivable_n_times?") (("1" (flatten -2) (("1" (rewrite "eta" 1) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "nderiv_derivable[T]" ("f" "f!1" "n" "n!1" "m" "n!1")) (("2" (assert) (("2" (lemma "tay1" ("bb" "bb!1" "n" "n!1")) (("2" (lemma "prod_derivable_fun[T]" ("f1" "nderiv(n!1, f!1)" "f2" "LAMBDA x: (bb!1 - x) ^ n!1 / factorial(n!1)")) (("2" (assert) (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (prod_derivable_fun formula-decl nil derivatives nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) nil (tay1 formula-decl nil taylors nil) (nderiv_derivable formula-decl nil nth_derivatives nil) (eta formula-decl nil functions nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (nderiv_term_derivable-1 nil 3255192119 ("" (skosimp*) (("" (case "n!1=0") (("1" (replace -1) (("1" (expand "derivable_n_times?") (("1" (flatten -2) (("1" (rewrite "eta" 1) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "nderiv_derivable[T]" ("f" "f!1" "n" "n!1" "m" "n!1")) (("2" (assert) (("2" (lemma "tay1" ("bb" "bb!1" "n" "n!1")) (("2" (lemma "prod_derivable_fun[T]" ("f1" "nderiv(n!1, f!1)" "f2" "LAMBDA x: (bb!1 - x) ^ n!1 / factorial(n!1)")) (("1" (assert) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "n!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_derivable formula-decl nil nth_derivatives nil) (prod_derivable_fun formula-decl nil derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (factorial def-decl "posnat" factorial ints)) nil)) (taylor_derivable_TCC1 0 (taylor_derivable_TCC1-2 "" 3754690330 ("" (skosimp*) (("" (lemma "derivable_n_times_lem[T]") (("" (inst - "f!1" "nn!1" "n!1+1") (("" (assert) nil nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (taylor_derivable subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.nn)")) (taylor_derivable_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (inst + "0") (("" (assert) nil nil)) nil)) nil) ((derivable_n_times_lem formula-decl nil nth_derivatives nil)) nil (taylor_derivable subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.nn)"))) (taylor_derivable_TCC2 0 (taylor_derivable_TCC2-1 nil 3255192119 ("" (skosimp*) (("" (lemma "derivable_n_times_lem[T]") (("" (inst - "f!1" "nn!1" "n!1+1") (("" (assert) nil nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (taylor_derivable subtype "taylors.nn" "{i: integers.int | booleans.OR(((number_fields.-)(taylors.bb, taylors.aa)) /= 0, reals.>=(i, 0))}"))) (taylor_derivable 0 (taylor_derivable-3 "" 3790090849 ("" (skosimp*) (("" (lemma "const_derivable_fun[T]" ("b" "f!1(bb!1)")) (("" (lemma "nderiv_term_derivable" ("f" "f!1" "n" "n!1" "bb" "bb!1")) (("" (replace -3) (("" (lemma "sigma_derivable" ("g" "LAMBDA (aa: T, nn:nat):IF nn > n!1 THEN 0
                              ELSIF nn = 0 THEN f!1(aa)
                              ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /
                                    factorial(nn)
                              ENDIF" "n" "n!1")) (("1" (split -1) (("1" (simplify -1) (("1" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): f!1(bb!1)" "f2" "LAMBDA (aa_1: T):
                    sigma(0, n!1,
                          LAMBDA m:
                            IF m > n!1 THEN 0
                            ELSIF m = 0 THEN f!1(aa_1)
                            ELSE nderiv(m, f!1)(aa_1) * (bb!1 - aa_1) ^ m /
                                  factorial(m)
                            ENDIF)")) (("1" (assert) (("1" (expand "-" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "ii!1") (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "ii!1+1")) (("2" (assert) (("2" (lemma "nderiv_term_derivable" ("f" "f!1" "n" "ii!1" "bb" "bb!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "n!1+1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (const_derivable_fun formula-decl nil derivatives nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (sigma_derivable formula-decl nil taylors nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (diff_derivable_fun formula-decl nil derivatives nil) nil (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subrange type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (nderiv_term_derivable formula-decl nil taylors nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (taylor_derivable-2 nil 3306748084 ("" (skosimp*) (("" (lemma "const_derivable_fun[T]" ("b" "f!1(bb!1)")) (("" (expand "const_fun") (("" (lemma "nderiv_term_derivable" ("f" "f!1" "n" "n!1" "bb" "bb!1")) (("" (replace -3) (("" (lemma "sigma_derivable" ("g" "LAMBDA (aa: T, nn:nat):IF nn > n!1 THEN 0
                              ELSIF nn = 0 THEN f!1(aa)
                              ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /
                                    factorial(nn)
                              ENDIF" "n" "n!1")) (("1" (split -1) (("1" (simplify -1) (("1" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): f!1(bb!1)" "f2" "LAMBDA (aa_1: T):
                    sigma(0, n!1,
                          LAMBDA m:
                            IF m > n!1 THEN 0
                            ELSIF m = 0 THEN f!1(aa_1)
                            ELSE nderiv(m, f!1)(aa_1) * (bb!1 - aa_1) ^ m /
                                  factorial(m)
                            ENDIF)")) (("1" (assert) (("1" (expand "-" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "ii!1") (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "ii!1+1")) (("2" (assert) (("2" (lemma "nderiv_term_derivable" ("f" "f!1" "n" "ii!1" "bb" "bb!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "n!1+1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((const_derivable_fun formula-decl nil derivatives nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (diff_derivable_fun formula-decl nil derivatives nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (factorial def-decl "posnat" factorial ints)) nil) (taylor_derivable-1 nil 3255192119 ("" (skosimp*) (("" (lemma "const_derivable_fun[T]" ("b" "f!1(bb!1)")) (("" (expand "const_fun") (("" (lemma "nderiv_term_derivable[T]" ("f" "f!1" "n" "n!1" "bb" "bb!1")) (("" (replace -3) (("" (lemma "sigma_derivable[T]" ("g" "LAMBDA (aa: T, nn:nat):IF nn > n!1 THEN 0
                           ELSIF nn = 0 THEN f!1(aa)
                           ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /
                                 factorial(nn)
                           ENDIF" "n" "n!1")) (("1" (split -1) (("1" (simplify -1) (("1" (lemma "diff_derivable_fun[T]" ("f1" "LAMBDA (x: T): f!1(bb!1)" "f2" "LAMBDA (aa_1: T):
             sigma(0, n!1,
                   LAMBDA m:
                     IF m > n!1 THEN 0
                     ELSIF m = 0 THEN f!1(aa_1)
                     ELSE nderiv(m, f!1)(aa_1) * (bb!1 - aa_1) ^ m /
                           factorial(m)
                     ENDIF)")) (("1" (assert) (("1" (expand "-" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "ii!1") (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "ii!1+1")) (("2" (assert) (("2" (lemma "nderiv_term_derivable[T]" ("f" "f!1" "n" "ii!1" "bb" "bb!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "n!1+1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((const_derivable_fun formula-decl nil derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (sigma def-decl "real" sigma reals) (diff_derivable_fun formula-decl nil derivatives nil) (const_fun const-decl "[T -> real]" real_fun_ops reals)) nil)) (deriv_nderiv_TCC1 0 (deriv_nderiv_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (lemma "derivable_n_times_lem" ("f" "f!1" "n" "n!1+1" "m" "n!1")) (("" (assert) nil nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (deriv_nderiv subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.n)"))) (deriv_nderiv_TCC2 0 (deriv_nderiv_TCC2-2 "" 3790090849 ("" (skosimp*) (("" (lemma "nderiv_derivable_eqv[T]" ("f" "f!1" "n" "n!1")) (("" (replace -2 -1) (("" (flatten -1) (("" (lemma "extensionality" ("f" "nderiv(n!1, f!1)" "g" "LAMBDA xx: (nderiv[T](n!1, f!1)(xx))")) (("" (split -1) (("1" (replace -1 1 rl) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nderiv_derivable_eqv formula-decl nil nth_derivatives nil) (extensionality formula-decl nil functions nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (deriv_nderiv subtype "(LAMBDA xx: (nth_derivatives[T].nderiv(taylors.n, taylors.f)(taylors.xx)))" "deriv_fun[T]")) (deriv_nderiv_TCC2-1 nil 3255192119 ("" (skosimp*) (("" (lemma "nderiv_derivable_eqv[T]" ("f" "f!1" "n" "n!1")) (("" (replace -2 -1) (("" (flatten -1) (("" (lemma "extensionality" ("f" "nderiv(n!1, f!1)" "g" "LAMBDA xx: (nderiv[T](n!1, f!1)(xx))")) (("1" (split -1) (("1" (replace -1 1 rl) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil) ("2" (skosimp*) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((nderiv_derivable_eqv formula-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil)) nil (deriv_nderiv subtype "(LAMBDA xx: (nth_derivatives[T].nderiv(taylors.n, taylors.f)(taylors.xx)))" "deriv_fun[T]"))) (deriv_nderiv_TCC3 0 (deriv_nderiv_TCC3-1 nil 3255192119 ("" (skosimp*) (("" (assert) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (deriv_nderiv subtype "taylors.f" "nth_derivatives[T].nderiv_fun((number_fields.+)(1, taylors.n))"))) (deriv_nderiv 0 (deriv_nderiv-2 "" 3790090850 ("" (skosimp*) (("" (lemma "nderiv_derivable_aux" ("f" "f!1" "n" "n!1")) (("" (assert) (("" (replace -1 1) (("" (lemma "extensionality" ("f" "LAMBDA xx: (nderiv(n!1, f!1)(xx))" "g" "nderiv(n!1, f!1)")) (("" (split -1) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nderiv_derivable_aux formula-decl nil nth_derivatives nil) (int_minus_int_is_int application-judgement "int" integers nil) (extensionality formula-decl nil functions nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (deriv_nderiv-1 nil 3255192119 ("" (skosimp*) (("" (lemma "nderiv_derivable_aux" ("f" "f!1" "n" "n!1")) (("" (assert) (("" (replace -1 1) (("" (lemma "extensionality" ("f" "LAMBDA xx: (nderiv(n!1, f!1)(xx))" "g" "nderiv(n!1, f!1)")) (("1" (split -1) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "n!1+1" "m" "n!1")) (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "n!1+1" "m" "n!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nderiv_derivable_aux formula-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil)) nil)) (term_by_term_deriv_TCC1 0 (term_by_term_deriv_TCC1-2 "" 3754690402 ("" (skosimp*) (("" (lemma "derivable_n_times_lem[T]") (("" (inst - "f!1" "ii!1" "n!1+1") (("" (assert) nil nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (term_by_term_deriv subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.ii)")) (term_by_term_deriv_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (inst + "0") (("" (assert) nil nil)) nil)) nil) ((derivable_n_times_lem formula-decl nil nth_derivatives nil)) nil (term_by_term_deriv subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.ii)"))) (term_by_term_deriv_TCC2 0 (term_by_term_deriv_TCC2-1 nil 3255192119 ("" (skosimp*) (("" (lemma "derivable_n_times_lem[T]") (("" (inst - "f!1" "ii!1" "n!1+1") (("" (assert) nil nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (term_by_term_deriv subtype "taylors.ii" "{i: integers.int | booleans.OR(((number_fields.-)(taylors.bb, taylors.xx)) /= 0, reals.>=(i, 0))}"))) (term_by_term_deriv_TCC3 0 (term_by_term_deriv_TCC3-2 "" 3754696984 ("" (skosimp*) (("" (case "ii!1=0") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "derivable_n_times?") (("2" (lemma "extensionality" ("f" "f!1" "g" "LAMBDA xx: f!1(xx)")) (("2" (split -1) (("1" (skosimp*) (("1" (assert) (("1" (lemma "nderiv_derivable[T]" ("f" "f!1" "n" "n!1" "m" "ii!1")) (("1" (assert) (("1" (lemma "identity_derivable_fun[T]") (("1" (expand "I") (("1" (assert) (("1" (hide -2) (("1" (use "nderiv_term_derivable") (("1" (expand "derivable_n_times?" -1) (("1" (lemma "derivable_n_times_lem[T]") (("1" (inst?) (("1" (inst -1 "n!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (derivable? const-decl "bool" derivatives nil) (derivable? const-decl "bool" derivatives_def nil) (convergent? const-decl "bool" lim_of_functions nil) (convergence const-decl "bool" lim_of_functions nil) (convergence const-decl "bool" convergence_functions nil) (NQ const-decl "real" derivatives_def nil) (adh const-decl "setof[real]" convergence_functions nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (fullset const-decl "set" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (I const-decl "(bijective?[T, T])" identity nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nderiv_term_derivable formula-decl nil taylors nil) (identity_derivable_fun formula-decl nil derivatives nil) (nderiv_derivable formula-decl nil nth_derivatives nil) (T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (extensionality formula-decl nil functions nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak (term_by_term_deriv subtype "LAMBDA xx: IF taylors.ii = 0 THEN taylors.f(taylors.xx) ELSE number_fields./(number_fields.*(nth_derivatives[T].nderiv(taylors.ii, taylors.f)(taylors.xx), exponentiation.^(((number_fields.-)(taylors.bb, taylors.xx)), taylors.ii)), factorial.factorial(taylors.ii)) ENDIF" "deriv_fun[T]")) (term_by_term_deriv_TCC3-1 nil 3255192119 ("" (skosimp*) (("" (case "ii!1=0") (("1" (propax) nil nil) ("2" (assert) (("2" (expand "derivable_n_times?") (("2" (lemma "extensionality" ("f" "f!1" "g" "LAMBDA xx: f!1(xx)")) (("2" (split -1) (("1" (skosimp*) (("1" (assert) (("1" (lemma "nderiv_derivable[T]" ("f" "f!1" "n" "n!1" "m" "ii!1")) (("1" (assert) (("1" (lemma "identity_derivable_fun[T]") (("1" (expand "I") (("1" (assert) (("1" (hide -2) (("1" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "ii!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((derivable_n_times? def-decl "bool" nth_derivatives nil) (derivable? const-decl "bool" derivatives nil) (derivable? const-decl "bool" derivatives_def nil) (convergent? const-decl "bool" lim_of_functions nil) (convergence const-decl "bool" lim_of_functions nil) (convergence const-decl "bool" convergence_functions nil) (NQ const-decl "real" derivatives_def nil) (adh const-decl "setof[real]" convergence_functions nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (identity_derivable_fun formula-decl nil derivatives nil) (nderiv_derivable formula-decl nil nth_derivatives nil)) nil (term_by_term_deriv subtype "LAMBDA xx: IF taylors.ii = 0 THEN taylors.f(taylors.xx) ELSE number_fields./(number_fields.*(nth_derivatives[T].nderiv(taylors.ii, taylors.f)(taylors.xx), exponentiation.^(((number_fields.-)(taylors.bb, taylors.xx)), taylors.ii)), factorial.factorial(taylors.ii)) ENDIF" "deriv_fun[T]"))) (term_by_term_deriv 0 (term_by_term_deriv-3 "" 3790090853 ("" (induct "n") (("1" (skosimp*) (("1" (expand "sigma") (("1" (expand "^") (("1" (expand "expt") (("1" (expand "factorial") (("1" (expand "nderiv") (("1" (expand "nderiv") (("1" (case-replace "(LAMBDA xx: f!1(xx)) = f!1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (inst?) (("2" (split -1) (("1" (expand "sigma" 1) (("1" (case-replace "       sigma(0, j!1,
                                                     LAMBDA ii:
                                                       IF ii > 1 + j!1
                                                         THEN 0
                                                       ELSE deriv(LAMBDA xx:
                                                                    IF ii = 0
                                                                      THEN f!1(xx)
                                                                    ELSE nderiv(ii, f!1)(xx) * (bb!1 - xx) ^ ii /
                                                                          factorial(ii)
                                                                    ENDIF)
                                                                 (x!1)
                                                       ENDIF)
                                         =  sigma(0, j!1,
                                                    LAMBDA ii:
                                                      IF ii > j!1
                                                        THEN 0
                                                      ELSE deriv(LAMBDA xx:
                                                                   IF ii = 0
                                                                     THEN f!1(xx)
                                                                   ELSE nderiv(ii, f!1)(xx) * (bb!1 - xx) ^ ii /
                                                                         factorial(ii)
                                                                   ENDIF)
                                                                (x!1)
                                                      ENDIF)") (("1" (replace -2) (("1" (hide -2) (("1" (hide -1) (("1" (case "derivable_n_times?(f!1, 1 + j!1)") (("1" (case "derivable?[T]((LAMBDA xx: (nderiv(1 + j!1, f!1)(xx))))") (("1" (case-replace "(LAMBDA xx:
                                                                                       (nderiv(1 + j!1, f!1)(xx) * (bb!1 - xx) ^ (1 + j!1)) /
                                                                                        factorial(1 + j!1)) = (LAMBDA xx:
                                                                                       (nderiv(1 + j!1, f!1)(xx))) * (LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) /
                                                                                        factorial(1 + j!1))") (("1" (hide -1) (("1" (lemma "deriv_prod_fun[T]") (("1" (case "derivable?[T]((LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) / factorial(1 + j!1)))") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "deriv((LAMBDA xx: (nderiv(1 + j!1, f!1)(xx)))) = nderiv(2 + j!1,f!1)") (("1" (hide -1) (("1" (expand "*" +) (("1" (expand "+") (("1" (case-replace "deriv((LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) / factorial(1 + j!1))) =
                                                                                                                                          (LAMBDA xx: -((bb!1 - xx)^j!1) / factorial(j!1))") (("1" (hide -1) (("1" (beta) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "j!1") (("2" (flatten) (("2" (replace -2) (("2" (apply-extensionality 1 :hide? t) (("2" (expand "-") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "deriv_nderiv") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "tay1") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (case-replace "(LAMBDA xx: (nderiv(1 + j!1, f!1)(xx))) = nderiv(1 + j!1, f!1)") (("1" (lemma "nderiv_derivable[T]" ("f" "f!1" "m" "1+j!1" "n" "1+j!1")) (("1" (assert) nil nil)) nil) ("2" (lemma "extensionality" ("f" "(LAMBDA xx: (nderiv(1 + j!1, f!1)(xx)))" "g" "nderiv(1 + j!1, f!1)")) (("2" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+j!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "nderiv_term_derivable") (("4" (inst?) (("4" (assert) (("4" (hide 3) (("4" (assert) (("4" (typepred "ii!1") (("4" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "nderiv_term_derivable") (("3" (inst?) (("3" (assert) (("3" (hide -1 3) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -1) (("4" (lemma "nderiv_term_derivable") (("4" (inst?) (("4" (assert) (("4" (hide 3) (("4" (lemma "derivable_n_times_lem[T]") (("4" (inst?) (("4" (inst - "(2+j!1)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (lemma "nderiv_term_derivable") (("5" (inst?) (("5" (assert) (("5" (assert) (("5" (hide -1 3) (("5" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+j!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "nderiv_term_derivable") (("3" (inst?) (("3" (assert) (("3" (hide 3) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!2" "m" "1+ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!2" "m" "ii!1")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (derivable? const-decl "bool" derivatives nil) (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (deriv_fun type-eq-decl nil derivatives nil) (deriv const-decl "[T -> real]" derivatives nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (sigma_0_neg formula-decl nil sigma_nat reals) (real_plus_real_is_real application-judgement "real" reals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (extensionality formula-decl nil functions nil) (nderiv_derivable formula-decl nil nth_derivatives nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (tay1 formula-decl nil taylors nil) nil nil nil (deriv_nderiv formula-decl nil taylors nil) nil (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (tay3 formula-decl nil taylors nil) nil (deriv_prod_fun formula-decl nil derivatives nil) nil (sigma_restrict_eq formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nderiv_term_derivable formula-decl nil taylors nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak) (term_by_term_deriv-2 nil 3445339548 ("" (induct "n") (("1" (skosimp*) (("1" (expand "sigma") (("1" (expand "^") (("1" (expand "expt") (("1" (expand "factorial") (("1" (expand "nderiv") (("1" (expand "nderiv") (("1" (case-replace "(LAMBDA xx: f!1(xx)) = f!1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (inst?) (("2" (split -1) (("1" (expand "sigma" 1) (("1" (case-replace "       sigma(0, j!1,
                                                     LAMBDA ii:
                                                       IF ii > 1 + j!1
                                                         THEN 0
                                                       ELSE deriv(LAMBDA xx:
                                                                    IF ii = 0
                                                                      THEN f!1(xx)
                                                                    ELSE nderiv(ii, f!1)(xx) * (bb!1 - xx) ^ ii /
                                                                          factorial(ii)
                                                                    ENDIF)
                                                                 (x!1)
                                                       ENDIF)
                                         =  sigma(0, j!1,
                                                    LAMBDA ii:
                                                      IF ii > j!1
                                                        THEN 0
                                                      ELSE deriv(LAMBDA xx:
                                                                   IF ii = 0
                                                                     THEN f!1(xx)
                                                                   ELSE nderiv(ii, f!1)(xx) * (bb!1 - xx) ^ ii /
                                                                         factorial(ii)
                                                                   ENDIF)
                                                                (x!1)
                                                      ENDIF)") (("1" (replace -2) (("1" (hide -2) (("1" (hide -1) (("1" (case "derivable_n_times?(f!1, 1 + j!1)") (("1" (case "derivable?[T]((LAMBDA xx: (nderiv(1 + j!1, f!1)(xx))))") (("1" (case-replace "(LAMBDA xx:
                                                                                       (nderiv(1 + j!1, f!1)(xx) * (bb!1 - xx) ^ (1 + j!1)) /
                                                                                        factorial(1 + j!1)) = (LAMBDA xx:
                                                                                       (nderiv(1 + j!1, f!1)(xx))) * (LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) /
                                                                                        factorial(1 + j!1))") (("1" (hide -1) (("1" (lemma "deriv_prod_fun[T]") (("1" (case "derivable?[T]((LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) / factorial(1 + j!1)))") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "deriv((LAMBDA xx: (nderiv(1 + j!1, f!1)(xx)))) = nderiv(2 + j!1,f!1)") (("1" (hide -1) (("1" (expand "*" +) (("1" (expand "+") (("1" (case-replace "deriv((LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) / factorial(1 + j!1))) =
                                                                                                                                          (LAMBDA xx: -((bb!1 - xx)^j!1) / factorial(j!1))") (("1" (hide -1) (("1" (beta) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "j!1") (("2" (flatten) (("2" (replace -2) (("2" (apply-extensionality 1 :hide? t) (("2" (expand "-") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "deriv_nderiv") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "tay1") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (case-replace "(LAMBDA xx: (nderiv(1 + j!1, f!1)(xx))) = nderiv(1 + j!1, f!1)") (("1" (lemma "nderiv_derivable[T]" ("f" "f!1" "m" "1+j!1" "n" "1+j!1")) (("1" (assert) nil nil)) nil) ("2" (lemma "extensionality" ("f" "(LAMBDA xx: (nderiv(1 + j!1, f!1)(xx)))" "g" "nderiv(1 + j!1, f!1)")) (("2" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+j!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "nderiv_term_derivable") (("4" (inst?) (("4" (assert) (("4" (hide 3) (("4" (assert) (("4" (typepred "ii!1") (("4" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "nderiv_term_derivable") (("3" (inst?) (("3" (assert) (("3" (hide -1 3) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -1) (("4" (lemma "nderiv_term_derivable") (("4" (inst?) (("4" (assert) (("4" (hide 3) (("4" (lemma "derivable_n_times_lem[T]") (("4" (inst?) (("4" (inst - "(2+j!1)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (lemma "nderiv_term_derivable") (("5" (inst?) (("5" (assert) (("5" (assert) (("5" (hide -1 3) (("5" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+j!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "nderiv_term_derivable") (("3" (inst?) (("3" (assert) (("3" (hide 3) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!2" "m" "1+ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!2" "m" "ii!1")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "[T -> real]" sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (deriv_prod_fun formula-decl nil derivatives nil) (nderiv_derivable formula-decl nil nth_derivatives nil) (sigma_0_neg formula-decl nil sigma_nat reals) (deriv const-decl "[T -> real]" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (derivable? const-decl "bool" derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (factorial def-decl "posnat" factorial ints) (derivable_n_times? def-decl "bool" nth_derivatives nil)) nil) (term_by_term_deriv-1 nil 3255192119 ("" (induct "n") (("1" (skosimp*) (("1" (expand "sigma") (("1" (expand "^") (("1" (expand "expt") (("1" (expand "factorial") (("1" (expand "nderiv") (("1" (expand "nderiv") (("1" (case-replace "(LAMBDA xx: f!1(xx)) = f!1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (inst?) (("2" (split -1) (("1" (expand "sigma" 1) (("1" (case-replace "       sigma(0, j!1,
                                               LAMBDA ii:
                                                 IF ii > 1 + j!1
                                                   THEN 0
                                                 ELSE deriv(LAMBDA xx:
                                                              IF ii = 0
                                                                THEN f!1(xx)
                                                              ELSE nderiv(ii, f!1)(xx) * (bb!1 - xx) ^ ii /
                                                                    factorial(ii)
                                                              ENDIF)
                                                           (x!1)
                                                 ENDIF)
                                   =  sigma(0, j!1,
                                              LAMBDA ii:
                                                IF ii > j!1
                                                  THEN 0
                                                ELSE deriv(LAMBDA xx:
                                                             IF ii = 0
                                                               THEN f!1(xx)
                                                             ELSE nderiv(ii, f!1)(xx) * (bb!1 - xx) ^ ii /
                                                                   factorial(ii)
                                                             ENDIF)
                                                          (x!1)
                                                ENDIF)") (("1" (replace -2) (("1" (hide -2) (("1" (hide -1) (("1" (case "derivable_n_times?(f!1, 1 + j!1)") (("1" (case "derivable[T]((LAMBDA xx: (nderiv(1 + j!1, f!1)(xx))))") (("1" (case-replace "(LAMBDA xx:
                                                                           (nderiv(1 + j!1, f!1)(xx) * (bb!1 - xx) ^ (1 + j!1)) /
                                                                            factorial(1 + j!1)) = (LAMBDA xx:
                                                                           (nderiv(1 + j!1, f!1)(xx))) * (LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) /
                                                                            factorial(1 + j!1))") (("1" (hide -1) (("1" (lemma "deriv_prod_fun[T]") (("1" (case "derivable?[T]((LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) / factorial(1 + j!1)))") (("1" (inst?) (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "deriv((LAMBDA xx: (nderiv(1 + j!1, f!1)(xx)))) = nderiv(2 + j!1,f!1)") (("1" (hide -1) (("1" (expand "*" +) (("1" (expand "+") (("1" (case-replace "deriv((LAMBDA xx: (bb!1 - xx) ^ (1 + j!1) / factorial(1 + j!1))) =
                                                                                                                        (LAMBDA xx: -((bb!1 - xx)^j!1) / factorial(j!1))") (("1" (hide -1) (("1" (beta) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "j!1") (("2" (flatten) (("2" (replace -2) (("2" (apply-extensionality 1 :hide? t) (("2" (expand "-") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "deriv_nderiv") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "tay1") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (case-replace "(LAMBDA xx: (nderiv(1 + j!1, f!1)(xx))) = nderiv(1 + j!1, f!1)") (("1" (lemma "nderiv_derivable[T]" ("f" "f!1" "m" "1+j!1" "n" "1+j!1")) (("1" (assert) nil nil)) nil) ("2" (lemma "extensionality" ("f" "(LAMBDA xx: (nderiv(1 + j!1, f!1)(xx)))" "g" "nderiv(1 + j!1, f!1)")) (("2" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+j!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "nderiv_term_derivable") (("4" (inst?) (("4" (assert) (("4" (hide 3) (("4" (assert) (("4" (typepred "ii!1") (("4" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) (("5" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "nderiv_term_derivable") (("3" (inst?) (("3" (assert) (("3" (hide -1 3) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (hide -1) (("4" (lemma "nderiv_term_derivable") (("4" (inst?) (("4" (assert) (("4" (hide 3) (("4" (lemma "derivable_n_times_lem[T]") (("4" (inst?) (("4" (inst - "(2+j!1)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (lemma "nderiv_term_derivable") (("5" (inst?) (("5" (assert) (("5" (assert) (("5" (hide -1 3) (("5" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+ii!1")) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "ii!1")) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "2+j!1" "m" "1+j!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (lemma "nderiv_term_derivable") (("3" (inst?) (("3" (assert) (("3" (hide 3) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!2" "m" "1+ii!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (assert) (("4" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!2" "m" "ii!1")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "[T -> real]" sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (deriv_prod_fun formula-decl nil derivatives nil) (nderiv_derivable formula-decl nil nth_derivatives nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil)) nil)) (taylor_lemma_TCC1 0 (taylor_lemma_TCC1-1 nil 3255192119 ("" (skosimp*) (("" (lemma "taylor_derivable" ("f" "f!1" "n" "n!1" "bb" "bb!1")) (("" (replace -2 * rl) (("" (assert) nil nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (taylor_derivable formula-decl nil taylors nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (taylor_lemma subtype "taylors.Rn" "deriv_fun[T]"))) (taylor_lemma 0 (taylor_lemma-2 "" 3790090855 ("" (skosimp*) (("" (replace -2) (("" (hide -2) (("" (lemma "deriv_diff_fun[T]") (("" (inst -1 "(LAMBDA aa: f!1(bb!1) )" "(LAMBDA aa:                   sigma(0, n!1,                         LAMBDA nn:                           IF nn > n!1                             THEN 0                           ELSIF nn = 0 THEN f!1(aa)                           ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /                                 factorial(nn)                           ENDIF))") (("1" (assert) (("1" (expand "-") (("1" (replace -1) (("1" (hide -1) (("1" (apply-extensionality 1 :hide? t) (("1" (lemma "deriv_const[T]") (("1" (expand "const_fun") (("1" (inst?) (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand "deriv" 1 1) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "deriv_sigma") (("1" (inst?) (("1" (split -1) (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (lemma "term_by_term_deriv") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (typepred "ii!1") (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_derivable") (("2" (inst?) (("1" (split -1) (("1" (skolem!) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (typepred "ii!1") (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (lemma "const_derivable_fun[T]") (("4" (inst -1 "f!1(bb!1)") (("4" (skolem!) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "sigma_derivable") (("1" (hide 2) (("1" (skosimp*) (("1" (lemma "nderiv_term_derivable") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (typepred "ii!1") (("1" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "1+ii!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (lemma "const_derivable_fun[T]") (("4" (inst -1 "f!1(bb!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (deriv_diff_fun formula-decl nil derivatives nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) nil nil (derivable? const-decl "bool" derivatives nil) (bool nonempty-type-eq-decl nil booleans nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) nil (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (deriv_fun type-eq-decl nil derivatives nil) nil (deriv const-decl "[T -> real]" derivatives nil) (- const-decl "[numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (nderiv_term_derivable formula-decl nil taylors nil) (term_by_term_deriv formula-decl nil taylors nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (deriv_sigma formula-decl nil taylors nil) (deriv_const formula-decl nil derivatives_def nil) (sigma_derivable formula-decl nil taylors nil) (const_derivable_fun formula-decl nil derivatives nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak) (taylor_lemma-1 nil 3255192119 ("" (skosimp*) (("" (replace -2) (("" (hide -2) (("" (lemma "deriv_diff_fun[T]") (("" (inst -1 "(LAMBDA aa: f!1(bb!1) )" "(LAMBDA aa:                   sigma(0, n!1,                         LAMBDA nn:                           IF nn > n!1                             THEN 0                           ELSIF nn = 0 THEN f!1(aa)                           ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /                                 factorial(nn)                           ENDIF))") (("1" (assert) (("1" (expand "-") (("1" (replace -1) (("1" (hide -1) (("1" (apply-extensionality 1 :hide? t) (("1" (lemma "deriv_const[T]") (("1" (expand "const_fun") (("1" (inst?) (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand "deriv" 1 1) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "deriv_sigma") (("1" (inst?) (("1" (split -1) (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (lemma "term_by_term_deriv") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (assert) (("2" (typepred "ii!1") (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "not_one_element") (("2" (expand "not_one_element?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "connected_domain") (("3" (lemma "deriv_domain") (("3" (expand "deriv_domain?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_derivable") (("2" (inst?) (("1" (split -1) (("1" (skolem!) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "nderiv_term_derivable") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (assert) (("2" (typepred "ii!1") (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "1+ii!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (lemma "const_derivable_fun[T]") (("4" (inst -1 "f!1(bb!1)") (("4" (skolem!) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "sigma_derivable") (("1" (hide 2) (("1" (skosimp*) (("1" (lemma "nderiv_term_derivable") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (assert) (("1" (typepred "ii!1") (("1" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "1+ii!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (lemma "const_derivable_fun[T]") (("4" (inst -1 "f!1(bb!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((deriv_diff_fun formula-decl nil derivatives nil) (deriv const-decl "[T -> real]" derivatives nil) (const_fun const-decl "[T -> real]" real_fun_ops reals) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (deriv_const formula-decl nil derivatives_def nil) (const_derivable_fun formula-decl nil derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (factorial def-decl "posnat" factorial ints) (derivable_n_times? def-decl "bool" nth_derivatives nil) (derivable? const-decl "bool" derivatives nil)) nil)) (Taylors 0 (Taylors-3 "" 3790090859 ("" (skosimp*) (("" (case-replace "bb!1 = aa!1") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (case-replace "(LAMBDA nn:
                                         IF nn > n!1
                                           THEN 0
                                         ELSIF nn = 0 THEN f!1(aa!1) ELSE 0 / factorial(nn)
                                         ENDIF)
                                          = (LAMBDA nn: IF nn = 0 THEN f!1(aa!1) ELSE 0 ENDIF)") (("1" (hide -1) (("1" (lemma "sigma_first_ge") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_const") (("1" (inst -1 "n!1" "1" "0") (("1" (case-replace "sigma(1, n!1, (LAMBDA nn: IF nn = 0 THEN f!1(aa!1) ELSE 0 ENDIF)) = sigma(1, n!1, LAMBDA (i: nat): 0)") (("1" (hide -1) (("1" (replace -1) (("1" (lift-if) (("1" (ground) (("1" (inst + "aa!1") nil nil) ("2" (inst + "aa!1") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "taylor_lemma") (("2" (name "RN" "(LAMBDA aa:
                                                                                                                                                                                f!1(bb!1) -
                                                                                                                                                                                 sigma(0, n!1,
                                                                                                                                                                                       LAMBDA nn:
                                                                                                                                                                                         IF nn > n!1
                                                                                                                                                                                           THEN 0
                                                                                                                                                                                         ELSIF nn = 0
                                                                                                                                                                                               THEN f!1(aa)
                                                                                                                                                                                               ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /
                                                                                                                                                                                                     factorial(nn)
                                                                                                                                                                                         ENDIF))") (("1" (inst - "RN" "bb!1" "f!1" "n!1") (("1" (assert) (("1" (case "(EXISTS (KK: real): RN(aa!1) = KK*(bb!1 - aa!1) ^ (n!1+1) /                                                     factorial(n!1+1))") (("1" (skosimp*) (("1" (name "PHI" "RN - (LAMBDA x: KK!1 * (bb!1 - x) ^ (n!1+1) / factorial(n!1+1))") (("1" (case "derivable?(PHI)") (("1" (case "PHI(aa!1) = 0 AND PHI(bb!1) = 0") (("1" (case "(EXISTS (cc: between(aa!1,bb!1)): deriv(PHI)(cc) = 0)") (("1" (skosimp*) (("1" (inst + "cc!1") (("1" (assert) (("1" (case-replace "RN(aa!1) = (nderiv(1 + n!1, f!1)(cc!1) * (bb!1 - aa!1) ^ (1 + n!1)) /
                                                                                                                                                                                                                                                      factorial(1 + n!1)") (("1" (hide -2 -3 -4 -5 -7) (("1" (replace -3 -1 rl) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -7) (("2" (replace -5 -1 rl) (("2" (lemma "deriv_diff_fun[T]") (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "n!1") (("2" (flatten) (("2" (inst?) (("1" (replace -3) (("1" (hide -3) (("1" (replace -9) (("1" (expand "-" -3) (("1" (case-replace "deriv((LAMBDA x: (KK!1 * (bb!1 - x) ^ (1 + n!1)) / factorial(1 + n!1))) =
                                                                                                                                                                                                                                                           -(LAMBDA x: (KK!1 * (bb!1 - x) ^ n!1) / factorial(n!1))") (("1" (hide -2 -3) (("1" (hide -1) (("1" (assert) (("1" (hide -2 -3 -4 -5 -7 -8) (("1" (replace -2) (("1" (hide -2) (("1" (expand "-" -) (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) = KK!1") (("1" (hide 2) (("1" (name-replace "BBCC" "(bb!1-cc!1)^n!1") (("1" (name-replace "FN" "factorial(n!1)") (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) * BBCC / FN  =((KK!1 * BBCC) / FN)") (("1" (hide -2) (("1" (assert) (("1" (case-replace "((KK!1 * BBCC) / FN) = KK!1 * (BBCC / FN)") (("1" (hide -1) (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) * BBCC / FN =
                                                                                                                                                                                                                                                                                                         nderiv(1 + n!1, f!1)(cc!1) * (BBCC / FN)") (("1" (hide -1) (("1" (name-replace bcfn "BBCC/FN") (("1" (lemma "both_sides_times1") (("1" (inst?) (("1" (assert) nil nil) ("2" (reveal -2 -6 -7) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (hide -1 2) (("2" (lemma "div_eq_zero") (("2" (inst?) (("2" (typepred "cc!1") (("2" (lemma "trich_lt" ("x" "aa!1" "y" "bb!1")) (("2" (split -1) (("1" (lemma "expt_nonzero" ("n0x" "bb!1-cc!1" "i" "n!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "expt_nonzero" ("n0x" "bb!1-cc!1" "i" "n!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9 2) (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "n!1") (("2" (flatten) (("2" (lemma "deriv_scal_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("1" (expand "*" -1 1) (("1" (case-replace "(LAMBDA (x_1578: real):
                                                                                                                                                     KK!1 * ((bb!1 - x_1578) ^ (1 + n!1) / factorial(1 + n!1))) =
                                                                                                                                       (LAMBDA (x_1578: real):
                                                                                                                                                     (KK!1 * (bb!1 - x_1578) ^ (1 + n!1)) / factorial(1 + n!1))") (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (expand "-") (("1" (apply-extensionality 1 :hide? t) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 2) (("3" (lemma "scal_derivable_fun[T]") (("3" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("3" (assert) (("3" (expand "*" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "scal_derivable_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("2" (assert) (("2" (expand "*" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 -6) (("2" (lemma "mean_value[T]") (("1" (case "aa!1 < bb!1") (("1" (inst - "aa!1" "bb!1" "PHI") (("1" (assert) (("1" (skosimp*) (("1" (replace -5) (("1" (replace -6) (("1" (inst + "c!1") (("1" (assert) (("1" (case-replace "deriv(PHI, c!1) * bb!1 - deriv(PHI, c!1) * aa!1 =
                                                                                                                                                       deriv(PHI, c!1) * (bb!1 - aa!1)") (("1" (hide -1) (("1" (rewrite "zero_times3") (("1" (expand "deriv" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "bb!1" "aa!1" "PHI") (("2" (assert) (("2" (skosimp*) (("2" (replace -5) (("2" (replace -4) (("2" (inst + "c!1") (("1" (assert) (("1" (case-replace "deriv(PHI, c!1) * aa!1 - deriv(PHI, c!1) * bb!1 =
                                                                                                                                                       deriv(PHI, c!1) * (aa!1 - bb!1)") (("1" (hide -1) (("1" (rewrite "zero_times3") (("1" (expand "deriv" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil) ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil) ("2" (hide -1 -5 -6) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (expand "-") (("2" (assert) (("2" (case-replace "(KK!1 * 0 ^ (1 + n!1)) / factorial(1 + n!1) = 0") (("1" (assert) (("1" (replace -3 * rl) (("1" (hide -1 -2 -3) (("1" (assert) (("1" (case-replace "(LAMBDA nn:
                                                                                                                     IF nn > n!1
                                                                                                                       THEN 0
                                                                                                                     ELSIF nn = 0
                                                                                                                           THEN f!1(bb!1)
                                                                                                                           ELSE nderiv(nn, f!1)(bb!1) * 0 ^ nn / factorial(nn)
                                                                                                                     ENDIF) = (LAMBDA nn: IF nn = 0
                                                                                                                           THEN f!1(bb!1)
                                                                                                                           ELSE 0 ENDIF)") (("1" (hide -1) (("1" (lemma "sigma_first_ge") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "sigma(1, n!1, (LAMBDA nn: IF nn = 0 THEN f!1(bb!1) ELSE 0 ENDIF)) = sigma(1, n!1, (LAMBDA nn: 0))") (("1" (hide -1) (("1" (lemma "sigma_const") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (reveal -8) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2 4) (("2" (expand "^") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 * rl) (("2" (hide -1 -2 -4) (("2" (lemma "diff_derivable_fun[T]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (split +) (("1" (lemma "taylor_derivable") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "scal_derivable_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x:
                                                                                                           (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("2" (assert) (("2" (expand "*" -1) (("2" (hide 2) (("2" (lemma "tay1") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (name-replace "FN" "factorial(n!1)") (("2" (name-replace "FN2" "factorial(n!1+1)") (("2" (name-replace "BBAA" "(bb!1-aa!1)^(n!1+1)") (("2" (inst + "RN(aa!1)/(BBAA/FN2)") (("1" (assert) nil nil) ("2" (hide -1 -2) (("2" (reveal -3 -4) (("2" (lemma "div_eq_zero") (("2" (inst?) (("2" (lemma "expt_nonzero" ("n0x" "bb!1-aa!1" "i" "n!1+1")) (("2" (typepred "factorial(n!1+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide -1 5) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((taylor_lemma formula-decl nil taylors nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil (derivable? const-decl "bool" derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_diff_fun formula-decl nil derivatives nil) (scal_derivable_fun formula-decl nil derivatives nil) (deriv_scal_fun formula-decl nil derivatives nil) (- const-decl "[numfield -> numfield]" number_fields nil) nil (both_sides_times1 formula-decl nil real_props nil) nil (nonzero_real nonempty-type-eq-decl nil reals nil) (trich_lt formula-decl nil real_props nil) (expt_nonzero formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (div_eq_zero formula-decl nil real_props nil) nil nil nil nil (tay3 formula-decl nil taylors nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil taylors nil) (not_one_element formula-decl nil taylors nil) nil nil nil (zero_times3 formula-decl nil real_props nil) (derivable? const-decl "bool" derivatives_def nil) (deriv const-decl "real" derivatives_def nil) (not_one_element? const-decl "bool" deriv_domain_def nil) (connected? const-decl "bool" deriv_domain_def nil) (mean_value formula-decl nil derivative_props nil) nil (derivable_n_times_lem formula-decl nil nth_derivatives nil) (taylor_derivable formula-decl nil taylors nil) (tay1 formula-decl nil taylors nil) (diff_derivable_fun formula-decl nil derivatives nil) nil nil (nat_exp application-judgement "nat" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (expt def-decl "real" exponentiation nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints) (sigma_first_ge formula-decl nil sigma_nat reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_const formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (int_times_even_is_even application-judgement "even_int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (between type-eq-decl nil taylors nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) nil (sigma def-decl "real" sigma reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (nat_expt application-judgement "nat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (Taylors-2 nil 3477738328 ("" (skosimp*) (("" (case-replace "bb!1 = aa!1") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (case-replace "(LAMBDA nn:
                                         IF nn > n!1
                                           THEN 0
                                         ELSIF nn = 0 THEN f!1(aa!1) ELSE 0 / factorial(nn)
                                         ENDIF)
                                          = (LAMBDA nn: IF nn = 0 THEN f!1(aa!1) ELSE 0 ENDIF)") (("1" (hide -1) (("1" (lemma "sigma_first_ge") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_const") (("1" (inst -1 "n!1" "1" "0") (("1" (case-replace "sigma(1, n!1, (LAMBDA nn: IF nn = 0 THEN f!1(aa!1) ELSE 0 ENDIF)) = sigma(1, n!1, LAMBDA (i: nat): 0)") (("1" (hide -1) (("1" (replace -1) (("1" (lift-if) (("1" (ground) (("1" (inst + "aa!1") nil nil) ("2" (inst + "aa!1") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "taylor_lemma") (("2" (name "RN" "(LAMBDA aa:
                                                                                                                                                                                f!1(bb!1) -
                                                                                                                                                                                 sigma(0, n!1,
                                                                                                                                                                                       LAMBDA nn:
                                                                                                                                                                                         IF nn > n!1
                                                                                                                                                                                           THEN 0
                                                                                                                                                                                         ELSIF nn = 0
                                                                                                                                                                                               THEN f!1(aa)
                                                                                                                                                                                               ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /
                                                                                                                                                                                                     factorial(nn)
                                                                                                                                                                                         ENDIF))") (("1" (inst - "RN" "bb!1" "f!1" "n!1") (("1" (assert) (("1" (case "(EXISTS (KK: real): RN(aa!1) = KK*(bb!1 - aa!1) ^ (n!1+1) /                                                     factorial(n!1+1))") (("1" (skosimp*) (("1" (name "PHI" "RN - (LAMBDA x: KK!1 * (bb!1 - x) ^ (n!1+1) / factorial(n!1+1))") (("1" (case "derivable?(PHI)") (("1" (case "PHI(aa!1) = 0 AND PHI(bb!1) = 0") (("1" (case "(EXISTS (cc: between(aa!1,bb!1)): deriv(PHI)(cc) = 0)") (("1" (skosimp*) (("1" (inst + "cc!1") (("1" (assert) (("1" (case-replace "RN(aa!1) = (nderiv(1 + n!1, f!1)(cc!1) * (bb!1 - aa!1) ^ (1 + n!1)) /
                                                                                                                                                                                                                                                      factorial(1 + n!1)") (("1" (hide -2 -3 -4 -5 -7) (("1" (replace -3 -1 rl) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -7) (("2" (replace -5 -1 rl) (("2" (lemma "deriv_diff_fun[T]") (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "n!1") (("2" (flatten) (("2" (inst?) (("1" (replace -3) (("1" (hide -3) (("1" (replace -9) (("1" (expand "-" -3) (("1" (case-replace "deriv((LAMBDA x: (KK!1 * (bb!1 - x) ^ (1 + n!1)) / factorial(1 + n!1))) =
                                                                                                                                                                                                                                                           -(LAMBDA x: (KK!1 * (bb!1 - x) ^ n!1) / factorial(n!1))") (("1" (hide -2 -3) (("1" (hide -1) (("1" (assert) (("1" (hide -2 -3 -4 -5 -7 -8) (("1" (replace -2) (("1" (hide -2) (("1" (expand "-" -) (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) = KK!1") (("1" (hide 2) (("1" (name-replace "BBCC" "(bb!1-cc!1)^n!1") (("1" (name-replace "FN" "factorial(n!1)") (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) * BBCC / FN  =((KK!1 * BBCC) / FN)") (("1" (hide -2) (("1" (assert) (("1" (case-replace "((KK!1 * BBCC) / FN) = KK!1 * (BBCC / FN)") (("1" (hide -1) (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) * BBCC / FN =
                                                                                                                                                                                                                                                                                                         nderiv(1 + n!1, f!1)(cc!1) * (BBCC / FN)") (("1" (hide -1) (("1" (name-replace bcfn "BBCC/FN") (("1" (lemma "both_sides_times1") (("1" (inst?) (("1" (assert) nil nil) ("2" (reveal -2 -6 -7) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (hide -1 2) (("2" (lemma "div_eq_zero") (("2" (inst?) (("2" (typepred "cc!1") (("2" (lemma "trich_lt" ("x" "aa!1" "y" "bb!1")) (("2" (split -1) (("1" (lemma "expt_nonzero" ("n0x" "bb!1-cc!1" "i" "n!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "expt_nonzero" ("n0x" "bb!1-cc!1" "i" "n!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9 2) (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "n!1") (("2" (flatten) (("2" (lemma "deriv_scal_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("1" (expand "*" -1 1) (("1" (case-replace "(LAMBDA (x_1578: real):
                                                                                                                                                     KK!1 * ((bb!1 - x_1578) ^ (1 + n!1) / factorial(1 + n!1))) =
                                                                                                                                       (LAMBDA (x_1578: real):
                                                                                                                                                     (KK!1 * (bb!1 - x_1578) ^ (1 + n!1)) / factorial(1 + n!1))") (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (expand "-") (("1" (apply-extensionality 1 :hide? t) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 2) (("3" (lemma "scal_derivable_fun[T]") (("3" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("3" (assert) (("3" (expand "*" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "scal_derivable_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("2" (assert) (("2" (expand "*" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 -6) (("2" (lemma "mean_value[T]") (("1" (case "aa!1 < bb!1") (("1" (inst - "aa!1" "bb!1" "PHI") (("1" (assert) (("1" (skosimp*) (("1" (replace -5) (("1" (replace -6) (("1" (inst + "c!1") (("1" (assert) (("1" (case-replace "deriv(PHI, c!1) * bb!1 - deriv(PHI, c!1) * aa!1 =
                                                                                                                                                       deriv(PHI, c!1) * (bb!1 - aa!1)") (("1" (hide -1) (("1" (rewrite "zero_times3") (("1" (expand "deriv" 1) (("1" (propax) nil nil)) nil) ("2" (lemma "deriv_domain") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "deriv_domain") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "bb!1" "aa!1" "PHI") (("2" (assert) (("2" (skosimp*) (("2" (replace -5) (("2" (replace -4) (("2" (inst + "c!1") (("1" (assert) (("1" (case-replace "deriv(PHI, c!1) * aa!1 - deriv(PHI, c!1) * bb!1 =
                                                                                                                                                       deriv(PHI, c!1) * (aa!1 - bb!1)") (("1" (hide -1) (("1" (rewrite "zero_times3") (("1" (expand "deriv" +) (("1" (propax) nil nil)) nil) ("2" (lemma "deriv_domain") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "deriv_domain") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil) ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil) ("2" (hide -1 -5 -6) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (expand "-") (("2" (assert) (("2" (case-replace "(KK!1 * 0 ^ (1 + n!1)) / factorial(1 + n!1) = 0") (("1" (assert) (("1" (replace -3 * rl) (("1" (hide -1 -2 -3) (("1" (assert) (("1" (case-replace "(LAMBDA nn:
                                                                                                                     IF nn > n!1
                                                                                                                       THEN 0
                                                                                                                     ELSIF nn = 0
                                                                                                                           THEN f!1(bb!1)
                                                                                                                           ELSE nderiv(nn, f!1)(bb!1) * 0 ^ nn / factorial(nn)
                                                                                                                     ENDIF) = (LAMBDA nn: IF nn = 0
                                                                                                                           THEN f!1(bb!1)
                                                                                                                           ELSE 0 ENDIF)") (("1" (hide -1) (("1" (lemma "sigma_first_ge") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "sigma(1, n!1, (LAMBDA nn: IF nn = 0 THEN f!1(bb!1) ELSE 0 ENDIF)) = sigma(1, n!1, (LAMBDA nn: 0))") (("1" (hide -1) (("1" (lemma "sigma_const") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (reveal -8) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2 4) (("2" (expand "^") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 * rl) (("2" (hide -1 -2 -4) (("2" (lemma "diff_derivable_fun[T]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (split +) (("1" (lemma "taylor_derivable") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "scal_derivable_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x:
                                                                                                           (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("2" (assert) (("2" (expand "*" -1) (("2" (hide 2) (("2" (lemma "tay1") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (name-replace "FN" "factorial(n!1)") (("2" (name-replace "FN2" "factorial(n!1+1)") (("2" (name-replace "BBAA" "(bb!1-aa!1)^(n!1+1)") (("2" (inst + "RN(aa!1)/(BBAA/FN2)") (("1" (assert) nil nil) ("2" (hide -1 -2) (("2" (reveal -3 -4) (("2" (lemma "div_eq_zero") (("2" (inst?) (("2" (lemma "expt_nonzero" ("n0x" "bb!1-aa!1" "i" "n!1+1")) (("2" (typepred "factorial(n!1+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide -1 5) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((factorial def-decl "posnat" factorial ints) (sigma_first_ge formula-decl nil sigma_nat reals) (sigma_const formula-decl nil sigma reals) (sigma def-decl "real" sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (derivable? const-decl "bool" derivatives nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_scal_fun formula-decl nil derivatives nil) (scal_derivable_fun formula-decl nil derivatives nil) (deriv_diff_fun formula-decl nil derivatives nil) (mean_value formula-decl nil derivative_props nil) (connected? const-decl "bool" deriv_domain_def nil) (not_one_element? const-decl "bool" deriv_domain_def nil) (derivable? const-decl "bool" derivatives_def nil) (deriv const-decl "real" derivatives_def nil) (diff_derivable_fun formula-decl nil derivatives nil)) nil) (Taylors-1 nil 3255192119 ("" (skosimp*) (("" (case-replace "bb!1 = aa!1") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (case-replace "(LAMBDA nn:
                                     IF nn > n!1
                                       THEN 0
                                     ELSIF nn = 0 THEN f!1(aa!1) ELSE 0 / factorial(nn)
                                     ENDIF)
                                      = (LAMBDA nn: IF nn = 0 THEN f!1(aa!1) ELSE 0 ENDIF)") (("1" (hide -1) (("1" (lemma "sigma_first_ge") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_const") (("1" (inst -1 "n!1" "1" "0") (("1" (case-replace "sigma(1, n!1, (LAMBDA nn: IF nn = 0 THEN f!1(aa!1) ELSE 0 ENDIF)) = sigma(1, n!1, LAMBDA (i: nat): 0)") (("1" (hide -1) (("1" (replace -1) (("1" (lift-if) (("1" (ground) (("1" (inst + "aa!1") nil nil) ("2" (inst + "aa!1") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "taylor_lemma") (("2" (name "RN" "(LAMBDA aa:
                                                                                                                                                                       f!1(bb!1) -
                                                                                                                                                                        sigma(0, n!1,
                                                                                                                                                                              LAMBDA nn:
                                                                                                                                                                                IF nn > n!1
                                                                                                                                                                                  THEN 0
                                                                                                                                                                                ELSIF nn = 0
                                                                                                                                                                                      THEN f!1(aa)
                                                                                                                                                                                      ELSE nderiv(nn, f!1)(aa) * (bb!1 - aa) ^ nn /
                                                                                                                                                                                            factorial(nn)
                                                                                                                                                                                ENDIF))") (("1" (inst - "RN" "bb!1" "f!1" "n!1") (("1" (assert) (("1" (case "(EXISTS (KK: real): RN(aa!1) = KK*(bb!1 - aa!1) ^ (n!1+1) /                                                     factorial(n!1+1))") (("1" (skosimp*) (("1" (name "PHI" "RN - (LAMBDA x: KK!1 * (bb!1 - x) ^ (n!1+1) / factorial(n!1+1))") (("1" (case "derivable?(PHI)") (("1" (case "PHI(aa!1) = 0 AND PHI(bb!1) = 0") (("1" (case "(EXISTS (cc: between(aa!1,bb!1)): deriv(PHI)(cc) = 0)") (("1" (skosimp*) (("1" (inst + "cc!1") (("1" (assert) (("1" (case-replace "RN(aa!1) = (nderiv(1 + n!1, f!1)(cc!1) * (bb!1 - aa!1) ^ (1 + n!1)) /
                                                                                                                                                                                                                                        factorial(1 + n!1)") (("1" (hide -2 -3 -4 -5 -7) (("1" (replace -3 -1 rl) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -7) (("2" (replace -5 -1 rl) (("2" (lemma "deriv_diff_fun[T]") (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "n!1") (("2" (flatten) (("2" (inst?) (("1" (replace -3) (("1" (hide -3) (("1" (replace -9) (("1" (expand "-" -3) (("1" (case-replace "deriv((LAMBDA x: (KK!1 * (bb!1 - x) ^ (1 + n!1)) / factorial(1 + n!1))) =
                                                                                                                                                                                                                                         -(LAMBDA x: (KK!1 * (bb!1 - x) ^ n!1) / factorial(n!1))") (("1" (hide -2 -3) (("1" (hide -1) (("1" (assert) (("1" (hide -2 -3 -4 -5 -7 -8) (("1" (replace -2) (("1" (hide -2) (("1" (expand "-" -) (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) = KK!1") (("1" (hide 2) (("1" (name-replace "BBCC" "(bb!1-cc!1)^n!1") (("1" (name-replace "FN" "factorial(n!1)") (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) * BBCC / FN  =((KK!1 * BBCC) / FN)") (("1" (hide -2) (("1" (assert) (("1" (case-replace "((KK!1 * BBCC) / FN) = KK!1 * (BBCC / FN)") (("1" (hide -1) (("1" (case-replace "nderiv(1 + n!1, f!1)(cc!1) * BBCC / FN =
                                                                                                                                                                                                                                                                                 nderiv(1 + n!1, f!1)(cc!1) * (BBCC / FN)") (("1" (hide -1) (("1" (name-replace bcfn "BBCC/FN") (("1" (lemma "both_sides_times1") (("1" (inst?) (("1" (assert) nil nil) ("2" (reveal -2 -6 -7) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (hide -1 2) (("2" (lemma "div_eq_zero") (("2" (inst?) (("2" (typepred "cc!1") (("2" (lemma "trich_lt" ("x" "aa!1" "y" "bb!1")) (("2" (split -1) (("1" (lemma "expt_nonzero" ("n0x" "bb!1-cc!1" "i" "n!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "expt_nonzero" ("n0x" "bb!1-cc!1" "i" "n!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -7 -8 -9 2) (("2" (lemma "tay3") (("2" (inst -1 "bb!1" "n!1") (("2" (flatten) (("2" (lemma "deriv_scal_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("1" (expand "*" -1 1) (("1" (case-replace "(LAMBDA (x_1578: real):
                                                                                                                               KK!1 * ((bb!1 - x_1578) ^ (1 + n!1) / factorial(1 + n!1))) =
                                                                                                                 (LAMBDA (x_1578: real):
                                                                                                                               (KK!1 * (bb!1 - x_1578) ^ (1 + n!1)) / factorial(1 + n!1))") (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (expand "-") (("1" (apply-extensionality 1 :hide? t) (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 2) (("3" (lemma "scal_derivable_fun[T]") (("3" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("3" (assert) (("3" (expand "*" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "scal_derivable_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x: (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("2" (assert) (("2" (expand "*" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 -6) (("2" (lemma "mean_value[T]") (("1" (case "aa!1 < bb!1") (("1" (inst - "aa!1" "bb!1" "PHI") (("1" (assert) (("1" (skosimp*) (("1" (replace -5) (("1" (replace -6) (("1" (inst + "c!1") (("1" (assert) (("1" (case-replace "deriv(PHI, c!1) * bb!1 - deriv(PHI, c!1) * aa!1 =
                                                                                                                                   deriv(PHI, c!1) * (bb!1 - aa!1)") (("1" (hide -1) (("1" (rewrite "zero_times3") (("1" (expand "deriv" 1) (("1" (propax) nil nil)) nil) ("2" (lemma "deriv_domain") (("2" (expand "deriv_domain?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "deriv_domain") (("3" (expand "deriv_domain?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "bb!1" "aa!1" "PHI") (("2" (assert) (("2" (skosimp*) (("2" (replace -5) (("2" (replace -4) (("2" (inst + "c!1") (("1" (assert) (("1" (case-replace "deriv(PHI, c!1) * aa!1 - deriv(PHI, c!1) * bb!1 =
                                                                                                                                   deriv(PHI, c!1) * (aa!1 - bb!1)") (("1" (hide -1) (("1" (rewrite "zero_times3") (("1" (expand "deriv" +) (("1" (propax) nil nil)) nil) ("2" (lemma "deriv_domain") (("2" (expand "deriv_domain?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "deriv_domain") (("3" (expand "deriv_domain?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil) ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil) ("2" (hide -1 -5 -6) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (expand "-") (("2" (assert) (("2" (case-replace "(KK!1 * 0 ^ (1 + n!1)) / factorial(1 + n!1) = 0") (("1" (assert) (("1" (replace -3 * rl) (("1" (hide -1 -2 -3) (("1" (assert) (("1" (case-replace "(LAMBDA nn:
                                                                                                       IF nn > n!1
                                                                                                         THEN 0
                                                                                                       ELSIF nn = 0
                                                                                                             THEN f!1(bb!1)
                                                                                                             ELSE nderiv(nn, f!1)(bb!1) * 0 ^ nn / factorial(nn)
                                                                                                       ENDIF) = (LAMBDA nn: IF nn = 0
                                                                                                             THEN f!1(bb!1)
                                                                                                             ELSE 0 ENDIF)") (("1" (hide -1) (("1" (lemma "sigma_first_ge") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "sigma(1, n!1, (LAMBDA nn: IF nn = 0 THEN f!1(bb!1) ELSE 0 ENDIF)) = sigma(1, n!1, (LAMBDA nn: 0))") (("1" (hide -1) (("1" (lemma "sigma_const") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality 1 :hide? t) (("1" (lift-if) (("1" (ground) (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (reveal -8) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2 4) (("2" (expand "^") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 * rl) (("2" (hide -1 -2 -4) (("2" (lemma "diff_derivable_fun[T]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (split +) (("1" (lemma "taylor_derivable") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "scal_derivable_fun[T]") (("2" (inst -1 "KK!1" "(LAMBDA x:
                                                                                               (bb!1 - x) ^ (1 + n!1) / factorial(1 + n!1))") (("2" (assert) (("2" (expand "*" -1) (("2" (hide 2) (("2" (lemma "tay1") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (name-replace "FN" "factorial(n!1)") (("2" (name-replace "FN2" "factorial(n!1+1)") (("2" (name-replace "BBAA" "(bb!1-aa!1)^(n!1+1)") (("2" (inst + "RN(aa!1)/(BBAA/FN2)") (("1" (assert) nil nil) ("2" (hide -1 -2) (("2" (reveal -3 -4) (("2" (lemma "div_eq_zero") (("2" (inst?) (("2" (lemma "expt_nonzero" ("n0x" "bb!1-aa!1" "i" "n!1+1")) (("2" (typepred "factorial(n!1+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide -1 5) (("2" (assert) (("2" (lemma "derivable_n_times_lem[T]" ("f" "f!1" "n" "1+n!1" "m" "nn!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((factorial def-decl "posnat" factorial ints) (sigma_first_ge formula-decl nil sigma_nat reals) (sigma_const formula-decl nil sigma reals) (sigma def-decl "real" sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (nderiv def-decl "[T -> real]" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (derivable? const-decl "bool" derivatives nil) (derivable_n_times_lem formula-decl nil nth_derivatives nil) (deriv_fun type-eq-decl nil derivatives nil) (deriv const-decl "[T -> real]" derivatives nil) (deriv_scal_fun formula-decl nil derivatives nil) (scal_derivable_fun formula-decl nil derivatives nil) (deriv_diff_fun formula-decl nil derivatives nil) (mean_value formula-decl nil derivative_props nil) (deriv_domain? const-decl "bool" deriv_domain_def nil) (derivable? const-decl "bool" derivatives_def nil) (deriv const-decl "real" derivatives_def nil) (diff_derivable_fun formula-decl nil derivatives nil)) nil)) (Taylor_term_TCC1 0 (Taylor_term_TCC1-2 "" 3790090859 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil) (inf_deriv_fun? const-decl "bool" taylors nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Taylor_term subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.n)")) (Taylor_term_TCC1-1 nil 3298375816 ("" (subtype-tcc) (("" (postpone) nil nil)) nil) nil shostak (Taylor_term subtype "taylors.f" "nth_derivatives[T].nderiv_fun(taylors.n)"))) (Taylors_inf_TCC1 0 (Taylors_inf_TCC1-2 "" 3790090859 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (T_pred const-decl "[real -> boolean]" taylors nil) (T formal-subtype-decl nil taylors nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (between type-eq-decl nil taylors nil) (inf_deriv_fun? const-decl "bool" taylors nil)) shostak (Taylors_inf subtype "taylors.f" "nth_derivatives[T].nderiv_fun((number_fields.+)(1, taylors.n))")) (Taylors_inf_TCC1-1 nil 3298376642 ("" (subtype-tcc) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) nil shostak (Taylors_inf subtype "taylors.f" "nth_derivatives[T].nderiv_fun((number_fields.+)(1, taylors.n))"))) (Taylors_inf 0 (Taylors_inf-1 nil 3298376718 ("" (skosimp*) (("" (lemma "Taylors") (("" (inst?) (("" (inst - "aa!1" "n!1") (("" (split -1) (("1" (skosimp*) (("1" (inst + "c!1") (("1" (expand "Taylor_rem") (("1" (expand "Taylor_term") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (rewrite "sigma_restrict_eq") (("1" (hide 2) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (hide 3) (("2" (expand "derivable_n_times?") (("2" (ground) (("1" (expand "inf_deriv_fun?") (("1" (inst - "1") (("1" (expand "derivable_n_times?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "inf_deriv_fun?") (("2" (inst?) (("2" (lemma "derivable_n_times_def[T]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) (("3" (expand "inf_deriv_fun?") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "inf_deriv_fun?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Taylors formula-decl nil taylors nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (between type-eq-decl nil taylors nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Taylor_term const-decl "real" taylors nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_restrict_eq formula-decl nil sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (derivable_n_times? def-decl "bool" nth_derivatives nil) (nderiv_fun type-eq-decl nil nth_derivatives nil) (nderiv def-decl "[T -> real]" nth_derivatives nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (factorial def-decl "posnat" factorial ints) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (derivable_n_times_def formula-decl nil nth_derivatives nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (inf_deriv_fun? const-decl "bool" taylors nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Taylor_rem const-decl "real" taylors nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-subtype-decl nil taylors nil) (T_pred const-decl "[real -> boolean]" taylors nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)))
