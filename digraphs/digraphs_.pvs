%==============================================================================%
%                                                                              %
% This theory contains basic definitions and properties for interpretations of %
% digraphs, as stated in "digraphs_abs.pvs".                                   %
%                                                                              %
% It is based on the previous version of the theory digraphs.pvs.              %
%                                                                              %
%   Ricky W. Butler        NASA Langley Research Center (US)      2004         %
%   Kristin Y. Rozier      NASA Langley Research Center (US)      2004         %
%   Jon Sjogren            AFOSR (US)                             2004         %
%   Mariano Moscato        National Institute of Aerospace (US)   2015         %
%                                                                              %
%==============================================================================%
digraphs_[ T: TYPE, 
	   ConcreteDigraph: TYPE,
	   vert: [ConcreteDigraph-> [T -> bool]],
	   edges: [ConcreteDigraph -> [T,T -> bool]],
	   make: [ v:(is_finite[T]),
	          {e: (is_finite[[T,T]]) | FORALL(x,y:T): 
		     e(x,y) IMPLIES v(x) AND v(y) } -> ConcreteDigraph] ]: THEORY 
BEGIN
  ASSUMING
    % This theory only makes sense if the parametric type ConcreteDigraph is a 
    % correct interpretation for (uninterpreted) digraphs. That is checked using 
    % the predicate defined in digraphs_abs.
    IMPORTING digraphs_abs[T,ConcreteDigraph,vert,edges,make]
    concretedigraph_implements_abstractdigraph: ASSUMPTION
      digraphs_abs.correct_implementation
  ENDASSUMING

  AUTO_REWRITE+ concretedigraph_implements_abstractdigraph

 % observational equality
 obs_eq(G1,G2: ConcreteDigraph): bool =
   vert(G1) = vert(G2) AND edges(G1) = edges(G2)

%------------------------------------------------------------------------------%
% Basic definitions.                                                           %
%------------------------------------------------------------------------------%

  G: var ConcreteDigraph

  x,y,v: VAR T
  IMPORTING digraphs_utils[T]
  e: VAR edgetype

  % A simple digraph is a graph without loops
  simple_digraph: TYPE = {G | FORALL e: edges(G)(e) IMPLIES 
                                        LET (x,y) = e IN x /= y}

  sd_graph      : TYPE = simple_digraph

  % An empty digraph: empty set of vertices and empty set of edges
  empty_digraph: ConcreteDigraph =
    make(emptyset[T],emptyset[edgetype])

  vert?(G)(x)  : bool = vert(G)(x)
  edge?(G)(x,y): bool = edges(G)((x,y))
 
  edge(G) : TYPE = (edge?(G))
  vert(G) : TYPE = (vert?(G))

  adjs(G)(x): finite_set[T] = {y|edges(G)(x,y)}

  edges_vert      : LEMMA in?(x,e) AND edges(G)(e) IMPLIES
                             (EXISTS y: vert(G)(y) AND in?(y,e))


  other_vert      : LEMMA in?(v,e) AND edges(G)(e)
                          IMPLIES (EXISTS (u: T): vert(G)(u) AND 
                                       e = (u, v) OR e = (v,u))

  edges_to_pair   : LEMMA edges(G)(e) IMPLIES
                            (EXISTS x,y: edges(G)(x,y) 
                                     AND vert(G)(x) AND vert(G)(y)
                                     AND x = proj_1(e) AND y = proj_2(e)) 

  % Size of digraphs.

  size(G): nat = card[T](vert(G))

  empty?(G): bool = empty?(vert(G))

%------------------------------------------------------------------------------%
% Kinds of digraphs.                                                           %
%------------------------------------------------------------------------------%

  singleton?(G): bool = (size(G) = 1)

  isolated?(G): bool = empty?(edges(G))

  bidirected?(G)(x,y): bool = edges(G)(x,y) AND edges(G)(y,x)

  %A complete digraph differs from a complete graph in that each edge must be
  %bidirected.
  complete?(G): bool = 
                      FORALL (x:T | (vert(G)(x)), y:T | (vert(G)(y) AND x /= y)):
                         edges(G)(x,y) OR edges(G)(y,x)

  digraph_complete?(G): bool = 
                      FORALL (x:T | (vert(G)(x)), y:T | (vert(G)(y) AND x /= y)):
                         bidirected?(G)(x,y)

  complete_digraph: TYPE = {G | complete?(G)}

  %An oriented graph has no bidirected edges:
  oriented?(G): bool = FORALL (x:T | (vert(G)(x)), y:T | (vert(G)(y) AND x/=y)):
                            NOT bidirected?(G)(x,y)

  oriented_digraph: TYPE = {G | oriented?(G)}

  tournament?(G): bool = complete?(G) AND oriented?(G)

  tournament: TYPE = {G | tournament?(G)}

  empty?_rew          : LEMMA empty?(G) = (card(vert(G)) = 0)

  empty_size          : LEMMA empty?(G) IFF size(G) = 0

  edges_of_empty      : LEMMA empty?(G) 
                                 IMPLIES edges(G) = emptyset[edgetype]

  singleton_edges     : LEMMA FORALL (SG: simple_digraph): 
                                   singleton?(SG) IMPLIES empty?(edges(SG))

  edge_in_card_gt_1   : LEMMA FORALL (SG: simple_digraph): 
                                   edges(SG)(e) IMPLIES card(vert(SG)) > 1

  not_singleton_2_vert: LEMMA NOT empty?(G) AND NOT singleton?(G) 
                                IMPLIES (EXISTS (x,y: T): x /= y AND
                                     vert(G)(x) AND vert(G)(y))

  proj_rew: LEMMA (proj_1(e), proj_2(e)) = e

  infdigraph: TYPE = [# vert : set[T],
                      edges: set[edgetype] #]

  is_digraph(g: infdigraph): bool = is_finite[T](vert(g))
                                AND is_finite[edgetype](edges(g))
                                AND (FORALL (e: edgetype): edges(g)(e) 
                             IMPLIES (FORALL x: in?(x,e) IMPLIES vert(g)(x)))

  singleton_digraph(v): ConcreteDigraph = 
   make(singleton[T](v), emptyset[edgetype])
  
  is_sing:  LEMMA singleton?(singleton_digraph(x))

  Digraph: TYPE = {G | nonempty?(vert(G))}

END digraphs_
