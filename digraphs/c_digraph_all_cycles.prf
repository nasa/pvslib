(c_digraph_all_cycles (loi_cons 0 (loi_cons-1 nil 3655568650 ("" (skeep) (("" (expand "list_of_idxs") (("" (skeep) (("" (inst -1 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (n skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (i skolem-const-decl "below(length(l))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (l skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (size const-decl "nat" c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nth def-decl "T" list_props nil)) shostak)) (walk?_TCC1 0 (walk?_TCC1-1 nil 3655548129 ("" (subtype-tcc) nil nil) nil nil (walk? subtype "(number_fields.+)(c_digraph_all_cycles.i, 1)" "below[length[nat](l)]"))) (walk?_TCC2 0 (walk?_TCC2-1 nil 3655548129 ("" (subtype-tcc) nil nil) nil nil (walk? subtype "c_digraph_all_cycles.i" "below[length[nat](l)]"))) (walk?_TCC3 0 (walk?_TCC3-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (l!1 skolem-const-decl "(list_of_idxs[T](C!1))" c_digraph_all_cycles nil) (i!1 skolem-const-decl "below(length[nat](l!1) - 1)" c_digraph_all_cycles nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil)) nil (walk? subtype "list_props[nat].nth(c_digraph_all_cycles.l, c_digraph_all_cycles.i)" "below[length[list[nat]](adjs(C))]"))) (walk_append_TCC1 0 (walk_append_TCC1-1 nil 3655576611 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil)) nil (walk_append subtype "c_digraph_all_cycles.l2" "(list_adt[nat].cons?)"))) (walk_append_TCC2 0 (walk_append_TCC2-1 nil 3655576611 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (C!1 skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil)) nil (walk_append subtype "more_list_props[nat].last(c_digraph_all_cycles.l1)" "below[length[list[nat]](adjs(C))]"))) (walk_append_TCC3 0 (walk_append_TCC3-1 nil 3655576611 ("" (skeep*) (("" (use "loi_append") (("" (assert) nil nil)) nil)) nil) ((T formal-type-decl nil c_digraph_all_cycles nil) (loi_append formula-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (walk_append subtype "list_props[nat].append(c_digraph_all_cycles.l1, c_digraph_all_cycles.l2)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (walk_append 0 (walk_append-2 "" 3804532594 ("" (skeep 1 :but ("l1")) (("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (skolem 1 ("v" "vs")) (("5" (flatten) (("5" (use "loi_cons") (("5" (assert) (("5" (case "walk?(C)(vs)") (("1" (assert) (("1" (split -7) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "walk?" 1) (("1" (skeep :preds? t) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (assert) (("1" (expand "nth" -7 (1 3)) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -5) (("2" (flatten) (("2" (inst -5 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "append" 1) (("2" (expand "walk?" 1) (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (expand "nth" -7 (1 3)) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "length(vs)=0") (("1" (expand "walk?" -4) (("1" (flatten) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -5) (("1" (expand "walk?" -1) (("1" (flatten) (("1" (inst -1 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT null?(vs)") (("1" (expand "walk?" 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (expand "walk?" -4) (("2" (skeep 1) (("2" (inst -4 "i+1") (("1" (assert) (("1" (expand "nth" -4 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 2) (("2" (expand "append" 2) (("2" (assert) (("2" (expand "walk?" 2) (("2" (skeep 2 :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 2 (1 3)) (("1" (case "last(cons(v,vs))=v") (("1" (replace -1 :hide? t) (("1" (expand "nth" 2 1) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3 1) (("2" (expand "walk?" -7) (("2" (inst -7 "i-1") (("1" (assert) (("1" (expand "nth" 3 3) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (skeep*) (("8" (use "loi_append") (("8" (assert) nil nil)) nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (skeep*) (("11" (expand "list_of_idxs") (("11" (expand "size") (("11" (expand "last") (("11" (inst -2 "length(l1)-1") (("1" (assert) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil)) nil)) nil) nil shostak) (walk_append-1 nil 3656062706 ("" (skeep 1 :but ("l1")) (("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (skolem 1 ("v" "vs")) (("5" (flatten) (("5" (use "loi_cons") (("5" (assert) (("5" (case "walk?(C)(vs)") (("1" (assert) (("1" (split -7) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "walk?" 1) (("1" (skeep :preds? t) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (assert) (("1" (expand "nth" -7 (1 3)) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -5) (("2" (flatten) (("2" (inst -5 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "append" 1) (("2" (expand "walk?" 1) (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (expand "nth" -7 (1 3)) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "length(vs)=0") (("1" (expand "walk?" -4) (("1" (flatten) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -5) (("1" (expand "walk?" -1) (("1" (flatten) (("1" (inst -1 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT null?(vs)") (("1" (expand "walk?" 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (expand "walk?" -4) (("2" (skeep 1) (("2" (inst -4 "i+1") (("1" (assert) (("1" (expand "nth" -4 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 2) (("2" (expand "append" 2) (("2" (assert) (("2" (expand "walk?" 2) (("2" (skeep 2 :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 2 (1 3)) (("1" (case "last(cons(v,vs))=v") (("1" (replace -1 :hide? t) (("1" (expand "nth" 2 1) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3 1) (("2" (expand "walk?" -7) (("2" (inst -7 "i-1") (("1" (assert) (("1" (expand "nth" 3 3) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (skeep*) (("8" (use "loi_append") (("8" (assert) nil nil)) nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (skeep*) (("11" (expand "list_of_idxs") (("11" (expand "size") (("11" (expand "last") (("11" (inst -4 "length(l1)-1") (("1" (assert) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (l2 skolem-const-decl "(list_of_idxs(C))" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (last const-decl "T" more_list_props structures) (< const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (member def-decl "bool" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list_induction formula-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (size const-decl "nat" c_digraphs_def nil) (i skolem-const-decl "below(length(vs) - 1)" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(cons(v, l2)) - 1)" c_digraph_all_cycles nil) (nth_append formula-decl nil more_list_props structures) (i skolem-const-decl "below(length(cons(v, append(vs, l2))) - 1)" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vs skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (v skolem-const-decl "nat" c_digraph_all_cycles nil) (int_plus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below(length(cons(v, append(vs, l2))) - 1)" c_digraph_all_cycles nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (loi_cons formula-decl nil c_digraph_all_cycles nil) (loi_append formula-decl nil c_digraphs_def nil) (TRUE const-decl "bool" booleans nil) (l1 skolem-const-decl "list[nat]" c_digraph_all_cycles nil)) shostak)) (circuit?_TCC1 0 (circuit?_TCC1-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil)) nil (circuit? subtype "c_digraph_all_cycles.w" "(list_adt[nat].cons?)"))) (circuit?_TCC2 0 (circuit?_TCC2-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil)) nil (circuit? subtype "c_digraph_all_cycles.w" "{l: list_adt[nat].list | (booleans.NOT)(list_adt[nat].null?(l))}"))) (no_repetitions_prefix 0 (no_repetitions_prefix-1 nil 3656073052 ("" (skeep) (("" (use "prefix_supl[nat]") (("" (assert) (("" (skeep) (("" (replace -1 :hide? t :dir rl) (("" (hide -2) (("" (expand "no_repetitions?") (("" (skeep 1 :preds? t) (("" (inst -3 "i" "j") (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (assert) (("1" (replace -1 :hide? t) (("1" (use "nth_append[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil) ("3" (use "length_append[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix_supl formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (j skolem-const-decl "below(length(l1))" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (l1 skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (i skolem-const-decl "below(length(l1))" c_digraph_all_cycles nil) (append def-decl "list[T]" list_props nil) (L skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures)) shostak)) (norep_loi_length 0 (norep_loi_length-1 nil 3656074107 ("" (skeep :preds? t) (("" (hide -2) (("" (lemma "list_pigeonhole[nat]") (("" (inst -1 "fullset[naturalnumbers.below(size(C))]" "l") (("1" (split -1) (("1" (skeep) (("1" (expand "no_repetitions?") (("1" (inst -4 "n" "m") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (use "every_nth[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (expand "extend") (("2" (expand "list_of_idxs") (("2" (inst -2 "i") (("2" (assert) (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "card(fullset[naturalnumbers.below(size(C))]) =size(C)") (("1" (assert) nil nil) ("2" (use "below_prelude_card") nil nil)) nil)) nil) ("2" (use "finite_extension[nat,below(size(C))]") (("2" (replace -1 :hide? t) (("2" (use "finite_full[below(size(C))]") (("2" (replace -1 :hide? t :dir rl) (("2" (expand "is_finite_type") (("2" (inst 1 "size(C)" "LAMBDA(i:below(size(C))):i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fullset const-decl "set" sets nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (below type-eq-decl nil naturalnumbers nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below_prelude_card formula-decl nil ordered_nat orders) (every_nth formula-decl nil list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (injective? const-decl "bool" functions nil) (is_finite_type const-decl "bool" finite_sets nil) (finite_full formula-decl nil finite_sets nil) (finite_extension formula-decl nil extend_set_props nil) (list_pigeonhole formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (cycle?_TCC1 0 (cycle?_TCC1-1 nil 3655551876 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycle? subtype "c_digraph_all_cycles.c" "(list_adt[nat].cons?)"))) (cycle_prefix 0 (cycle_prefix-1 nil 3656082121 ("" (skeep) (("" (use "prefix_supl[nat]") (("" (replace -1 :hide? t) (("" (skeep) (("" (case "L=null") (("1" (replace -1 :hide? t) (("1" (use "append_null[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "car(c2)=last(c2)") (("1" (case "car(c1) = last(c1)") (("1" (case "car(c1) = car(c2)") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "last") (("1" (expand "cycle?" -3) (("1" (expand "no_repetitions?") (("1" (case "length(c1)>=2") (("1" (case "length(c2)>=2") (("1" (expand "nth" -3) (("1" (assert) (("1" (inst -5 "length(c1)-2" "length(c2)-2") (("1" (split -5) (("1" (expand "/=") (("1" (replace -3 :hide? t :dir rl) (("1" (replace -4 :hide? t :dir rl) (("1" (expand "append" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "c1") (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (hide-all-but (-1 -6 1)) (("2" (replace -2 :hide? t :dir rl) (("2" (use "length_append[nat]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 :hide? t :dir rl) (("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (typepred "c1") (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "c2") (("2" (expand "circuit?" -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "c1") (("2" (expand "circuit?" -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (lift-if -5) (("2" (split -5) (("1" (flatten) (("1" (typepred "c1") (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "c1") (("2" (expand "circuit?") (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "c1") (("3" (expand "walk?") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "c1") (("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "c2") (("2" (expand "circuit?" -4) (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "c2") (("3" (expand "walk?") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "c2") (("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix_supl formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (/= const-decl "boolean" notequal nil) (length_append formula-decl nil list_props nil) (below type-eq-decl nil naturalnumbers nil) (c2 skolem-const-decl "(circuit?(C))" c_digraph_all_cycles nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (c1 skolem-const-decl "(circuit?(C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (last const-decl "T" more_list_props structures) (append_null formula-decl nil list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (cycle_construction_loi 0 (cycle_construction_loi-1 nil 3656764704 ("" (skeep) (("" (expand "list_of_idxs") (("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (expand "list_of_idxs") (("" (use "reverse_def[nat]") (("" (assert) (("" (split -1) (("1" (replaces -1) (("1" (inst?) (("1" (hide 2) (("1" (typepred "i") (("1" (use "length_reverse[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (length_reverse formula-decl nil list_props nil) (i skolem-const-decl "below(length(reverse[nat](walked)))" c_digraph_all_cycles nil) (walked skolem-const-decl "(list_of_idxs[T](C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (reverse def-decl "list[T]" list_props nil) (below type-eq-decl nil naturalnumbers nil) (reverse_def formula-decl nil more_list_props structures)) nil)) (cycle_construction_TCC1 0 (cycle_construction_TCC1-2 nil 3655803332 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))")) (cycle_construction_TCC1-1 nil 3655641985 ("" (subtype-tcc) nil nil) nil nil (cycle_construction subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycle_construction_TCC2 0 (cycle_construction_TCC2-1 nil 3655641985 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (last const-decl "T" more_list_props structures)) nil (cycle_construction subtype "c_digraph_all_cycles.walked" "(list_adt[nat].cons?)"))) (cycle_construction_TCC3 0 (cycle_construction_TCC3-1 nil 3655641985 ("" (skeep*) (("" (typepred "walked") (("" (hide-all-but (-2 2)) (("" (expand "list_of_idxs") (("" (expand "size") (("" (typepred "C") (("" (expand "cdigraph") (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (assert) nil nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (1 2)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) | NOT null?(walked)}" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (size const-decl "nat" c_digraphs_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction subtype "list_adt[nat].car(c_digraph_all_cycles.walked)" "below[length[list[nat]](adjs(C))]"))) (cycle_construction_TCC4 0 (cycle_construction_TCC4-3 "" 3744338290 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (split 2) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (use "last_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "list_of_idxs") (("2" (skeep) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth") (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (reverse def-decl "list[T]" list_props nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) | NOT null?(walked)}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (permutation_list const-decl "bool" permutations_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(cons[nat](v, walked)))" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (permutation_reflexive formula-decl nil permutations_list structures) (permutation_reverse formula-decl nil permutations_list structures) (loi_permutation formula-decl nil c_digraphs_def nil) (walk_append formula-decl nil c_digraph_all_cycles nil) (null adt-constructor-decl "(null?)" list_adt nil) (last_reverse formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (last_cons formula-decl nil more_list_props structures) (car_reverse formula-decl nil more_list_props structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_reverse formula-decl nil list_props nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycle_construction subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.v, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))")) (cycle_construction_TCC4-2 nil 3655803535 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (split 2) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (use "last_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "list_of_idxs") (("2" (skeep) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth") (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (permutation_list const-decl "bool" permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (permutation_reverse formula-decl nil permutations_list structures) (loi_permutation formula-decl nil c_digraphs_def nil) (last_reverse formula-decl nil more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (last_cons formula-decl nil more_list_props structures) (car_reverse formula-decl nil more_list_props structures)) nil (cycle_construction subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.v, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))")) (cycle_construction_TCC4-1 nil 3655641985 ("" (subtype-tcc) nil nil) nil nil (cycle_construction subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.v, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))"))) (cycle_construction 0 (cycle_construction-2 nil 3656333987 ("" (skeep*) (("" (expand "cycle?") (("" (hide-all-but (-3 -2 1)) (("" (expand "reverse" 1) (("" (use "cdr_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "no_repetitions_append[nat]") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "no_repetitions?") (("1" (skeep) (("1" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (reveal -5) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -5) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "member" -2) (("3" (expand "member" -2) (("3" (replace -2 :hide? t) (("3" (replace -3 :hide? t :dir rl) (("3" (expand "no_repetitions?") (("3" (use "member_nth[nat]") (("3" (assert) (("3" (skeep -1) (("3" (inst -3 "i+1" "0") (("1" (expand "/=") (("1" (expand "nth" 1) (("1" (use "car_reverse[nat]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -8) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (expand "walk?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cycle? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (j skolem-const-decl "below(length(cdr(reverse(walked))))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length(cdr(reverse(walked))))" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (below type-eq-decl nil nat_types nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (v skolem-const-decl "below(size(C))" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (member def-decl "bool" list_props nil) (i skolem-const-decl "below(length(cdr(reverse(walked))))" c_digraph_all_cycles nil) (car_reverse formula-decl nil more_list_props structures) (member_nth formula-decl nil more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (no_repetitions_append formula-decl nil more_list_props structures) (walked skolem-const-decl "{walked: (list_of_idxs(C)) | NOT null?(walked)}" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cdr_append formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (cycle_construction-1 nil 3655642083 ("" (skeep*) (("" (expand "cycle?") (("" (hide-all-but (-3 -2 1)) (("" (expand "reverse" 1) (("" (use "cdr_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "no_repetitions_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "no_repetitions?") (("1" (skeep) (("1" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (reveal -5) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -5) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "member" -2) (("3" (expand "member" -2) (("3" (replace -2 :hide? t) (("3" (replace -3 :hide? t :dir rl) (("3" (expand "no_repetitions?") (("3" (use "member_nth[nat]") (("3" (assert) (("3" (skeep -1) (("3" (inst -3 "i+1" "0") (("1" (expand "/=") (("1" (expand "nth" 1) (("1" (use "car_reverse[nat]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -8) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (expand "walk?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (car_reverse formula-decl nil more_list_props structures) (member_nth formula-decl nil more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (cdr_append formula-decl nil more_list_props structures)) shostak)) (cycle_construction_size_TCC1 0 (cycle_construction_size_TCC1-1 nil 3656764056 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction_size subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycle_construction_size_TCC2 0 (cycle_construction_size_TCC2-1 nil 3656764056 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reverse def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures)) nil (cycle_construction_size subtype "c_digraph_all_cycles.walked" "{l: list_adt[nat].list | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cycle_construction_size 0 (cycle_construction_size-2 nil 3656764143 ("" (skeep*) (("" (use "norep_loi_length") (("1" (assert) nil nil) ("2" (typepred "walked") (("2" (hide-all-but (-4 1)) (("2" (expand "no_repetitions?") (("2" (skeep) (("2" (inst -1 "length(walked)-1-i" "length(walked)-1-j") (("1" (assert) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "walked" "length(walked) - 1 - j") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "walked" "length(walked) - 1 - i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil) ("3" (use "length_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((norep_loi_length formula-decl nil c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (no_repetitions? const-decl "bool" more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (length_reverse formula-decl nil list_props nil) (reverse_def formula-decl nil more_list_props structures) (j skolem-const-decl "below(length(walked))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length(walked))" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (cycle_construction_size-1 nil 3656764065 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil))))))))) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil))))))))))))) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w_1") (("1" (assert) (("1" (replace -5 :hide? t) (("1" (grind) nil))))))))))))))) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil))))))))))))))))))))))))))) ("2" (flatten) (("2" (skeep -1) (("2" (case "w_1 =v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil))))))))))))) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil))))))))))))))) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil))))))))))))))))))))))) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w_1") (("1" (assert) nil))))))))) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil)) (cycle_construction_grow_TCC1 0 (cycle_construction_grow_TCC1-1 nil 3656764502 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (cycle_construction_grow subtype "c_digraph_all_cycles.walked" "(list_adt[nat].cons?)"))) (cycle_construction_grow_TCC2 0 (cycle_construction_grow_TCC2-2 nil 3656764944 ("" (skeep*) (("" (typepred "walked") (("" (hide-all-but (-2 1)) (("" (expand "list_of_idxs") (("" (expand "size") (("" (typepred "C") (("" (expand "cdigraph") (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "cons?(walked)") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (typepred "walked") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_reverse formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction_grow subtype "list_adt[nat].car(c_digraph_all_cycles.walked)" "below[length[list[nat]](C`adjs)]")) (cycle_construction_grow_TCC2-1 nil 3656764502 ("" (subtype-tcc) nil nil) nil nil (cycle_construction_grow subtype "list_adt[nat].car(c_digraph_all_cycles.walked)" "below[length[list[nat]](C`adjs)]"))) (cycle_construction_grow_TCC3 0 (cycle_construction_grow_TCC3-1 nil 3656764502 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction_grow subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycle_construction_grow_TCC4 0 (cycle_construction_grow_TCC4-1 nil 3656764502 ("" (assert) nil nil) nil nil (cycle_construction_grow subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{l: list_adt[nat].list | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cycle_construction_grow 0 (cycle_construction_grow-2 "" 3744338402 ("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "walking") (("1" (replace -8 :hide? t) (("1" (hide-all-but (1 -2)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (typepred "walking") (("2" (hide -1) (("2" (hide-all-but (1 -4 -2 -7)) (("2" (use "walk_append") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -3 -1 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "w") (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "walked") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -6 -2 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep) (("2" (inst -1 "i") (("1" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "reverse" 1) (("3" (use "no_repetitions_append[nat]") (("3" (replace -1 1 :dir rl :hide? t) (("3" (assert) (("3" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (replace -2 :hide? t) (("2" (lemma "member_reverse[nat]") (("2" (inst -1 "w" "walked") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (use "last_cons[nat]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below(length(cons[nat](w, walked)))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (TRUE const-decl "bool" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (below type-eq-decl nil nat_types nil) (suffix? def-decl "bool" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (i skolem-const-decl "below(length(cons[nat](w, null[nat])))" c_digraph_all_cycles nil) (suffix_member formula-decl nil more_list_props structures) (member def-decl "bool" list_props nil) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (walk_append formula-decl nil c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (member_reverse formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures)) shostak) (cycle_construction_grow-1 nil 3656764508 ("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "walking") (("1" (replace -8 :hide? t) (("1" (hide-all-but (1 -2)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (typepred "walking") (("2" (hide -1) (("2" (hide-all-but (1 -4 -2 -7)) (("2" (use "walk_append") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -3 -1 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "w") (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "walked") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -6 -2 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep) (("2" (inst -1 "i") (("1" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "reverse" 1) (("3" (use "no_repetitions_append[nat]") (("3" (replace -1 1 :dir rl :hide? t) (("3" (assert) (("3" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (replace -2 :hide? t) (("2" (lemma "member_reverse[nat]") (("2" (inst -1 "w" "walked") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (use "last_cons[nat]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures)) nil)) (cycles_from_measure_TCC1 0 (cycles_from_measure_TCC1-2 nil 3655801965 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from_measure subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))")) (cycles_from_measure_TCC1-1 nil 3655748237 ("" (subtype-tcc) nil nil) nil nil (cycles_from_measure subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycles_from_measure_TCC2 0 (cycles_from_measure_TCC2-1 nil 3655748237 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (reverse def-decl "list[T]" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (C!1 skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures)) nil (cycles_from_measure subtype "c_digraph_all_cycles.walked" "{l: list_adt[nat].list | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cycles_from_measure_TCC3 0 (cycles_from_measure_TCC3-1 nil 3655748237 ("" (skeep*) (("" (use "cycle_construction_size") nil nil)) nil) ((last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_size formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from_measure subtype "(number_fields.-)(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), list_props[nat].length(c_digraph_all_cycles.walked))" "nat"))) (cycles_from_TCC1 0 (cycles_from_TCC1-1 nil 3655548129 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (member def-decl "bool" list_props nil) (reverse def-decl "list[T]" list_props nil)) nil (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].null" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_from_TCC2 0 (cycles_from_TCC2-3 "" 3804532698 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (replace -6 :hide? t) (("" (split 1) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (hide-all-but (1 -5)) (("1" (typepred "walking") (("1" (replace -4 :hide? t) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "walking") (("2" (hide-all-but (-3 2 1 -8)) (("2" (replace -2 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "v") (("2" (split -1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "walked") (("1" (assert) nil nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -8 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "cycle_construction") (("4" (assert) (("4" (typepred "walking") (("4" (replace -8 :hide? t) (("4" (hide-all-but (-3 1)) (("4" (use "suffix_member[nat]") (("4" (assert) (("4" (inst -1 "v") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))")) (cycles_from_TCC2-2 "" 3744338551 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (replace -5 :hide? t) (("" (split 1) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (hide-all-but (1 -5)) (("1" (typepred "walking") (("1" (replace -4 :hide? t) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "walking") (("2" (hide-all-but (-3 2 1 -8)) (("2" (replace -2 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "v") (("2" (split -1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "walked") (("1" (assert) nil nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -8 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "cycle_construction") (("4" (assert) (("4" (typepred "walking") (("4" (replace -8 :hide? t) (("4" (hide-all-but (-3 1)) (("4" (use "suffix_member[nat]") (("4" (assert) (("4" (inst -1 "v") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (cycle_construction formula-decl nil c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (length_reverse formula-decl nil list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (member def-decl "bool" list_props nil) (suffix_member formula-decl nil more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (walk_append formula-decl nil c_digraph_all_cycles nil) (loi_permutation formula-decl nil c_digraphs_def nil) (permutation_reverse formula-decl nil permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (suffix? def-decl "bool" more_list_props structures) (below type-eq-decl nil nat_types nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(length(cons[nat](v, walked)))" c_digraph_all_cycles nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (permutation_list const-decl "bool" permutations_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))")) (cycles_from_TCC2-1 nil 3655549886 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (replace -5 :hide? t) (("" (split 1) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (hide-all-but (1 -5)) (("1" (typepred "walking") (("1" (replace -4 :hide? t) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "walking") (("2" (hide-all-but (-3 2 1 -8)) (("2" (replace -2 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "v") (("2" (split -1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "walked") (("1" (assert) nil nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -8 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "cycle_construction") (("4" (assert) (("4" (typepred "walking") (("4" (replace -8 :hide? t) (("4" (hide-all-but (-3 1)) (("4" (use "suffix_member[nat]") (("4" (assert) (("4" (inst -1 "v") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (car_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (loi_permutation formula-decl nil c_digraphs_def nil) (permutation_reverse formula-decl nil permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (suffix? def-decl "bool" more_list_props structures) (permutation_list const-decl "bool" permutations_list structures)) nil (cycles_from subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))"))) (cycles_from_TCC3 0 (cycles_from_TCC3-3 "" 3804532801 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -3 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC3-2 "" 3790101839 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -4 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_end formula-decl nil more_list_props structures) (loi_cons formula-decl nil c_digraph_all_cycles nil)) shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC3-1 nil 3655550370 ("" (then (skeep) (typepred "walking") (hide -1) (replace -4 :hide? t) (use "loi_cons") (assert) (use "suffix_end[nat]") (assert)) nil nil) ((suffix_end formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (size const-decl "nat" c_digraphs_def nil)) nil (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}"))) (cycles_from_TCC4 0 (cycles_from_TCC4-1 nil 3655550370 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (< def-decl "bool" ordinals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (lex2 const-decl "ordinal" lex2 nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "nil"))) (cycles_from_TCC5 0 (cycles_from_TCC5-4 "" 3804538809 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -4 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -4 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "cycles_from_TCC2") (("3" (inst?) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-3 "" 3744401450 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -5 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "cycles_from_TCC2") (("3" (inst?) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (prefix? def-decl "bool" more_list_props structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (suffix_end formula-decl nil more_list_props structures) (loi_cons formula-decl nil c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (prefix_reflexive formula-decl nil more_list_props structures) (reverse def-decl "list[T]" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (walking skolem-const-decl "{walking: (list_of_idxs(C)) | suffix?(walking, nth(adjs(C), car(walked)))}" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cycle_prefix formula-decl nil c_digraph_all_cycles nil) (cycle_construction formula-decl nil c_digraph_all_cycles nil) (suffix_member formula-decl nil more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (/= const-decl "boolean" notequal nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cycles_from_TCC2 subtype-tcc nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-2 "" 3744340798 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -5 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (assert) (("3" (hide -1 -3) (("3" (typepred "walked") (("3" (hide -1) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((suffix_member formula-decl nil more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (prefix_reflexive formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (suffix_end formula-decl nil more_list_props structures) (prefix? def-decl "bool" more_list_props structures)) shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-1 nil 3655550370 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w_1") (("1" (assert) (("1" (replace -5 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w_1 =v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix? def-decl "bool" more_list_props structures) (suffix_end formula-decl nil more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (prefix_reflexive formula-decl nil more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (suffix_member formula-decl nil more_list_props structures)) nil (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_from_TCC6 0 (cycles_from_TCC6-3 "" 3804538841 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -3 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC6-2 "" 3790101843 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -4 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_end formula-decl nil more_list_props structures) (loi_cons formula-decl nil c_digraph_all_cycles nil)) shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC6-1 nil 3655550370 ("" (then (skeep) (typepred "walking") (hide -1) (replace -4 :hide? t) (use "loi_cons") (assert) (use "suffix_end[nat]") (assert)) nil nil) ((suffix_end formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (size const-decl "nat" c_digraphs_def nil)) nil (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}"))) (cycles_from_TCC7 0 (cycles_from_TCC7-1 nil 3655550370 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (< def-decl "bool" ordinals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (lex2 const-decl "ordinal" lex2 nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "nil"))) (cycles_from_TCC8 0 (cycles_from_TCC8-3 "" 3804539280 ("" (skeep*) (("" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (replace -1 :hide? t) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "walked") (("2" (case "no_repetitions?(cdr(reverse[nat](cons[nat](w, walked))))") (("1" (expand "reverse" -1) (("1" (case "no_repetitions?(cdr(reverse(walked))) AND no_repetitions?(cons(w, null)) AND NOT EXISTS(n:nat): member(n,cdr(reverse(walked))) AND member(n, cons(w,null))") (("1" (hide -2) (("1" (flatten) (("1" (inst 1 "w") (("1" (expand "member" 1 2) (("1" (lemma "rdc_rac[nat]") (("1" (inst -1 "walked") (("1" (replace -1 -10 :dir rl :hide? t) (("1" (expand "rac") (("1" (expand "last") (("1" (replace -7 -9 :hide? t) (("1" (use "member_append_fi[nat]") (("1" (assert) (("1" (expand "member" -1 2) (("1" (expand "member" -1 2) (("1" (expand "rdc") (("1" (hide-all-but (-1 1)) (("1" (lemma "member_reverse[nat]") (("1" (inst -1 "w" "cdr(reverse(walked))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "no_repetitions_append[nat]") (("2" (replace -1 :dir rl) (("2" (flatten) (("2" (assert) (("2" (skeep -6) (("2" (inst -5 "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (1 -11 -5)) (("2" (expand "cycle?") (("2" (use "prefix_cdr[nat]") (("1" (assert) (("1" (hide -3) (("1" (use "no_repetitions_prefix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (expand "walk?" -3) (("2" (flatten) nil nil)) nil)) nil) ("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (hide-all-but (1 -2 -3 -4)) (("2" (replace -3 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC8-2 nil 3656334009 ("" (skeep*) (("" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (replace -1 :hide? t) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (replace -4 :hide? t) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "walked") (("2" (case "no_repetitions?(cdr(reverse[nat](cons[nat](w, walked))))") (("1" (expand "reverse" -1) (("1" (case "no_repetitions?(cdr(reverse(walked))) AND no_repetitions?(cons(w, null)) AND NOT EXISTS(n:nat): member(n,cdr(reverse(walked))) AND member(n, cons(w,null))") (("1" (hide -2) (("1" (flatten) (("1" (inst 1 "w") (("1" (expand "member" 1 2) (("1" (lemma "rdc_rac[nat]") (("1" (inst -1 "walked") (("1" (replace -1 -10 :dir rl :hide? t) (("1" (expand "rac") (("1" (expand "last") (("1" (replace -7 -9 :hide? t) (("1" (use "member_append_fi[nat]") (("1" (assert) (("1" (expand "member" -1 2) (("1" (expand "member" -1 2) (("1" (expand "rdc") (("1" (hide-all-but (-1 1)) (("1" (lemma "member_reverse[nat]") (("1" (inst -1 "w" "cdr(reverse(walked))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "no_repetitions_append[nat]") (("2" (replace -1 :dir rl) (("2" (flatten) (("2" (assert) (("2" (skeep -6) (("2" (inst -5 "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (1 -11 -5)) (("2" (expand "cycle?") (("2" (use "prefix_cdr[nat]") (("1" (assert) (("1" (hide -3) (("1" (use "no_repetitions_prefix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (expand "walk?" -3) (("2" (flatten) nil nil)) nil)) nil) ("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (hide-all-but (1 -2 -3 -5)) (("2" (replace -3 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (prefix? def-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (suffix? def-decl "bool" more_list_props structures) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_reverse formula-decl nil more_list_props structures) (no_repetitions_prefix formula-decl nil c_digraph_all_cycles nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (cycle skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (prefix_cdr formula-decl nil more_list_props structures) (append def-decl "list[T]" list_props nil) (/= const-decl "boolean" notequal nil) (no_repetitions_append formula-decl nil more_list_props structures) (rdc_rac formula-decl nil more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (loi_cons formula-decl nil c_digraph_all_cycles nil) (suffix_end formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC8-1 nil 3655550370 ("" (skeep*) (("" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (replace -1 :hide? t) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (replace -4 :hide? t) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "walked") (("2" (case "no_repetitions?(cdr(reverse[nat](cons[nat](w, walked))))") (("1" (expand "reverse" -1) (("1" (case "no_repetitions?(cdr(reverse(walked))) AND no_repetitions?(cons(w, null)) AND NOT EXISTS(n:nat): member(n,cdr(reverse(walked))) AND member(n, cons(w,null))") (("1" (hide -2) (("1" (flatten) (("1" (inst 1 "w") (("1" (expand "member" 1 2) (("1" (lemma "rdc_rac[nat]") (("1" (inst -1 "walked") (("1" (replace -1 -10 :dir rl :hide? t) (("1" (expand "rac") (("1" (expand "last") (("1" (replace -7 -9 :hide? t) (("1" (use "member_append_fi[nat]") (("1" (assert) (("1" (expand "member" -1 2) (("1" (expand "member" -1 2) (("1" (expand "rdc") (("1" (hide-all-but (-1 1)) (("1" (lemma "member_reverse[nat]") (("1" (inst -1 "w" "cdr(reverse(walked))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "no_repetitions_append") (("2" (replace -1 :dir rl) (("2" (flatten) (("2" (assert) (("2" (skeep -6) (("2" (inst -5 "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (1 -11 -5)) (("2" (expand "cycle?") (("2" (use "prefix_cdr[nat]") (("1" (assert) (("1" (hide -3) (("1" (use "no_repetitions_prefix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (expand "walk?" -3) (("2" (flatten) nil nil)) nil)) nil) ("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (hide-all-but (1 -2 -3 -5)) (("2" (replace -3 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix? def-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (null_reverse formula-decl nil more_list_props structures) (prefix_cdr formula-decl nil more_list_props structures) (rdc_rac formula-decl nil more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (suffix_end formula-decl nil more_list_props structures)) nil (cycles_from subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_from_TCC9 0 (cycles_from_TCC9-3 "" 3804539350 ("" (use "cycle_construction_grow") (("" (skeep) (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}")) (cycles_from_TCC9-2 nil 3656334023 ("" (use "cycle_construction_grow") nil nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_grow formula-decl nil c_digraph_all_cycles nil)) nil (cycles_from subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}")) (cycles_from_TCC9-1 nil 3655550370 ("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "walking") (("1" (replace -8 :hide? t) (("1" (hide-all-but (1 -2)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (typepred "walking") (("2" (hide -1) (("2" (hide-all-but (1 -4 -2 -7)) (("2" (use "walk_append") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -3 -1 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "w") (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "walked") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -6 -2 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep) (("2" (inst -1 "i") (("1" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "reverse" 1) (("3" (use "no_repetitions_append") (("3" (replace -1 1 :dir rl :hide? t) (("3" (assert) (("3" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (replace -2 :hide? t) (("2" (lemma "member_reverse[nat]") (("2" (inst -1 "w" "walked") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (use "last_cons[nat]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (length_null formula-decl nil more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures)) nil (cycles_from subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}"))) (cycles_from_TCC10 0 (cycles_from_TCC10-1 nil 3655550370 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (expand "list_of_idxs") (("" (inst -1 "0") (("1" (replace -3 :hide? t) (("1" (expand "nth" -1) (("1" (expand "size") (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 :hide? t) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (walking skolem-const-decl "{walking: (list_of_idxs(C)) | suffix?(walking, nth(adjs(C), car(walked)))}" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_from subtype "c_digraph_all_cycles.w" "below[length[list[nat]](adjs(C))]"))) (cycles_from_TCC11 0 (cycles_from_TCC11-1 nil 3655550370 ("" (skeep*) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (inst -2 "w") (("1" (expand "list_of_idxs") (("1" (inst -2 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil) ((< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (suffix_reflexive formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from subtype "list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w))}"))) (cycles_from_TCC12 0 (cycles_from_TCC12-1 nil 3655550370 ("" (skeep*) (("" (lemma "lex2_lt") (("" (expand "cycles_from_measure") (("" (inst? -1 :where 3) (("1" (replace -1 :hide? t) (("1" (flatten) (("1" (hide 4) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "cycle_construction_size") nil nil) ("3" (lemma "cycle_construction_size") (("3" (inst -1 "C" "v" "cons(w,walked)") (("3" (assert) (("3" (use "cycle_construction_grow") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (suffix? def-decl "bool" more_list_props structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cycle_construction_size formula-decl nil c_digraph_all_cycles nil) (cycle_construction_grow formula-decl nil c_digraph_all_cycles nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w))" "nil"))) (cycles_from_TCC13 0 (cycles_from_TCC13-1 nil 3655550370 ("" (skeep*) (("" (typepred "walking") (("" (replaces -4) (("" (split 3) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (typepred "i") (("1" (inst -2 "i+1") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (i skolem-const-decl "below(length(ws))" c_digraph_all_cycles nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (suffix_end formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}"))) (cycles_from_TCC14 0 (cycles_from_TCC14-1 nil 3655550370 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (< def-decl "bool" ordinals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (lex2 const-decl "ordinal" lex2 nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "nil"))) (cycles_from_TCC15 0 (cycles_from_TCC15-2 "" 3744342678 ("" (skeep*) (("" (case "list_of_idxs[T](C)(nth[list[nat]](adjs(C), w))") (("1" (label "loi_adjs_w" -1) (("1" (hide "loi_adjs_w") (("1" (split 3) (("1" (flatten) (("1" (use "member_append_fi[(cycle?(C))]") (("1" (assert) (("1" (hide -2) (("1" (split -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w") (("1" (replace -4 1) (("1" (expand "member" 1 1) (("1" (hide-all-but (-2 1)) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (skeep -1) (("1" (replace -1 :dir rl :hide? t) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (inst 1 "cons(w_1, L)") (("1" (expand "reverse" 1 2) (("1" (use "append_assoc[nat]") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 3) (("1" (expand "append" 1 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs" -2) (("2" (replace -7 :hide? t) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (reveal -2) (("2" (replaces -1) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (replace -3 -1) (("2" (expand "member" -1) (("2" (split -1) (("1" (replaces -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_l[(cycle?(C))]") (("1" (assert) (("1" (typepred "cycle") (("1" (case "NOT reverse[nat](cons[nat](w, walked)) = cycle") (("1" (label "cycle is incomplete" 1) (("1" (hide "cycle is incomplete") (("1" (inst 2 "nth(cycle, length(walked) + 1)") (("1" (hide -1) (("1" (case "nth(cycle, length(walked)) = w") (("1" (split 2) (("1" (expand "walk?") (("1" (flatten) (("1" (hide-all-but (-1 -3 1)) (("1" (inst -2 "length(walked)") (("1" (assert) nil nil) ("2" (reveal -5) (("2" (hide-all-but (1 -1)) (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (expand "length" -1 1) (("2" (case "1 + length[nat](walked) = length(cycle)") (("1" (hide -2 1) (("1" (reveal -10 "cycle is incomplete") (("1" (use "prefix_eq[nat]") (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "reverse" 1) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where -2) (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :dir rl) (("2" (use "prefix_app[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where 1) (("2" (replace -1 :hide? t) (("2" (case "NOT null? (L)") (("1" (label "L not null" 1) (("1" (hide "L not null") (("1" (inst 1 "cdr(L)") (("1" (case "car(L)= nth(append(reverse[nat](cons[nat](w, walked)), L),
                                                                                                                                                                                                                          1 + length(walked))
                                                                                                                                                                                                                      ") (("1" (replaces -1 :dir rl :hide? t) (("1" (expand "append" 1) (("1" (expand "append" 1) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (reveal "L not null") (("2" (expand "length" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "L not null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (reveal "cycle is incomplete") (("2" (use "append_null[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "reverse" -1) (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :hide? t :dir rl) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 3) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -5)) (("3" (use "prefix_length[nat]") (("3" (assert) (("3" (hide -2) (("3" (use "length_reverse[nat]") (("3" (replace -1 :hide? t) (("3" (expand "length" -1 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1 + length[nat](walked)") nil nil)) nil)) nil) ("3" (hide-all-but (1 -6)) (("3" (reveal "cycle is incomplete") (("3" (assert) (("3" (case "length(reverse[nat](cons[nat](w, walked))) = length(cycle)") (("1" (hide -2 2) (("1" (use "prefix_eq[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1 3)) (("2" (use "prefix_length[nat]") (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (-6 -5 5 -10)) (("2" (replace -2 :dir rl :hide? t) (("2" (expand "circuit?") (("2" (flatten) (("2" (lemma "car_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (use "last_cons[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_r[(cycle?(C))]") (("1" (assert) (("1" (inst 2 "w!1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (inst -2 "w") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (prefix_length formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length_reverse formula-decl nil list_props nil) (prefix_eq formula-decl nil more_list_props structures) (prefix_app formula-decl nil more_list_props structures) (append_null formula-decl nil list_props nil) (L skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nth_append formula-decl nil more_list_props structures) (list_cons_extensionality formula-decl nil list_adt nil) (cycle skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (car_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (member_append_l formula-decl nil more_list_props structures) (member_append_r formula-decl nil more_list_props structures) (cycles_from_TCC9 subtype-tcc nil c_digraph_all_cycles nil) (suffix_reflexive formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (prefix_supl formula-decl nil more_list_props structures) (append def-decl "list[T]" list_props nil) (append_assoc formula-decl nil list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (walking skolem-const-decl "{walking: (list_of_idxs(C)) | suffix?(walking, nth(adjs(C), car(walked)))}" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cycles_from_TCC13 subtype-tcc nil c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (suffix? def-decl "bool" more_list_props structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (prefix? def-decl "bool" more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].append(c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC15-1 nil 3655550614 ("" (skeep*) (("" (case "list_of_idxs[T](C)(nth[list[nat]](adjs(C), w))") (("1" (label "loi_adjs_w" -1) (("1" (hide "loi_adjs_w") (("1" (split 3) (("1" (flatten) (("1" (use "member_append_fi[(cycle?(C))]") (("1" (assert) (("1" (hide -2) (("1" (split -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w") (("1" (replace -4 1) (("1" (expand "member" 1 1) (("1" (hide-all-but (-2 1)) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (skeep -1) (("1" (replace -1 :dir rl :hide? t) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (inst 1 "cons(w_1, L)") (("1" (expand "reverse" 1 2) (("1" (use "append_assoc[nat]") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 3) (("1" (expand "append" 1 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs" -2) (("2" (replace -7 :hide? t) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (reveal -2) (("2" (replaces -1) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w_1") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (replace -3 -1) (("2" (expand "member" -1) (("2" (split -1) (("1" (replaces -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_l[(cycle?(C))]") (("1" (assert) (("1" (typepred "cycle") (("1" (case "NOT reverse[nat](cons[nat](w, walked)) = cycle") (("1" (label "cycle is incomplete" 1) (("1" (hide "cycle is incomplete") (("1" (inst 2 "nth(cycle, length(walked) + 1)") (("1" (hide -1) (("1" (case "nth(cycle, length(walked)) = w") (("1" (split 2) (("1" (expand "walk?") (("1" (flatten) (("1" (hide-all-but (-1 -3 1)) (("1" (inst -2 "length(walked)") (("1" (assert) nil nil) ("2" (reveal -5) (("2" (hide-all-but (1 -1)) (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (expand "length" -1 1) (("2" (case "1 + length[nat](walked) = length(cycle)") (("1" (hide -2 1) (("1" (reveal -10 "cycle is incomplete") (("1" (use "prefix_eq[nat]") (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "reverse" 1) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where -2) (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :dir rl) (("2" (use "prefix_app[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where 1) (("2" (replace -1 :hide? t) (("2" (case "NOT null? (L)") (("1" (label "L not null" 1) (("1" (hide "L not null") (("1" (inst 1 "cdr(L)") (("1" (case "car(L)= nth(append(reverse[nat](cons[nat](w, walked)), L),
                                                                                                                                                                                             1 + length(walked))
                                                                                                                                                                                         ") (("1" (replaces -1 :dir rl :hide? t) (("1" (expand "append" 1) (("1" (expand "append" 1) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (reveal "L not null") (("2" (expand "length" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "L not null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (reveal "cycle is incomplete") (("2" (use "append_null[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "reverse" -1) (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :hide? t :dir rl) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 3) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -5)) (("3" (use "prefix_length[nat]") (("3" (assert) (("3" (hide -2) (("3" (use "length_reverse[nat]") (("3" (replace -1 :hide? t) (("3" (expand "length" -1 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1 + length[nat](walked)") nil nil)) nil)) nil) ("3" (hide-all-but (1 -6)) (("3" (reveal "cycle is incomplete") (("3" (assert) (("3" (case "length(reverse[nat](cons[nat](w, walked))) = length(cycle)") (("1" (hide -2 2) (("1" (use "prefix_eq[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1 3)) (("2" (use "prefix_length[nat]") (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (-6 -5 5 -10)) (("2" (replace -2 :dir rl :hide? t) (("2" (expand "circuit?") (("2" (flatten) (("2" (lemma "car_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (use "last_cons[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_r[(cycle?(C))]") (("1" (assert) (("1" (inst 2 "w_1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (inst -2 "w") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (prefix_length formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (prefix_eq formula-decl nil more_list_props structures) (prefix_app formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (car_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (member_append_l formula-decl nil more_list_props structures) (member_append_r formula-decl nil more_list_props structures) (suffix_reflexive formula-decl nil more_list_props structures) (prefix_supl formula-decl nil more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (prefix? def-decl "bool" more_list_props structures) (member_append_fi formula-decl nil more_list_props structures)) nil (cycles_from subtype "list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].append(c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_for_TCC1 0 (cycles_for_TCC1-1 nil 3655811132 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_for subtype "c_digraph_all_cycles.cycle" "(list_adt[nat].cons?)"))) (cycles_for_TCC2 0 (cycles_for_TCC2-1 nil 3655811132 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (last const-decl "T" more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (walk? const-decl "bool" c_digraph_all_cycles nil)) nil (cycles_for subtype "(: c_digraph_all_cycles.v :)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}"))) (cycles_for_TCC3 0 (cycles_for_TCC3-1 nil 3655811132 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_for subtype "c_digraph_all_cycles.v" "below[length[list[nat]](adjs(C))]"))) (cycles_for_TCC4 0 (cycles_for_TCC4-1 nil 3655811132 ("" (skeep) (("" (typepred "C") (("" (expand "cdigraph") (("" (flatten) (("" (inst -2 "v") (("1" (assert) (("1" (use "suffix_reflexive[nat]") nil nil)) nil) ("2" (typepred "v") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_reflexive formula-decl nil more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_for subtype "list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.v)" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.v))}"))) (cycles_for_TCC5 0 (cycles_for_TCC5-1 nil 3655811132 ("" (skeep*) (("" (typepred "cycles_from(C)(v)((: v :), nth[list[nat]](adjs(C), v))") (("" (hide -1) (("" (inst -1 "cycle") (("" (replace -1 :hide? t) (("" (split 1) (("1" (flatten) (("1" (skeep -1) (("1" (expand "reverse" -2) (("1" (expand "reverse" -2) (("1" (expand "reverse" -2) (("1" (expand "append" -2 2) (("1" (expand "append" -2) (("1" (expand "append" -2) (("1" (lemma "nnprefixes_same_head[nat]") (("1" (inst -1 "cycle" "cons(v,cons(w,null))") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "prefixes") (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "nth(cycle,1)") (("1" (split 1) (("1" (typepred "cycle") (("1" (expand "walk?") (("1" (hide-all-but (1 -3 -6)) (("1" (flatten) (("1" (inst -1 "0") (("1" (expand "nth" -1 3) (("1" (assert) nil nil)) nil) ("2" (reveal -4) (("2" (expand "circuit?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (expand "reverse" 1) (("2" (expand "reverse" 1) (("2" (expand "append" 1 2) (("2" (case "cycle=append(cons(v,null),cdr(cycle))") (("1" (replace -1 1 :hide? t) (("1" (expand "append" 1) (("1" (expand "nth" 1) (("1" (expand "append" 1) (("1" (expand "nth" 1) (("1" (case "cons(car(cdr(cycle)), null) = append((:car(cdr(cycle)):),null)") (("1" (replace -1 :hide? t) (("1" (case "cdr(cycle) = append((:car(cdr(cycle)):),cdr(cdr(cycle)))") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 2) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "append") (("2" (apply-extensionality) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" 1) (("2" (replace -1 :dir rl) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (-2 -4 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1") nil nil)) nil)) nil)) nil) ("3" (typepred "cycle") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cycles_from def-decl "{cs: list[(cycle?(C))] |
   FORALL (cycle: (cycle?(C))):
     member(cycle, cs) IFF
      EXISTS (w: below(size(C))):
        member(w, walking) AND prefix?(reverse(cons(w, walked)), cycle)}" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (prefix? def-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (suffix? def-decl "bool" more_list_props structures) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (append def-decl "list[T]" list_props nil) (prefixes const-decl "bool" more_list_props structures) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (cycle skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (w skolem-const-decl "below(size(C))" c_digraph_all_cycles nil) (null adt-constructor-decl "(null?)" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (prefix_supl formula-decl nil more_list_props structures) (nnprefixes_same_head formula-decl nil more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (list_cons_extensionality formula-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_for subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)((: c_digraph_all_cycles.v :), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.v))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), list_adt[nat].car(cycle) = c_digraph_all_cycles.v)}"))) (all_cycles_rec_TCC1 0 (all_cycles_rec_TCC1-1 nil 3656158837 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (int_minus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil)) nil (all_cycles_rec subtype "c_digraph_all_cycles.i" "below[length[list[(cycle?(C))]](cs)]"))) (all_cycles_rec_TCC2 0 (all_cycles_rec_TCC2-1 nil 3656158837 ("" (grind) nil nil) ((T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (circuit? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (cycle? const-decl "bool" c_digraph_all_cycles nil) (every adt-def-decl "boolean" list_adt nil)) nil (all_cycles_rec subtype "list_adt[list_adt[list_adt[numbers.number].list].list].null" "list[list[(cycle?(C))]]"))) (all_cycles_rec_TCC3 0 (all_cycles_rec_TCC3-1 nil 3656158837 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil)) nil (all_cycles_rec subtype "(number_fields.-)(c_digraph_all_cycles.n, 1)" "naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))"))) (all_cycles_rec_TCC4 0 (all_cycles_rec_TCC4-2 "" 3790101860 ("" (skeep*) (("" (case "n=0") (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (all_cycles_rec termination "c_digraph_all_cycles.all_cycles_rec(c_digraph_all_cycles.C)((number_fields.-)(c_digraph_all_cycles.n, 1))" "nil")) (all_cycles_rec_TCC4-1 nil 3656158837 ("" (skeep*) (("" (case "n=0") (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (split 2) (("1" (typepred "v(C)(n - 1)") (("1" (grind) nil nil)) nil) ("2" (skeep 1 :preds? t) (("2" (case "i=n-2") (("1" (hide -2) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil)) nil (all_cycles_rec termination "c_digraph_all_cycles.all_cycles_rec(c_digraph_all_cycles.C)((number_fields.-)(c_digraph_all_cycles.n, 1))" "nil"))) (all_cycles_rec_TCC5 0 (all_cycles_rec_TCC5-2 "" 3744345521 ("" (skeep :preds? t) (("" (rewrite "every_nth") (("" (skeep :preds? t) (("" (expand "length" -1) (("" (expand "length" -1) (("" (expand "nth" 1) (("" (assert) (("" (typepred "cycles_for(C)(n)") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (< const-decl "bool" reals nil) (cycles_for const-decl "{cs: list[(cycle?(C))] |
   FORALL (cycle: (cycle?(C))): member(cycle, cs) IFF car(cycle) = v}" c_digraph_all_cycles nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (all_cycles_rec subtype "(: c_digraph_all_cycles.cycles_for(c_digraph_all_cycles.C)(c_digraph_all_cycles.n) :)" "list[list[(cycle?(C))]]")) (all_cycles_rec_TCC5-1 nil 3656159837 ("" (skeep*) (("" (case "n=0") (("1" (replace -1) (("1" (assert) (("1" (split 1) (("1" (use "length_append[list[(cycle?(C))]]") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (expand "walk?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (replace -2) (("2" (assert) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (skeep) (("1" (lemma "append_null_left[list[(cycle?(C))]]") (("1" (inst -1 "(: cycles_for(C)(0) :)") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (typepred "cycles_for(C)(0)") (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (expand "walk?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split 2) (("1" (typepred "v(C)(n - 1)") (("1" (hide-all-but (1 -2)) (("1" (use "length_append[list[(cycle?(C))]]") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (expand "walk?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case "i=n") (("1" (replace -1 :hide? t) (("1" (hide -1) (("1" (skeep) (("1" (lemma "nth_append[list[(cycle?(C))]]") (("1" (inst -1 "v(C)(n - 1)" "(: cycles_for(C)(n) :)" "n") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (typepred "v(C)(n-1)") (("1" (replace -2 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (hide -1 -2) (("1" (typepred "cycles_for(C)(n)") (("1" (inst -2 "cycle") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (expand "walk?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep 2) (("2" (use "nth_append[list[(cycle?(C))]]") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (typepred "v(C)(n-1)") (("1" (inst -3 "i") (("1" (inst -3 "cycle") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (expand "walk?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil)) nil (all_cycles_rec subtype "(: c_digraph_all_cycles.cycles_for(c_digraph_all_cycles.C)(c_digraph_all_cycles.n) :)" "list[list[(cycle?(C))]]"))) (all_cycles_rec_TCC6 0 (all_cycles_rec_TCC6-1 nil 3744308780 ("" (skeep*) (("" (case "n=0") (("1" (replace -1) (("1" (assert) (("1" (split 1) (("1" (use "length_append[list[(cycle?(C))]]") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (replace -2) (("2" (assert) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (skeep) (("1" (lemma "append_null_left[list[(cycle?(C))]]") (("1" (inst -1 "(: cycles_for(C)(0) :)") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (typepred "cycles_for(C)(0)") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split 2) (("1" (typepred "v(C)(n - 1)") (("1" (hide-all-but (1 -2)) (("1" (use "length_append[list[(cycle?(C))]]") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case "i=n") (("1" (replace -1 :hide? t) (("1" (hide -1) (("1" (skeep) (("1" (lemma "nth_append[list[(cycle?(C))]]") (("1" (inst -1 "v(C)(n - 1)" "(: cycles_for(C)(n) :)" "n") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (typepred "v(C)(n-1)") (("1" (replace -2 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (hide -1 -2) (("1" (typepred "cycles_for(C)(n)") (("1" (inst -2 "cycle") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep 2) (("2" (use "nth_append[list[(cycle?(C))]]") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (typepred "v(C)(n-1)") (("2" (inst -3 "i") (("2" (inst -3 "cycle") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (append_null_left formula-decl nil more_list_props structures) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (length_append formula-decl nil list_props nil) (cycles_for const-decl "{cs: list[(cycle?(C))] |
   FORALL (cycle: (cycle?(C))): member(cycle, cs) IFF car(cycle) = v}" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth_append formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (all_cycles_rec subtype "list_props[list[(cycle?(C))]].append(IF c_digraph_all_cycles.n = 0 THEN list_adt[list_adt[list_adt[numbers.number].list].list].null ELSE c_digraph_all_cycles.all_cycles_rec(c_digraph_all_cycles.C)((number_fields.-)(c_digraph_all_cycles.n, 1)) ENDIF, (: c_digraph_all_cycles.cycles_for(c_digraph_all_cycles.C)(c_digraph_all_cycles.n) :))" "{cs: list_adt[list[(cycle?(C))]].list | booleans.AND(list_props[list[(cycle?(C))]].length(cs) = (number_fields.+)(1, c_digraph_all_cycles.n), FORALL (i: naturalnumbers.below((number_fields.+)(c_digraph_all_cycles.n, 1))): FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, list_props[list[(cycle?(C))]].nth(cs, i)), list_adt[nat].car(cycle) = i))}"))) (all_cycles_TCC1 0 (all_cycles_TCC1-1 nil 3656158837 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (last const-decl "T" more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil)) nil (all_cycles subtype "c_digraph_all_cycles.i" "below[length[list[(cycle?(C))]](cs)]"))) (all_cycles_TCC2 0 (all_cycles_TCC2-1 nil 3656158837 ("" (skeep :preds? t) (("" (split 1) (("1" (grind) nil nil) ("2" (skeep :preds? t) (("2" (assert) nil nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (all_cycles subtype "list_adt[list[(cycle?(C))]].null" "{cs: list_adt[list[(cycle?(C))]].list | booleans.AND(list_props[list[(cycle?(C))]].length(cs) = c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), FORALL (i: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, list_props[list[(cycle?(C))]].nth(cs, i)), list_adt[nat].car(cycle) = i))}"))) (all_cycles_TCC3 0 (all_cycles_TCC3-1 nil 3656163383 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil)) nil (all_cycles subtype "(number_fields.-)(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), 1)" "naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))"))))
