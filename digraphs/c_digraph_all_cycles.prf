(c_digraph_all_cycles (loi_cons 0 (loi_cons-1 nil 3655568650 ("" (skeep) (("" (expand "list_of_idxs") (("" (skeep) (("" (inst -1 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (n skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (i skolem-const-decl "below(length(l))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (l skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (size const-decl "nat" c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nth def-decl "T" list_props nil)) shostak)) (walk?_TCC1 0 (walk?_TCC1-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk? subtype "(number_fields.+)(c_digraph_all_cycles.i, 1)" "below[length[nat](l)]"))) (walk?_TCC2 0 (walk?_TCC2-1 nil 3655548129 ("" (subtype-tcc) nil nil) nil nil (walk? subtype "c_digraph_all_cycles.i" "below[length[nat](l)]"))) (walk?_TCC3 0 (walk?_TCC3-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (l!1 skolem-const-decl "(list_of_idxs[T](C!1))" c_digraph_all_cycles nil) (i!1 skolem-const-decl "below(length[nat](l!1) - 1)" c_digraph_all_cycles nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil)) nil (walk? subtype "list_props[nat].nth(c_digraph_all_cycles.l, c_digraph_all_cycles.i)" "below[length[list[nat]](adjs(C))]"))) (walk_eq_TCC1 0 (walk_eq_TCC1-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk_eq subtype "c_digraph_all_cycles.i" "below[length[nat](w2)]"))) (walk_eq_TCC2 0 (walk_eq_TCC2-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (i!1 skolem-const-decl "below(length(w1!1))" c_digraph_all_cycles nil) (w1!1 skolem-const-decl "Walk[T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](C!1)" c_digraph_all_cycles nil) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (edge? const-decl "bool" digraphs_ nil) (edges const-decl "bool" c_digraphs_def nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (verts_in? const-decl "bool" walks_ nil) (vert const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk_eq subtype "list_props[nat].nth(c_digraph_all_cycles.w2, c_digraph_all_cycles.i)" "below[length[T](data(C))]"))) (walk_append_TCC1 0 (walk_append_TCC1-1 nil 3655576611 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk_append subtype "c_digraph_all_cycles.l2" "(list_adt[nat].cons?)"))) (walk_append_TCC2 0 (walk_append_TCC2-1 nil 3655576611 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (C!1 skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nth def-decl "T" list_props nil)) nil (walk_append subtype "more_list_props[nat].last(c_digraph_all_cycles.l1)" "below[length[list[nat]](adjs(C))]"))) (walk_append_TCC3 0 (walk_append_TCC3-1 nil 3655576611 ("" (skeep*) (("" (use "loi_append") (("" (assert) nil nil)) nil)) nil) ((T formal-type-decl nil c_digraph_all_cycles nil) (loi_append formula-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (walk_append subtype "list_props[nat].append(c_digraph_all_cycles.l1, c_digraph_all_cycles.l2)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (walk_append 0 (walk_append-2 "" 3804532594 ("" (skeep 1 :but ("l1")) (("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (skolem 1 ("v" "vs")) (("5" (flatten) (("5" (use "loi_cons") (("5" (assert) (("5" (case "walk?(C)(vs)") (("1" (assert) (("1" (split -7) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "walk?" 1) (("1" (skeep :preds? t) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (assert) (("1" (expand "nth" -7 (1 3)) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -5) (("2" (flatten) (("2" (inst -5 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "append" 1) (("2" (expand "walk?" 1) (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (expand "nth" -7 (1 3)) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "length(vs)=0") (("1" (expand "walk?" -4) (("1" (flatten) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -5) (("1" (expand "walk?" -1) (("1" (flatten) (("1" (inst -1 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT null?(vs)") (("1" (expand "walk?" 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (expand "walk?" -4) (("2" (skeep 1) (("2" (inst -4 "i+1") (("1" (assert) (("1" (expand "nth" -4 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 2) (("2" (expand "append" 2) (("2" (assert) (("2" (expand "walk?" 2) (("2" (skeep 2 :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 2 (1 3)) (("1" (case "last(cons(v,vs))=v") (("1" (replace -1 :hide? t) (("1" (expand "nth" 2 1) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3 1) (("2" (expand "walk?" -7) (("2" (inst -7 "i-1") (("1" (assert) (("1" (expand "nth" 3 3) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (skeep*) (("8" (use "loi_append") (("8" (assert) nil nil)) nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (skeep*) (("11" (expand "list_of_idxs") (("11" (expand "size") (("11" (expand "last") (("11" (inst -2 "length(l1)-1") (("1" (assert) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (l2 skolem-const-decl "(list_of_idxs(C))" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (last const-decl "T" more_list_props structures) (< const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (member def-decl "bool" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list_induction formula-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (size const-decl "nat" c_digraphs_def nil) (i skolem-const-decl "below(length(vs) - 1)" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(cons(v, l2)) - 1)" c_digraph_all_cycles nil) (nth_append formula-decl nil more_list_props structures) (i skolem-const-decl "below(length(cons(v, append[nat](vs, l2))) - 1)" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vs skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (v skolem-const-decl "nat" c_digraph_all_cycles nil) (int_plus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below(length(cons(v, append[nat](vs, l2))) - 1)" c_digraph_all_cycles nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (loi_cons formula-decl nil c_digraph_all_cycles nil) (loi_append formula-decl nil c_digraphs_def nil) (TRUE const-decl "bool" booleans nil) (l1 skolem-const-decl "list[nat]" c_digraph_all_cycles nil)) shostak) (walk_append-1 nil 3656062706 ("" (skeep 1 :but ("l1")) (("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (skolem 1 ("v" "vs")) (("5" (flatten) (("5" (use "loi_cons") (("5" (assert) (("5" (case "walk?(C)(vs)") (("1" (assert) (("1" (split -7) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "walk?" 1) (("1" (skeep :preds? t) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (assert) (("1" (expand "nth" -7 (1 3)) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -5) (("2" (flatten) (("2" (inst -5 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "append" 1) (("2" (expand "walk?" 1) (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (expand "walk?" -7) (("1" (inst -7 "0") (("1" (expand "nth" -7 (1 3)) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "length(vs)=0") (("1" (expand "walk?" -4) (("1" (flatten) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 1) (("2" (expand "walk?" -3) (("2" (flatten) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -5) (("1" (expand "walk?" -1) (("1" (flatten) (("1" (inst -1 "i-1") (("1" (assert) (("1" (expand "nth" 3 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT null?(vs)") (("1" (expand "walk?" 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (expand "walk?" -4) (("2" (skeep 1) (("2" (inst -4 "i+1") (("1" (assert) (("1" (expand "nth" -4 (1 3)) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 2) (("2" (expand "append" 2) (("2" (assert) (("2" (expand "walk?" 2) (("2" (skeep 2 :preds? t) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 2 (1 3)) (("1" (case "last(cons(v,vs))=v") (("1" (replace -1 :hide? t) (("1" (expand "nth" 2 1) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3 1) (("2" (expand "walk?" -7) (("2" (inst -7 "i-1") (("1" (assert) (("1" (expand "nth" 3 3) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (skeep*) (("8" (use "loi_append") (("8" (assert) nil nil)) nil)) nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (skeep*) (("11" (expand "list_of_idxs") (("11" (expand "size") (("11" (expand "last") (("11" (inst -4 "length(l1)-1") (("1" (assert) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (last const-decl "T" more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (nth_append formula-decl nil more_list_props structures) (loi_append formula-decl nil c_digraphs_def nil)) shostak)) (walk_eq_inj_1 0 (walk_eq_inj_1-1 nil 3828696935 ("" (skeep) (("" (expand "walk_eq") (("" (apply-extensionality) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (apply-extensionality) (("2" (flatten) (("2" (inst?) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_eq const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil c_digraph_all_cycles nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (circuit?_TCC1 0 (circuit?_TCC1-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (circuit? subtype "c_digraph_all_cycles.w" "(list_adt[nat].cons?)"))) (circuit?_TCC2 0 (circuit?_TCC2-1 nil 3655548129 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (circuit? subtype "c_digraph_all_cycles.w" "{l: list[nat] | (booleans.NOT)(list_adt[nat].null?(l))}"))) (no_repetitions_append 0 (no_repetitions_append-1 nil 3828696935 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skolem 1 ("v" "vs")) (("2" (flatten) (("2" (skeep 1) (("2" (inst -1 "l2") (("2" (split 1) (("1" (flatten) (("1" (hide -5) (("1" (assert) (("1" (expand "append" 1) (("1" (expand "no_repetitions?" 1) (("1" (skeep :preds? t) (("1" (split -7) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" -7 1) (("1" (expand "nth" -7 1) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if -7) (("1" (split -7) (("1" (flatten) (("1" (expand "no_repetitions?" -6) (("1" (inst -6 "0" "j") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "nth_member[nat]") (("2" (inst -1 "l2" "v" "j-1-length(vs)") (("1" (assert) (("1" (inst -8 "v") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "length" -1) (("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j=0") (("1" (replace -1 :hide? t) (("1" (hide 2) (("1" (expand "nth" -7) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if -7) (("1" (split -7) (("1" (flatten) (("1" (expand "no_repetitions?" -6) (("1" (inst -6 "0" "i") (("1" (assert) (("1" (assert) (("1" (expand "nth" -6) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "nth_member[nat]") (("2" (inst -1 "l2" "v" "i-1-length(vs)") (("1" (assert) (("1" (inst -8 "v") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (expand "length" -1) (("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_repetitions?" -1) (("2" (inst -1 "i-1" "j-1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3)) (("2" (expand "no_repetitions?") (("2" (skeep) (("2" (inst -2 "i!1+1" "j!1+1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (skeep) (("3" (inst -3 "n") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide -2) (("2" (split -2) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (hide-all-but (-4 1)) (("1" (expand "no_repetitions?") (("1" (skeep 1 :preds? t) (("1" (inst -4 "i" "j") (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (assert) (("1" (replace -1 :hide? t) (("1" (use "nth_append[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil) ("3" (use "length_append[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep 1) (("2" (inst -5 "n") (("2" (expand "member" -1) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "no_repetitions?" -4) (("1" (use "member_nth[nat]") (("1" (assert) (("1" (skeep -1) (("1" (inst -5 "0" "i+length(cons(v,vs)) ") (("1" (split -5) (("1" (expand "nth" -1 1) (("1" (expand "append" 1 1) (("1" (use "nth_append[nat]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil) ("3" (use "length_append[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "no_repetitions?") (("2" (skeep) (("2" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((j!1 skolem-const-decl "below(length(vs))" c_digraph_all_cycles nil) (i!1 skolem-const-decl "below(length(vs))" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nth_member formula-decl nil more_list_props structures) (v skolem-const-decl "nat" c_digraph_all_cycles nil) (vs skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (l2 skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (j skolem-const-decl "below(length(cons(v, append(vs, l2))))" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nth_append formula-decl nil more_list_props structures) (i skolem-const-decl "below(length(cons(v, append(vs, l2))))" c_digraph_all_cycles nil) (j skolem-const-decl "below(length(append(vs, l2)))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length(append(vs, l2)))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length(cons(v, vs)))" c_digraph_all_cycles nil) (j skolem-const-decl "below(length(cons(v, vs)))" c_digraph_all_cycles nil) (member_nth formula-decl nil more_list_props structures) (i skolem-const-decl "below(length(l2))" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (l2!1 skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (append def-decl "list[T]" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (no_repetitions_prefix 0 (no_repetitions_prefix-1 nil 3656073052 ("" (skeep) (("" (use "prefix_supl[nat]") (("" (assert) (("" (skeep) (("" (replace -1 :hide? t :dir rl) (("" (hide -2) (("" (expand "no_repetitions?") (("" (skeep 1 :preds? t) (("" (inst -3 "i" "j") (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (assert) (("1" (replace -1 :hide? t) (("1" (use "nth_append[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil) ("3" (use "length_append[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix_supl formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (j skolem-const-decl "below(length[nat](l1))" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (l1 skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (i skolem-const-decl "below(length[nat](l1))" c_digraph_all_cycles nil) (append def-decl "list[T]" list_props nil) (L skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures)) shostak)) (norep_loi_length 0 (norep_loi_length-1 nil 3656074107 ("" (skeep :preds? t) (("" (hide -2) (("" (lemma "list_pigeonhole[nat]") (("" (inst -1 "fullset[naturalnumbers.below(size(C))]" "l") (("1" (split -1) (("1" (skeep) (("1" (expand "no_repetitions?") (("1" (inst -4 "n" "m") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (use "every_nth[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (expand "extend") (("2" (expand "list_of_idxs") (("2" (inst -2 "i") (("2" (assert) (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "card(fullset[naturalnumbers.below(size(C))]) =size(C)") (("1" (assert) nil nil) ("2" (use "below_prelude_card") nil nil)) nil)) nil) ("2" (use "finite_extension[nat,below(size(C))]") (("2" (replace -1 :hide? t) (("2" (use "finite_full[below(size(C))]") (("2" (replace -1 :hide? t :dir rl) (("2" (expand "is_finite_type") (("2" (inst 1 "size(C)" "LAMBDA(i:below(size(C))):i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fullset const-decl "set" sets nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (below type-eq-decl nil naturalnumbers nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below_prelude_card formula-decl nil ordered_nat orders) (every_nth formula-decl nil list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (injective? const-decl "bool" functions nil) (is_finite_type const-decl "bool" finite_sets nil) (finite_full formula-decl nil finite_sets nil) (finite_extension formula-decl nil extend_set_props nil) (list_pigeonhole formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (cycle?_TCC1 0 (cycle?_TCC1-1 nil 3655551876 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycle? subtype "c_digraph_all_cycles.c" "(list_adt[nat].cons?)"))) (cycle_prefix 0 (cycle_prefix-1 nil 3656082121 ("" (skeep) (("" (use "prefix_supl[nat]") (("" (replace -1 :hide? t) (("" (skeep) (("" (case "L=null") (("1" (replace -1 :hide? t) (("1" (use "append_null[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "car(c2)=last(c2)") (("1" (case "car(c1) = last(c1)") (("1" (case "car(c1) = car(c2)") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "last") (("1" (expand "cycle?" -3) (("1" (expand "no_repetitions?") (("1" (case "length(c1)>=2") (("1" (case "length(c2)>=2") (("1" (expand "nth" -3) (("1" (assert) (("1" (inst -5 "length(c1)-2" "length(c2)-2") (("1" (split -5) (("1" (expand "/=") (("1" (replace -3 :hide? t :dir rl) (("1" (replace -4 :hide? t :dir rl) (("1" (expand "append" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "c1") (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 2) (("1" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (hide-all-but (-1 -6 1)) (("2" (replace -2 :hide? t :dir rl) (("2" (use "length_append[nat]") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 :hide? t :dir rl) (("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (typepred "c1") (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "c2") (("2" (expand "circuit?" -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "c1") (("2" (expand "circuit?" -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -5) (("2" (lift-if -5) (("2" (split -5) (("1" (flatten) (("1" (typepred "c1") (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "c1") (("2" (expand "circuit?") (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "c1") (("3" (expand "walk?") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "c1") (("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "c2") (("2" (expand "circuit?" -4) (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "c2") (("3" (expand "walk?") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "c2") (("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix_supl formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (/= const-decl "boolean" notequal nil) (length_append formula-decl nil list_props nil) (below type-eq-decl nil naturalnumbers nil) (c2 skolem-const-decl "(circuit?(C))" c_digraph_all_cycles nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (c1 skolem-const-decl "(circuit?(C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (last const-decl "T" more_list_props structures) (append_null formula-decl nil list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (cycle_construction_loi 0 (cycle_construction_loi-1 nil 3656764704 ("" (skeep) (("" (expand "list_of_idxs") (("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (expand "list_of_idxs") (("" (use "reverse_def[nat]") (("" (assert) (("" (split -1) (("1" (replaces -1) (("1" (inst?) (("1" (hide 2) (("1" (typepred "i") (("1" (use "length_reverse[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (length_reverse formula-decl nil list_props nil) (i skolem-const-decl "below(length(reverse[nat](walked)))" c_digraph_all_cycles nil) (walked skolem-const-decl "(list_of_idxs[T](C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (reverse def-decl "list[T]" list_props nil) (below type-eq-decl nil naturalnumbers nil) (reverse_def formula-decl nil more_list_props structures)) nil)) (cycle_construction_TCC1 0 (cycle_construction_TCC1-2 nil 3655803332 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))")) (cycle_construction_TCC1-1 nil 3655641985 ("" (subtype-tcc) nil nil) nil nil (cycle_construction subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycle_construction_TCC2 0 (cycle_construction_TCC2-1 nil 3655641985 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (last const-decl "T" more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cycle_construction subtype "c_digraph_all_cycles.walked" "(list_adt[nat].cons?)"))) (cycle_construction_TCC3 0 (cycle_construction_TCC3-1 nil 3655641985 ("" (skeep*) (("" (typepred "walked") (("" (hide-all-but (-2 2)) (("" (expand "list_of_idxs") (("" (expand "size") (("" (typepred "C") (("" (expand "cdigraph") (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (assert) nil nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (1 2)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) | NOT null?(walked)}" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (size const-decl "nat" c_digraphs_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction subtype "list_adt[nat].car(c_digraph_all_cycles.walked)" "below[length[list[nat]](adjs(C))]"))) (cycle_construction_TCC4 0 (cycle_construction_TCC4-3 "" 3744338290 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (split 2) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (use "last_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "list_of_idxs") (("2" (skeep) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth") (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (reverse def-decl "list[T]" list_props nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) | NOT null?(walked)}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (permutation_list const-decl "bool" permutations_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(cons[nat](v, walked)))" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (permutation_reflexive formula-decl nil permutations_list structures) (permutation_reverse formula-decl nil permutations_list structures) (loi_permutation formula-decl nil c_digraphs_def nil) (walk_append formula-decl nil c_digraph_all_cycles nil) (null adt-constructor-decl "(null?)" list_adt nil) (last_reverse formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (last_cons formula-decl nil more_list_props structures) (car_reverse formula-decl nil more_list_props structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_reverse formula-decl nil list_props nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycle_construction subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.v, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))")) (cycle_construction_TCC4-2 nil 3655803535 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (split 2) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (use "last_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "list_of_idxs") (("2" (skeep) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth") (("1" (typepred "v") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (permutation_list const-decl "bool" permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (permutation_reverse formula-decl nil permutations_list structures) (loi_permutation formula-decl nil c_digraphs_def nil) (last_reverse formula-decl nil more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (last_cons formula-decl nil more_list_props structures) (car_reverse formula-decl nil more_list_props structures)) nil (cycle_construction subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.v, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))")) (cycle_construction_TCC4-1 nil 3655641985 ("" (subtype-tcc) nil nil) nil nil (cycle_construction subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.v, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))"))) (cycle_construction 0 (cycle_construction-2 nil 3656333987 ("" (skeep*) (("" (expand "cycle?") (("" (hide-all-but (-3 -2 1)) (("" (expand "reverse" 1) (("" (use "cdr_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "no_repetitions_append[nat]") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "no_repetitions?") (("1" (skeep) (("1" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (reveal -5) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -5) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "member" -2) (("3" (expand "member" -2) (("3" (replace -2 :hide? t) (("3" (replace -3 :hide? t :dir rl) (("3" (expand "no_repetitions?") (("3" (use "member_nth[nat]") (("3" (assert) (("3" (skeep -1) (("3" (inst -3 "i+1" "0") (("1" (expand "/=") (("1" (expand "nth" 1) (("1" (use "car_reverse[nat]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -8) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (expand "walk?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cycle? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (j skolem-const-decl "below(length[nat](cdr(reverse[nat](walked))))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length[nat](cdr(reverse[nat](walked))))" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (below type-eq-decl nil nat_types nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (v skolem-const-decl "below(size(C))" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (member def-decl "bool" list_props nil) (i skolem-const-decl "below(length[nat](cdr(reverse[nat](walked))))" c_digraph_all_cycles nil) (car_reverse formula-decl nil more_list_props structures) (member_nth formula-decl nil more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (no_repetitions_append formula-decl nil more_list_props structures) (walked skolem-const-decl "{walked: (list_of_idxs(C)) | NOT null?(walked)}" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cdr_append formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (cycle_construction-1 nil 3655642083 ("" (skeep*) (("" (expand "cycle?") (("" (hide-all-but (-3 -2 1)) (("" (expand "reverse" 1) (("" (use "cdr_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "no_repetitions_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "no_repetitions?") (("1" (skeep) (("1" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (reveal -5) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -5) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "member" -2) (("3" (expand "member" -2) (("3" (replace -2 :hide? t) (("3" (replace -3 :hide? t :dir rl) (("3" (expand "no_repetitions?") (("3" (use "member_nth[nat]") (("3" (assert) (("3" (skeep -1) (("3" (inst -3 "i+1" "0") (("1" (expand "/=") (("1" (expand "nth" 1) (("1" (use "car_reverse[nat]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -8) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (reveal -8) (("3" (expand "walk?") (("3" (flatten) (("3" (expand "length" 2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (expand "walk?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (car_reverse formula-decl nil more_list_props structures) (member_nth formula-decl nil more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (cdr_append formula-decl nil more_list_props structures)) shostak)) (circuit_walk_eq 0 (circuit_walk_eq-1 nil 3828697190 ("" (then (skeep) (typepred "ci") (hide -1) (expand "circuit?") (flatten) (expand "walk_eq") (flatten) (assert) (expand "finseq_appl") (expand "pre_circuit?") (expand "finseq_appl") (inst-cp -6 "0") (inst -6 "length(ci)-1") (replace -5 :dir rl) (replace -6 :hide? t) (replace -6 :hide? t) (expand "last") (assert) (grind)) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (last const-decl "T" more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (size const-decl "nat" c_digraphs_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (pre_circuit? const-decl "bool" circuits_ nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" circuits_ nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil)) shostak)) (cycle_walk_eq 0 (cycle_walk_eq-1 nil 3828697190 ("" (skeep) (("" (typepred "ci") (("" (hide -1) (("" (expand "cycle?") (("" (split 1) (("1" (use "circuit_walk_eq") (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (skeep) (("2" (case "i=0") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "no_repetitions?") (("1" (expand "last") (("1" (expand "nth" -5) (("1" (lift-if -5) (("1" (split -5) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -7 "length(cdr(ci))-1" "j-1") (("1" (split -7) (("1" (expand "/=") (("1" (replace -1 :dir rl :hide? t) (("1" (expand "walk_eq") (("1" (flatten) (("1" (inst-cp -7 "0") (("1" (inst -7 "j") (("1" (expand "finseq_appl") (("1" (expand "nth" -8 2) (("1" (expand "nth" -7 2) (("1" (replace -1 -2) (("1" (replace -7 :hide? t) (("1" (replace -7 :hide? t) (("1" (replace -1 :hide? t) (("1" (hide-all-but (-1 1 4)) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (hide-all-but (-3 -5 1 2)) (("1" (expand "no_repetitions?") (("1" (inst -1 "car(ci)" "nth(cdr(ci),j-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "length" -6) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j=0") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "no_repetitions?") (("1" (expand "last") (("1" (expand "nth" -5) (("1" (lift-if -5) (("1" (split -5) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -7 "i-1" "length(cdr(ci))-1") (("1" (split -7) (("1" (expand "/=") (("1" (replace -1 :dir rl :hide? t) (("1" (expand "walk_eq") (("1" (flatten) (("1" (inst-cp -7 "0") (("1" (inst -7 "i") (("1" (expand "finseq_appl") (("1" (expand "nth" -8 2) (("1" (expand "nth" -7 2) (("1" (replace -1 -2) (("1" (replace -7 :hide? t) (("1" (replace -7 :hide? t) (("1" (replace -1 :hide? t) (("1" (hide-all-but (-1 1 4)) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (hide-all-but (-3 -5 1 2)) (("1" (expand "no_repetitions?") (("1" (inst -1 "car(ci)" "nth(cdr(ci),i-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil) ("2" (expand "length" -6) (("2" (assert) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_repetitions?") (("2" (expand "walk_eq") (("2" (flatten) (("2" (inst-cp -7 "i") (("2" (expand "finseq_appl") (("2" (expand "nth" -8 2) (("2" (assert) (("2" (inst -7 "j") (("2" (expand "nth" -7 2) (("2" (replace -7 :hide? t) (("2" (replace -7 :hide? t) (("2" (inst -5 "i-1" "j-1") (("2" (assert) (("2" (hide-all-but (-1 -5)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (hide-all-but (-3 -5 1)) (("2" (expand "no_repetitions?") (("2" (inst -1 "nth(cdr(ci), i - 1)" "nth(cdr(ci), j - 1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cycle? const-decl "bool" cycles_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (last const-decl "T" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (ci skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](C)" c_digraph_all_cycles nil) (j skolem-const-decl "below(length(w) - 1)" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (length def-decl "nat" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (size const-decl "nat" c_digraphs_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth def-decl "T" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (i skolem-const-decl "below(length(w) - 1)" c_digraph_all_cycles nil) (circuit_walk_eq formula-decl nil c_digraph_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil)) shostak)) (cycle_construction_size_TCC1 0 (cycle_construction_size_TCC1-1 nil 3656764056 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction_size subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycle_construction_size_TCC2 0 (cycle_construction_size_TCC2-1 nil 3656764056 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reverse def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cycle_construction_size subtype "c_digraph_all_cycles.walked" "{l: list[nat] | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cycle_construction_size 0 (cycle_construction_size-2 nil 3656764143 ("" (skeep*) (("" (use "norep_loi_length") (("1" (assert) nil nil) ("2" (typepred "walked") (("2" (hide-all-but (-4 1)) (("2" (expand "no_repetitions?") (("2" (skeep) (("2" (inst -1 "length(walked)-1-i" "length(walked)-1-j") (("1" (assert) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "walked" "length(walked) - 1 - j") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "walked" "length(walked) - 1 - i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil) ("3" (use "length_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((norep_loi_length formula-decl nil c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (no_repetitions? const-decl "bool" more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (length_reverse formula-decl nil list_props nil) (reverse_def formula-decl nil more_list_props structures) (j skolem-const-decl "below(length[nat](walked))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length[nat](walked))" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (cycle_construction_size-1 nil 3656764065 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil))))))))) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil))))))))))))) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w_1") (("1" (assert) (("1" (replace -5 :hide? t) (("1" (grind) nil))))))))))))))) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil))))))))))))))))))))))))))) ("2" (flatten) (("2" (skeep -1) (("2" (case "w_1 =v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil))))))))))))) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil))))))))))))))) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil))))))))))))))))))))))) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w_1") (("1" (assert) nil))))))))) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil)) (cycle_construction_grow_TCC1 0 (cycle_construction_grow_TCC1-1 nil 3656764502 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (cycle_construction_grow subtype "c_digraph_all_cycles.walked" "(list_adt[nat].cons?)"))) (cycle_construction_grow_TCC2 0 (cycle_construction_grow_TCC2-2 nil 3656764944 ("" (skeep*) (("" (typepred "walked") (("" (hide-all-but (-2 1)) (("" (expand "list_of_idxs") (("" (expand "size") (("" (typepred "C") (("" (expand "cdigraph") (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "cons?(walked)") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (typepred "walked") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_reverse formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction_grow subtype "list_adt[nat].car(c_digraph_all_cycles.walked)" "below[length[list[nat]](C`adjs)]")) (cycle_construction_grow_TCC2-1 nil 3656764502 ("" (subtype-tcc) nil nil) nil nil (cycle_construction_grow subtype "list_adt[nat].car(c_digraph_all_cycles.walked)" "below[length[list[nat]](C`adjs)]"))) (cycle_construction_grow_TCC3 0 (cycle_construction_grow_TCC3-1 nil 3656764502 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) ((C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycle_construction_grow subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycle_construction_grow_TCC4 0 (cycle_construction_grow_TCC4-1 nil 3656764502 ("" (assert) nil nil) nil nil (cycle_construction_grow subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{l: list[nat] | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cycle_construction_grow 0 (cycle_construction_grow-2 "" 3744338402 ("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "walking") (("1" (replace -8 :hide? t) (("1" (hide-all-but (1 -2)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (typepred "walking") (("2" (hide -1) (("2" (hide-all-but (1 -4 -2 -7)) (("2" (use "walk_append") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -3 -1 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "w") (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "walked") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -6 -2 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep) (("2" (inst -1 "i") (("1" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "reverse" 1) (("3" (use "no_repetitions_append[nat]") (("3" (replace -1 1 :dir rl :hide? t) (("3" (assert) (("3" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (replace -2 :hide? t) (("2" (lemma "member_reverse[nat]") (("2" (inst -1 "w" "walked") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (use "last_cons[nat]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below(length(cons[nat](w, walked)))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse[nat](walked)) AND
    no_repetitions?[nat](reverse[nat](walked)) AND last[nat](walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (TRUE const-decl "bool" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (below type-eq-decl nil nat_types nil) (suffix? def-decl "bool" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (i skolem-const-decl "below(length(cons[nat](w, null[nat])))" c_digraph_all_cycles nil) (suffix_member formula-decl nil more_list_props structures) (member def-decl "bool" list_props nil) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (walk_append formula-decl nil c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (member_reverse formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures)) shostak) (cycle_construction_grow-1 nil 3656764508 ("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "walking") (("1" (replace -8 :hide? t) (("1" (hide-all-but (1 -2)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (typepred "walking") (("2" (hide -1) (("2" (hide-all-but (1 -4 -2 -7)) (("2" (use "walk_append") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -3 -1 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "w") (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "walked") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -6 -2 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep) (("2" (inst -1 "i") (("1" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "reverse" 1) (("3" (use "no_repetitions_append[nat]") (("3" (replace -1 1 :dir rl :hide? t) (("3" (assert) (("3" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (replace -2 :hide? t) (("2" (lemma "member_reverse[nat]") (("2" (inst -1 "w" "walked") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (use "last_cons[nat]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures)) nil)) (cycles_from_measure_TCC1 0 (cycles_from_measure_TCC3-1 nil 3655748237 ("" (skeep*) (("" (use "cycle_construction_size") nil nil)) nil) ((last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_size formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from_measure subtype "(number_fields.-)(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), list_props[nat].length(c_digraph_all_cycles.walked))" "nat"))) (cycles_from_TCC1 0 (cycles_from_TCC1-2 "" 3884639821 ("" (skeep*) (("" (use "cycle_construction_loi") nil nil)) nil) nil shostak (cycles_from subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))")) (cycles_from_TCC1-1 nil 3884635194 ("" (subtype-tcc) nil nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_loi formula-decl nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from subtype "list_props[nat].reverse(c_digraph_all_cycles.walked)" "(c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C))"))) (cycles_from_TCC2 0 (cycles_from_TCC2-2 "" 3884639918 ("" (grind) nil nil) nil shostak (cycles_from subtype "c_digraph_all_cycles.walked" "{l: list[nat] | (booleans.NOT)(list_adt[nat].null?(l))}")) (cycles_from_TCC2-1 nil 3884635194 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (reverse def-decl "list[T]" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (C!1 skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cycles_from subtype "c_digraph_all_cycles.walked" "{l: list[nat] | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cycles_from_TCC3 0 (cycles_from_TCC1-1 nil 3655548129 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (member def-decl "bool" list_props nil) (reverse def-decl "list[T]" list_props nil)) nil (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].null" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_from_TCC4 0 (cycles_from_TCC2-3 "" 3804532698 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (replace -6 :hide? t) (("" (split 1) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (hide-all-but (1 -5)) (("1" (typepred "walking") (("1" (replace -4 :hide? t) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "walking") (("2" (hide-all-but (-3 2 1 -8)) (("2" (replace -2 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "v") (("2" (split -1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "walked") (("1" (assert) nil nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -8 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "cycle_construction") (("4" (assert) (("4" (typepred "walking") (("4" (replace -8 :hide? t) (("4" (hide-all-but (-3 1)) (("4" (use "suffix_member[nat]") (("4" (assert) (("4" (inst -1 "v") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (cycle_construction formula-decl nil c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (length_reverse formula-decl nil list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (member def-decl "bool" list_props nil) (suffix_member formula-decl nil more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (walk_append formula-decl nil c_digraph_all_cycles nil) (loi_permutation formula-decl nil c_digraphs_def nil) (permutation_reverse formula-decl nil permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (suffix? def-decl "bool" more_list_props structures) (below type-eq-decl nil nat_types nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(length(cons[nat](v, walked)))" c_digraph_all_cycles nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (permutation_list const-decl "bool" permutations_list structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))")) (cycles_from_TCC2-2 "" 3744338551 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (replace -5 :hide? t) (("" (split 1) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (hide-all-but (1 -5)) (("1" (typepred "walking") (("1" (replace -4 :hide? t) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "walking") (("2" (hide-all-but (-3 2 1 -8)) (("2" (replace -2 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "v") (("2" (split -1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "walked") (("1" (assert) nil nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -8 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "cycle_construction") (("4" (assert) (("4" (typepred "walking") (("4" (replace -8 :hide? t) (("4" (hide-all-but (-3 1)) (("4" (use "suffix_member[nat]") (("4" (assert) (("4" (inst -1 "v") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (car_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (loi_permutation formula-decl nil c_digraphs_def nil) (permutation_reverse formula-decl nil permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (suffix? def-decl "bool" more_list_props structures) (permutation_list const-decl "bool" permutations_list structures)) shostak (cycles_from subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))")) (cycles_from_TCC2-1 nil 3655549886 ("" (skeep*) (("" (typepred "walked") (("" (hide -1) (("" (replace -5 :hide? t) (("" (split 1) (("1" (lemma "loi_permutation") (("1" (inst -1 "C" "cons[nat](v, walked)" "reverse(cons[nat](v, walked))") (("1" (assert) (("1" (hide 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (hide-all-but (1 -5)) (("1" (typepred "walking") (("1" (replace -4 :hide? t) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "permutation_reverse[nat]") (("2" (assert) (("2" (hide 2) (("2" (use "permutation_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (use "walk_append") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "walking") (("2" (hide-all-but (-3 2 1 -8)) (("2" (replace -2 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "v") (("2" (split -1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "walked") (("1" (assert) nil nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -8 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep :preds? t) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "circuit?") (("3" (split 1) (("1" (lemma "last_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "car_reverse[nat]") (("1" (inst -1 "cons[nat](v, walked)") (("1" (replace -1 :hide? t) (("1" (use "last_cons[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length") (("2" (expand "walk?") (("2" (flatten) (("2" (use "null_reverse[nat]") (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (use "cycle_construction") (("4" (assert) (("4" (typepred "walking") (("4" (replace -8 :hide? t) (("4" (hide-all-but (-3 1)) (("4" (use "suffix_member[nat]") (("4" (assert) (("4" (inst -1 "v") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (car_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (loi_permutation formula-decl nil c_digraphs_def nil) (permutation_reverse formula-decl nil permutations_list structures) (permutation_reflexive formula-decl nil permutations_list structures) (suffix? def-decl "bool" more_list_props structures) (permutation_list const-decl "bool" permutations_list structures)) nil (cycles_from subtype "list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked))" "(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))"))) (cycles_from_TCC5 0 (cycles_from_TCC3-3 "" 3804532801 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -3 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_end formula-decl nil more_list_props structures) (loi_cons formula-decl nil c_digraph_all_cycles nil)) shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC3-2 "" 3790101839 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -4 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (suffix_end formula-decl nil more_list_props structures)) shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC3-1 nil 3655550370 ("" (then (skeep) (typepred "walking") (hide -1) (replace -4 :hide? t) (use "loi_cons") (assert) (use "suffix_end[nat]") (assert)) nil nil) ((suffix_end formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (size const-decl "nat" c_digraphs_def nil)) nil (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}"))) (cycles_from_TCC6 0 (cycles_from_TCC4-1 nil 3655550370 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (< def-decl "bool" ordinals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (lex2 const-decl "ordinal" lex2 nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "nil"))) (cycles_from_TCC7 0 (cycles_from_TCC7-1 "" 3884640968 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -4 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -4 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "cycles_from_TCC4") (("3" (inst?) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-4 "" 3804538809 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -4 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -4 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "cycles_from_TCC2") (("3" (inst?) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (prefix? def-decl "bool" more_list_props structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (suffix_end formula-decl nil more_list_props structures) (loi_cons formula-decl nil c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (prefix_reflexive formula-decl nil more_list_props structures) (reverse def-decl "list[T]" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (walking skolem-const-decl "{walking: (list_of_idxs(C)) | suffix?(walking, nth(adjs(C), car(walked)))}" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cycle_prefix formula-decl nil c_digraph_all_cycles nil) (cycle_construction formula-decl nil c_digraph_all_cycles nil) (suffix_member formula-decl nil more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (/= const-decl "boolean" notequal nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cycles_from_TCC4 subtype-tcc nil c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-3 "" 3744401450 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -5 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "cycles_from_TCC2") (("3" (inst?) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix? def-decl "bool" more_list_props structures) (suffix_end formula-decl nil more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (prefix_reflexive formula-decl nil more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (suffix_member formula-decl nil more_list_props structures)) shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-2 "" 3744340798 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (replace -5 :hide? t) (("1" (inst 1 "w!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w!1 = v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (assert) (("3" (hide -1 -3) (("3" (typepred "walked") (("3" (hide -1) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((suffix_member formula-decl nil more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (prefix_reflexive formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (suffix_end formula-decl nil more_list_props structures) (prefix? def-decl "bool" more_list_props structures)) shostak (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC5-1 nil 3655550370 ("" (skeep*) (("" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (split -1) (("1" (inst 1 "w") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "member") (("1" (hide -1) (("1" (use "prefix_reflexive[nat]") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs") (("2" (inst -2 "0") (("1" (assert) nil nil) ("2" (replace -5 :hide? t) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w_1") (("1" (assert) (("1" (replace -5 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ws") (("2" (hide -1) (("2" (typepred "walking") (("2" (hide -1) (("2" (replace -5 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (case "w_1 =v") (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (flatten) (("1" (case "cycle?(C)(reverse[nat](cons[nat](v, walked)))") (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "cycle") (("1" (hide-all-but (-5 -6 -7 1)) (("1" (lemma "cycle_prefix") (("1" (inst? -1 :where -4) (("1" (inst? -1 :where -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (use "cycle_construction") (("1" (assert) (("1" (typepred "walking") (("1" (replace -6 :hide? t) (("1" (hide-all-but (1 -3)) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "v") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "walking") (("2" (hide-all-but (1 -3)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (assert) (("2" (expand "member" 2) (("2" (flatten) (("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (inst 1 "w_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (reveal -1) (("2" (hide -2) (("2" (replace -1 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix? def-decl "bool" more_list_props structures) (suffix_end formula-decl nil more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (prefix_reflexive formula-decl nil more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (suffix_member formula-decl nil more_list_props structures)) nil (cycles_from subtype "list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].cons(list_props[nat].reverse(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_from_TCC8 0 (cycles_from_TCC6-3 "" 3804538841 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -3 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_end formula-decl nil more_list_props structures) (loi_cons formula-decl nil c_digraph_all_cycles nil)) shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC6-2 "" 3790101843 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (replace -4 :hide? t) (("" (use "loi_cons") (("" (assert) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (suffix_end formula-decl nil more_list_props structures)) shostak (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}")) (cycles_from_TCC6-1 nil 3655550370 ("" (then (skeep) (typepred "walking") (hide -1) (replace -4 :hide? t) (use "loi_cons") (assert) (use "suffix_end[nat]") (assert)) nil nil) ((suffix_end formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (size const-decl "nat" c_digraphs_def nil)) nil (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}"))) (cycles_from_TCC9 0 (cycles_from_TCC7-1 nil 3655550370 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (< def-decl "bool" ordinals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (lex2 const-decl "ordinal" lex2 nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "nil"))) (cycles_from_TCC10 0 (cycles_from_TCC8-3 "" 3804539280 ("" (skeep*) (("" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (replace -1 :hide? t) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -3 :hide? t) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "walked") (("2" (case "no_repetitions?(cdr(reverse[nat](cons[nat](w, walked))))") (("1" (expand "reverse" -1) (("1" (case "no_repetitions?(cdr(reverse(walked))) AND no_repetitions?(cons(w, null)) AND NOT EXISTS(n:nat): member(n,cdr(reverse(walked))) AND member(n, cons(w,null))") (("1" (hide -2) (("1" (flatten) (("1" (inst 1 "w") (("1" (expand "member" 1 2) (("1" (lemma "rdc_rac[nat]") (("1" (inst -1 "walked") (("1" (replace -1 -10 :dir rl :hide? t) (("1" (expand "rac") (("1" (expand "last") (("1" (replace -7 -9 :hide? t) (("1" (use "member_append_fi[nat]") (("1" (assert) (("1" (expand "member" -1 2) (("1" (expand "member" -1 2) (("1" (expand "rdc") (("1" (hide-all-but (-1 1)) (("1" (lemma "member_reverse[nat]") (("1" (inst -1 "w" "cdr(reverse(walked))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "no_repetitions_append[nat]") (("2" (replace -1 :dir rl) (("2" (flatten) (("2" (assert) (("2" (skeep -6) (("2" (inst -5 "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (1 -11 -5)) (("2" (expand "cycle?") (("2" (use "prefix_cdr[nat]") (("1" (assert) (("1" (hide -3) (("1" (use "no_repetitions_prefix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (expand "walk?" -3) (("2" (flatten) nil nil)) nil)) nil) ("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (hide-all-but (1 -2 -3 -4)) (("2" (replace -3 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (prefix? def-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (suffix? def-decl "bool" more_list_props structures) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_reverse formula-decl nil more_list_props structures) (no_repetitions_prefix formula-decl nil c_digraph_all_cycles nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (cycle skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (prefix_cdr formula-decl nil more_list_props structures) (append def-decl "list[T]" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil) (no_repetitions_append formula-decl nil more_list_props structures) (rdc_rac formula-decl nil more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (loi_cons formula-decl nil c_digraph_all_cycles nil) (suffix_end formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC8-2 nil 3656334009 ("" (skeep*) (("" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (replace -1 :hide? t) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (replace -4 :hide? t) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "walked") (("2" (case "no_repetitions?(cdr(reverse[nat](cons[nat](w, walked))))") (("1" (expand "reverse" -1) (("1" (case "no_repetitions?(cdr(reverse(walked))) AND no_repetitions?(cons(w, null)) AND NOT EXISTS(n:nat): member(n,cdr(reverse(walked))) AND member(n, cons(w,null))") (("1" (hide -2) (("1" (flatten) (("1" (inst 1 "w") (("1" (expand "member" 1 2) (("1" (lemma "rdc_rac[nat]") (("1" (inst -1 "walked") (("1" (replace -1 -10 :dir rl :hide? t) (("1" (expand "rac") (("1" (expand "last") (("1" (replace -7 -9 :hide? t) (("1" (use "member_append_fi[nat]") (("1" (assert) (("1" (expand "member" -1 2) (("1" (expand "member" -1 2) (("1" (expand "rdc") (("1" (hide-all-but (-1 1)) (("1" (lemma "member_reverse[nat]") (("1" (inst -1 "w" "cdr(reverse(walked))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "no_repetitions_append[nat]") (("2" (replace -1 :dir rl) (("2" (flatten) (("2" (assert) (("2" (skeep -6) (("2" (inst -5 "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (1 -11 -5)) (("2" (expand "cycle?") (("2" (use "prefix_cdr[nat]") (("1" (assert) (("1" (hide -3) (("1" (use "no_repetitions_prefix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (expand "walk?" -3) (("2" (flatten) nil nil)) nil)) nil) ("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (hide-all-but (1 -2 -3 -5)) (("2" (replace -3 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix? def-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (null_reverse formula-decl nil more_list_props structures) (prefix_cdr formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (rdc_rac formula-decl nil more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (suffix_end formula-decl nil more_list_props structures)) nil (cycles_from subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC8-1 nil 3655550370 ("" (skeep*) (("" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (replace -1 :hide? t) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -4 :hide? t) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (replace -4 :hide? t) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "walked") (("2" (case "no_repetitions?(cdr(reverse[nat](cons[nat](w, walked))))") (("1" (expand "reverse" -1) (("1" (case "no_repetitions?(cdr(reverse(walked))) AND no_repetitions?(cons(w, null)) AND NOT EXISTS(n:nat): member(n,cdr(reverse(walked))) AND member(n, cons(w,null))") (("1" (hide -2) (("1" (flatten) (("1" (inst 1 "w") (("1" (expand "member" 1 2) (("1" (lemma "rdc_rac[nat]") (("1" (inst -1 "walked") (("1" (replace -1 -10 :dir rl :hide? t) (("1" (expand "rac") (("1" (expand "last") (("1" (replace -7 -9 :hide? t) (("1" (use "member_append_fi[nat]") (("1" (assert) (("1" (expand "member" -1 2) (("1" (expand "member" -1 2) (("1" (expand "rdc") (("1" (hide-all-but (-1 1)) (("1" (lemma "member_reverse[nat]") (("1" (inst -1 "w" "cdr(reverse(walked))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "no_repetitions_append") (("2" (replace -1 :dir rl) (("2" (flatten) (("2" (assert) (("2" (skeep -6) (("2" (inst -5 "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "walk?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (1 -11 -5)) (("2" (expand "cycle?") (("2" (use "prefix_cdr[nat]") (("1" (assert) (("1" (hide -3) (("1" (use "no_repetitions_prefix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (expand "walk?" -3) (("2" (flatten) nil nil)) nil)) nil) ("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (use "null_reverse[nat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (hide-all-but (1 -2 -3 -5)) (("2" (replace -3 :hide? t) (("2" (use "loi_cons") (("2" (assert) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prefix? def-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (null_reverse formula-decl nil more_list_props structures) (prefix_cdr formula-decl nil more_list_props structures) (rdc_rac formula-decl nil more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (suffix_end formula-decl nil more_list_props structures)) nil (cycles_from subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_from_TCC11 0 (cycles_from_TCC9-3 "" 3804539350 ("" (use "cycle_construction_grow") (("" (skeep) (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (cycle_construction_grow formula-decl nil c_digraph_all_cycles nil)) shostak (cycles_from subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}")) (cycles_from_TCC9-2 nil 3656334023 ("" (use "cycle_construction_grow") nil nil) ((suffix? def-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil)) nil (cycles_from subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}")) (cycles_from_TCC9-1 nil 3655550370 ("" (skeep) (("" (typepred "walked") (("" (hide -1) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "walking") (("1" (replace -8 :hide? t) (("1" (hide-all-but (1 -2)) (("1" (expand "list_of_idxs") (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (typepred "walking") (("2" (hide -1) (("2" (hide-all-but (1 -4 -2 -7)) (("2" (use "walk_append") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -3 -1 :hide? t) (("2" (use "suffix_member[nat]") (("2" (assert) (("2" (inst -1 "w") (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "walked") (("1" (assert) (("1" (expand "member" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (use "null_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (replace -6 -2 :hide? t) (("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (skeep) (("2" (inst -1 "i") (("1" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "reverse" 1) (("3" (use "no_repetitions_append") (("3" (replace -1 1 :dir rl :hide? t) (("3" (assert) (("3" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -2) (("2" (expand "member" -2) (("2" (replace -2 :hide? t) (("2" (lemma "member_reverse[nat]") (("2" (inst -1 "w" "walked") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (use "last_cons[nat]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (length_null formula-decl nil more_list_props structures) (suffix_member formula-decl nil more_list_props structures) (null_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (member_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures)) nil (cycles_from subtype "list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}"))) (cycles_from_TCC12 0 (cycles_from_TCC10-1 nil 3655550370 ("" (skeep) (("" (typepred "walking") (("" (hide -1) (("" (expand "list_of_idxs") (("" (inst -1 "0") (("1" (replace -3 :hide? t) (("1" (expand "nth" -1) (("1" (expand "size") (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 :hide? t) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (walking skolem-const-decl "{walking: (list_of_idxs(C)) | suffix?(walking, nth(adjs(C), car(walked)))}" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_from subtype "c_digraph_all_cycles.w" "below[length[list[nat]](adjs(C))]"))) (cycles_from_TCC13 0 (cycles_from_TCC11-1 nil 3655550370 ("" (skeep*) (("" (split 3) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (inst -2 "w") (("1" (expand "list_of_idxs") (("1" (inst -2 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil) ((< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (suffix_reflexive formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from subtype "list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w))}"))) (cycles_from_TCC14 0 (cycles_from_TCC12-1 nil 3655550370 ("" (skeep*) (("" (lemma "lex2_lt") (("" (expand "cycles_from_measure") (("" (inst? -1 :where 3) (("1" (replace -1 :hide? t) (("1" (flatten) (("1" (hide 4) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "cycle_construction_size") nil nil) ("3" (lemma "cycle_construction_size") (("3" (inst -1 "C" "v" "cons(w,walked)") (("3" (assert) (("3" (use "cycle_construction_grow") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (suffix? def-decl "bool" more_list_props structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cycle_construction_size formula-decl nil c_digraph_all_cycles nil) (cycle_construction_grow formula-decl nil c_digraph_all_cycles nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w))" "nil"))) (cycles_from_TCC15 0 (cycles_from_TCC13-1 nil 3655550370 ("" (skeep*) (("" (typepred "walking") (("" (replaces -4) (("" (split 3) (("1" (hide-all-but (-2 1)) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (typepred "i") (("1" (inst -2 "i+1") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (use "suffix_end[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (i skolem-const-decl "below(length(ws))" c_digraph_all_cycles nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (suffix_end formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_from subtype "c_digraph_all_cycles.ws" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), list_adt[nat].car(c_digraph_all_cycles.walked)))}"))) (cycles_from_TCC16 0 (cycles_from_TCC14-1 nil 3655550370 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last const-decl "T" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (/= const-decl "boolean" notequal nil) (< def-decl "bool" ordinals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (lex2 const-decl "ordinal" lex2 nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cycles_from termination "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws)" "nil"))) (cycles_from_TCC17 0 (cycles_from_TCC17-1 "" 3884642508 ("" (skeep*) (("" (case "list_of_idxs[T](C)(nth[list[nat]](adjs(C), w))") (("1" (label "loi_adjs_w" -1) (("1" (hide "loi_adjs_w") (("1" (split 3) (("1" (flatten) (("1" (use "member_append_fi[(cycle?(C))]") (("1" (assert) (("1" (hide -2) (("1" (split -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w") (("1" (replace -4 1) (("1" (expand "member" 1 1) (("1" (hide-all-but (-2 1)) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (skeep -1) (("1" (replace -1 :dir rl :hide? t) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (inst 1 "cons(w_1, L)") (("1" (expand "reverse" 1 2) (("1" (use "append_assoc[nat]") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 3) (("1" (expand "append" 1 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs" -2) (("2" (replace -7 :hide? t) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (reveal -2) (("2" (replaces -1) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC11") (("3" (assert) nil nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC15") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC15") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC11") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (replace -3 -1) (("2" (expand "member" -1) (("2" (split -1) (("1" (replaces -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_l[(cycle?(C))]") (("1" (assert) (("1" (typepred "cycle") (("1" (case "NOT reverse[nat](cons[nat](w, walked)) = cycle") (("1" (label "cycle is incomplete" 1) (("1" (hide "cycle is incomplete") (("1" (inst 2 "nth(cycle, length(walked) + 1)") (("1" (hide -1) (("1" (case "nth(cycle, length(walked)) = w") (("1" (split 2) (("1" (expand "walk?") (("1" (flatten) (("1" (hide-all-but (-1 -3 1)) (("1" (inst -2 "length(walked)") (("1" (assert) nil nil) ("2" (reveal -5) (("2" (hide-all-but (1 -1)) (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (expand "length" -1 1) (("2" (case "1 + length[nat](walked) = length(cycle)") (("1" (hide -2 1) (("1" (reveal -10 "cycle is incomplete") (("1" (use "prefix_eq[nat]") (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "reverse" 1) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where -2) (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :dir rl) (("2" (use "prefix_app[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where 1) (("2" (replace -1 :hide? t) (("2" (case "NOT null? (L)") (("1" (label "L not null" 1) (("1" (hide "L not null") (("1" (inst 1 "cdr(L)") (("1" (case "car(L)= nth(append(reverse[nat](cons[nat](w, walked)), L),
                                                                                                                                                                                                                                                       1 + length(walked))
                                                                                                                                                                                                                                                   ") (("1" (replaces -1 :dir rl :hide? t) (("1" (expand "append" 1) (("1" (expand "append" 1) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (reveal "L not null") (("2" (expand "length" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "L not null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (reveal "cycle is incomplete") (("2" (use "append_null[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "reverse" -1) (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :hide? t :dir rl) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 3) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -5)) (("3" (use "prefix_length[nat]") (("3" (assert) (("3" (hide -2) (("3" (use "length_reverse[nat]") (("3" (replace -1 :hide? t) (("3" (expand "length" -1 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1 + length[nat](walked)") nil nil)) nil)) nil) ("3" (hide-all-but (1 -6)) (("3" (reveal "cycle is incomplete") (("3" (assert) (("3" (case "length(reverse[nat](cons[nat](w, walked))) = length(cycle)") (("1" (hide -2 2) (("1" (use "prefix_eq[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1 3)) (("2" (use "prefix_length[nat]") (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (-6 -5 5 -10)) (("2" (replace -2 :dir rl :hide? t) (("2" (expand "circuit?") (("2" (flatten) (("2" (lemma "car_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (use "last_cons[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC15") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC11") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC11") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_r[(cycle?(C))]") (("1" (assert) (("1" (inst 2 "w!1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "cycles_from_TCC15") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC11") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "cycles_from_TCC15") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (inst -2 "w") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cycles_from subtype "list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].append(c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC15-2 "" 3744342678 ("" (skeep*) (("" (case "list_of_idxs[T](C)(nth[list[nat]](adjs(C), w))") (("1" (label "loi_adjs_w" -1) (("1" (hide "loi_adjs_w") (("1" (split 3) (("1" (flatten) (("1" (use "member_append_fi[(cycle?(C))]") (("1" (assert) (("1" (hide -2) (("1" (split -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w") (("1" (replace -4 1) (("1" (expand "member" 1 1) (("1" (hide-all-but (-2 1)) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (skeep -1) (("1" (replace -1 :dir rl :hide? t) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (inst 1 "cons(w_1, L)") (("1" (expand "reverse" 1 2) (("1" (use "append_assoc[nat]") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 3) (("1" (expand "append" 1 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs" -2) (("2" (replace -7 :hide? t) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (reveal -2) (("2" (replaces -1) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (replace -3 -1) (("2" (expand "member" -1) (("2" (split -1) (("1" (replaces -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_l[(cycle?(C))]") (("1" (assert) (("1" (typepred "cycle") (("1" (case "NOT reverse[nat](cons[nat](w, walked)) = cycle") (("1" (label "cycle is incomplete" 1) (("1" (hide "cycle is incomplete") (("1" (inst 2 "nth(cycle, length(walked) + 1)") (("1" (hide -1) (("1" (case "nth(cycle, length(walked)) = w") (("1" (split 2) (("1" (expand "walk?") (("1" (flatten) (("1" (hide-all-but (-1 -3 1)) (("1" (inst -2 "length(walked)") (("1" (assert) nil nil) ("2" (reveal -5) (("2" (hide-all-but (1 -1)) (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (expand "length" -1 1) (("2" (case "1 + length[nat](walked) = length(cycle)") (("1" (hide -2 1) (("1" (reveal -10 "cycle is incomplete") (("1" (use "prefix_eq[nat]") (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "reverse" 1) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where -2) (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :dir rl) (("2" (use "prefix_app[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where 1) (("2" (replace -1 :hide? t) (("2" (case "NOT null? (L)") (("1" (label "L not null" 1) (("1" (hide "L not null") (("1" (inst 1 "cdr(L)") (("1" (case "car(L)= nth(append(reverse[nat](cons[nat](w, walked)), L),
                                                                                                                                                                                                                          1 + length(walked))
                                                                                                                                                                                                                      ") (("1" (replaces -1 :dir rl :hide? t) (("1" (expand "append" 1) (("1" (expand "append" 1) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (reveal "L not null") (("2" (expand "length" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "L not null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (reveal "cycle is incomplete") (("2" (use "append_null[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "reverse" -1) (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :hide? t :dir rl) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 3) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -5)) (("3" (use "prefix_length[nat]") (("3" (assert) (("3" (hide -2) (("3" (use "length_reverse[nat]") (("3" (replace -1 :hide? t) (("3" (expand "length" -1 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1 + length[nat](walked)") nil nil)) nil)) nil) ("3" (hide-all-but (1 -6)) (("3" (reveal "cycle is incomplete") (("3" (assert) (("3" (case "length(reverse[nat](cons[nat](w, walked))) = length(cycle)") (("1" (hide -2 2) (("1" (use "prefix_eq[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1 3)) (("2" (use "prefix_length[nat]") (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (-6 -5 5 -10)) (("2" (replace -2 :dir rl :hide? t) (("2" (expand "circuit?") (("2" (flatten) (("2" (lemma "car_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (use "last_cons[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_r[(cycle?(C))]") (("1" (assert) (("1" (inst 2 "w!1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (inst -2 "w") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (prefix_length formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (length_singleton formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length_reverse formula-decl nil list_props nil) (prefix_eq formula-decl nil more_list_props structures) (prefix_app formula-decl nil more_list_props structures) (append_null formula-decl nil list_props nil) (L skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nth_append formula-decl nil more_list_props structures) (list_cons_extensionality formula-decl nil list_adt nil) (cycle skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (car_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (member_append_l formula-decl nil more_list_props structures) (member_append_r formula-decl nil more_list_props structures) (cycles_from_TCC11 subtype-tcc nil c_digraph_all_cycles nil) (suffix_reflexive formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (prefix_supl formula-decl nil more_list_props structures) (append def-decl "list[T]" list_props nil) (append_assoc formula-decl nil list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (walking skolem-const-decl "{walking: (list_of_idxs(C)) | suffix?(walking, nth(adjs(C), car(walked)))}" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cycles_from_TCC15 subtype-tcc nil c_digraph_all_cycles nil) (walked skolem-const-decl "{walked: (list_of_idxs(C)) |
   walk?(C)(reverse(walked)) AND
    no_repetitions?(reverse(walked)) AND last(walked) = v}" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (w skolem-const-decl "nat" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (suffix? def-decl "bool" more_list_props structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (ws skolem-const-decl "list[nat]" c_digraph_all_cycles nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (cycles_from_measure const-decl "ordinal" c_digraph_all_cycles nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (prefix? def-decl "bool" more_list_props structures) (member_append_fi formula-decl nil more_list_props structures) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cycles_from subtype "list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].append(c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}")) (cycles_from_TCC15-1 nil 3655550614 ("" (skeep*) (("" (case "list_of_idxs[T](C)(nth[list[nat]](adjs(C), w))") (("1" (label "loi_adjs_w" -1) (("1" (hide "loi_adjs_w") (("1" (split 3) (("1" (flatten) (("1" (use "member_append_fi[(cycle?(C))]") (("1" (assert) (("1" (hide -2) (("1" (split -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w") (("1" (replace -4 1) (("1" (expand "member" 1 1) (("1" (hide-all-but (-2 1)) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (skeep -1) (("1" (replace -1 :dir rl :hide? t) (("1" (lemma "prefix_supl[nat]") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (inst 1 "cons(w_1, L)") (("1" (expand "reverse" 1 2) (("1" (use "append_assoc[nat]") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 3) (("1" (expand "append" 1 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walking") (("2" (expand "list_of_idxs" -2) (("2" (replace -7 :hide? t) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (reveal -2) (("2" (replaces -1) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (assert) (("1" (skeep -1) (("1" (inst 1 "w_1") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep -1) (("2" (replace -3 -1) (("2" (expand "member" -1) (("2" (split -1) (("1" (replaces -1) (("1" (typepred "v1(C)(v)(cons[nat](w, walked), nth[list[nat]](adjs(C), w))") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_l[(cycle?(C))]") (("1" (assert) (("1" (typepred "cycle") (("1" (case "NOT reverse[nat](cons[nat](w, walked)) = cycle") (("1" (label "cycle is incomplete" 1) (("1" (hide "cycle is incomplete") (("1" (inst 2 "nth(cycle, length(walked) + 1)") (("1" (hide -1) (("1" (case "nth(cycle, length(walked)) = w") (("1" (split 2) (("1" (expand "walk?") (("1" (flatten) (("1" (hide-all-but (-1 -3 1)) (("1" (inst -2 "length(walked)") (("1" (assert) nil nil) ("2" (reveal -5) (("2" (hide-all-but (1 -1)) (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (expand "length" -1 1) (("2" (case "1 + length[nat](walked) = length(cycle)") (("1" (hide -2 1) (("1" (reveal -10 "cycle is incomplete") (("1" (use "prefix_eq[nat]") (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "reverse" 1) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where -2) (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :dir rl) (("2" (use "prefix_app[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "prefix_supl[nat]") (("2" (inst? -1 :where 1) (("2" (replace -1 :hide? t) (("2" (case "NOT null? (L)") (("1" (label "L not null" 1) (("1" (hide "L not null") (("1" (inst 1 "cdr(L)") (("1" (case "car(L)= nth(append(reverse[nat](cons[nat](w, walked)), L),
                                                                                                                                                                                             1 + length(walked))
                                                                                                                                                                                         ") (("1" (replaces -1 :dir rl :hide? t) (("1" (expand "append" 1) (("1" (expand "append" 1) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (reveal "L not null") (("2" (expand "length" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "L not null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (reveal "cycle is incomplete") (("2" (use "append_null[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "reverse" -1) (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (replace -1 :hide? t :dir rl) (("2" (use "nth_append[nat]") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_append[nat]") (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 3) (("1" (assert) (("1" (use "nth_append[nat]") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "length_reverse[nat]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_reverse[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (use "length_reverse[nat]") (("2" (replace -1 :hide? t) (("2" (expand "length" 1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -5)) (("3" (use "prefix_length[nat]") (("3" (assert) (("3" (hide -2) (("3" (use "length_reverse[nat]") (("3" (replace -1 :hide? t) (("3" (expand "length" -1 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1 + length[nat](walked)") nil nil)) nil)) nil) ("3" (hide-all-but (1 -6)) (("3" (reveal "cycle is incomplete") (("3" (assert) (("3" (case "length(reverse[nat](cons[nat](w, walked))) = length(cycle)") (("1" (hide -2 2) (("1" (use "prefix_eq[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1 3)) (("2" (use "prefix_length[nat]") (("2" (assert) (("2" (use "length_reverse[nat]") (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walked") (("2" (hide-all-but (-6 -5 5 -10)) (("2" (replace -2 :dir rl :hide? t) (("2" (expand "circuit?") (("2" (flatten) (("2" (lemma "car_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (use "last_cons[nat]") (("2" (replace -1 :hide? t) (("2" (lemma "last_reverse[nat]") (("2" (inst -1 "cons(w, walked)") (("2" (replace -1 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal "loi_adjs_w") (("2" (assert) (("2" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("3" (use "cycles_from_TCC9") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "v1(C)(v)(walked, ws)") (("1" (hide -1) (("1" (inst -1 "cycle") (("1" (use "member_append_r[(cycle?(C))]") (("1" (assert) (("1" (inst 2 "w_1") (("1" (assert) nil nil)) nil)) nil) ("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil) ("3" (hide-all-but 1) (("3" (reveal "loi_adjs_w") (("3" (assert) (("3" (use "suffix_reflexive[nat]") nil nil)) nil)) nil)) nil) ("4" (use "cycles_from_TCC9") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "cycles_from_TCC13") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (inst -2 "w") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (prefix_length formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (prefix_eq formula-decl nil more_list_props structures) (prefix_app formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (car_reverse formula-decl nil more_list_props structures) (last_reverse formula-decl nil more_list_props structures) (last_cons formula-decl nil more_list_props structures) (member_append_l formula-decl nil more_list_props structures) (member_append_r formula-decl nil more_list_props structures) (suffix_reflexive formula-decl nil more_list_props structures) (prefix_supl formula-decl nil more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (prefix? def-decl "bool" more_list_props structures) (member_append_fi formula-decl nil more_list_props structures)) nil (cycles_from subtype "list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].append(c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(list_adt[nat].cons(c_digraph_all_cycles.w, c_digraph_all_cycles.walked), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.w)), c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)(c_digraph_all_cycles.walked, c_digraph_all_cycles.ws))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), EXISTS (w: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): booleans.AND(list_props[nat].member(w, c_digraph_all_cycles.walking), more_list_props[nat].prefix?(list_props[nat].reverse(list_adt[nat].cons(w, c_digraph_all_cycles.walked)), cycle)))}"))) (cycles_for_TCC1 0 (cycles_for_TCC1-1 nil 3655811132 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_for subtype "c_digraph_all_cycles.cycle" "(list_adt[nat].cons?)"))) (cycles_for_TCC2 0 (cycles_for_TCC2-1 nil 3655811132 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (last const-decl "T" more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (walk? const-decl "bool" c_digraph_all_cycles nil)) nil (cycles_for subtype "(: c_digraph_all_cycles.v :)" "{walked: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | booleans.AND(c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)(list_props[nat].reverse(walked)), booleans.AND(more_list_props[nat].no_repetitions?(list_props[nat].reverse(walked)), more_list_props[nat].last(walked) = c_digraph_all_cycles.v))}"))) (cycles_for_TCC3 0 (cycles_for_TCC3-1 nil 3655811132 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_for subtype "c_digraph_all_cycles.v" "below[length[list[nat]](adjs(C))]"))) (cycles_for_TCC4 0 (cycles_for_TCC4-1 nil 3655811132 ("" (skeep) (("" (typepred "C") (("" (expand "cdigraph") (("" (flatten) (("" (inst -2 "v") (("1" (assert) (("1" (use "suffix_reflexive[nat]") nil nil)) nil) ("2" (typepred "v") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_reflexive formula-decl nil more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (below type-eq-decl nil naturalnumbers nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cycles_for subtype "list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.v)" "{walking: (c_digraphs_def[c_digraph_all_cycles.T].list_of_idxs(c_digraph_all_cycles.C)) | more_list_props[nat].suffix?(walking, list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.v))}"))) (cycles_for_TCC5 0 (cycles_for_TCC5-1 nil 3655811132 ("" (skeep*) (("" (typepred "cycles_from(C)(v)((: v :), nth[list[nat]](adjs(C), v))") (("" (hide -1) (("" (inst -1 "cycle") (("" (replace -1 :hide? t) (("" (split 1) (("1" (flatten) (("1" (skeep -1) (("1" (expand "reverse" -2) (("1" (expand "reverse" -2) (("1" (expand "reverse" -2) (("1" (expand "append" -2 2) (("1" (expand "append" -2) (("1" (expand "append" -2) (("1" (lemma "nnprefixes_same_head[nat]") (("1" (inst -1 "cycle" "cons(v,cons(w,null))") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "prefixes") (("2" (use "prefix_supl[nat]") (("2" (replace -1 :hide? t) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "nth(cycle,1)") (("1" (split 1) (("1" (typepred "cycle") (("1" (expand "walk?") (("1" (hide-all-but (1 -3 -6)) (("1" (flatten) (("1" (inst -1 "0") (("1" (expand "nth" -1 3) (("1" (assert) nil nil)) nil) ("2" (reveal -4) (("2" (expand "circuit?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "reverse" 1) (("2" (expand "reverse" 1) (("2" (expand "reverse" 1) (("2" (expand "append" 1 2) (("2" (case "cycle=append(cons(v,null),cdr(cycle))") (("1" (replace -1 1 :hide? t) (("1" (expand "append" 1) (("1" (expand "nth" 1) (("1" (expand "append" 1) (("1" (expand "nth" 1) (("1" (case "cons(car(cdr(cycle)), null) = append((:car(cdr(cycle)):),null)") (("1" (replace -1 :hide? t) (("1" (case "cdr(cycle) = append((:car(cdr(cycle)):),cdr(cdr(cycle)))") (("1" (replace -1 :hide? t) (("1" (expand "append" 1 2) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "append") (("2" (apply-extensionality) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (expand "append" 1) (("2" (replace -1 :dir rl) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cycle") (("2" (hide-all-but (-2 -4 1)) (("2" (expand "list_of_idxs") (("2" (inst -1 "1") nil nil)) nil)) nil)) nil) ("3" (typepred "cycle") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cycles_from def-decl "{cs: list[(cycle?(C))] |
   FORALL (cycle: (cycle?(C))):
     member(cycle, cs) IFF
      EXISTS (w: below(size(C))):
        member(w, walking) AND prefix?(reverse(cons(w, walked)), cycle)}" c_digraph_all_cycles nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (prefix? def-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (suffix? def-decl "bool" more_list_props structures) (< const-decl "bool" reals nil) (last const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (append def-decl "list[T]" list_props nil) (prefixes const-decl "bool" more_list_props structures) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (cycle skolem-const-decl "(cycle?(C))" c_digraph_all_cycles nil) (v skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (w skolem-const-decl "below(size(C))" c_digraph_all_cycles nil) (null adt-constructor-decl "(null?)" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (prefix_supl formula-decl nil more_list_props structures) (nnprefixes_same_head formula-decl nil more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (list_cons_extensionality formula-decl nil list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cycles_for subtype "c_digraph_all_cycles.cycles_from(c_digraph_all_cycles.C)(c_digraph_all_cycles.v)((: c_digraph_all_cycles.v :), list_props[list[nat]].nth(adjs(c_digraph_all_cycles.C), c_digraph_all_cycles.v))" "{cs: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, cs), list_adt[nat].car(cycle) = c_digraph_all_cycles.v)}"))) (all_cycles_rec_TCC1 0 (all_cycles_rec_TCC1-1 nil 3656158837 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (int_minus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (all_cycles_rec subtype "c_digraph_all_cycles.i" "below[length[list[(cycle?(C))]](cs)]"))) (all_cycles_rec_TCC2 0 (all_cycles_rec_TCC3-1 nil 3656158837 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (all_cycles_rec subtype "(number_fields.-)(c_digraph_all_cycles.n, 1)" "below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))"))) (all_cycles_rec_TCC3 0 (all_cycles_rec_TCC4-2 "" 3790101860 ("" (skeep*) (("" (case "n=0") (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (all_cycles_rec termination "c_digraph_all_cycles.all_cycles_rec(c_digraph_all_cycles.C)((number_fields.-)(c_digraph_all_cycles.n, 1))" "nil")) (all_cycles_rec_TCC4-1 nil 3656158837 ("" (skeep*) (("" (case "n=0") (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (split 2) (("1" (typepred "v(C)(n - 1)") (("1" (grind) nil nil)) nil) ("2" (skeep 1 :preds? t) (("2" (case "i=n-2") (("1" (hide -2) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil)) nil (all_cycles_rec termination "c_digraph_all_cycles.all_cycles_rec(c_digraph_all_cycles.C)((number_fields.-)(c_digraph_all_cycles.n, 1))" "nil"))) (all_cycles_rec_TCC4 0 (all_cycles_rec_TCC2-1 nil 3656158837 ("" (skeep*) (("" (case "n=0") (("1" (replace -1) (("1" (assert) (("1" (split 1) (("1" (use "length_append[list[(cycle?(C))]]") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (replace -2) (("2" (assert) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (skeep) (("1" (lemma "append_null_left[list[(cycle?(C))]]") (("1" (inst -1 "(: cycles_for(C)(0) :)") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (typepred "cycles_for(C)(0)") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split 2) (("1" (typepred "v(C)(n - 1)") (("1" (hide-all-but (1 -2)) (("1" (use "length_append[list[(cycle?(C))]]") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case "i=n") (("1" (replace -1 :hide? t) (("1" (hide -1) (("1" (skeep) (("1" (lemma "nth_append[list[(cycle?(C))]]") (("1" (inst -1 "v(C)(n - 1)" "(: cycles_for(C)(n) :)" "n") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (typepred "v(C)(n-1)") (("1" (replace -2 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (hide -1 -2) (("1" (typepred "cycles_for(C)(n)") (("1" (inst -2 "cycle") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep 2) (("2" (use "nth_append[list[(cycle?(C))]]") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (typepred "v(C)(n-1)") (("2" (inst -3 "i") (("2" (inst -3 "cycle") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (cdigraph const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (append_null_left formula-decl nil more_list_props structures) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (length_append formula-decl nil list_props nil) (cycles_for const-decl "{cs: list[(cycle?(C))] |
   FORALL (cycle: (cycle?(C))): member(cycle, cs) IFF car(cycle) = v}" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth_append formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (all_cycles_rec subtype "list_props[list[(cycle?(C))]].append(IF c_digraph_all_cycles.n = 0 THEN list_adt[list[(cycle?(C))]].null ELSE c_digraph_all_cycles.all_cycles_rec(c_digraph_all_cycles.C)((number_fields.-)(c_digraph_all_cycles.n, 1)) ENDIF, (: c_digraph_all_cycles.cycles_for(c_digraph_all_cycles.C)(c_digraph_all_cycles.n) :))" "{cs: list_adt[list[(cycle?(C))]].list | booleans.AND(list_props[list[(cycle?(C))]].length(cs) = (number_fields.+)(1, c_digraph_all_cycles.n), FORALL (i: naturalnumbers.below((number_fields.+)(c_digraph_all_cycles.n, 1))): FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, list_props[list[(cycle?(C))]].nth(cs, i)), list_adt[nat].car(cycle) = i))}"))) (all_cycles_TCC1 0 (all_cycles_TCC1-1 nil 3656158837 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (last const-decl "T" more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil)) nil (all_cycles subtype "c_digraph_all_cycles.i" "below[length[list[(cycle?(C))]](cs)]"))) (all_cycles_TCC2 0 (all_cycles_TCC2-1 nil 3656158837 ("" (skeep :preds? t) (("" (split 1) (("1" (grind) nil nil) ("2" (skeep :preds? t) (("2" (assert) nil nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (all_cycles subtype "list_adt[list[(cycle?(C))]].null" "{cs: list_adt[list[(cycle?(C))]].list | booleans.AND(list_props[list[(cycle?(C))]].length(cs) = c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), FORALL (i: naturalnumbers.below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))): FORALL (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, list_props[list[(cycle?(C))]].nth(cs, i)), list_adt[nat].car(cycle) = i))}"))) (all_cycles_TCC3 0 (all_cycles_TCC3-1 nil 3656163383 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (all_cycles subtype "(number_fields.-)(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), 1)" "below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))"))) (w?2w_TCC1 0 (w?2w_TCC1-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (w?2w subtype "list_props[nat].nth(c_digraph_all_cycles.cw, c_digraph_all_cycles.i)" "below[length[T](data(C))]"))) (w?2w_TCC2 0 (w?2w_TCC2-2 nil 3828697335 ("" (skeep) (("" (typepred "cw") (("" (expand "walk?" -3) (("" (flatten) (("" (split 2) (("1" (grind) nil nil) ("2" (expand "walk?") (("2" (expand "finseq_appl") (("2" (expand "verts_in?") (("2" (expand "digraph_verts") (("2" (split 1) (("1" (skeep) (("1" (expand "vert") (("1" (use "nth_member[T]") nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "edge?") (("2" (expand "digraph_edges") (("2" (expand "edges") (("2" (assert) (("2" (expand "vert") (("2" (split 1) (("1" (use "nth_member[T]") nil nil) ("2" (use "nth_member[T]") nil nil) ("3" (use "idx_nth_no_rep[T]") (("1" (replace -1 :hide? t) (("1" (use "idx_nth_no_rep[T]") (("1" (replace -1 :hide? t) (("1" (inst? -4 :where 1) nil nil)) nil) ("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" walks_ nil) (verts_in? const-decl "bool" walks_ nil) (vert const-decl "bool" c_digraphs_def nil) (nth_member formula-decl nil more_list_props structures) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (edge? const-decl "bool" digraphs_ nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (edges const-decl "bool" c_digraphs_def nil) (idx_nth_no_rep formula-decl nil more_list_props structures) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (w?2w subtype "(# length := list_props[nat].length(c_digraph_all_cycles.cw), seq := (LAMBDA (i: naturalnumbers.below(list_props[nat].length(c_digraph_all_cycles.cw))): list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), list_props[nat].nth(c_digraph_all_cycles.cw, i))) #)" "{w: walks_[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make].Walk(c_digraph_all_cycles.C) | c_digraph_all_cycles.walk_eq(c_digraph_all_cycles.C)(w, c_digraph_all_cycles.cw)}")) (w?2w_TCC2-1 nil 3828696916 ("" (subtype-tcc) nil nil) nil nil (w?2w subtype "(# length := list_props[nat].length(c_digraph_all_cycles.cw), seq := (LAMBDA (i: naturalnumbers.below(list_props[nat].length(c_digraph_all_cycles.cw))): list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), list_props[nat].nth(c_digraph_all_cycles.cw, i))) #)" "{w: walks_[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make].Walk(c_digraph_all_cycles.C) | c_digraph_all_cycles.walk_eq(c_digraph_all_cycles.C)(w, c_digraph_all_cycles.cw)}"))) (w2w?_rec_TCC1 0 (w2w?_rec_TCC1-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def nil) (verts_in? const-decl "bool" walks_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def nil) (edge? const-decl "bool" digraphs_ nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (w2w?_rec subtype "(number_fields.+)(c_digraph_all_cycles.i, c_digraph_all_cycles.offset)" "below[length(w)]"))) (w2w?_rec_TCC2 0 (w2w?_rec_TCC2-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (w2w?_rec subtype "(number_fields.-)(length(c_digraph_all_cycles.w), c_digraph_all_cycles.offset)" "naturalnumber"))) (w2w?_rec_TCC3 0 (w2w?_rec_TCC3-1 nil 3828696916 ("" (then (skeep) (expand "finseq_appl") (typepred "C") (typepred "w") (expand "walk?") (flatten) (expand "verts_in?") (expand "digraph_verts") (inst -2 "offset") (typepred "list2set(data(C::ComputableDigraph[T]))") (replace -2 :hide? t) (assert) (expand "vert") (propax)) nil nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (verts_in? const-decl "bool" walks_ nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vert const-decl "bool" c_digraphs_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (w2w?_rec subtype "finite_sequences[c_digraph_all_cycles.T].finseq_appl(c_digraph_all_cycles.w)(c_digraph_all_cycles.offset)" "{a: c_digraph_all_cycles.T | list_props[c_digraph_all_cycles.T].member(a, data(c_digraph_all_cycles.C))}"))) (w2w?_rec_TCC4 0 (w2w?_rec_TCC5-1 nil 3828696916 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def nil) (verts_in? const-decl "bool" walks_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def nil) (edge? const-decl "bool" digraphs_ nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (w2w?_rec subtype "(number_fields.+)(c_digraph_all_cycles.offset, 1)" "below(length(c_digraph_all_cycles.w))"))) (w2w?_rec_TCC5 0 (w2w?_rec_TCC6-1 nil 3828696916 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (w2w?_rec termination "c_digraph_all_cycles.w2w?_rec(c_digraph_all_cycles.C)(c_digraph_all_cycles.w, (number_fields.+)(c_digraph_all_cycles.offset, 1))" "nil"))) (w2w?_rec_TCC6 0 (w2w?_rec_TCC4-1 nil 3828696916 ("" (skeep) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (expand "list_of_idxs") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "finseq_appl") (("4" (skeep) (("4" (typepred "i") (("4" (assert) (("4" (case "i=0") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "nth" 1 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "v(C) (w, offset + 1)") (("1" (hide -1) (("1" (expand "finseq_appl") (("1" (split 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (expand "size") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -1 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?") (("2" (skeep 1) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 3) (("1" (expand "nth" 1 1) (("1" (typepred "w") (("1" (expand "walk?") (("1" (flatten) (("1" (inst -3 "offset") (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst -7 "0") (("1" (assert) (("1" (replace -7 :hide? t) (("1" (expand "edge?") (("1" (expand "digraph_edges") (("1" (expand "edges") (("1" (flatten) (("1" (use "idx_nth_no_rep[T]") (("1" (assert) nil nil) ("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2 3) (("2" (assert) (("2" (expand "nth" 2 1) (("2" (inst -2 "i-1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "length" 1 1) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 2) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "nth" 2 2) (("2" (assert) (("2" (inst -4 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below(length(cons[nat]
                 (idx[T](data(C), w`seq(offset)), v(C)(w, 1 + offset)))
       - 1)" c_digraph_all_cycles nil) (v skolem-const-decl "[C1: (cdigraph) ->
   [d1:
      {z:
         [w:
            Walk[T, digraph_type[T], digraph_verts, digraph_edges,
                 digraph_size, digraph_make](C1),
          below(length(w))] |
         length(z`1) - z`2 < length(w) - offset} ->
      {wi: (walk?(C1)) |
         length(wi) + d1`2 = length(d1`1) AND
          FORALL (i: below(length(wi))):
            finseq_appl[T](d1`1)(i + d1`2) = nth(data(C1), nth(wi, i))}]]" c_digraph_all_cycles nil) (offset skolem-const-decl "below(length(w))" c_digraph_all_cycles nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](C)" c_digraph_all_cycles nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (edge? const-decl "bool" digraphs_ nil) (edges const-decl "bool" c_digraphs_def nil) (idx_nth_no_rep formula-decl nil more_list_props structures) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (length_singleton formula-decl nil more_list_props structures) (walk? const-decl "bool" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (size const-decl "nat" c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (w2w?_rec subtype "list_adt[nat].cons(more_list_props[c_digraph_all_cycles.T].idx(data(c_digraph_all_cycles.C), finite_sequences[c_digraph_all_cycles.T].finseq_appl(c_digraph_all_cycles.w)(c_digraph_all_cycles.offset)), IF c_digraph_all_cycles.offset = (number_fields.-)(length(c_digraph_all_cycles.w), 1) THEN list_adt[nat].null ELSE c_digraph_all_cycles.w2w?_rec(c_digraph_all_cycles.C)(c_digraph_all_cycles.w, (number_fields.+)(c_digraph_all_cycles.offset, 1)) ENDIF)" "{wi: (c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)) | booleans.AND((number_fields.+)(c_digraph_all_cycles.offset, list_props[nat].length(wi)) = length(c_digraph_all_cycles.w), FORALL (i: naturalnumbers.below(list_props[nat].length(wi))): finite_sequences[c_digraph_all_cycles.T].finseq_appl(c_digraph_all_cycles.w)((number_fields.+)(i, c_digraph_all_cycles.offset)) = list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), list_props[nat].nth(wi, i)))}"))) (w2w?_TCC1 0 (w2w?_TCC1-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (w2w? subtype "0" "below(length(c_digraph_all_cycles.w))"))) (w2w?_TCC2 0 (w2w?_TCC2-1 nil 3828696916 ("" (then (skeep) (typepred "w2w?_rec(C)(w, 0)") (expand "walk_eq") (assert) (skeep) (inst -5 "i")) nil nil) ((walk_eq const-decl "bool" c_digraph_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (Walk type-eq-decl nil walks_ nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nth def-decl "T" list_props nil) (w2w?_rec def-decl "{wi: (walk?(C)) |
   length(wi) + offset = length(w) AND
    FORALL (i: below(length(wi))):
      finseq_appl[T](w)(i + offset) = nth(data(C), nth(wi, i))}" c_digraph_all_cycles nil)) nil (w2w? subtype "c_digraph_all_cycles.w2w?_rec(c_digraph_all_cycles.C)(c_digraph_all_cycles.w, 0)" "{wi: (c_digraph_all_cycles.walk?(c_digraph_all_cycles.C)) | c_digraph_all_cycles.walk_eq(c_digraph_all_cycles.C)(c_digraph_all_cycles.w, wi)}"))) (w2w?_circuit 0 (w2w?_circuit-1 nil 3828696936 ("" (skeep) (("" (typepred "w2w?(C)(w)") (("" (hide -1) (("" (expand "circuit?") (("" (flatten) (("" (split 1) (("1" (expand "pre_circuit?") (("1" (expand "finseq_appl") (("1" (expand "walk_eq") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (inst? :copy? t) (("1" (expand "last") (("1" (inst -4 "length(w)-1") (("1" (replace -4 :hide? t) (("1" (replace -3 :hide? t) (("1" (replace -3 :hide? t) (("1" (hide-all-but (-3 1)) (("1" (expand "nth" -1 2) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (hide-all-but (-5 1 -3)) (("1" (expand "no_repetitions?") (("1" (inst -1 "car(w2w?(C)(w))" "nth(w2w?(C)(w), length(w2w?(C)(w)) - 1)") (("1" (assert) nil nil) ("2" (typepred "w2w?(C)(w)") (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "w2w?(C)(w)") (("2" (expand "walk_eq") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((w2w? const-decl "{wi: (walk?(C)) | walk_eq(C)(w, wi)}" c_digraph_all_cycles nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (Walk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" circuits_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (no_repetitions? const-decl "bool" more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](C)" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (last const-decl "T" more_list_props structures) (pre_circuit? const-decl "bool" circuits_ nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (w2w?_cycle_TCC1 0 (w2w?_cycle_TCC1-1 nil 3828696916 ("" (then (skeep) (use "w2w?_circuit") (assert) (expand "cycle?") (propax)) nil nil) ((cycle? const-decl "bool" cycles_ nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (w2w?_circuit formula-decl nil c_digraph_all_cycles nil)) nil (w2w?_cycle subtype "c_digraph_all_cycles.w2w?(c_digraph_all_cycles.C)(c_digraph_all_cycles.w)" "(c_digraph_all_cycles.circuit?(c_digraph_all_cycles.C))"))) (w2w?_cycle 0 (w2w?_cycle-1 nil 3828696936 ("" (skeep) (("" (typepred "w2w?(C)(w)") (("" (hide -1) (("" (expand "cycle?") (("" (flatten) (("" (expand "finseq_appl") (("" (expand "no_repetitions?") (("" (skeep :preds? t) (("" (expand "walk_eq") (("" (flatten) (("" (expand "finseq_appl") (("" (expand "length" -5) (("" (lift-if -5) (("" (split -5) (("1" (flatten) (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "i < length(w) -1") (("1" (hide -3) (("1" (case "j<length(w)-1") (("1" (hide -4) (("1" (case "i+1=length(w)-1") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "pre_circuit?") (("1" (expand "finseq_appl") (("1" (inst -10 "0" "j+1") (("1" (assert) (("1" (inst-cp -7 "j+1") (("1" (replace -8 2 :hide? t) (("1" (expand "nth" 2 2) (("1" (replace -10 :dir rl :hide? t) (("1" (assert) (("1" (inst -7 "length(w)-1") (("1" (replace -7 -8 :hide? t) (("1" (replace -1 :hide? t :dir rl) (("1" (expand "nth" -6 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j+1=length(w)-1") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "pre_circuit?") (("1" (expand "finseq_appl") (("1" (inst -10 "0" "i+1") (("1" (assert) (("1" (inst-cp -7 "i+1") (("1" (replace -8 3 :hide? t) (("1" (expand "nth" 3 2) (("1" (replace -10 :hide? t) (("1" (inst -7 "length(w)-1") (("1" (replace -7 -8 :hide? t) (("1" (replace -1 :hide? t :dir rl) (("1" (expand "nth" -6 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -6 "i+1") (("1" (expand "nth" -7 2) (("1" (inst -6 "j+1") (("1" (expand "nth" -6 2) (("1" (inst -9 "i+1" "j+1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((w2w? const-decl "{wi: (walk?(C)) | walk_eq(C)(w, wi)}" c_digraph_all_cycles nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (Walk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" cycles_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (j skolem-const-decl "below(length[nat](cdr(w2w?(C)(w))))" c_digraph_all_cycles nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](C)" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph)" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ nil) (circuit? const-decl "bool" circuits_ nil) (i skolem-const-decl "below(length[nat](cdr(w2w?(C)(w))))" c_digraph_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures)) shostak)) (lc?2lw_TCC1 0 (lc?2lw_TCC2-1 nil 3828696916 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (finseq type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lc?2lw subtype "c_digraph_all_cycles.i" "below[length[(cycle?(C))](cycles)]"))) (lc?2lw_TCC2 0 (lc?2lw_TCC1-1 nil 3828696916 ("" (then (skeep) (typepred "nth(cycles,i)") (expand "circuit?") (flatten) (assert)) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil)) nil (lc?2lw subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]"))) (lc?2lw_TCC3 0 (lc?2lw_TCC3-2 "" 3884643003 ("" (skeep) (("" (typepred "nth(cycles,i)") (("" (expand "circuit?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (lc?2lw subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]")) (lc?2lw_TCC3-1 nil 3828696916 ("" (grind) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil)) nil (lc?2lw subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]"))) (lc?2lw_TCC4 0 (lc?2lw_TCC4-1 "" 3884643054 ("" (grind) nil nil) nil shostak (lc?2lw subtype "list_adt[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].null" "{cs: list_adt[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].list | booleans.AND(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(cs) = list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].length(c_digraph_all_cycles.cycles), FORALL (i: naturalnumbers.below(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(cs))): c_digraph_all_cycles.walk_eq(c_digraph_all_cycles.C)(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].nth(cs, i), list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].nth(c_digraph_all_cycles.cycles, i)))}")) (lc?2lw_TCC6-1 nil 3828696916 ("" (skeep) (("" (split 1) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (typepred "v(C)(v_idx, cycles_)") (("1" (hide -1) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (replace -4 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -2 "i-1") (("2" (assert) (("2" (replace -4 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "cycles") (("2" (hide -1) (("2" (skeep) (("2" (replace -3) (("2" (inst -1 "i!1+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lc?2lw subtype "list_adt[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].null" "{cs: list_adt[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].list | booleans.AND(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(cs) = list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].length(c_digraph_all_cycles.cycles), FORALL (i: naturalnumbers.below(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(cs))): c_digraph_all_cycles.walk_eq(c_digraph_all_cycles.C)(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].nth(cs, i), list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].nth(c_digraph_all_cycles.cycles, i)))}"))) (lc?2lw_TCC5 0 (lc?2lw_TCC4-1 nil 3828696916 ("" (skeep) (("" (skeep) (("" (typepred "cycles") (("" (hide -1) (("" (replace -2) (("" (inst -1 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cycles skolem-const-decl "{cycles: list[(cycle?(C))] |
   FORALL (i: below(length(cycles))): nth(nth(cycles, i), 0) = v_idx}" c_digraph_all_cycles nil) (v_idx skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (i skolem-const-decl "below(length(cycles_))" c_digraph_all_cycles nil) (cycles_ skolem-const-decl "list[(cycle?(C))]" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (size const-decl "nat" c_digraphs_def nil)) nil (lc?2lw subtype "c_digraph_all_cycles.cycles_" "{cycles: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (i: naturalnumbers.below(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].length(cycles))): list_props[nat].nth(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].nth(cycles, i), 0) = c_digraph_all_cycles.v_idx}"))) (lc?2lw_TCC6 0 (lc?2lw_TCC5-1 nil 3828696916 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil)) nil (lc?2lw termination "c_digraph_all_cycles.lc?2lw(c_digraph_all_cycles.C)(c_digraph_all_cycles.v_idx, c_digraph_all_cycles.cycles_)" "nil"))) (lc?2lw_TCC7 0 (lc?2lw_TCC7-1 nil 3884635194 ("" (skeep) (("" (split 1) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (typepred "v(C)(v_idx, cycles_)") (("1" (hide -1) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (replace -4 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -2 "i-1") (("2" (assert) (("2" (replace -4 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "cycles") (("2" (hide -1) (("2" (skeep) (("2" (replace -3) (("2" (inst -1 "i!1+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (w?2w const-decl "{w: Walk(C) | walk_eq(C)(w, cw)}" c_digraph_all_cycles nil) (cycles skolem-const-decl "{cycles: list[(cycle?(C))] |
   FORALL (i: below(length(cycles))): nth(nth(cycles, i), 0) = v_idx}" c_digraph_all_cycles nil) (v_idx skolem-const-decl "below(size[T](C))" c_digraph_all_cycles nil) (i!1 skolem-const-decl "below(length(cycles_))" c_digraph_all_cycles nil) (cycles_ skolem-const-decl "list[(cycle?(C))]" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil c_digraph_all_cycles nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (Walk type-eq-decl nil walks_ nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil)) nil (lc?2lw subtype "list_adt[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].cons(c_digraph_all_cycles.w?2w(c_digraph_all_cycles.C)(c_digraph_all_cycles.cycle), c_digraph_all_cycles.lc?2lw(c_digraph_all_cycles.C)(c_digraph_all_cycles.v_idx, c_digraph_all_cycles.cycles_))" "{cs: list_adt[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].list | booleans.AND(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(cs) = list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].length(c_digraph_all_cycles.cycles), FORALL (i: naturalnumbers.below(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(cs))): c_digraph_all_cycles.walk_eq(c_digraph_all_cycles.C)(list_props[Walk[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].nth(cs, i), list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].nth(c_digraph_all_cycles.cycles, i)))}"))) (ac2vl_rec_TCC1 0 (ac2vl_rec_TCC1-1 nil 3828696916 ("" (then (skeep) (typepred "C") (skeep :preds? t) (typepred "cs") (assert) (expand "size") (assert)) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil)) nil (ac2vl_rec subtype "(number_fields.+)(c_digraph_all_cycles.n, c_digraph_all_cycles.offset)" "below[length[T](data(C))]"))) (ac2vl_rec_TCC2 0 (ac2vl_rec_TCC2-1 nil 3828696916 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (VertCycles type-eq-decl nil cycles_ nil) (CyclesAt type-eq-decl nil cycles_ nil) (vert type-eq-decl nil digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (C!1 skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ac2vl_rec subtype "list_adt[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].null" "{l: list_adt[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].list | booleans.AND(list_props[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(l) = list_props[list[(cycle?(C))]].length(c_digraph_all_cycles.cs), FORALL (n: naturalnumbers.below(list_props[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(l))): list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), (number_fields.+)(n, c_digraph_all_cycles.offset)) = vert(list_props[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].nth(l, n)))}"))) (ac2vl_rec_TCC3 0 (ac2vl_rec_TCC3-1 nil 3828696916 ("" (then (skeep) (typepred "cs") (hide -1) (expand "size") (replace -1 :dir rl :hide? t) (grind)) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil (ac2vl_rec subtype "c_digraph_all_cycles.offset" "below[length[T](data(C))]"))) (ac2vl_rec_TCC4 0 (ac2vl_rec_TCC4-1 nil 3828696916 ("" (then (skeep) (typepred "C") (expand "vert?") (expand "digraph_verts") (expand "vert") (use "nth_member[T]")) nil nil) ((vert? const-decl "bool" digraphs_ nil) (vert const-decl "bool" c_digraphs_def nil) (nth_member formula-decl nil more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil)) nil (ac2vl_rec subtype "list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), c_digraph_all_cycles.offset)" "vert[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)"))) (ac2vl_rec_TCC5 0 (ac2vl_rec_TCC5-1 nil 3828696916 ("" (then (skeep) (typepred "cs") (grind)) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (last const-decl "T" more_list_props structures) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil (ac2vl_rec subtype "c_digraph_all_cycles.offset" "below(c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C))"))) (ac2vl_rec_TCC6 0 (ac2vl_rec_TCC6-1 nil 3828696916 ("" (skeep) (("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -3 :hide? t) (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (expand "nth" 1 1) (("1" (inst -2 "nth(cycles,i)") (("1" (assert) (("1" (use "nth_member[(cycle?(C))]") nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))) (cycle: (cycle?(C))):
      member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" c_digraph_all_cycles nil) (offset skolem-const-decl "nat" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_member formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil (ac2vl_rec subtype "c_digraph_all_cycles.cycles" "{cycles: list_adt[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].list | FORALL (i: naturalnumbers.below(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].length(cycles))): list_props[nat].nth(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].nth(cycles, i), 0) = c_digraph_all_cycles.offset}"))) (ac2vl_rec_TCC7 0 (ac2vl_rec_TCC7-1 nil 3828696916 ("" (skeep) (("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -3 :hide? t) (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (typepred "lc?2lw(C)(offset, cycles)") (("1" (hide -1) (("1" (expand "cycle_at?") (("1" (expand "finseq_appl") (("1" (split 1) (("1" (flatten) (("1" (use "member_nth[Walk(C)]") (("1" (assert) (("1" (hide -2) (("1" (skeep -1) (("1" (inst -3 "i") (("1" (inst -5 "nth(cycles,i)") (("1" (use "nth_member[(cycle?(C))]") (("1" (assert) (("1" (expand "walk_eq") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (replace -2 :hide? t) (("1" (inst -4 "0") (("1" (replace -4 :hide? t) (("1" (expand "nth" 1 2) (("1" (use "cycle_walk_eq") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "EXISTS(cc: (cycle?(C))): walk_eq(C)(walk,cc)") (("1" (skeep -1) (("1" (inst -7 "cc") (("1" (flatten -7) (("1" (hide -7) (("1" (split -) (("1" (use "member_nth[(cycle?(C))]") (("1" (assert) (("1" (skeep -1) (("1" (inst -7 "i") (("1" (replace -1 :hide? t) (("1" (lemma "walk_eq_inj_1") (("1" (inst? -1 :where -3) (("1" (inst? -1 :where -7) (("1" (assert) (("1" (replace -1) (("1" (use "nth_member[Walk(C)]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk_eq" -1) (("2" (flatten) (("2" (inst -2 "0") (("2" (expand "finseq_appl") (("2" (replace -2 :hide? t) (("2" (hide-all-but (-3 1)) (("2" (expand "nth" -1 2) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (expand "no_repetitions?" -3) (("2" (inst -3 "car(cc)" "offset") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "w2w?(C)(walk)") (("1" (typepred "w2w?(C)(walk)") (("1" (propax) nil nil)) nil) ("2" (use "w2w?_cycle") (("2" (assert) (("2" (expand "cycle?") (("2" (flatten) (("2" (use "w2w?_circuit") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))) (cycle: (cycle?(C))):
      member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" c_digraph_all_cycles nil) (offset skolem-const-decl "nat" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (lc?2lw def-decl "{cs:
   list[Walk[T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](C)] |
   length(cs) = length(cycles) AND
    FORALL (i: below(length(cs))): walk_eq(C)(nth(cs, i), nth(cycles, i))}" c_digraph_all_cycles nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (cycle_at? const-decl "bool" cycles_ nil) (member_nth formula-decl nil more_list_props structures) (nth_member formula-decl nil more_list_props structures) (cycle_walk_eq formula-decl nil c_digraph_all_cycles nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (walk_eq_inj_1 formula-decl nil c_digraph_all_cycles nil) (w2w?_cycle formula-decl nil c_digraph_all_cycles nil) (cycle? const-decl "bool" cycles_ nil) (w2w?_circuit formula-decl nil c_digraph_all_cycles nil) (walk skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](C)" c_digraph_all_cycles nil) (w2w? const-decl "{wi: (walk?(C)) | walk_eq(C)(w, wi)}" c_digraph_all_cycles nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil (ac2vl_rec subtype "c_digraph_all_cycles.lc?2lw(c_digraph_all_cycles.C)(c_digraph_all_cycles.offset, c_digraph_all_cycles.cycles)" "CyclesAt[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C, list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), c_digraph_all_cycles.offset))"))) (ac2vl_rec_TCC8 0 (ac2vl_rec_TCC8-1 nil 3828696916 ("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -1 :dir rl) (("" (assert) (("" (replace -3) (("" (expand "length" 1 2) (("" (skeep :preds? t) (("" (inst -3 "i+1") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraph_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))) (cycle: (cycle?(C))):
      member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" c_digraph_all_cycles nil) (offset skolem-const-decl "nat" c_digraph_all_cycles nil) (i skolem-const-decl "below(length(cs_))" c_digraph_all_cycles nil) (cs_ skolem-const-decl "list[list[(cycle?(C))]]" c_digraph_all_cycles nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (ac2vl_rec subtype "c_digraph_all_cycles.cs_" "{cs: list_adt[list[(cycle?(C))]].list | booleans.AND((number_fields.+)((number_fields.+)(1, c_digraph_all_cycles.offset), list_props[list[(cycle?(C))]].length(cs)) = c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), FORALL (i: naturalnumbers.below(list_props[list[(cycle?(C))]].length(cs))) (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, list_props[list[(cycle?(C))]].nth(cs, i)), list_adt[nat].car(cycle) = (number_fields.+)((number_fields.+)(1, i), c_digraph_all_cycles.offset)))}"))) (ac2vl_rec_TCC9 0 (ac2vl_rec_TCC9-1 nil 3828696916 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last const-decl "T" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil)) nil (ac2vl_rec termination "c_digraph_all_cycles.ac2vl_rec(c_digraph_all_cycles.C)((number_fields.+)(c_digraph_all_cycles.offset, 1), c_digraph_all_cycles.cs_)" "nil"))) (ac2vl_rec_TCC10 0 (ac2vl_rec_TCC10-1 nil 3828696916 ("" (skeep) (("" (typepred "v(C)(offset + 1, cs_)") (("1" (split 1) (("1" (replace -3 :hide? t) (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (case "n=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil) ("2" (inst -3 "n-1") (("1" (assert) (("1" (expand "nth" 2 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (typepred "cs") (("3" (replace -2 :dir rl) (("3" (assert) (("3" (replace -4) (("3" (expand "length" 1 2) (("3" (skeep :preds? t) (("3" (skeep) (("3" (inst -4 "i+1") (("1" (inst?) (("1" (replace -4 :dir rl) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (length def-decl "nat" list_props nil) (VertCycles type-eq-decl nil cycles_ nil) (CyclesAt type-eq-decl nil cycles_ nil) (vert type-eq-decl nil digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lc?2lw def-decl "{cs:
   list[Walk[T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](C)] |
   length(cs) = length(cycles) AND
    FORALL (i: below(length(cs))): walk_eq(C)(nth(cs, i), nth(cycles, i))}" c_digraph_all_cycles nil) (walk_eq const-decl "bool" c_digraph_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (C skolem-const-decl "(cdigraph[T])" c_digraph_all_cycles nil) (offset skolem-const-decl "nat" c_digraph_all_cycles nil) (cycles skolem-const-decl "list[(cycle?(C))]" c_digraph_all_cycles nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))) (cycle: (cycle?(C))):
      member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" c_digraph_all_cycles nil) (v skolem-const-decl "[C1: (cdigraph) ->
   [d1:
      {z:
         [offset: nat,
          {cs: list[list[(cycle?(C1))]] |
             offset + length(cs) = size(C1) AND
              FORALL (i: below(length(cs))) (cycle: (cycle?(C1))):
                member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}] |
         length(z`2) < length(cs)} ->
      {l:
         list[VertCycles
                  [T, digraph_type[T], digraph_verts, digraph_edges,
                   digraph_size, digraph_make](C1)] |
         length(l) = length(d1`2) AND
          FORALL (n: below(length(l))):
            nth[T](data(C1), n + d1`1) = vert(nth(l, n))}]]" c_digraph_all_cycles nil) (cs_ skolem-const-decl "list[list[(cycle?(C))]]" c_digraph_all_cycles nil) (n skolem-const-decl "below(length(cons((# vert := nth(data(C), offset),
                     cycles := lc?2lw(C)(offset, cycles) #),
                  v(C)(1 + offset, cs_))))" c_digraph_all_cycles nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (last const-decl "T" more_list_props structures) (i skolem-const-decl "below(length(cs_))" c_digraph_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ac2vl_rec subtype "list_adt[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].cons((# vert := list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), c_digraph_all_cycles.offset), cycles := c_digraph_all_cycles.lc?2lw(c_digraph_all_cycles.C)(c_digraph_all_cycles.offset, c_digraph_all_cycles.cycles) #), c_digraph_all_cycles.ac2vl_rec(c_digraph_all_cycles.C)((number_fields.+)(c_digraph_all_cycles.offset, 1), c_digraph_all_cycles.cs_))" "{l: list_adt[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].list | booleans.AND(list_props[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(l) = list_props[list[(cycle?(C))]].length(c_digraph_all_cycles.cs), FORALL (n: naturalnumbers.below(list_props[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].length(l))): list_props[c_digraph_all_cycles.T].nth(data(c_digraph_all_cycles.C), (number_fields.+)(n, c_digraph_all_cycles.offset)) = vert(list_props[VertCycles[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)].nth(l, n)))}"))) (all_cycles_vl_TCC1 0 (all_cycles_vl_TCC1-1 nil 3828696916 ("" (then (expand "vert?") (expand "digraph_verts") (assert) (expand "vert") (skeep) (use "every_nth[T]") (assert) (hide 2) (skeep) (use "nth_member[T]")) nil nil) ((vert? const-decl "bool" digraphs_ nil) (nth_member formula-decl nil more_list_props structures) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (number nonempty-type-decl nil numbers nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (every_nth formula-decl nil list_props nil) (T formal-type-decl nil c_digraph_all_cycles nil) (vert const-decl "bool" c_digraphs_def nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil)) nil (all_cycles_vl subtype "data(c_digraph_all_cycles.C)" "list[vert[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]](C)]"))) (all_cycles_vl_TCC2 0 (all_cycles_vl_TCC2-1 nil 3828696916 ("" (use "data_vert_list") nil nil) ((T formal-type-decl nil c_digraph_all_cycles nil) (data_vert_list judgement-tcc nil c_digraphs nil)) nil (all_cycles_vl subtype "data(c_digraph_all_cycles.C)" "VertList[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C)"))) (all_cycles_vl_TCC3 0 (all_cycles_vl_TCC3-1 nil 3828696916 ("" (then (skeep*) (typepred "all_cycles(C)") (assert) (skeep*) (inst? -3)) nil nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraph_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (all_cycles const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) = size(C) AND
    FORALL (i: below(size(C))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i}" c_digraph_all_cycles nil)) nil (all_cycles_vl subtype "c_digraph_all_cycles.all_cycles(c_digraph_all_cycles.C)" "{cs: list_adt[list[(cycle?(C))]].list | booleans.AND(list_props[list[(cycle?(C))]].length(cs) = c_digraphs_def[c_digraph_all_cycles.T].size(c_digraph_all_cycles.C), FORALL (i: naturalnumbers.below(list_props[list[(cycle?(C))]].length(cs))) (cycle: (c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles.cycle?(c_digraph_all_cycles.C))].member(cycle, list_props[list[(cycle?(C))]].nth(cs, i)), list_adt[nat].car(cycle) = i))}"))) (all_cycles_vl_TCC4 0 (all_cycles_vl_TCC4-1 nil 3828696916 ("" (skeep) (("" (typepred "ac2vl_rec(C)(0, all_cycles(C))") (("1" (replace -1 :hide? t) (("1" (typepred "all_cycles(C)") (("1" (assert) (("1" (expand "size") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "all_cycles(C)") (("2" (assert) (("2" (skeep*) (("2" (inst? -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((all_cycles const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) = size(C) AND
    FORALL (i: below(size(C))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i}" c_digraph_all_cycles nil) (ac2vl_rec def-decl "{l:
   list[VertCycles
            [T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](C)] |
   length(l) = length(cs) AND
    FORALL (n: below(length(l))):
      nth[T](data(C), n + offset) = vert(nth(l, n))}" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (length def-decl "nat" list_props nil) (VertCycles type-eq-decl nil cycles_ nil) (CyclesAt type-eq-decl nil cycles_ nil) (vert type-eq-decl nil digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp nil) (digraph_type type-eq-decl nil c_digraphs_imp nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (all_cycles_vl subtype "c_digraph_all_cycles.ac2vl_rec(c_digraph_all_cycles.C)(0, c_digraph_all_cycles.all_cycles(c_digraph_all_cycles.C))" "VCList[c_digraph_all_cycles.T, digraph_type[T], c_digraphs_imp[c_digraph_all_cycles.T].digraph_verts, c_digraphs_imp[c_digraph_all_cycles.T].digraph_edges, c_digraphs_imp[c_digraph_all_cycles.T].digraph_size, c_digraphs_imp[c_digraph_all_cycles.T].digraph_make](c_digraph_all_cycles.C, data(c_digraph_all_cycles.C))"))))
